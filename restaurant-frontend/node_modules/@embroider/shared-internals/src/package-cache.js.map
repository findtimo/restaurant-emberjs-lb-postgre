{"version":3,"file":"package-cache.js","sourceRoot":"","sources":["package-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import Package from './package';\nimport { existsSync, realpathSync } from 'fs';\nimport { getOrCreate } from './get-or-create';\nimport resolvePackagePath from 'resolve-package-path';\nimport { dirname, sep } from 'path';\n\nconst realpathSyncCache = new Map<string, string>();\n\nfunction getCachedRealpath(path: string): string {\n  let cached = realpathSyncCache.get(path);\n  if (cached) {\n    return cached;\n  }\n\n  let root = realpathSync(path);\n  realpathSyncCache.set(path, root);\n  return root;\n}\n\nconst existsCache = new Map<string, boolean>();\n\nfunction getCachedExists(path: string): boolean {\n  if (existsCache.has(path)) {\n    const cachedExists = existsCache.get(path);\n    if (cachedExists !== undefined) {\n      return cachedExists;\n    }\n  }\n\n  const exists = existsSync(path);\n  existsCache.set(path, exists);\n  return exists;\n}\n\nexport default class PackageCache {\n  constructor(public appRoot: string) {}\n\n  resolve(packageName: string, fromPackage: Package): Package {\n    let cache = getOrCreate(this.resolutionCache, fromPackage, () => new Map() as Map<string, Package | null>);\n    let result = getOrCreate(cache, packageName, () => {\n      // the type cast is needed because resolvePackagePath itself is erroneously typed as `any`.\n      let packagePath = resolvePackagePath(packageName, fromPackage.root) as string | null;\n      if (!packagePath) {\n        // this gets our null into the cache so we don't keep trying to resolve\n        // a thing that is not found\n        return null;\n      }\n      return this.get(dirname(packagePath));\n    });\n    if (!result) {\n      let e = new Error(`unable to resolve package ${packageName} from ${fromPackage.root}`);\n      (e as any).code = 'MODULE_NOT_FOUND';\n      throw e;\n    }\n    return result;\n  }\n\n  private rootCache: Map<string, Package> = new Map();\n  private resolutionCache: Map<Package, Map<string, Package | null>> = new Map();\n\n  get(packageRoot: string) {\n    let root = getCachedRealpath(packageRoot);\n    let p = getOrCreate(this.rootCache, root, () => {\n      return new Package(root, this, root === this.appRoot);\n    });\n    return p;\n  }\n\n  ownerOfFile(filename: string): Package | undefined {\n    let segments = filename.split(sep);\n\n    // first we look through our cached packages for any that are rooted right\n    // at or above the file.\n    for (let length = segments.length; length >= 0; length--) {\n      if (segments[length - 1] === 'node_modules' || segments[length - 1] === '') {\n        // once we hit a node_modules or the filesystem root, we're leaving the\n        // package we were in, so any higher caches don't apply to us\n        break;\n      }\n\n      let usedSegments = segments.slice(0, length);\n      let candidate = usedSegments.join(sep);\n      if (this.rootCache.has(candidate)) {\n        return this.rootCache.get(candidate);\n      }\n      if (getCachedExists([...usedSegments, 'package.json'].join(sep))) {\n        return this.get(candidate);\n      }\n    }\n  }\n\n  static shared(identifier: string, appRoot: string) {\n    let pk = getOrCreate(shared, identifier + appRoot, () => new PackageCache(appRoot));\n\n    // it's not clear that this could ever happen because appRoot is part of the new identifier\n    // but it doesn't cost much to leave this code here.\n    if (pk.appRoot !== appRoot) {\n      throw new Error(`bug: PackageCache appRoot disagreement ${appRoot}!=${pk.appRoot}`);\n    }\n    return pk;\n  }\n}\n\nconst shared: Map<string, PackageCache> = new Map();\n"]}