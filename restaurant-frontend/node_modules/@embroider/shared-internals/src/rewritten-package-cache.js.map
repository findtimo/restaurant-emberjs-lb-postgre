{"version":3,"file":"rewritten-package-cache.js","sourceRoot":"","sources":["rewritten-package-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import PackageCache from './package-cache';\nimport Package from './package';\nimport { existsSync, readJSONSync, realpathSync } from 'fs-extra';\nimport { resolve } from 'path';\nimport { getOrCreate } from './get-or-create';\nimport { locateEmbroiderWorkingDir } from './working-dir';\n\nexport interface RewrittenPackageIndex {\n  // keys are paths to original package root directories.\n  //\n  // values are paths to rewritten directories.\n  //\n  // all paths are interpreted relative to the rewritten package index file\n  // itself.\n  packages: Record<string, string>;\n\n  // key is path to the rewritten package that needs to resolve an extra\n  // dependency\n  //\n  // value is list of paths to packages that it should be able to resolve.\n  //\n  // while the key is always one of our rewritten packages, the values can be\n  // rewritten ones or not.\n  extraResolutions: Record<string, string[]>;\n}\n\n// without this, using a class as an interface forces you to have the same\n// private and protected methods too (since people trying to extend from you\n// could see all of those)\ntype PublicAPI<T> = { [K in keyof T]: T[K] };\n\nexport class RewrittenPackageCache implements PublicAPI<PackageCache> {\n  constructor(private plainCache: PackageCache) {}\n\n  get appRoot(): string {\n    return this.plainCache.appRoot;\n  }\n\n  resolve(packageName: string, fromPackage: Package): Package {\n    // check for any extraResolutions\n    let extraResolutions = this.index.extraResolutions.get(fromPackage.root);\n    if (extraResolutions) {\n      for (let depRoot of extraResolutions) {\n        let depPkg = this.plainCache.get(depRoot);\n        if (depPkg.name === packageName) {\n          return this.maybeMoved(this.withRewrittenDeps(depPkg));\n        }\n      }\n    }\n\n    let resolveFromPkg: Package;\n    let oldRoot = this.index.newToOld.get(fromPackage.root);\n    if (oldRoot) {\n      // the requesting package has been moved, so do the resolving from the old location\n      resolveFromPkg = this.plainCache.get(oldRoot);\n    } else {\n      // the requesting package has not been moved\n      resolveFromPkg = fromPackage;\n    }\n\n    let oldDest = this.withRewrittenDeps(this.plainCache.resolve(packageName, resolveFromPkg));\n\n    // if the package we found was itself moved return the moved one.\n    return this.maybeMoved(oldDest);\n  }\n\n  // ensure we have the moved version of the package\n  maybeMoved(pkg: Package): Package {\n    let newRoot = this.index.oldToNew.get(pkg.root);\n    if (newRoot) {\n      return this.get(newRoot);\n    } else {\n      return pkg;\n    }\n  }\n\n  get(packageRoot: string): Package {\n    return this.withRewrittenDeps(this.plainCache.get(packageRoot));\n  }\n\n  original(pkg: Package): Package {\n    let oldRoot = this.index.newToOld.get(pkg.root);\n    if (oldRoot) {\n      return this.withRewrittenDeps(this.plainCache.get(oldRoot));\n    } else {\n      return pkg;\n    }\n  }\n\n  // given any package, give us a new representation of it where its deps are\n  // replaced with rewritten versions of those deps, as needed\n  withRewrittenDeps(pkg: Package): Package {\n    let found = wrapped.get(pkg);\n    if (!found) {\n      if (pkg.root === this.index.oldToNew.get(this.appRoot)) {\n        // the plain representation of our moved app doesn't know that it's an\n        // app, so we instead make a plain Package with isApp set to true\n        // explicitly.\n        found = new WrappedPackage(this, new Package(pkg.root, this.plainCache, true));\n      } else {\n        found = new WrappedPackage(this, pkg);\n      }\n      wrapped.set(pkg, found);\n    }\n    return castToPackage(found);\n  }\n\n  ownerOfFile(filename: string): Package | undefined {\n    let owner = this.plainCache.ownerOfFile(filename);\n    if (owner) {\n      return this.withRewrittenDeps(owner);\n    }\n  }\n\n  private indexCache:\n    | {\n        oldToNew: Map<string, string>;\n        newToOld: Map<string, string>;\n        extraResolutions: Map<string, string[]>;\n      }\n    | undefined;\n\n  private get index(): {\n    oldToNew: Map<string, string>;\n    newToOld: Map<string, string>;\n    extraResolutions: Map<string, string[]>;\n  } {\n    if (!this.indexCache) {\n      this.indexCache = this.loadIndex();\n    }\n    return this.indexCache;\n  }\n\n  invalidateIndex(): void {\n    this.indexCache = undefined;\n  }\n\n  private loadIndex(): RewrittenPackageCache['index'] {\n    let workingDir = locateEmbroiderWorkingDir(this.appRoot);\n    let indexFile = resolve(workingDir, 'rewritten-packages', 'index.json');\n    if (!existsSync(indexFile)) {\n      return {\n        oldToNew: new Map(),\n        newToOld: new Map(),\n        extraResolutions: new Map(),\n      };\n    }\n\n    workingDir = realpathSync(workingDir);\n    let addonsDir = resolve(workingDir, 'rewritten-packages');\n\n    let { packages, extraResolutions } = readJSONSync(indexFile) as RewrittenPackageIndex;\n    return {\n      oldToNew: new Map(\n        Object.entries(packages).map(([oldRoot, newRoot]) => [resolve(addonsDir, oldRoot), resolve(addonsDir, newRoot)])\n      ),\n      newToOld: new Map(\n        Object.entries(packages).map(([oldRoot, newRoot]) => [resolve(addonsDir, newRoot), resolve(addonsDir, oldRoot)])\n      ),\n      extraResolutions: new Map(\n        Object.entries(extraResolutions).map(([fromRoot, toRoots]) => [\n          resolve(addonsDir, fromRoot),\n          toRoots.map(r => resolve(addonsDir, r)),\n        ])\n      ),\n    };\n  }\n\n  static shared(identifier: string, appRoot: string) {\n    let pk = getOrCreate(\n      shared,\n      identifier + appRoot,\n      () => new RewrittenPackageCache(PackageCache.shared(identifier, appRoot))\n    );\n\n    // it's not clear that this could ever happen because appRoot is part of the new identifier\n    // but it doesn't cost much to leave this code here.\n    if (pk.appRoot !== appRoot) {\n      throw new Error(`bug: RewrittenPackageCache appRoot disagreement ${appRoot} != ${pk.appRoot}`);\n    }\n    return pk;\n  }\n}\n\nconst shared: Map<string, RewrittenPackageCache> = new Map();\nconst wrapped = new WeakMap<Package, WrappedPackage>();\n\ntype PackageTheGoodParts = Omit<PublicAPI<Package>, 'nonResolvableDeps'>;\n\nfunction castToPackage(m: WrappedPackage): Package {\n  return m as unknown as Package;\n}\n\nclass WrappedPackage implements PackageTheGoodParts {\n  // Questions about *this* package will be answered based on the given\n  // plainPkg.\n  //\n  // Questions about *this package's deps* will be translated through the set of\n  // moved packages.\n  //\n  // There are two different cases that this enables. The first is when we're\n  // representing a package that has itself been rewritten, in which case\n  // plainPkg points at the *rewritten* copy of the package, so that we see our\n  // own rewritten package.json, etc. The second case is in Stage2 when the\n  // dependencies have been rewritten but the app has not -- we represent the\n  // app as a WrappedPackage where plainPkg is the *original* app package, so\n  // we're still seeing the original package.json, etc, but while also seeing\n  // the rewritten addons.\n  constructor(private packageCache: RewrittenPackageCache, private plainPkg: Package) {}\n\n  get root() {\n    return this.plainPkg.root;\n  }\n\n  get name() {\n    return this.plainPkg.name;\n  }\n\n  get version() {\n    return this.plainPkg.version;\n  }\n\n  get packageJSON() {\n    return this.plainPkg.packageJSON;\n  }\n\n  get meta() {\n    return this.plainPkg.meta;\n  }\n\n  isEmberPackage() {\n    return this.plainPkg.isEmberPackage();\n  }\n\n  isEngine() {\n    return this.plainPkg.isEngine();\n  }\n\n  isLazyEngine() {\n    return this.plainPkg.isLazyEngine();\n  }\n\n  isV2Ember() {\n    return this.plainPkg.isV2Ember();\n  }\n\n  isV2App() {\n    return this.plainPkg.isV2App();\n  }\n\n  isV2Addon() {\n    return this.plainPkg.isV2Addon();\n  }\n\n  // it's important that we're calling this.dependencies here at this level, not\n  // plainPkg.dependencies, which wouldn't be correct\n  findDescendants(filter?: (pkg: Package) => boolean): Package[] {\n    let pkgs = new Set<Package>();\n    let queue: Package[] = [castToPackage(this)];\n    while (true) {\n      let pkg = queue.shift();\n      if (!pkg) {\n        break;\n      }\n      if (!pkgs.has(pkg)) {\n        pkgs.add(pkg);\n        let nextLevel;\n        if (filter) {\n          nextLevel = pkg.dependencies.filter(filter);\n        } else {\n          nextLevel = pkg.dependencies;\n        }\n        nextLevel.forEach(d => queue.push(d));\n      }\n    }\n    pkgs.delete(castToPackage(this));\n    return [...pkgs.values()];\n  }\n\n  get mayRebuild() {\n    return this.plainPkg.mayRebuild;\n  }\n\n  get dependencyNames() {\n    return this.plainPkg.dependencyNames;\n  }\n\n  get dependencies() {\n    return this.plainPkg.dependencyNames\n      .map(name => {\n        try {\n          // this is going through the rewriting-aware resolve in\n          // RewrittenPackageCache.\n          let dep = this.packageCache.resolve(name, this.plainPkg);\n\n          // and this ensures that regardless of whether the package we found\n          // was itself moved, if any of its deps have moved it will see those\n          // ones.\n          return this.packageCache.withRewrittenDeps(dep);\n        } catch (error) {\n          // if the package was not found do not error out here. this is relevant\n          // for the case where a package might be an optional peerDependency and we dont\n          // want to error if it was not found. Additionally, erroring here is \"far\" away\n          // from the actual logical failure point and so not failing here will provide a better\n          // error message down the line\n          if (error.code === 'MODULE_NOT_FOUND') {\n            return false;\n          }\n\n          throw error;\n        }\n      })\n      .filter(Boolean) as Package[];\n  }\n\n  hasDependency(name: string): boolean {\n    // this is *not* extended because it's understood that the rewritten package\n    // should explictly list the things that need extraResolutions in its own\n    // package.json.ß\n    return this.plainPkg.hasDependency(name);\n  }\n\n  categorizeDependency(name: string): 'dependencies' | 'devDependencies' | 'peerDependencies' | undefined {\n    return this.plainPkg.categorizeDependency(name);\n  }\n}\n"]}