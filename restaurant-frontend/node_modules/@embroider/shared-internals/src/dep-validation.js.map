{"version":3,"file":"dep-validation.js","sourceRoot":"","sources":["dep-validation.ts"],"names":[],"mappings":"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","sourcesContent":["import type Package from './package';\n\n// For each package in the graph, discover all the paths to reach that package.\n// That is, we're identifying all its consumers.\nexport function crawlDeps(startingPackage: Package): Map<Package, Package[][]> {\n  let queue: { pkg: Package; path: Package[] }[] = [{ pkg: startingPackage, path: [] }];\n  let seen = new Set<Package>();\n  let results = new Map<Package, Package[][]>();\n  for (;;) {\n    let entry = queue.shift();\n    if (!entry) {\n      break;\n    }\n    let { pkg, path } = entry;\n\n    let paths = results.get(pkg);\n    if (paths) {\n      paths.push(path);\n    } else {\n      results.set(pkg, [path]);\n    }\n\n    if (!seen.has(pkg)) {\n      seen.add(pkg);\n      for (let dep of pkg.dependencies) {\n        if (pkg.categorizeDependency(dep.name) !== 'peerDependencies') {\n          queue.push({ pkg: dep, path: [...path, pkg] });\n        }\n      }\n    }\n  }\n  return results;\n}\n\ninterface PeerDepViolation {\n  // this package...\n  pkg: Package;\n  // sees this peer dep.\n  dep: Package;\n  // pkg was reached by this path of ancestors\n  ancestors: Package[];\n  // this particular ancestor...\n  ancestor: Package;\n  // provides a conflicting value for the peerDep\n  ancestorsDep: Package;\n}\n\nexport function validatePeerDependencies(appPackage: Package): PeerDepViolation[] {\n  let violations = [];\n  for (let [pkg, consumptions] of crawlDeps(appPackage)) {\n    for (let dep of pkg.dependencies) {\n      if (pkg.categorizeDependency(dep.name) === 'peerDependencies') {\n        for (let ancestors of consumptions) {\n          for (let ancestor of ancestors.slice().reverse()) {\n            if (ancestor.hasDependency(dep.name)) {\n              let ancestorsDep = ancestor.dependencies.find(d => d.name === dep.name)!;\n              if (ancestorsDep !== dep && dep.isEmberPackage()) {\n                violations.push({ pkg, dep, ancestors, ancestor, ancestorsDep });\n              }\n              continue;\n            }\n          }\n        }\n      }\n    }\n  }\n  return violations;\n}\n\nexport function summarizePeerDepViolations(violations: PeerDepViolation[]): string {\n  let message = [];\n  for (let { pkg, dep, ancestors, ancestor, ancestorsDep } of violations) {\n    for (let [index, a] of ancestors.entries()) {\n      message.push(packageIdSummary(a));\n      if (index + 1 < ancestors.length) {\n        message.push(displayConnection(a, ancestors[index + 1]));\n      } else {\n        message.push(displayConnection(a, pkg));\n      }\n    }\n    message.push(packageIdSummary(pkg));\n    message.push('\\n');\n    message.push(`    sees peerDep ${packageIdSummary(dep)}\\n      at ${dep.root}\\n`);\n    message.push(\n      `    but ${packageIdSummary(ancestor)} is using ${packageIdSummary(ancestorsDep)}\\n      at ${\n        ancestorsDep.root\n      }\\n\\n`\n    );\n  }\n  return message.join('');\n}\n\nfunction displayConnection(left: Package, right: Package) {\n  if (left.packageJSON.dependencies?.[right.name]) {\n    return ' -> ';\n  }\n  if (left.packageJSON.peerDependencies?.[right.name]) {\n    return ' (peer)-> ';\n  }\n  if (left.packageJSON.devDependencies?.[right.name]) {\n    return ' (dev)-> ';\n  }\n  return ' (?)-> ';\n}\n\nfunction packageIdSummary(pkg: Package): string {\n  return `${pkg.name}@${pkg.version}`;\n}\n"]}