{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type * as Babel from \"@babel/core\";\nimport type { types as t, NodePath } from \"@babel/core\";\nimport { createRequire } from \"node:module\";\nimport { ImportUtil } from \"babel-import-util\";\nimport { globalId } from \"./global-id.ts\";\nconst req = createRequire(import.meta.url);\nconst { default: decoratorSyntax } = req(\"@babel/plugin-syntax-decorators\");\n\ninterface State extends Babel.PluginPass {\n  currentClassBodies: t.ClassBody[];\n  currentObjectExpressions: {\n    decorated: [\n      \"field\" | \"method\",\n      t.Expression, // for the property name\n      t.Expression[] // for the decorators applied to it\n    ][];\n  }[];\n  opts: Options;\n  runtime: (target: NodePath<t.Node>, fnName: string) => t.Expression;\n  optsWithDefaults: Required<Options>;\n}\n\nexport interface Options {\n  runtime?: \"globals\" | { import: string };\n  staticBlock?: \"native\" | \"field\";\n}\n\nexport default function legacyDecoratorCompat(\n  babel: typeof Babel\n): Babel.PluginObj<State> {\n  const t = babel.types;\n  return {\n    inherits: (api: unknown, _options: unknown, dirname: unknown) =>\n      decoratorSyntax(api, { legacy: true }, dirname),\n    visitor: {\n      Program(path: NodePath<t.Program>, state: State) {\n        state.currentClassBodies = [];\n        state.currentObjectExpressions = [];\n        state.optsWithDefaults = {\n          runtime: \"globals\",\n          staticBlock: \"native\",\n          ...state.opts,\n        };\n        let importUtil = new ImportUtil(t, path);\n        state.runtime = (target: NodePath<t.Node>, fnName: string) => {\n          const { runtime } = state.optsWithDefaults;\n          if (runtime === \"globals\") {\n            return t.memberExpression(\n              t.identifier(globalId),\n              t.identifier(fnName)\n            );\n          } else {\n            return importUtil.import(target, runtime.import, fnName);\n          }\n        };\n      },\n      ClassBody: {\n        enter(path, state) {\n          state.currentClassBodies.unshift(path.node);\n        },\n        exit(_path, state) {\n          state.currentClassBodies.shift();\n        },\n      },\n      ClassExpression(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          let call = t.expressionStatement(\n            t.callExpression(state.runtime(path, \"c\"), [\n              path.node,\n              t.arrayExpression(\n                decorators\n                  .slice()\n                  .reverse()\n                  .map((d) => d.node.expression)\n              ),\n            ])\n          );\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n          path.replaceWith(call);\n        }\n      },\n      ClassDeclaration(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          let call = t.callExpression(state.runtime(path, \"c\"), [\n            t.classExpression(\n              path.node.id,\n              path.node.superClass,\n              path.node.body,\n              [] // decorators removed here\n            ),\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression)\n            ),\n          ]);\n\n          if (path.parentPath.isExportDefaultDeclaration()) {\n            let id = path.node.id;\n            if (id) {\n              path.parentPath.insertBefore(\n                t.variableDeclaration(\"const\", [t.variableDeclarator(id, call)])\n              );\n              path.parentPath.replaceWith(t.exportDefaultDeclaration(id));\n            } else {\n              path.parentPath.replaceWith(t.exportDefaultDeclaration(call));\n            }\n          } else if (path.parentPath.isExportNamedDeclaration()) {\n            let id = path.node.id;\n            if (!id) {\n              throw new Error(\n                `bug: expected a class name is required in this context`\n              );\n            }\n            path.parentPath.insertBefore(\n              t.variableDeclaration(\"const\", [t.variableDeclarator(id, call)])\n            );\n            path.parentPath.replaceWith(\n              t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)])\n            );\n          } else {\n            let id = path.node.id;\n            if (!id) {\n              throw new Error(\n                `bug: expected a class name is required in this context`\n              );\n            }\n            path.replaceWith(\n              t.variableDeclaration(\"const\", [t.variableDeclarator(id, call)])\n            );\n          }\n        }\n      },\n      ClassProperty(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          let prototype: t.Expression;\n          if (path.node.static) {\n            prototype = t.identifier(\"this\");\n          } else {\n            prototype = t.memberExpression(\n              t.identifier(\"this\"),\n              t.identifier(\"prototype\")\n            );\n          }\n          let args: t.Expression[] = [\n            prototype,\n            valueForFieldKey(t, path.node.key),\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression)\n            ),\n          ];\n          if (path.node.value) {\n            args.push(\n              t.functionExpression(\n                null,\n                [],\n                t.blockStatement([t.returnStatement(path.node.value)])\n              )\n            );\n          }\n          path.insertBefore(\n            compatStaticBlock(\n              state,\n              t,\n              path.node.key,\n              t.callExpression(state.runtime(path, \"g\"), args)\n            )\n          );\n          path.insertBefore(\n            t.classPrivateProperty(\n              t.privateName(\n                t.identifier(\n                  unusedPrivateNameLike(state, propName(path.node.key))\n                )\n              ),\n              t.sequenceExpression([\n                t.callExpression(state.runtime(path, \"i\"), [\n                  t.identifier(\"this\"),\n                  valueForFieldKey(t, path.node.key),\n                ]),\n                t.identifier(\"void 0\"),\n              ])\n            )\n          );\n          path.remove();\n        }\n      },\n      ClassMethod(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          let prototype: t.Expression;\n          if (path.node.static) {\n            prototype = t.identifier(\"this\");\n          } else {\n            prototype = t.memberExpression(\n              t.identifier(\"this\"),\n              t.identifier(\"prototype\")\n            );\n          }\n          path.insertAfter(\n            compatStaticBlock(\n              state,\n              t,\n              path.node.key,\n              t.callExpression(state.runtime(path, \"n\"), [\n                prototype,\n                valueForFieldKey(t, path.node.key),\n                t.arrayExpression(\n                  decorators\n                    .slice()\n                    .reverse()\n                    .map((d) => d.node.expression)\n                ),\n              ])\n            )\n          );\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n        }\n      },\n      ObjectExpression: {\n        enter(_path, state) {\n          state.currentObjectExpressions.unshift({\n            decorated: [],\n          });\n        },\n        exit(path, state) {\n          let { decorated } = state.currentObjectExpressions.shift()!;\n          if (decorated.length > 0) {\n            path.replaceWith(\n              t.callExpression(state.runtime(path, \"p\"), [\n                path.node,\n                t.arrayExpression(\n                  decorated.map(([type, prop, decorators]) =>\n                    t.arrayExpression([\n                      t.stringLiteral(type),\n                      prop,\n                      t.arrayExpression(decorators),\n                    ])\n                  )\n                ),\n              ])\n            );\n          }\n        },\n      },\n      ObjectProperty(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          if (state.currentObjectExpressions.length === 0) {\n            throw new Error(\n              `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`\n            );\n          }\n          let prop = path.node.key;\n          if (prop.type === \"PrivateName\") {\n            throw new Error(`cannot decorate private field`);\n          }\n          state.currentObjectExpressions[0].decorated.push([\n            \"field\",\n            valueForFieldKey(t, prop),\n            decorators\n              .slice()\n              .reverse()\n              .map((d) => d.node.expression),\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n        }\n      },\n\n      ObjectMethod(path, state) {\n        let decorators = path.get(\"decorators\") as\n          | NodePath<t.Decorator>[]\n          | NodePath<undefined>;\n        if (Array.isArray(decorators) && decorators.length > 0) {\n          if (state.currentObjectExpressions.length === 0) {\n            throw new Error(\n              `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`\n            );\n          }\n          let prop = path.node.key;\n          state.currentObjectExpressions[0].decorated.push([\n            \"method\",\n            valueForFieldKey(t, prop),\n            decorators\n              .slice()\n              .reverse()\n              .map((d) => d.node.expression),\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction unusedPrivateNameLike(state: State, name: string): string {\n  let classBody = state.currentClassBodies[0];\n  if (!classBody) {\n    throw new Error(\n      `bug: no current class body around our class field decorator`\n    );\n  }\n  let usedNames = new Set();\n  for (let element of classBody.body) {\n    if (\n      (element.type === \"ClassPrivateProperty\" ||\n        element.type === \"ClassPrivateMethod\" ||\n        element.type === \"ClassAccessorProperty\") &&\n      element.key.type === \"PrivateName\"\n    ) {\n      usedNames.add(element.key.id.name);\n    }\n  }\n  let candidate = name;\n  while (usedNames.has(candidate)) {\n    candidate = candidate + \"_\";\n  }\n  return candidate;\n}\n\n// derive a best-effort name we can use when creating a private-field\nfunction propName(expr: t.Expression): string {\n  if (expr.type === \"Identifier\") {\n    return expr.name;\n  }\n  if (expr.type === \"BigIntLiteral\" || expr.type === \"NumericLiteral\") {\n    return `_${expr.value}`;\n  }\n  if (expr.type === \"StringLiteral\") {\n    return \"_\" + expr.value.replace(/[^a-zA-Z]/g, \"\");\n  }\n  return \"_\";\n}\n\n// turn the field key into a runtime value. Identifiers are special because they\n// need to become string literals, anything else is already usable as a value.\nfunction valueForFieldKey(\n  t: (typeof Babel)[\"types\"],\n  expr: t.Expression\n): t.Expression {\n  if (expr.type === \"Identifier\") {\n    return t.stringLiteral(expr.name);\n  }\n  return expr;\n}\n\n// create a static block or a private class field depending on the staticBlock option\nfunction compatStaticBlock(\n  state: State,\n  t: (typeof Babel)[\"types\"],\n  key: t.Expression,\n  expression: t.Expression\n) {\n  if (state.optsWithDefaults.staticBlock === \"native\") {\n    return t.staticBlock([t.expressionStatement(expression)]);\n  } else {\n    return t.classPrivateProperty(\n      t.privateName(t.identifier(unusedPrivateNameLike(state, propName(key)))),\n      expression,\n      null,\n      true\n    );\n  }\n}\n"],"mappings":"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","names":[]}