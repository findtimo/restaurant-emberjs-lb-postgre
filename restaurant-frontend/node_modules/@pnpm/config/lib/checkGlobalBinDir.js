"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkGlobalBinDir = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const error_1 = require("@pnpm/error");
const can_write_to_dir_1 = require("can-write-to-dir");
const path_name_1 = __importDefault(require("path-name"));
async function checkGlobalBinDir(globalBinDir, { env, shouldAllowWrite }) {
    if (!env[path_name_1.default]) {
        throw new error_1.PnpmError('NO_PATH_ENV', `Couldn't find a global directory for executables because the "${path_name_1.default}" environment variable is not set.`);
    }
    if (!await globalBinDirIsInPath(globalBinDir, env)) {
        throw new error_1.PnpmError('GLOBAL_BIN_DIR_NOT_IN_PATH', `The configured global bin directory "${globalBinDir}" is not in PATH`);
    }
    if (shouldAllowWrite && !canWriteToDirAndExists(globalBinDir)) {
        throw new error_1.PnpmError('PNPM_DIR_NOT_WRITABLE', `The CLI has no write access to the pnpm home directory at ${globalBinDir}`);
    }
}
exports.checkGlobalBinDir = checkGlobalBinDir;
async function globalBinDirIsInPath(globalBinDir, env) {
    const dirs = env[path_name_1.default]?.split(path_1.default.delimiter) ?? [];
    if (dirs.some((dir) => areDirsEqual(globalBinDir, dir)))
        return true;
    const realGlobalBinDir = await fs_1.promises.realpath(globalBinDir);
    return dirs.some((dir) => areDirsEqual(realGlobalBinDir, dir));
}
const areDirsEqual = (dir1, dir2) => path_1.default.relative(dir1, dir2) === '';
function canWriteToDirAndExists(dir) {
    try {
        return (0, can_write_to_dir_1.sync)(dir);
    }
    catch (err) { // eslint-disable-line
        if (err.code !== 'ENOENT')
            throw err;
        return false;
    }
}
//# sourceMappingURL=checkGlobalBinDir.js.map