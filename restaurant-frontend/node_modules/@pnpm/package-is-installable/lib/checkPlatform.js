"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPlatform = exports.UnsupportedPlatformError = void 0;
const error_1 = require("@pnpm/error");
const detect_libc_1 = require("detect-libc");
const currentLibc = (0, detect_libc_1.familySync)() ?? 'unknown';
class UnsupportedPlatformError extends error_1.PnpmError {
    constructor(packageId, wanted, current) {
        super('UNSUPPORTED_PLATFORM', `Unsupported platform for ${packageId}: wanted ${JSON.stringify(wanted)} (current: ${JSON.stringify(current)})`);
        this.wanted = wanted;
        this.current = current;
    }
}
exports.UnsupportedPlatformError = UnsupportedPlatformError;
function checkPlatform(packageId, wantedPlatform) {
    const { platform, arch } = process;
    let osOk = true;
    let cpuOk = true;
    let libcOk = true;
    if (wantedPlatform.os) {
        osOk = checkList(platform, wantedPlatform.os);
    }
    if (wantedPlatform.cpu) {
        cpuOk = checkList(arch, wantedPlatform.cpu);
    }
    if (wantedPlatform.libc && currentLibc !== 'unknown') {
        libcOk = checkList(currentLibc, wantedPlatform.libc);
    }
    if (!osOk || !cpuOk || !libcOk) {
        return new UnsupportedPlatformError(packageId, wantedPlatform, { os: platform, cpu: arch, libc: currentLibc });
    }
    return null;
}
exports.checkPlatform = checkPlatform;
function checkList(value, list) {
    let tmp;
    let match = false;
    let blc = 0;
    if (typeof list === 'string') {
        list = [list];
    }
    if (list.length === 1 && list[0] === 'any') {
        return true;
    }
    for (let i = 0; i < list.length; ++i) {
        tmp = list[i];
        if (tmp[0] === '!') {
            tmp = tmp.slice(1);
            if (tmp === value) {
                return false;
            }
            ++blc;
        }
        else {
            match = match || tmp === value;
        }
    }
    return match || blc === list.length;
}
//# sourceMappingURL=checkPlatform.js.map