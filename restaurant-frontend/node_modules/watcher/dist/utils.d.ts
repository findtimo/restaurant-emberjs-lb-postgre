/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import type { Callback, Ignore, ReaddirMap, Stats } from './types';
declare const Utils: {
    lang: {
        debounce: <Args extends unknown[]>(fn: import("dettle/dist/types").FN<Args, unknown>, wait?: number | undefined, options?: import("dettle/dist/types").DebounceOptions | undefined) => import("dettle/dist/types").Debounced<Args>;
        attempt: <T>(fn: () => T) => T | Error;
        castArray: <T_1>(x: T_1 | T_1[]) => T_1[];
        castError: (exception: unknown) => Error;
        defer: (callback: Callback) => NodeJS.Timeout;
        isArray: (value: unknown) => value is unknown[];
        isError: (value: unknown) => value is Error;
        isFunction: (value: unknown) => value is Function;
        isNaN: (value: unknown) => value is number;
        isNumber: (value: unknown) => value is number;
        isPrimitive: (value: unknown) => value is string | number | bigint | boolean | symbol | null | undefined;
        isShallowEqual: (x: any, y: any) => boolean;
        isSet: (value: unknown) => value is Set<unknown>;
        isString: (value: unknown) => value is string;
        isUndefined: (value: unknown) => value is undefined;
        noop: () => undefined;
        uniq: <T_2>(arr: T_2[]) => T_2[];
    };
    fs: {
        getDepth: (targetPath: string) => number;
        getRealPath: (targetPath: string, native?: boolean) => string | undefined;
        isSubPath: (targetPath: string, subPath: string) => boolean;
        poll: (targetPath: string, timeout?: number) => Promise<Stats | undefined>;
        readdir: (rootPath: string, ignore?: Ignore, depth?: number, limit?: number, signal?: {
            aborted: boolean;
        }, readdirMap?: ReaddirMap) => Promise<[string[], string[]]>;
    };
};
export default Utils;
