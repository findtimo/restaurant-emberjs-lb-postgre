"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _routeInfo = require("../route-info");

var _transitionIntent = require("../transition-intent");

var _transitionState = _interopRequireDefault(require("../transition-state"));

var _unrecognizedUrlError = _interopRequireDefault(require("../unrecognized-url-error"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class URLTransitionIntent extends _transitionIntent.TransitionIntent {
  constructor(router, url, data) {
    super(router, data);
    this.url = url;
    this.preTransitionState = undefined;
  }

  applyToState(oldState) {
    let newState = new _transitionState.default();
    let results = this.router.recognizer.recognize(this.url),
        i,
        len;

    if (!results) {
      throw new _unrecognizedUrlError.default(this.url);
    }

    let statesDiffer = false;
    let _url = this.url; // Checks if a handler is accessible by URL. If it is not, an error is thrown.
    // For the case where the handler is loaded asynchronously, the error will be
    // thrown once it is loaded.

    function checkHandlerAccessibility(handler) {
      if (handler && handler.inaccessibleByURL) {
        throw new _unrecognizedUrlError.default(_url);
      }

      return handler;
    }

    for (i = 0, len = results.length; i < len; ++i) {
      let result = results[i];
      let name = result.handler;
      let paramNames = [];

      if (this.router.recognizer.hasRoute(name)) {
        paramNames = this.router.recognizer.handlersFor(name)[i].names;
      }

      let newRouteInfo = new _routeInfo.UnresolvedRouteInfoByParam(this.router, name, paramNames, result.params);
      let route = newRouteInfo.route;

      if (route) {
        checkHandlerAccessibility(route);
      } else {
        // If the handler is being loaded asynchronously, check if we can
        // access it after it has resolved
        newRouteInfo.routePromise = newRouteInfo.routePromise.then(checkHandlerAccessibility);
      }

      let oldRouteInfo = oldState.routeInfos[i];

      if (statesDiffer || newRouteInfo.shouldSupersede(oldRouteInfo)) {
        statesDiffer = true;
        newState.routeInfos[i] = newRouteInfo;
      } else {
        newState.routeInfos[i] = oldRouteInfo;
      }
    }

    (0, _utils.merge)(newState.queryParams, results.queryParams);
    return newState;
  }

}

exports.default = URLTransitionIntent;