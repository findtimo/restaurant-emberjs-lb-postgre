"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransitionError = exports.default = void 0;

var _rsvp = require("rsvp");

var _utils = require("./utils");

var _transitionAbortedError = require("./transition-aborted-error");

function handleError(currentState, transition, error) {
  // This is the only possible
  // reject value of TransitionState#resolve
  let routeInfos = currentState.routeInfos;
  let errorHandlerIndex = transition.resolveIndex >= routeInfos.length ? routeInfos.length - 1 : transition.resolveIndex;
  let wasAborted = transition.isAborted;
  throw new TransitionError(error, currentState.routeInfos[errorHandlerIndex].route, wasAborted, currentState);
}

function resolveOneRouteInfo(currentState, transition) {
  if (transition.resolveIndex === currentState.routeInfos.length) {
    // This is is the only possible
    // fulfill value of TransitionState#resolve
    return;
  }

  let routeInfo = currentState.routeInfos[transition.resolveIndex];
  let callback = proceed.bind(null, currentState, transition);
  return routeInfo.resolve(transition).then(callback, null, currentState.promiseLabel('Proceed'));
}

function proceed(currentState, transition, resolvedRouteInfo) {
  let wasAlreadyResolved = currentState.routeInfos[transition.resolveIndex].isResolved; // Swap the previously unresolved routeInfo with
  // the resolved routeInfo

  currentState.routeInfos[transition.resolveIndex++] = resolvedRouteInfo;

  if (!wasAlreadyResolved) {
    // Call the redirect hook. The reason we call it here
    // vs. afterModel is so that redirects into child
    // routes don't re-run the model hooks for this
    // already-resolved route.
    let {
      route
    } = resolvedRouteInfo;

    if (route !== undefined) {
      if (route.redirect) {
        route.redirect(resolvedRouteInfo.context, transition);
      }
    }
  } // Proceed after ensuring that the redirect hook
  // didn't abort this transition by transitioning elsewhere.


  (0, _transitionAbortedError.throwIfAborted)(transition);
  return resolveOneRouteInfo(currentState, transition);
}

class TransitionState {
  constructor() {
    this.routeInfos = [];
    this.queryParams = {};
    this.params = {};
  }

  promiseLabel(label) {
    let targetName = '';
    (0, _utils.forEach)(this.routeInfos, function (routeInfo) {
      if (targetName !== '') {
        targetName += '.';
      }

      targetName += routeInfo.name;
      return true;
    });
    return (0, _utils.promiseLabel)("'" + targetName + "': " + label);
  }

  resolve(transition) {
    // First, calculate params for this state. This is useful
    // information to provide to the various route hooks.
    let params = this.params;
    (0, _utils.forEach)(this.routeInfos, routeInfo => {
      params[routeInfo.name] = routeInfo.params || {};
      return true;
    });
    transition.resolveIndex = 0;
    let callback = resolveOneRouteInfo.bind(null, this, transition);
    let errorHandler = handleError.bind(null, this, transition); // The prelude RSVP.resolve() async moves us into the promise land.

    return _rsvp.Promise.resolve(null, this.promiseLabel('Start transition')).then(callback, null, this.promiseLabel('Resolve route')).catch(errorHandler, this.promiseLabel('Handle error')).then(() => this);
  }

}

exports.default = TransitionState;

class TransitionError {
  constructor(error, route, wasAborted, state) {
    this.error = error;
    this.route = route;
    this.wasAborted = wasAborted;
    this.state = state;
  }

}

exports.TransitionError = TransitionError;