import{assert as t,scheduleRevalidate as e}from"@glimmer/global-context";import{getLast as n,asPresentArray as a}from"@glimmer/util";function r(t){if(null==t)throw new Error("Expected value to be present");return t}const i={};{let e=null;const r=[],o={debugMessage(t,e){let n;if("function"==typeof t)n=t.name;else if("object"==typeof t&&null!==t){n=`(an instance of ${t.constructor&&t.constructor.name||"(unknown class)"})`}else n=void 0===t?"(an unknown tag)":String(t);return`You attempted to update ${e?`\`${e}\` on \`${n}\``:`\`${n}\``}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`}};i.setTrackingTransactionEnv=t=>Object.assign(o,t),i.beginTrackingTransaction=t=>{e=e||new WeakMap;let n=t||void 0,a=r[r.length-1]??null;r.push({parent:a,debugLabel:n})},i.endTrackingTransaction=()=>{if(0===r.length)throw new Error("attempted to close a tracking transaction, but one was not open");r.pop(),0===r.length&&(e=null)},i.resetTrackingTransaction=()=>{let t="";return r.length>0&&(t=i.logTrackingStack(r[r.length-1])),r.splice(0,r.length),e=null,t},i.runInTrackingTransaction=(t,e)=>{i.beginTrackingTransaction(e);let n=!0;try{let e=t();return n=!1,e}finally{!0!==n&&i.endTrackingTransaction()}};let s=(t,e,n,a=-1)=>{let r=a;for(;n-- >0&&r++<t.length&&(r=t.indexOf(e,r),!(r<0)););return r},l=(t,e,n)=>{let a=[o.debugMessage(e,n&&String(n))];return a.push(`\`${String(n)}\` was first used:`),a.push(i.logTrackingStack(t)),a.push("Stack trace for the update:"),a.join("\n\n")};i.logTrackingStack=t=>{let e=[],n=t||r[r.length-1];if(void 0===n)return"";for(;n;)n.debugLabel&&e.unshift(n.debugLabel),n=n.parent;return e.map(((t,e)=>" ".repeat(2*e)+t)).join("\n")},i.markTagAsConsumed=t=>{if(!e||e.has(t))return;e.set(t,n(a(r)));let o=t.subtag;o&&i.markTagAsConsumed&&(Array.isArray(o)?o.forEach(i.markTagAsConsumed):i.markTagAsConsumed(o))},i.assertTagNotConsumed=(n,a,r)=>{if(null===e)return;let i=e.get(n);var o;if(i)try{t(!1,l(i,a,r))}catch(t){if("object"==typeof(o=t)&&null!==o&&"stack"in o&&"string"==typeof o.stack){let e=t.stack.indexOf("Stack trace for the update:");if(-1!==e){let n=s(t.stack,"\n",1,e),a=s(t.stack,"\n",4,e);t.stack=t.stack.substr(0,n)+t.stack.substr(a)}}throw t}}}const o=0,s=1,l=NaN;let u=1;function c(){u++}const f=1,g=Symbol("TAG_COMPUTE");function d(t){return t[g]()}function h(t,e){return e>=t[g]()}const p=Symbol("TAG_TYPE");let b;b=new WeakMap;class m{static combine(t){switch(t.length){case 0:return v;case 1:return t[0];default:{let e=new m(2);return e.subtag=t,e}}}revision=1;lastChecked=1;lastValue=1;isUpdating=!1;subtag=null;subtagBufferCache=null;[p];constructor(t){this[p]=t}[g](){let{lastChecked:t}=this;if(!0===this.isUpdating){if(e=this,void 0!==b&&!b.has(e))throw new Error("Cycles in tags are not allowed");this.lastChecked=++u}else if(t!==u){this.isUpdating=!0,this.lastChecked=u;try{let{subtag:t,revision:e}=this;if(null!==t)if(Array.isArray(t))e=t.reduce(((t,e)=>{let n=e[g]();return n>t?n:t}),e);else{let n=t[g]();n===this.subtagBufferCache?e=e>this.lastValue?e:this.lastValue:(this.subtagBufferCache=null,e=e>n?e:n)}this.lastValue=e}finally{this.isUpdating=!1}}var e;return this.lastValue}static updateTag(t,e){if(t[p]!==f)throw new Error("Attempted to update a tag that was not updatable");let n=t,a=e;a===v?n.subtag=null:(n.subtagBufferCache=a[g](),n.subtag=a)}static dirtyTag(t,n){if(t[p]!==f&&0!==t[p])throw new Error("Attempted to dirty a tag that was not dirtyable");!0!==n&&r(i.assertTagNotConsumed)(t),t.revision=++u,e()}}const w=m.dirtyTag,y=m.updateTag;function T(){return new m(0)}function k(){return new m(f)}const v=new m(3);function C(t){return t===v}class S{[p]=100;[g](){return NaN}}const A=new S;class E{[p]=101;[g](){return u}}const M=new E,N=m.combine;let $=k(),L=k(),V=k();d($),w($),d($),y($,N([L,V])),d($),w(L),d($),w(V),d($),y($,V),d($),w(V),d($);const j=new WeakMap;function U(t,e,n){if(("object"!=typeof(a=t)||null===a)&&"function"!=typeof a)throw new Error("BUG: Can't update a tag for a primitive");var a;let o=void 0===n?j.get(t):n;if(void 0===o)return;let s=o.get(e);void 0!==s&&(r(i.assertTagNotConsumed)(s,t,e),w(s,!0))}function B(t){let e=j.get(t);return void 0===e&&(e=new Map,j.set(t,e)),e}function G(t,e,n){let a=void 0===n?B(t):n,r=a.get(e);return void 0===r&&(r=k(),a.set(e,r)),r}class O{tags=new Set;last=null;add(t){t!==v&&(this.tags.add(t),r(i.markTagAsConsumed)(t),this.last=t)}combine(){let{tags:t}=this;return 0===t.size?v:1===t.size?this.last:N(Array.from(this.tags))}}let I=null;const _=[];function x(t){_.push(I),I=new O,r(i.beginTrackingTransaction)(t)}function R(){let t=I;if(0===_.length)throw new Error("attempted to close a tracking frame, but one was not open");return r(i.endTrackingTransaction)(),I=_.pop()||null,r(t).combine()}function W(){_.push(I),I=null}function P(){if(0===_.length)throw new Error("attempted to close a tracking frame, but one was not open");I=_.pop()||null}function Y(){for(;_.length>0;)_.pop();return I=null,r(i.resetTrackingTransaction)()}function z(){return null!==I}function D(t){null!==I&&I.add(t)}const F=Symbol("FN"),H=Symbol("LAST_VALUE"),q=Symbol("TAG"),J=Symbol("SNAPSHOT"),K=Symbol("DEBUG_LABEL");function Q(t,e){if("function"!=typeof t)throw new Error(`createCache() must be passed a function as its first parameter. Called with: ${String(t)}`);let n={[F]:t,[H]:void 0,[q]:void 0,[J]:-1};return n[K]=e,n}function X(t){tt(t,"getValue");let e=t[F],n=t[q],a=t[J];if(void 0!==n&&h(n,a))D(n);else{x();try{t[H]=e()}finally{n=R(),t[q]=n,t[J]=d(n),D(n)}}return t[H]}function Z(t){tt(t,"isConst");let e=t[q];return function(t,e){if(void 0===t)throw new Error(`isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\n\n${String(e[F])}`)}(e,t),C(e)}function tt(t,e){if("object"!=typeof t||null===t||!(F in t))throw new Error(`${e}() can only be used on an instance of a cache created with createCache(). Called with: ${String(t)}`)}function et(t,e){let n;x(e);try{t()}finally{n=R()}return n}function nt(t){W();try{return t()}finally{P()}}function at(t,e){let n=new WeakMap,a="function"==typeof e;return{getter:function(r){let i;return D(G(r,t)),a&&!n.has(r)?(i=e.call(r),n.set(r,i)):i=n.get(r),i},setter:function(e,a){U(e,t),n.set(e,a)}}}const rt=Symbol("GLIMMER_VALIDATOR_REGISTRATION"),it=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}();if(!0===it[rt])throw new Error("The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.");it[rt]=!0;export{b as ALLOW_CYCLES,g as COMPUTE,o as CONSTANT,v as CONSTANT_TAG,M as CURRENT_TAG,E as CurrentTag,s as INITIAL,l as VOLATILE,A as VOLATILE_TAG,S as VolatileTag,x as beginTrackFrame,W as beginUntrackFrame,c as bump,N as combine,D as consumeTag,Q as createCache,T as createTag,k as createUpdatableTag,i as debug,w as dirtyTag,U as dirtyTagFor,R as endTrackFrame,P as endUntrackFrame,X as getValue,Z as isConst,C as isConstTag,z as isTracking,Y as resetTracking,G as tagFor,B as tagMetaFor,et as track,at as trackedData,nt as untrack,y as updateTag,h as validateTag,d as valueForTag};
//# sourceMappingURL=index.js.map
