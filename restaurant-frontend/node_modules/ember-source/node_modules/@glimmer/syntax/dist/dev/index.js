import { assert, isPresentArray, assertNever, getFirst, getLast, unwrap, expect, assign, asPresentArray, assertPresentArray, dict } from '@glimmer/util';
import { parseWithoutProcessing, parse } from '@handlebars/parser';
import { EventedTokenizer, EntityParser, HTML5NamedCharRefs } from 'simple-html-tokenizer';
import { DEBUG } from '@glimmer/env';
import { SexpOpcodes } from '@glimmer/wire-format';

var Char = /*#__PURE__*/function (Char) {
  Char[Char["NBSP"] = 160] = "NBSP";
  Char[Char["QUOT"] = 34] = "QUOT";
  Char[Char["LT"] = 60] = "LT";
  Char[Char["GT"] = 62] = "GT";
  Char[Char["AMP"] = 38] = "AMP";
  return Char;
}(Char || {});
const ATTR_VALUE_REGEX_TEST = /["&\xA0]/u;
const ATTR_VALUE_REGEX_REPLACE = new RegExp(ATTR_VALUE_REGEX_TEST.source, 'gu');
const TEXT_REGEX_TEST = /[&<>\xA0]/u;
const TEXT_REGEX_REPLACE = new RegExp(TEXT_REGEX_TEST.source, 'gu');
function attrValueReplacer(char) {
  switch (char.charCodeAt(0)) {
    case Char.NBSP:
      return '&nbsp;';
    case Char.QUOT:
      return '&quot;';
    case Char.AMP:
      return '&amp;';
    default:
      return char;
  }
}
function textReplacer(char) {
  switch (char.charCodeAt(0)) {
    case Char.NBSP:
      return '&nbsp;';
    case Char.AMP:
      return '&amp;';
    case Char.LT:
      return '&lt;';
    case Char.GT:
      return '&gt;';
    default:
      return char;
  }
}
function escapeAttrValue(attrValue) {
  if (ATTR_VALUE_REGEX_TEST.test(attrValue)) {
    return attrValue.replace(ATTR_VALUE_REGEX_REPLACE, attrValueReplacer);
  }
  return attrValue;
}
function escapeText(text) {
  if (TEXT_REGEX_TEST.test(text)) {
    return text.replace(TEXT_REGEX_REPLACE, textReplacer);
  }
  return text;
}
function sortByLoc(a, b) {
  // If either is invisible, don't try to order them
  if (a.loc.isInvisible || b.loc.isInvisible) {
    return 0;
  }
  if (a.loc.startPosition.line < b.loc.startPosition.line) {
    return -1;
  }
  if (a.loc.startPosition.line === b.loc.startPosition.line && a.loc.startPosition.column < b.loc.startPosition.column) {
    return -1;
  }
  if (a.loc.startPosition.line === b.loc.startPosition.line && a.loc.startPosition.column === b.loc.startPosition.column) {
    return 0;
  }
  return 1;
}

const voidMap = new Set(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
function getVoidTags() {
  return [...voidMap];
}
const NON_WHITESPACE = /^\S/u;
/**
 * Examples when true:
 *  - link
 *  - liNK
 *
 * Examples when false:
 *  - Link (component)
 */
function isVoidTag(tag) {
  return voidMap.has(tag.toLowerCase()) && tag[0]?.toLowerCase() === tag[0];
}
class Printer {
  buffer = '';
  options;
  constructor(options) {
    this.options = options;
  }

  /*
    This is used by _all_ methods on this Printer class that add to `this.buffer`,
    it allows consumers of the printer to use alternate string representations for
    a given node.
     The primary use case for this are things like source -> source codemod utilities.
    For example, ember-template-recast attempts to always preserve the original string
    formatting in each AST node if no modifications are made to it.
  */
  handledByOverride(node, ensureLeadingWhitespace = false) {
    if (this.options.override !== undefined) {
      let result = this.options.override(node, this.options);
      if (typeof result === 'string') {
        if (ensureLeadingWhitespace && NON_WHITESPACE.test(result)) {
          result = ` ${result}`;
        }
        this.buffer += result;
        return true;
      }
    }
    return false;
  }
  Node(node) {
    switch (node.type) {
      case 'MustacheStatement':
      case 'BlockStatement':
      case 'PartialStatement':
      case 'MustacheCommentStatement':
      case 'CommentStatement':
      case 'TextNode':
      case 'ElementNode':
      case 'AttrNode':
      case 'Block':
      case 'Template':
        return this.TopLevelStatement(node);
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'UndefinedLiteral':
      case 'NullLiteral':
      case 'PathExpression':
      case 'SubExpression':
        return this.Expression(node);
      case 'Program':
        return this.Block(node);
      case 'ConcatStatement':
        // should have an AttrNode parent
        return this.ConcatStatement(node);
      case 'Hash':
        return this.Hash(node);
      case 'HashPair':
        return this.HashPair(node);
      case 'ElementModifierStatement':
        return this.ElementModifierStatement(node);
    }
  }
  Expression(expression) {
    switch (expression.type) {
      case 'StringLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'UndefinedLiteral':
      case 'NullLiteral':
        return this.Literal(expression);
      case 'PathExpression':
        return this.PathExpression(expression);
      case 'SubExpression':
        return this.SubExpression(expression);
    }
  }
  Literal(literal) {
    switch (literal.type) {
      case 'StringLiteral':
        return this.StringLiteral(literal);
      case 'BooleanLiteral':
        return this.BooleanLiteral(literal);
      case 'NumberLiteral':
        return this.NumberLiteral(literal);
      case 'UndefinedLiteral':
        return this.UndefinedLiteral(literal);
      case 'NullLiteral':
        return this.NullLiteral(literal);
    }
  }
  TopLevelStatement(statement) {
    switch (statement.type) {
      case 'MustacheStatement':
        return this.MustacheStatement(statement);
      case 'BlockStatement':
        return this.BlockStatement(statement);
      case 'PartialStatement':
        return this.PartialStatement(statement);
      case 'MustacheCommentStatement':
        return this.MustacheCommentStatement(statement);
      case 'CommentStatement':
        return this.CommentStatement(statement);
      case 'TextNode':
        return this.TextNode(statement);
      case 'ElementNode':
        return this.ElementNode(statement);
      case 'Block':
      case 'Template':
        return this.Block(statement);
      case 'AttrNode':
        // should have element
        return this.AttrNode(statement);
    }
  }
  Block(block) {
    /*
      When processing a template like:
       ```hbs
      {{#if whatever}}
        whatever
      {{else if somethingElse}}
        something else
      {{else}}
        fallback
      {{/if}}
      ```
       The AST still _effectively_ looks like:
       ```hbs
      {{#if whatever}}
        whatever
      {{else}}{{#if somethingElse}}
        something else
      {{else}}
        fallback
      {{/if}}{{/if}}
      ```
       The only way we can tell if that is the case is by checking for
      `block.chained`, but unfortunately when the actual statements are
      processed the `block.body[0]` node (which will always be a
      `BlockStatement`) has no clue that its ancestor `Block` node was
      chained.
       This "forwards" the `chained` setting so that we can check
      it later when processing the `BlockStatement`.
    */
    if (block.chained) {
      let firstChild = block.body[0];
      firstChild.chained = true;
    }
    if (this.handledByOverride(block)) {
      return;
    }
    this.TopLevelStatements(block.body);
  }
  TopLevelStatements(statements) {
    statements.forEach(statement => this.TopLevelStatement(statement));
  }
  ElementNode(el) {
    if (this.handledByOverride(el)) {
      return;
    }
    this.OpenElementNode(el);
    this.TopLevelStatements(el.children);
    this.CloseElementNode(el);
  }
  OpenElementNode(el) {
    this.buffer += `<${el.tag}`;
    const parts = [...el.attributes, ...el.modifiers, ...el.comments].sort(sortByLoc);
    for (const part of parts) {
      this.buffer += ' ';
      switch (part.type) {
        case 'AttrNode':
          this.AttrNode(part);
          break;
        case 'ElementModifierStatement':
          this.ElementModifierStatement(part);
          break;
        case 'MustacheCommentStatement':
          this.MustacheCommentStatement(part);
          break;
      }
    }
    if (el.blockParams.length) {
      this.BlockParams(el.blockParams);
    }
    if (el.selfClosing) {
      this.buffer += ' /';
    }
    this.buffer += '>';
  }
  CloseElementNode(el) {
    if (el.selfClosing || isVoidTag(el.tag)) {
      return;
    }
    this.buffer += `</${el.tag}>`;
  }
  AttrNode(attr) {
    if (this.handledByOverride(attr)) {
      return;
    }
    let {
      name,
      value
    } = attr;
    this.buffer += name;
    if (value.type !== 'TextNode' || value.chars.length > 0) {
      this.buffer += '=';
      this.AttrNodeValue(value);
    }
  }
  AttrNodeValue(value) {
    if (value.type === 'TextNode') {
      this.buffer += '"';
      this.TextNode(value, true);
      this.buffer += '"';
    } else {
      this.Node(value);
    }
  }
  TextNode(text, isAttr) {
    if (this.handledByOverride(text)) {
      return;
    }
    if (this.options.entityEncoding === 'raw') {
      this.buffer += text.chars;
    } else if (isAttr) {
      this.buffer += escapeAttrValue(text.chars);
    } else {
      this.buffer += escapeText(text.chars);
    }
  }
  MustacheStatement(mustache) {
    if (this.handledByOverride(mustache)) {
      return;
    }
    this.buffer += mustache.escaped ? '{{' : '{{{';
    if (mustache.strip.open) {
      this.buffer += '~';
    }
    this.Expression(mustache.path);
    this.Params(mustache.params);
    this.Hash(mustache.hash);
    if (mustache.strip.close) {
      this.buffer += '~';
    }
    this.buffer += mustache.escaped ? '}}' : '}}}';
  }
  BlockStatement(block) {
    if (this.handledByOverride(block)) {
      return;
    }
    if (block.chained) {
      this.buffer += block.inverseStrip.open ? '{{~' : '{{';
      this.buffer += 'else ';
    } else {
      this.buffer += block.openStrip.open ? '{{~#' : '{{#';
    }
    this.Expression(block.path);
    this.Params(block.params);
    this.Hash(block.hash);
    if (block.program.blockParams.length) {
      this.BlockParams(block.program.blockParams);
    }
    if (block.chained) {
      this.buffer += block.inverseStrip.close ? '~}}' : '}}';
    } else {
      this.buffer += block.openStrip.close ? '~}}' : '}}';
    }
    this.Block(block.program);
    if (block.inverse) {
      if (!block.inverse.chained) {
        this.buffer += block.inverseStrip.open ? '{{~' : '{{';
        this.buffer += 'else';
        this.buffer += block.inverseStrip.close ? '~}}' : '}}';
      }
      this.Block(block.inverse);
    }
    if (!block.chained) {
      this.buffer += block.closeStrip.open ? '{{~/' : '{{/';
      this.Expression(block.path);
      this.buffer += block.closeStrip.close ? '~}}' : '}}';
    }
  }
  BlockParams(blockParams) {
    this.buffer += ` as |${blockParams.join(' ')}|`;
  }
  PartialStatement(partial) {
    if (this.handledByOverride(partial)) {
      return;
    }
    this.buffer += '{{>';
    this.Expression(partial.name);
    this.Params(partial.params);
    this.Hash(partial.hash);
    this.buffer += '}}';
  }
  ConcatStatement(concat) {
    if (this.handledByOverride(concat)) {
      return;
    }
    this.buffer += '"';
    concat.parts.forEach(part => {
      if (part.type === 'TextNode') {
        this.TextNode(part, true);
      } else {
        this.Node(part);
      }
    });
    this.buffer += '"';
  }
  MustacheCommentStatement(comment) {
    if (this.handledByOverride(comment)) {
      return;
    }
    this.buffer += `{{!--${comment.value}--}}`;
  }
  ElementModifierStatement(mod) {
    if (this.handledByOverride(mod)) {
      return;
    }
    this.buffer += '{{';
    this.Expression(mod.path);
    this.Params(mod.params);
    this.Hash(mod.hash);
    this.buffer += '}}';
  }
  CommentStatement(comment) {
    if (this.handledByOverride(comment)) {
      return;
    }
    this.buffer += `<!--${comment.value}-->`;
  }
  PathExpression(path) {
    if (this.handledByOverride(path)) {
      return;
    }
    this.buffer += path.original;
  }
  SubExpression(sexp) {
    if (this.handledByOverride(sexp)) {
      return;
    }
    this.buffer += '(';
    this.Expression(sexp.path);
    this.Params(sexp.params);
    this.Hash(sexp.hash);
    this.buffer += ')';
  }
  Params(params) {
    // TODO: implement a top level Params AST node (just like the Hash object)
    // so that this can also be overridden
    if (params.length) {
      params.forEach(param => {
        this.buffer += ' ';
        this.Expression(param);
      });
    }
  }
  Hash(hash) {
    if (this.handledByOverride(hash, true)) {
      return;
    }
    hash.pairs.forEach(pair => {
      this.buffer += ' ';
      this.HashPair(pair);
    });
  }
  HashPair(pair) {
    if (this.handledByOverride(pair)) {
      return;
    }
    this.buffer += pair.key;
    this.buffer += '=';
    this.Node(pair.value);
  }
  StringLiteral(str) {
    if (this.handledByOverride(str)) {
      return;
    }
    this.buffer += JSON.stringify(str.value);
  }
  BooleanLiteral(bool) {
    if (this.handledByOverride(bool)) {
      return;
    }
    this.buffer += bool.value;
  }
  NumberLiteral(number) {
    if (this.handledByOverride(number)) {
      return;
    }
    this.buffer += number.value;
  }
  UndefinedLiteral(node) {
    if (this.handledByOverride(node)) {
      return;
    }
    this.buffer += 'undefined';
  }
  NullLiteral(node) {
    if (this.handledByOverride(node)) {
      return;
    }
    this.buffer += 'null';
  }
  print(node) {
    let {
      options
    } = this;
    if (options.override) {
      let result = options.override(node, options);
      if (result !== undefined) {
        return result;
      }
    }
    this.buffer = '';
    this.Node(node);
    return this.buffer;
  }
}

function build(ast, options = {
  entityEncoding: 'transformed'
}) {
  if (!ast) {
    return '';
  }
  let printer = new Printer(options);
  return printer.print(ast);
}

function isKeyword(word) {
  return word in KEYWORDS_TYPES;
}

/**
 * This includes the full list of keywords currently in use in the template
 * language, and where their valid usages are.
 */
const KEYWORDS_TYPES = {
  component: ['Call', 'Append', 'Block'],
  debugger: ['Append'],
  'each-in': ['Block'],
  each: ['Block'],
  'has-block-params': ['Call', 'Append'],
  'has-block': ['Call', 'Append'],
  helper: ['Call', 'Append'],
  if: ['Call', 'Append', 'Block'],
  'in-element': ['Block'],
  let: ['Block'],
  'link-to': ['Append', 'Block'],
  log: ['Call', 'Append'],
  modifier: ['Call'],
  mount: ['Append'],
  mut: ['Call', 'Append'],
  outlet: ['Append'],
  'query-params': ['Call'],
  readonly: ['Call', 'Append'],
  unbound: ['Call', 'Append'],
  unless: ['Call', 'Append', 'Block'],
  with: ['Block'],
  yield: ['Append']
};

const UNKNOWN_POSITION = Object.freeze({
  line: 1,
  column: 0
});
const SYNTHETIC_LOCATION = Object.freeze({
  source: '(synthetic)',
  start: UNKNOWN_POSITION,
  end: UNKNOWN_POSITION
});
const NON_EXISTENT_LOCATION = Object.freeze({
  source: '(nonexistent)',
  start: UNKNOWN_POSITION,
  end: UNKNOWN_POSITION
});
const BROKEN_LOCATION = Object.freeze({
  source: '(broken)',
  start: UNKNOWN_POSITION,
  end: UNKNOWN_POSITION
});

let OffsetKind = /*#__PURE__*/function (OffsetKind) {
  OffsetKind["CharPosition"] = "CharPosition";
  OffsetKind["HbsPosition"] = "HbsPosition";
  OffsetKind["InternalsSynthetic"] = "InternalsSynthetic";
  OffsetKind["NonExistent"] = "NonExistent";
  OffsetKind["Broken"] = "Broken";
  return OffsetKind;
}({});

/**
 * This file implements the DSL used by span and offset in places where they need to exhaustively
 * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
 * offsets).
 *
 * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
 * removed.
 */

const MatchAny = 'MATCH_ANY';
const IsInvisible = 'IS_INVISIBLE';
class WhenList {
  _whens;
  constructor(whens) {
    this._whens = whens;
  }
  first(kind) {
    for (const when of this._whens) {
      const value = when.match(kind);
      if (isPresentArray(value)) {
        return value[0];
      }
    }
    return null;
  }
}
class When {
  _map = new Map();
  get(pattern, or) {
    let value = this._map.get(pattern);
    if (value) {
      return value;
    }
    value = or();
    this._map.set(pattern, value);
    return value;
  }
  add(pattern, out) {
    this._map.set(pattern, out);
  }
  match(kind) {
    const pattern = patternFor(kind);
    const out = [];
    const exact = this._map.get(pattern);
    const fallback = this._map.get(MatchAny);
    if (exact) {
      out.push(exact);
    }
    if (fallback) {
      out.push(fallback);
    }
    return out;
  }
}
function match(callback) {
  return callback(new Matcher()).check();
}
class Matcher {
  _whens = new When();

  /**
   * You didn't exhaustively match all possibilities.
   */
  check() {
    return (left, right) => this.matchFor(left.kind, right.kind)(left, right);
  }
  matchFor(left, right) {
    const nesteds = this._whens.match(left);
    assert(isPresentArray(nesteds), `no match defined for (${left}, ${right}) and no AnyMatch defined either`);
    const callback = new WhenList(nesteds).first(right);
    assert(callback !== null, `no match defined for (${left}, ${right}) and no AnyMatch defined either`);
    return callback;
  }

  // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness
  // checking so that matchers can ensure they've actually covered all the cases (and TypeScript
  // will treat it as an exhaustive match).
  when(left, right, callback) {
    this._whens.get(left, () => new When()).add(right, callback);
    return this;
  }
}
function patternFor(kind) {
  switch (kind) {
    case OffsetKind.Broken:
    case OffsetKind.InternalsSynthetic:
    case OffsetKind.NonExistent:
      return IsInvisible;
    default:
      return kind;
  }
}

class SourceSlice {
  static synthetic(chars) {
    let offsets = SourceSpan.synthetic(chars);
    return new SourceSlice({
      loc: offsets,
      chars: chars
    });
  }
  static load(source, slice) {
    return new SourceSlice({
      loc: SourceSpan.load(source, slice[1]),
      chars: slice[0]
    });
  }
  chars;
  loc;
  constructor(options) {
    this.loc = options.loc;
    this.chars = options.chars;
  }
  getString() {
    return this.chars;
  }
  serialize() {
    return [this.chars, this.loc.serialize()];
  }
}

/**
 * All spans have these details in common.
 */

/**
 * A `SourceSpan` object represents a span of characters inside of a template source.
 *
 * There are three kinds of `SourceSpan` objects:
 *
 * - `ConcreteSourceSpan`, which contains byte offsets
 * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
 *   converted to byte offsets on demand.
 * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
 *   because:
 *     - they were created synthetically
 *     - their location is nonsensical (the span is broken)
 *     - they represent nothing in the source (this currently happens only when a bug in the
 *       upstream Handlebars parser fails to assign a location to empty blocks)
 *
 * At a high level, all `SourceSpan` objects provide:
 *
 * - byte offsets
 * - source in column and line format
 *
 * And you can do these operations on `SourceSpan`s:
 *
 * - collapse it to a `SourceSpan` representing its starting or ending position
 * - slice out some characters, optionally skipping some characters at the beginning or end
 * - create a new `SourceSpan` with a different starting or ending offset
 *
 * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
 * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
 *
 * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
 * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
 *
 * The goal is to avoid creating any problems for use-cases like AST Explorer.
 */
class SourceSpan {
  static get NON_EXISTENT() {
    return new InvisibleSpan(OffsetKind.NonExistent, NON_EXISTENT_LOCATION).wrap();
  }
  static load(source, serialized) {
    if (typeof serialized === 'number') {
      return SourceSpan.forCharPositions(source, serialized, serialized);
    } else if (typeof serialized === 'string') {
      return SourceSpan.synthetic(serialized);
    } else if (Array.isArray(serialized)) {
      return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);
    } else if (serialized === OffsetKind.NonExistent) {
      return SourceSpan.NON_EXISTENT;
    } else if (serialized === OffsetKind.Broken) {
      return SourceSpan.broken(BROKEN_LOCATION);
    }
    assertNever(serialized);
  }
  static forHbsLoc(source, loc) {
    const start = new HbsPosition(source, loc.start);
    const end = new HbsPosition(source, loc.end);
    return new HbsSpan(source, {
      start,
      end
    }, loc).wrap();
  }
  static forCharPositions(source, startPos, endPos) {
    const start = new CharPosition(source, startPos);
    const end = new CharPosition(source, endPos);
    return new CharPositionSpan(source, {
      start,
      end
    }).wrap();
  }
  static synthetic(chars) {
    return new InvisibleSpan(OffsetKind.InternalsSynthetic, NON_EXISTENT_LOCATION, chars).wrap();
  }
  static broken(pos = BROKEN_LOCATION) {
    return new InvisibleSpan(OffsetKind.Broken, pos).wrap();
  }
  isInvisible;
  constructor(data) {
    this.data = data;
    this.isInvisible = data.kind !== OffsetKind.CharPosition && data.kind !== OffsetKind.HbsPosition;
  }
  getStart() {
    return this.data.getStart().wrap();
  }
  getEnd() {
    return this.data.getEnd().wrap();
  }
  get loc() {
    const span = this.data.toHbsSpan();
    return span === null ? BROKEN_LOCATION : span.toHbsLoc();
  }
  get module() {
    return this.data.getModule();
  }

  /**
   * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */
  get startPosition() {
    return this.loc.start;
  }

  /**
   * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */
  get endPosition() {
    return this.loc.end;
  }

  /**
   * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
   */
  toJSON() {
    return this.loc;
  }

  /**
   * Create a new span with the current span's end and a new beginning.
   */
  withStart(other) {
    return span(other.data, this.data.getEnd());
  }

  /**
   * Create a new span with the current span's beginning and a new ending.
   */
  withEnd(other) {
    return span(this.data.getStart(), other.data);
  }
  asString() {
    return this.data.asString();
  }

  /**
   * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
   * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
   * string.
   */
  toSlice(expected) {
    const chars = this.data.asString();
    if (DEBUG) {
      if (expected !== undefined && chars !== expected) {
        // eslint-disable-next-line no-console
        console.warn(`unexpectedly found ${JSON.stringify(chars)} when slicing source, but expected ${JSON.stringify(expected)}`);
      }
    }
    return new SourceSlice({
      loc: this,
      chars: expected || chars
    });
  }

  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use startPosition instead
   */
  get start() {
    return this.loc.start;
  }

  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withStart instead
   */
  set start(position) {
    this.data.locDidUpdate({
      start: position
    });
  }

  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use endPosition instead
   */
  get end() {
    return this.loc.end;
  }

  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withEnd instead
   */
  set end(position) {
    this.data.locDidUpdate({
      end: position
    });
  }

  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use module instead
   */
  get source() {
    return this.module;
  }
  collapse(where) {
    switch (where) {
      case 'start':
        return this.getStart().collapsed();
      case 'end':
        return this.getEnd().collapsed();
    }
  }
  extend(other) {
    return span(this.data.getStart(), other.data.getEnd());
  }
  serialize() {
    return this.data.serialize();
  }
  slice({
    skipStart = 0,
    skipEnd = 0
  }) {
    return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);
  }
  sliceStartChars({
    skipStart = 0,
    chars
  }) {
    return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);
  }
  sliceEndChars({
    skipEnd = 0,
    chars
  }) {
    return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);
  }
}
class CharPositionSpan {
  kind = OffsetKind.CharPosition;
  _locPosSpan = null;
  constructor(source, charPositions) {
    this.source = source;
    this.charPositions = charPositions;
  }
  wrap() {
    return new SourceSpan(this);
  }
  asString() {
    return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);
  }
  getModule() {
    return this.source.module;
  }
  getStart() {
    return this.charPositions.start;
  }
  getEnd() {
    return this.charPositions.end;
  }
  locDidUpdate() {
  }
  toHbsSpan() {
    let locPosSpan = this._locPosSpan;
    if (locPosSpan === null) {
      const start = this.charPositions.start.toHbsPos();
      const end = this.charPositions.end.toHbsPos();
      if (start === null || end === null) {
        locPosSpan = this._locPosSpan = BROKEN;
      } else {
        locPosSpan = this._locPosSpan = new HbsSpan(this.source, {
          start,
          end
        });
      }
    }
    return locPosSpan === BROKEN ? null : locPosSpan;
  }
  serialize() {
    const {
      start: {
        charPos: start
      },
      end: {
        charPos: end
      }
    } = this.charPositions;
    if (start === end) {
      return start;
    } else {
      return [start, end];
    }
  }
  toCharPosSpan() {
    return this;
  }
}
class HbsSpan {
  kind = OffsetKind.HbsPosition;
  _charPosSpan = null;

  // the source location from Handlebars + AST Plugins -- could be wrong
  _providedHbsLoc;
  constructor(source, hbsPositions, providedHbsLoc = null) {
    this.source = source;
    this.hbsPositions = hbsPositions;
    this._providedHbsLoc = providedHbsLoc;
  }
  serialize() {
    const charPos = this.toCharPosSpan();
    return charPos === null ? OffsetKind.Broken : charPos.wrap().serialize();
  }
  wrap() {
    return new SourceSpan(this);
  }
  updateProvided(pos, edge) {
    if (this._providedHbsLoc) {
      this._providedHbsLoc[edge] = pos;
    }

    // invalidate computed character offsets
    this._charPosSpan = null;
    this._providedHbsLoc = {
      start: pos,
      end: pos
    };
  }
  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.updateProvided(start, 'start');
      this.hbsPositions.start = new HbsPosition(this.source, start, null);
    }
    if (end !== undefined) {
      this.updateProvided(end, 'end');
      this.hbsPositions.end = new HbsPosition(this.source, end, null);
    }
  }
  asString() {
    const span = this.toCharPosSpan();
    return span === null ? '' : span.asString();
  }
  getModule() {
    return this.source.module;
  }
  getStart() {
    return this.hbsPositions.start;
  }
  getEnd() {
    return this.hbsPositions.end;
  }
  toHbsLoc() {
    return {
      start: this.hbsPositions.start.hbsPos,
      end: this.hbsPositions.end.hbsPos
    };
  }
  toHbsSpan() {
    return this;
  }
  toCharPosSpan() {
    let charPosSpan = this._charPosSpan;
    if (charPosSpan === null) {
      const start = this.hbsPositions.start.toCharPos();
      const end = this.hbsPositions.end.toCharPos();
      if (start && end) {
        charPosSpan = this._charPosSpan = new CharPositionSpan(this.source, {
          start,
          end
        });
      } else {
        charPosSpan = this._charPosSpan = BROKEN;
        return null;
      }
    }
    return charPosSpan === BROKEN ? null : charPosSpan;
  }
}
class InvisibleSpan {
  constructor(kind,
  // whatever was provided, possibly broken
  loc,
  // if the span represents a synthetic string
  string = null) {
    this.kind = kind;
    this.loc = loc;
    this.string = string;
  }
  serialize() {
    switch (this.kind) {
      case OffsetKind.Broken:
      case OffsetKind.NonExistent:
        return this.kind;
      case OffsetKind.InternalsSynthetic:
        return this.string || '';
    }
  }
  wrap() {
    return new SourceSpan(this);
  }
  asString() {
    return this.string || '';
  }
  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.loc.start = start;
    }
    if (end !== undefined) {
      this.loc.end = end;
    }
  }
  getModule() {
    // TODO: Make this reflect the actual module this span originated from
    return 'an unknown module';
  }
  getStart() {
    return new InvisiblePosition(this.kind, this.loc.start);
  }
  getEnd() {
    return new InvisiblePosition(this.kind, this.loc.end);
  }
  toCharPosSpan() {
    return this;
  }
  toHbsSpan() {
    return null;
  }
  toHbsLoc() {
    return BROKEN_LOCATION;
  }
}
const span = match(m => m.when(OffsetKind.HbsPosition, OffsetKind.HbsPosition, (left, right) => new HbsSpan(left.source, {
  start: left,
  end: right
}).wrap()).when(OffsetKind.CharPosition, OffsetKind.CharPosition, (left, right) => new CharPositionSpan(left.source, {
  start: left,
  end: right
}).wrap()).when(OffsetKind.CharPosition, OffsetKind.HbsPosition, (left, right) => {
  const rightCharPos = right.toCharPos();
  if (rightCharPos === null) {
    return new InvisibleSpan(OffsetKind.Broken, BROKEN_LOCATION).wrap();
  } else {
    return span(left, rightCharPos);
  }
}).when(OffsetKind.HbsPosition, OffsetKind.CharPosition, (left, right) => {
  const leftCharPos = left.toCharPos();
  if (leftCharPos === null) {
    return new InvisibleSpan(OffsetKind.Broken, BROKEN_LOCATION).wrap();
  } else {
    return span(leftCharPos, right);
  }
}).when(IsInvisible, MatchAny, left => new InvisibleSpan(left.kind, BROKEN_LOCATION).wrap()).when(MatchAny, IsInvisible, (_, right) => new InvisibleSpan(right.kind, BROKEN_LOCATION).wrap()));

/**
 * All positions have these details in common. Most notably, all three kinds of positions can
 * must be able to attempt to convert themselves into {@see CharPosition}.
 */

/**
 * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
 * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
 * attempted (and therefore to cache the failure)
 */
const BROKEN = 'BROKEN';
/**
 * A `SourceOffset` represents a single position in the source.
 *
 * There are three kinds of backing data for `SourceOffset` objects:
 *
 * - `CharPosition`, which contains a character offset into the raw source string
 * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
 *   converted to a `CharPosition` on demand.
 * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
 */
class SourceOffset {
  /**
   * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
   * into a character offset on demand, which avoids unnecessarily computing the offset of every
   * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
   */
  static forHbsPos(source, pos) {
    return new HbsPosition(source, pos, null).wrap();
  }

  /**
   * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
   * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
   * any part of the source.
   */
  static broken(pos = UNKNOWN_POSITION) {
    return new InvisiblePosition(OffsetKind.Broken, pos).wrap();
  }
  constructor(data) {
    this.data = data;
  }

  /**
   * Get the character offset for this `SourceOffset`, if possible.
   */
  get offset() {
    const charPos = this.data.toCharPos();
    return charPos === null ? null : charPos.offset;
  }

  /**
   * Compare this offset with another one.
   *
   * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
   * the same. This avoids computing offsets unnecessarily.
   *
   * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
   * are the same.
   */
  eql(right) {
    return eql(this.data, right.data);
  }

  /**
   * Create a span that starts from this source offset and ends with another source offset. Avoid
   * computing character offsets if both `SourceOffset`s are still lazy.
   */
  until(other) {
    return span(this.data, other.data);
  }

  /**
   * Create a `SourceOffset` by moving the character position represented by this source offset
   * forward or backward (if `by` is negative), if possible.
   *
   * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
   *
   * If the resulting character offset is less than 0 or greater than the size of the source, `move`
   * returns a broken offset.
   */
  move(by) {
    const charPos = this.data.toCharPos();
    if (charPos === null) {
      return SourceOffset.broken();
    } else {
      const result = charPos.offset + by;
      if (charPos.source.check(result)) {
        return new CharPosition(charPos.source, result).wrap();
      } else {
        return SourceOffset.broken();
      }
    }
  }

  /**
   * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
   * computing the character offset if it has not already been computed.
   */
  collapsed() {
    return span(this.data, this.data);
  }

  /**
   * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
   * existing plugins.
   */
  toJSON() {
    return this.data.toJSON();
  }
}
class CharPosition {
  kind = OffsetKind.CharPosition;

  /** Computed from char offset */
  _locPos = null;
  constructor(source, charPos) {
    this.source = source;
    this.charPos = charPos;
  }

  /**
   * This is already a `CharPosition`.
   *
   * {@see HbsPosition} for the alternative.
   */
  toCharPos() {
    return this;
  }

  /**
   * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
   * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
   */
  toJSON() {
    const hbs = this.toHbsPos();
    return hbs === null ? UNKNOWN_POSITION : hbs.toJSON();
  }
  wrap() {
    return new SourceOffset(this);
  }

  /**
   * A `CharPosition` always has an offset it can produce without any additional computation.
   */
  get offset() {
    return this.charPos;
  }

  /**
   * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
   * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
   * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
   * computing the `HbsPosition` should be a one-time operation.
   */
  toHbsPos() {
    let locPos = this._locPos;
    if (locPos === null) {
      const hbsPos = this.source.hbsPosFor(this.charPos);
      if (hbsPos === null) {
        this._locPos = locPos = BROKEN;
      } else {
        this._locPos = locPos = new HbsPosition(this.source, hbsPos, this.charPos);
      }
    }
    return locPos === BROKEN ? null : locPos;
  }
}
class HbsPosition {
  kind = OffsetKind.HbsPosition;
  _charPos;
  constructor(source, hbsPos, charPos = null) {
    this.source = source;
    this.hbsPos = hbsPos;
    this._charPos = charPos === null ? null : new CharPosition(source, charPos);
  }

  /**
   * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
   * computed its `CharPosition`, it will not need to do compute it again, and the same
   * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
   * `CharPosition` should be a one-time operation.
   */
  toCharPos() {
    let charPos = this._charPos;
    if (charPos === null) {
      const charPosNumber = this.source.charPosFor(this.hbsPos);
      if (charPosNumber === null) {
        this._charPos = charPos = BROKEN;
      } else {
        this._charPos = charPos = new CharPosition(this.source, charPosNumber);
      }
    }
    return charPos === BROKEN ? null : charPos;
  }

  /**
   * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
   * does not need to compute anything.
   */
  toJSON() {
    return this.hbsPos;
  }
  wrap() {
    return new SourceOffset(this);
  }

  /**
   * This is already an `HbsPosition`.
   *
   * {@see CharPosition} for the alternative.
   */
  toHbsPos() {
    return this;
  }
}
class InvisiblePosition {
  constructor(kind,
  // whatever was provided, possibly broken
  pos) {
    this.kind = kind;
    this.pos = pos;
  }

  /**
   * A broken position cannot be turned into a {@see CharacterPosition}.
   */
  toCharPos() {
    return null;
  }

  /**
   * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
   * originally identified as broken, non-existent or synthetic.
   *
   * If an `InvisiblePosition` never had an source offset at all, this method returns
   * {@see UNKNOWN_POSITION} for compatibility.
   */
  toJSON() {
    return this.pos;
  }
  wrap() {
    return new SourceOffset(this);
  }
  get offset() {
    return null;
  }
}

/**
 * Compare two {@see AnyPosition} and determine whether they are equal.
 *
 * @see {SourceOffset#eql}
 */
const eql = match(m => m.when(OffsetKind.HbsPosition, OffsetKind.HbsPosition, ({
  hbsPos: left
}, {
  hbsPos: right
}) => left.column === right.column && left.line === right.line).when(OffsetKind.CharPosition, OffsetKind.CharPosition, ({
  charPos: left
}, {
  charPos: right
}) => left === right).when(OffsetKind.CharPosition, OffsetKind.HbsPosition, ({
  offset: left
}, right) => left === right.toCharPos()?.offset).when(OffsetKind.HbsPosition, OffsetKind.CharPosition, (left, {
  offset: right
}) => left.toCharPos()?.offset === right).when(MatchAny, MatchAny, () => false));

class Source {
  static from(source, options = {}) {
    return new Source(source, options.meta?.moduleName);
  }
  constructor(source, module = 'an unknown module') {
    this.source = source;
    this.module = module;
  }

  /**
   * Validate that the character offset represents a position in the source string.
   */
  check(offset) {
    return offset >= 0 && offset <= this.source.length;
  }
  slice(start, end) {
    return this.source.slice(start, end);
  }
  offsetFor(line, column) {
    return SourceOffset.forHbsPos(this, {
      line,
      column
    });
  }
  spanFor({
    start,
    end
  }) {
    return SourceSpan.forHbsLoc(this, {
      start: {
        line: start.line,
        column: start.column
      },
      end: {
        line: end.line,
        column: end.column
      }
    });
  }
  hbsPosFor(offset) {
    let seenLines = 0;
    let seenChars = 0;
    if (offset > this.source.length) {
      return null;
    }

    // eslint-disable-next-line no-constant-condition
    while (true) {
      let nextLine = this.source.indexOf('\n', seenChars);
      if (offset <= nextLine || nextLine === -1) {
        return {
          line: seenLines + 1,
          column: offset - seenChars
        };
      } else {
        seenLines += 1;
        seenChars = nextLine + 1;
      }
    }
  }
  charPosFor(position) {
    let {
      line,
      column
    } = position;
    let sourceString = this.source;
    let sourceLength = sourceString.length;
    let seenLines = 0;
    let seenChars = 0;
    while (seenChars < sourceLength) {
      let nextLine = this.source.indexOf('\n', seenChars);
      if (nextLine === -1) nextLine = this.source.length;
      if (seenLines === line - 1) {
        if (seenChars + column > nextLine) return nextLine;
        if (DEBUG) {
          let roundTrip = this.hbsPosFor(seenChars + column);
          assert(roundTrip !== null, `the returned offset failed to round-trip`);
          assert(roundTrip.line === line, `the round-tripped line didn't match the original line`);
          assert(roundTrip.column === column, `the round-tripped column didn't match the original column`);
        }
        return seenChars + column;
      } else if (nextLine === -1) {
        return 0;
      } else {
        seenLines += 1;
        seenChars = nextLine + 1;
      }
    }
    return sourceLength;
  }
}

class SpanList {
  static range(span, fallback = SourceSpan.NON_EXISTENT) {
    return new SpanList(span.map(loc)).getRangeOffset(fallback);
  }
  _span;
  constructor(span = []) {
    this._span = span;
  }
  add(offset) {
    this._span.push(offset);
  }
  getRangeOffset(fallback) {
    if (isPresentArray(this._span)) {
      let first = getFirst(this._span);
      let last = getLast(this._span);
      return first.extend(last);
    } else {
      return fallback;
    }
  }
}
function loc(span) {
  if (Array.isArray(span)) {
    let first = getFirst(span);
    let last = getLast(span);
    return loc(first).extend(loc(last));
  } else if (span instanceof SourceSpan) {
    return span;
  } else {
    return span.loc;
  }
}
function hasSpan(span) {
  if (Array.isArray(span) && span.length === 0) {
    return false;
  }
  return true;
}
function maybeLoc(location, fallback) {
  if (hasSpan(location)) {
    return loc(location);
  } else {
    return fallback;
  }
}

var api$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NON_EXISTENT_LOCATION: NON_EXISTENT_LOCATION,
  SYNTHETIC_LOCATION: SYNTHETIC_LOCATION,
  Source: Source,
  SourceOffset: SourceOffset,
  SourceSlice: SourceSlice,
  SourceSpan: SourceSpan,
  SpanList: SpanList,
  UNKNOWN_POSITION: UNKNOWN_POSITION,
  hasSpan: hasSpan,
  loc: loc,
  maybeLoc: maybeLoc
});

function generateSyntaxError(message, location) {
  let {
    module,
    loc
  } = location;
  let {
    line,
    column
  } = loc.start;
  let code = location.asString();
  let quotedCode = code ? `\n\n|\n|  ${code.split('\n').join('\n|  ')}\n|\n\n` : '';
  let error = new Error(`${message}: ${quotedCode}(error occurred in '${module}' @ line ${line} : column ${column})`);
  error.name = 'SyntaxError';
  error.location = location;
  error.code = code;
  return error;
}

// ensure stays in sync with typing
// ParentNode and ChildKey types are derived from VisitorKeysMap
const visitorKeys = {
  Program: ['body'],
  Template: ['body'],
  Block: ['body'],
  MustacheStatement: ['path', 'params', 'hash'],
  BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],
  ElementModifierStatement: ['path', 'params', 'hash'],
  PartialStatement: ['name', 'params', 'hash'],
  CommentStatement: [],
  MustacheCommentStatement: [],
  ElementNode: ['attributes', 'modifiers', 'children', 'comments'],
  AttrNode: ['value'],
  TextNode: [],
  ConcatStatement: ['parts'],
  SubExpression: ['path', 'params', 'hash'],
  PathExpression: [],
  PathHead: [],
  StringLiteral: [],
  BooleanLiteral: [],
  NumberLiteral: [],
  NullLiteral: [],
  UndefinedLiteral: [],
  Hash: ['pairs'],
  HashPair: ['value'],
  // v2 new nodes
  NamedBlock: ['attributes', 'modifiers', 'children', 'comments'],
  SimpleElement: ['attributes', 'modifiers', 'children', 'comments'],
  Component: ['head', 'attributes', 'modifiers', 'children', 'comments']
};

const TraversalError = function () {
  TraversalError.prototype = Object.create(Error.prototype);
  TraversalError.prototype.constructor = TraversalError;
  function TraversalError(message, node, parent, key) {
    let error = Error.call(this, message);
    this.key = key;
    this.message = message;
    this.node = node;
    this.parent = parent;
    if (error.stack) {
      this.stack = error.stack;
    }
  }
  return TraversalError;
}();
function cannotRemoveNode(node, parent, key) {
  return new TraversalError('Cannot remove a node unless it is part of an array', node, parent, key);
}
function cannotReplaceNode(node, parent, key) {
  return new TraversalError('Cannot replace a node with multiple nodes unless it is part of an array', node, parent, key);
}
function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
  return new TraversalError('Replacing and removing in key handlers is not yet supported.', node, null, key);
}

class WalkerPath {
  node;
  parent;
  parentKey;
  constructor(node, parent = null, parentKey = null) {
    this.node = node;
    this.parent = parent;
    this.parentKey = parentKey;
  }
  get parentNode() {
    return this.parent ? this.parent.node : null;
  }
  parents() {
    return {
      [Symbol.iterator]: () => {
        return new PathParentsIterator(this);
      }
    };
  }
}
class PathParentsIterator {
  path;
  constructor(path) {
    this.path = path;
  }
  next() {
    if (this.path.parent) {
      this.path = this.path.parent;
      return {
        done: false,
        value: this.path
      };
    } else {
      return {
        done: true,
        value: null
      };
    }
  }
}

function getEnterFunction(handler) {
  if (typeof handler === 'function') {
    return handler;
  } else {
    return handler.enter;
  }
}
function getExitFunction(handler) {
  if (typeof handler === 'function') {
    return undefined;
  } else {
    return handler.exit;
  }
}
function getKeyHandler(handler, key) {
  let keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;
  if (keyVisitor === undefined) return;
  let keyHandler = keyVisitor[key];
  if (keyHandler !== undefined) {
    return keyHandler;
  }
  return keyVisitor.All;
}
function getNodeHandler(visitor, nodeType) {
  if (nodeType === 'Template' || nodeType === 'Block') {
    if (visitor.Program) {
      return visitor.Program;
    }
  }
  let handler = visitor[nodeType];
  if (handler !== undefined) {
    return handler;
  }
  return visitor.All;
}
function visitNode(visitor, path) {
  let {
    node,
    parent,
    parentKey
  } = path;
  let handler = getNodeHandler(visitor, node.type);
  let enter;
  let exit;
  if (handler !== undefined) {
    enter = getEnterFunction(handler);
    exit = getExitFunction(handler);
  }
  let result;
  if (enter !== undefined) {
    result = enter(node, path);
  }
  if (result !== undefined && result !== null) {
    if (JSON.stringify(node) === JSON.stringify(result)) {
      result = undefined;
    } else if (Array.isArray(result)) {
      visitArray(visitor, result, parent, parentKey);
      return result;
    } else {
      let path = new WalkerPath(result, parent, parentKey);
      return visitNode(visitor, path) || result;
    }
  }
  if (result === undefined) {
    let keys = visitorKeys[node.type];
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      // we know if it has child keys we can widen to a ParentNode
      visitKey(visitor, handler, path, key);
    }
    if (exit !== undefined) {
      result = exit(node, path);
    }
  }
  return result;
}
function get(node, key) {
  return node[key];
}
function set(node, key, value) {
  node[key] = value;
}
function visitKey(visitor, handler, path, key) {
  let {
    node
  } = path;
  let value = get(node, key);
  if (!value) {
    return;
  }
  let keyEnter;
  let keyExit;
  if (handler !== undefined) {
    let keyHandler = getKeyHandler(handler, key);
    if (keyHandler !== undefined) {
      keyEnter = getEnterFunction(keyHandler);
      keyExit = getExitFunction(keyHandler);
    }
  }
  if (keyEnter !== undefined) {
    if (keyEnter(node, key) !== undefined) {
      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
    }
  }
  if (Array.isArray(value)) {
    visitArray(visitor, value, path, key);
  } else {
    let keyPath = new WalkerPath(value, path, key);
    let result = visitNode(visitor, keyPath);
    if (result !== undefined) {
      // TODO: dynamically check the results by having a table of
      // expected node types in value space, not just type space

      assignKey(node, key, value, result);
    }
  }
  if (keyExit !== undefined) {
    if (keyExit(node, key) !== undefined) {
      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
    }
  }
}
function visitArray(visitor, array, parent, parentKey) {
  for (let i = 0; i < array.length; i++) {
    let node = unwrap(array[i]);
    let path = new WalkerPath(node, parent, parentKey);
    let result = visitNode(visitor, path);
    if (result !== undefined) {
      i += spliceArray(array, i, result) - 1;
    }
  }
}
function assignKey(node, key, value, result) {
  if (result === null) {
    throw cannotRemoveNode(value, node, key);
  } else if (Array.isArray(result)) {
    if (result.length === 1) {
      set(node, key, result[0]);
    } else {
      if (result.length === 0) {
        throw cannotRemoveNode(value, node, key);
      } else {
        throw cannotReplaceNode(value, node, key);
      }
    }
  } else {
    set(node, key, result);
  }
}
function spliceArray(array, index, result) {
  if (result === null) {
    array.splice(index, 1);
    return 0;
  } else if (Array.isArray(result)) {
    array.splice(index, 1, ...result);
    return result.length;
  } else {
    array.splice(index, 1, result);
    return 1;
  }
}
function traverse(node, visitor) {
  let path = new WalkerPath(node);
  visitNode(visitor, path);
}

class Walker {
  stack = [];
  constructor(order) {
    this.order = order;
  }
  visit(node, visitor) {
    if (!node) {
      return;
    }
    this.stack.push(node);
    if (this.order === 'post') {
      this.children(node, visitor);
      visitor(node, this);
    } else {
      visitor(node, this);
      this.children(node, visitor);
    }
    this.stack.pop();
  }
  children(node, callback) {
    switch (node.type) {
      case 'Block':
      case 'Template':
        return visitors.Program(this, node, callback);
      case 'ElementNode':
        return visitors.ElementNode(this, node, callback);
      case 'BlockStatement':
        return visitors.BlockStatement(this, node, callback);
      default:
        return;
    }
  }
}
const visitors = {
  Program(walker, node, callback) {
    walkBody(walker, node.body, callback);
  },
  Template(walker, node, callback) {
    walkBody(walker, node.body, callback);
  },
  Block(walker, node, callback) {
    walkBody(walker, node.body, callback);
  },
  ElementNode(walker, node, callback) {
    walkBody(walker, node.children, callback);
  },
  BlockStatement(walker, node, callback) {
    walker.visit(node.program, callback);
    walker.visit(node.inverse || null, callback);
  }
};
function walkBody(walker, body, callback) {
  for (const child of body) {
    walker.visit(child, callback);
  }
}

// Regex to validate the identifier for block parameters.
// Based on the ID validation regex in Handlebars.

let ID_INVERSE_PATTERN = /[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;

// Checks the element's attributes to see if it uses block params.
// If it does, registers the block params with the program and
// removes the corresponding attributes from the element.

function parseElementBlockParams(element) {
  let params = parseBlockParams(element);
  if (params) element.blockParams = params;
}
function parseBlockParams(element) {
  let l = element.attributes.length;
  let attrNames = [];
  for (let i = 0; i < l; i++) {
    attrNames.push(unwrap(element.attributes[i]).name);
  }
  let asIndex = attrNames.indexOf('as');
  if (asIndex === -1 && attrNames.length > 0 && unwrap(attrNames[attrNames.length - 1]).charAt(0) === '|') {
    throw generateSyntaxError('Block parameters must be preceded by the `as` keyword, detected block parameters without `as`', element.loc);
  }
  if (asIndex !== -1 && l > asIndex && unwrap(attrNames[asIndex + 1]).charAt(0) === '|') {
    // Some basic validation, since we're doing the parsing ourselves
    let paramsString = attrNames.slice(asIndex).join(' ');
    if (paramsString.charAt(paramsString.length - 1) !== '|' || expect(paramsString.match(/\|/gu), `block params must exist here`).length !== 2) {
      throw generateSyntaxError("Invalid block parameters syntax, '" + paramsString + "'", element.loc);
    }
    let params = [];
    for (let i = asIndex + 1; i < l; i++) {
      let param = unwrap(attrNames[i]).replace(/\|/gu, '');
      if (param !== '') {
        if (ID_INVERSE_PATTERN.test(param)) {
          throw generateSyntaxError("Invalid identifier for block parameters, '" + param + "'", element.loc);
        }
        params.push(param);
      }
    }
    if (params.length === 0) {
      throw generateSyntaxError('Cannot use zero block parameters', element.loc);
    }
    element.attributes = element.attributes.slice(0, asIndex);
    return params;
  }
  return null;
}
function childrenFor(node) {
  switch (node.type) {
    case 'Block':
    case 'Template':
      return node.body;
    case 'ElementNode':
      return node.children;
  }
}
function appendChild(parent, node) {
  childrenFor(parent).push(node);
}
function isHBSLiteral(path) {
  return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
}
function printLiteral(literal) {
  if (literal.type === 'UndefinedLiteral') {
    return 'undefined';
  } else {
    return JSON.stringify(literal.value);
  }
}
function isUpperCase(tag) {
  return tag[0] === tag[0]?.toUpperCase() && tag[0] !== tag[0]?.toLowerCase();
}
function isLowerCase(tag) {
  return tag[0] === tag[0]?.toLowerCase() && tag[0] !== tag[0]?.toUpperCase();
}

let _SOURCE;
function SOURCE() {
  if (!_SOURCE) {
    _SOURCE = new Source('', '(synthetic)');
  }
  return _SOURCE;
}

// const SOURCE = new Source('', '(tests)');

// Statements
function buildMustache(path, params, hash, raw, loc, strip) {
  if (typeof path === 'string') {
    path = buildPath(path);
  }
  return {
    type: 'MustacheStatement',
    path,
    params: params || [],
    hash: hash || buildHash([]),
    escaped: !raw,
    trusting: !!raw,
    loc: buildLoc(loc || null),
    strip: strip || {
      open: false,
      close: false
    }
  };
}
function buildBlock(path, params, hash, _defaultBlock, _elseBlock, loc, openStrip, inverseStrip, closeStrip) {
  let defaultBlock;
  let elseBlock;
  if (_defaultBlock.type === 'Template') {
    defaultBlock = assign({}, _defaultBlock, {
      type: 'Block'
    });
  } else {
    defaultBlock = _defaultBlock;
  }
  if (_elseBlock !== undefined && _elseBlock !== null && _elseBlock.type === 'Template') {
    elseBlock = assign({}, _elseBlock, {
      type: 'Block'
    });
  } else {
    elseBlock = _elseBlock;
  }
  return {
    type: 'BlockStatement',
    path: buildPath(path),
    params: params || [],
    hash: hash || buildHash([]),
    program: defaultBlock || null,
    inverse: elseBlock || null,
    loc: buildLoc(loc || null),
    openStrip: openStrip || {
      open: false,
      close: false
    },
    inverseStrip: inverseStrip || {
      open: false,
      close: false
    },
    closeStrip: closeStrip || {
      open: false,
      close: false
    }
  };
}
function buildElementModifier(path, params, hash, loc) {
  return {
    type: 'ElementModifierStatement',
    path: buildPath(path),
    params: params || [],
    hash: hash || buildHash([]),
    loc: buildLoc(loc || null)
  };
}
function buildPartial(name, params, hash, indent, loc) {
  return {
    type: 'PartialStatement',
    name: name,
    params: params || [],
    hash: hash || buildHash([]),
    indent: indent || '',
    strip: {
      open: false,
      close: false
    },
    loc: buildLoc(loc || null)
  };
}
function buildComment(value, loc) {
  return {
    type: 'CommentStatement',
    value: value,
    loc: buildLoc(loc || null)
  };
}
function buildMustacheComment(value, loc) {
  return {
    type: 'MustacheCommentStatement',
    value: value,
    loc: buildLoc(loc || null)
  };
}
function buildConcat(parts, loc) {
  if (!isPresentArray(parts)) {
    throw new Error(`b.concat requires at least one part`);
  }
  return {
    type: 'ConcatStatement',
    parts: parts || [],
    loc: buildLoc(loc || null)
  };
}

// Nodes

function buildElement(tag, options = {}) {
  let {
    attrs,
    blockParams,
    modifiers,
    comments,
    children,
    loc
  } = options;
  let tagName;

  // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST
  let selfClosing = false;
  if (typeof tag === 'object') {
    selfClosing = tag.selfClosing;
    tagName = tag.name;
  } else if (tag.slice(-1) === '/') {
    tagName = tag.slice(0, -1);
    selfClosing = true;
  } else {
    tagName = tag;
  }
  return {
    type: 'ElementNode',
    tag: tagName,
    selfClosing: selfClosing,
    attributes: attrs || [],
    blockParams: blockParams || [],
    modifiers: modifiers || [],
    comments: comments || [],
    children: children || [],
    loc: buildLoc(loc || null)
  };
}
function buildAttr(name, value, loc) {
  return {
    type: 'AttrNode',
    name: name,
    value: value,
    loc: buildLoc(loc || null)
  };
}
function buildText(chars, loc) {
  return {
    type: 'TextNode',
    chars: chars || '',
    loc: buildLoc(loc || null)
  };
}

// Expressions

function buildSexpr(path, params, hash, loc) {
  return {
    type: 'SubExpression',
    path: buildPath(path),
    params: params || [],
    hash: hash || buildHash([]),
    loc: buildLoc(loc || null)
  };
}
function headToString$1(head) {
  switch (head.type) {
    case 'AtHead':
      return {
        original: head.name,
        parts: [head.name]
      };
    case 'ThisHead':
      return {
        original: `this`,
        parts: []
      };
    case 'VarHead':
      return {
        original: head.name,
        parts: [head.name]
      };
  }
}
function buildHead(original, loc) {
  let [head, ...tail] = asPresentArray(original.split('.'));
  let headNode;
  if (head === 'this') {
    headNode = {
      type: 'ThisHead',
      loc: buildLoc(loc || null)
    };
  } else if (head[0] === '@') {
    headNode = {
      type: 'AtHead',
      name: head,
      loc: buildLoc(loc || null)
    };
  } else {
    headNode = {
      type: 'VarHead',
      name: head,
      loc: buildLoc(loc || null)
    };
  }
  return {
    head: headNode,
    tail
  };
}
function buildThis(loc) {
  return {
    type: 'ThisHead',
    loc: buildLoc(loc || null)
  };
}
function buildAtName(name, loc) {
  // the `@` should be included so we have a complete source range
  assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);
  return {
    type: 'AtHead',
    name,
    loc: buildLoc(loc || null)
  };
}
function buildVar(name, loc) {
  assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);
  assert(name[0] !== '@', `You called builders.var() with '${name}'. Call builders.at('${name}') instead`);
  return {
    type: 'VarHead',
    name,
    loc: buildLoc(loc || null)
  };
}
function buildHeadFromString(head, loc) {
  if (head[0] === '@') {
    return buildAtName(head, loc);
  } else if (head === 'this') {
    return buildThis(loc);
  } else {
    return buildVar(head, loc);
  }
}
function buildNamedBlockName(name, loc) {
  return {
    type: 'NamedBlockName',
    name,
    loc: buildLoc(loc || null)
  };
}
function buildCleanPath(head, tail, loc) {
  let {
    original: originalHead,
    parts: headParts
  } = headToString$1(head);
  let parts = [...headParts, ...tail];
  let original = [...originalHead, ...parts].join('.');
  return new PathExpressionImplV1(original, head, tail, buildLoc(loc || null));
}
function buildPath(path, loc) {
  if (typeof path !== 'string') {
    if ('type' in path) {
      return path;
    } else {
      let {
        head,
        tail
      } = buildHead(path.head, SourceSpan.broken());
      assert(tail.length === 0, `builder.path({ head, tail }) should not be called with a head with dots in it`);
      let {
        original: originalHead
      } = headToString$1(head);
      return new PathExpressionImplV1([originalHead, ...tail].join('.'), head, tail, buildLoc(loc || null));
    }
  }
  let {
    head,
    tail
  } = buildHead(path, SourceSpan.broken());
  return new PathExpressionImplV1(path, head, tail, buildLoc(loc || null));
}
function buildLiteral(type, value, loc) {
  return {
    type,
    value,
    original: value,
    loc: buildLoc(loc || null)
  };
}

// Miscellaneous

function buildHash(pairs, loc) {
  return {
    type: 'Hash',
    pairs: pairs || [],
    loc: buildLoc(loc || null)
  };
}
function buildPair(key, value, loc) {
  return {
    type: 'HashPair',
    key: key,
    value,
    loc: buildLoc(loc || null)
  };
}
function buildProgram(body, blockParams, loc) {
  return {
    type: 'Template',
    body: body || [],
    blockParams: blockParams || [],
    loc: buildLoc(loc || null)
  };
}
function buildBlockItself(body, blockParams, chained = false, loc) {
  return {
    type: 'Block',
    body: body || [],
    blockParams: blockParams || [],
    chained,
    loc: buildLoc(loc || null)
  };
}
function buildTemplate(body, blockParams, loc) {
  return {
    type: 'Template',
    body: body || [],
    blockParams: blockParams || [],
    loc: buildLoc(loc || null)
  };
}
function buildPosition(line, column) {
  return {
    line,
    column
  };
}
function buildLoc(...args) {
  if (args.length === 1) {
    let loc = args[0];
    if (loc && typeof loc === 'object') {
      return SourceSpan.forHbsLoc(SOURCE(), loc);
    } else {
      return SourceSpan.forHbsLoc(SOURCE(), SYNTHETIC_LOCATION);
    }
  } else {
    let [startLine, startColumn, endLine, endColumn, _source] = args;
    let source = _source ? new Source('', _source) : SOURCE();
    return SourceSpan.forHbsLoc(source, {
      start: {
        line: startLine,
        column: startColumn
      },
      end: {
        line: endLine,
        column: endColumn
      }
    });
  }
}
var publicBuilder = {
  mustache: buildMustache,
  block: buildBlock,
  partial: buildPartial,
  comment: buildComment,
  mustacheComment: buildMustacheComment,
  element: buildElement,
  elementModifier: buildElementModifier,
  attr: buildAttr,
  text: buildText,
  sexpr: buildSexpr,
  concat: buildConcat,
  hash: buildHash,
  pair: buildPair,
  literal: buildLiteral,
  program: buildProgram,
  blockItself: buildBlockItself,
  template: buildTemplate,
  loc: buildLoc,
  pos: buildPosition,
  path: buildPath,
  fullPath: buildCleanPath,
  head: buildHeadFromString,
  at: buildAtName,
  var: buildVar,
  this: buildThis,
  blockName: buildNamedBlockName,
  string: literal('StringLiteral'),
  boolean: literal('BooleanLiteral'),
  number: literal('NumberLiteral'),
  undefined() {
    return buildLiteral('UndefinedLiteral', undefined);
  },
  null() {
    return buildLiteral('NullLiteral', null);
  }
};
function literal(type) {
  return function (value, loc) {
    return buildLiteral(type, value, loc);
  };
}

class PathExpressionImplV1 {
  type = 'PathExpression';
  parts;
  this = false;
  data = false;
  constructor(original, head, tail, loc) {
    this.original = original;
    this.loc = loc;
    let parts = tail.slice();
    if (head.type === 'ThisHead') {
      this.this = true;
    } else if (head.type === 'AtHead') {
      this.data = true;
      parts.unshift(head.name.slice(1));
    } else {
      parts.unshift(head.name);
    }
    this.parts = parts;
  }

  // Cache for the head value.
  _head = undefined;
  get head() {
    if (this._head) {
      return this._head;
    }
    let firstPart;
    if (this.this) {
      firstPart = 'this';
    } else if (this.data) {
      firstPart = `@${getFirst(asPresentArray(this.parts))}`;
    } else {
      assertPresentArray(this.parts);
      firstPart = getFirst(this.parts);
    }
    let firstPartLoc = this.loc.collapse('start').sliceStartChars({
      chars: firstPart.length
    }).loc;
    return this._head = publicBuilder.head(firstPart, firstPartLoc);
  }
  get tail() {
    return this.this ? this.parts : this.parts.slice(1);
  }
}

const DEFAULT_STRIP = {
  close: false,
  open: false
};

/**
 * The Parser Builder differentiates from the public builder API by:
 *
 * 1. Offering fewer different ways to instantiate nodes
 * 2. Mandating source locations
 */
class Builders {
  pos(line, column) {
    return {
      line,
      column
    };
  }
  blockItself({
    body = [],
    blockParams = [],
    chained = false,
    loc
  }) {
    return {
      type: 'Block',
      body: body,
      blockParams: blockParams,
      chained,
      loc
    };
  }
  template({
    body,
    blockParams,
    loc
  }) {
    return {
      type: 'Template',
      body: body || [],
      blockParams: blockParams || [],
      loc
    };
  }
  mustache({
    path,
    params,
    hash,
    trusting,
    loc,
    strip = DEFAULT_STRIP
  }) {
    return {
      type: 'MustacheStatement',
      path,
      params,
      hash,
      escaped: !trusting,
      trusting,
      loc,
      strip: strip || {
        open: false,
        close: false
      }
    };
  }
  block({
    path,
    params,
    hash,
    defaultBlock,
    elseBlock = null,
    loc,
    openStrip = DEFAULT_STRIP,
    inverseStrip = DEFAULT_STRIP,
    closeStrip = DEFAULT_STRIP
  }) {
    return {
      type: 'BlockStatement',
      path: path,
      params,
      hash,
      program: defaultBlock,
      inverse: elseBlock,
      loc: loc,
      openStrip: openStrip,
      inverseStrip: inverseStrip,
      closeStrip: closeStrip
    };
  }
  comment(value, loc) {
    return {
      type: 'CommentStatement',
      value: value,
      loc
    };
  }
  mustacheComment(value, loc) {
    return {
      type: 'MustacheCommentStatement',
      value: value,
      loc
    };
  }
  concat(parts, loc) {
    return {
      type: 'ConcatStatement',
      parts,
      loc
    };
  }
  element({
    tag,
    selfClosing,
    attrs,
    blockParams,
    modifiers,
    comments,
    children,
    loc
  }) {
    return {
      type: 'ElementNode',
      tag,
      selfClosing: selfClosing,
      attributes: attrs || [],
      blockParams: blockParams || [],
      modifiers: modifiers || [],
      comments: comments || [],
      children: children || [],
      loc
    };
  }
  elementModifier({
    path,
    params,
    hash,
    loc
  }) {
    return {
      type: 'ElementModifierStatement',
      path,
      params,
      hash,
      loc
    };
  }
  attr({
    name,
    value,
    loc
  }) {
    return {
      type: 'AttrNode',
      name: name,
      value: value,
      loc
    };
  }
  text({
    chars,
    loc
  }) {
    return {
      type: 'TextNode',
      chars,
      loc
    };
  }
  sexpr({
    path,
    params,
    hash,
    loc
  }) {
    return {
      type: 'SubExpression',
      path,
      params,
      hash,
      loc
    };
  }
  path({
    head,
    tail,
    loc
  }) {
    let {
      original: originalHead
    } = headToString(head);
    let original = [...originalHead, ...tail].join('.');
    return new PathExpressionImplV1(original, head, tail, loc);
  }
  head(head, loc) {
    if (head[0] === '@') {
      return this.atName(head, loc);
    } else if (head === 'this') {
      return this.this(loc);
    } else {
      return this.var(head, loc);
    }
  }
  this(loc) {
    return {
      type: 'ThisHead',
      loc
    };
  }
  atName(name, loc) {
    // the `@` should be included so we have a complete source range
    assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);
    return {
      type: 'AtHead',
      name,
      loc
    };
  }
  var(name, loc) {
    assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);
    assert(name[0] !== '@', `You called builders.var() with '${name}'. Call builders.at('${name}') instead`);
    return {
      type: 'VarHead',
      name,
      loc
    };
  }
  hash(pairs, loc) {
    return {
      type: 'Hash',
      pairs: pairs || [],
      loc
    };
  }
  pair({
    key,
    value,
    loc
  }) {
    return {
      type: 'HashPair',
      key: key,
      value,
      loc
    };
  }
  literal({
    type,
    value,
    loc
  }) {
    return {
      type,
      value,
      original: value,
      loc
    };
  }
  undefined() {
    return this.literal({
      type: 'UndefinedLiteral',
      value: undefined
    });
  }
  null() {
    return this.literal({
      type: 'NullLiteral',
      value: null
    });
  }
  string(value, loc) {
    return this.literal({
      type: 'StringLiteral',
      value,
      loc
    });
  }
  boolean(value, loc) {
    return this.literal({
      type: 'BooleanLiteral',
      value,
      loc
    });
  }
  number(value, loc) {
    return this.literal({
      type: 'NumberLiteral',
      value,
      loc
    });
  }
}

// Nodes

// Expressions

function headToString(head) {
  switch (head.type) {
    case 'AtHead':
      return {
        original: head.name,
        parts: [head.name]
      };
    case 'ThisHead':
      return {
        original: `this`,
        parts: []
      };
    case 'VarHead':
      return {
        original: head.name,
        parts: [head.name]
      };
  }
}
var b = new Builders();

class Parser {
  elementStack = [];
  lines;
  source;
  currentAttribute = null;
  currentNode = null;
  tokenizer;
  constructor(source, entityParser = new EntityParser(HTML5NamedCharRefs), mode = 'precompile') {
    this.source = source;
    this.lines = source.source.split(/\r\n?|\n/u);
    this.tokenizer = new EventedTokenizer(this, entityParser, mode);
  }
  offset() {
    let {
      line,
      column
    } = this.tokenizer;
    return this.source.offsetFor(line, column);
  }
  pos({
    line,
    column
  }) {
    return this.source.offsetFor(line, column);
  }
  finish(node) {
    return assign({}, node, {
      loc: node.loc.until(this.offset())
    });

    // node.loc = node.loc.withEnd(end);
  }

  get currentAttr() {
    return expect(this.currentAttribute, 'expected attribute');
  }
  get currentTag() {
    let node = this.currentNode;
    assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');
    return node;
  }
  get currentStartTag() {
    let node = this.currentNode;
    assert(node && node.type === 'StartTag', 'expected start tag');
    return node;
  }
  get currentEndTag() {
    let node = this.currentNode;
    assert(node && node.type === 'EndTag', 'expected end tag');
    return node;
  }
  get currentComment() {
    let node = this.currentNode;
    assert(node && node.type === 'CommentStatement', 'expected a comment');
    return node;
  }
  get currentData() {
    let node = this.currentNode;
    assert(node && node.type === 'TextNode', 'expected a text node');
    return node;
  }
  acceptTemplate(node) {
    return this[node.type](node);
  }
  acceptNode(node) {
    return this[node.type](node);
  }
  currentElement() {
    return getLast(asPresentArray(this.elementStack));
  }
  sourceForNode(node, endNode) {
    let firstLine = node.loc.start.line - 1;
    let currentLine = firstLine - 1;
    let firstColumn = node.loc.start.column;
    let string = [];
    let line;
    let lastLine;
    let lastColumn;
    if (endNode) {
      lastLine = endNode.loc.end.line - 1;
      lastColumn = endNode.loc.end.column;
    } else {
      lastLine = node.loc.end.line - 1;
      lastColumn = node.loc.end.column;
    }
    while (currentLine < lastLine) {
      currentLine++;
      line = unwrap(this.lines[currentLine]);
      if (currentLine === firstLine) {
        if (firstLine === lastLine) {
          string.push(line.slice(firstColumn, lastColumn));
        } else {
          string.push(line.slice(firstColumn));
        }
      } else if (currentLine === lastLine) {
        string.push(line.slice(0, lastColumn));
      } else {
        string.push(line);
      }
    }
    return string.join('\n');
  }
}

const BEFORE_ATTRIBUTE_NAME = 'beforeAttributeName';
const ATTRIBUTE_VALUE_UNQUOTED = 'attributeValueUnquoted';
class HandlebarsNodeVisitors extends Parser {
  get isTopLevel() {
    return this.elementStack.length === 0;
  }
  Program(program) {
    const body = [];
    let node;
    if (this.isTopLevel) {
      node = b.template({
        body,
        blockParams: program.blockParams,
        loc: this.source.spanFor(program.loc)
      });
    } else {
      node = b.blockItself({
        body,
        blockParams: program.blockParams,
        chained: program.chained,
        loc: this.source.spanFor(program.loc)
      });
    }
    let i,
      l = program.body.length;
    this.elementStack.push(node);
    if (l === 0) {
      return this.elementStack.pop();
    }
    for (i = 0; i < l; i++) {
      this.acceptNode(unwrap(program.body[i]));
    }

    // Ensure that that the element stack is balanced properly.
    const poppedNode = this.elementStack.pop();
    if (poppedNode !== node) {
      const elementNode = poppedNode;
      throw generateSyntaxError(`Unclosed element \`${elementNode.tag}\``, elementNode.loc);
    }
    return node;
  }
  BlockStatement(block) {
    if (this.tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(block));
      return;
    }
    if (this.tokenizer.state !== 'data' && this.tokenizer.state !== 'beforeData') {
      throw generateSyntaxError('A block may only be used inside an HTML element or another block.', this.source.spanFor(block.loc));
    }
    const {
      path,
      params,
      hash
    } = acceptCallNodes(this, block);

    // These are bugs in Handlebars upstream
    if (!block.program.loc) {
      block.program.loc = NON_EXISTENT_LOCATION;
    }
    if (block.inverse && !block.inverse.loc) {
      block.inverse.loc = NON_EXISTENT_LOCATION;
    }
    const program = this.Program(block.program);
    const inverse = block.inverse ? this.Program(block.inverse) : null;
    const node = b.block({
      path,
      params,
      hash,
      defaultBlock: program,
      elseBlock: inverse,
      loc: this.source.spanFor(block.loc),
      openStrip: block.openStrip,
      inverseStrip: block.inverseStrip,
      closeStrip: block.closeStrip
    });
    const parentProgram = this.currentElement();
    appendChild(parentProgram, node);
  }
  MustacheStatement(rawMustache) {
    const {
      tokenizer
    } = this;
    if (tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(rawMustache));
      return;
    }
    let mustache;
    const {
      escaped,
      loc,
      strip
    } = rawMustache;
    if (isHBSLiteral(rawMustache.path)) {
      mustache = b.mustache({
        path: this.acceptNode(rawMustache.path),
        params: [],
        hash: b.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    } else {
      const {
        path,
        params,
        hash
      } = acceptCallNodes(this, rawMustache);
      mustache = b.mustache({
        path,
        params,
        hash,
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    }
    switch (tokenizer.state) {
      // Tag helpers
      case 'tagOpen':
      case 'tagName':
        throw generateSyntaxError(`Cannot use mustaches in an elements tagname`, mustache.loc);
      case 'beforeAttributeName':
        addElementModifier(this.currentStartTag, mustache);
        break;
      case 'attributeName':
      case 'afterAttributeName':
        this.beginAttributeValue(false);
        this.finishAttributeValue();
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);
        break;
      case 'afterAttributeValueQuoted':
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);
        break;

      // Attribute values
      case 'beforeAttributeValue':
        this.beginAttributeValue(false);
        this.appendDynamicAttributeValuePart(mustache);
        tokenizer.transitionTo(ATTRIBUTE_VALUE_UNQUOTED);
        break;
      case 'attributeValueDoubleQuoted':
      case 'attributeValueSingleQuoted':
      case 'attributeValueUnquoted':
        this.appendDynamicAttributeValuePart(mustache);
        break;

      // TODO: Only append child when the tokenizer state makes
      // sense to do so, otherwise throw an error.
      default:
        appendChild(this.currentElement(), mustache);
    }
    return mustache;
  }
  appendDynamicAttributeValuePart(part) {
    this.finalizeTextPart();
    const attr = this.currentAttr;
    attr.isDynamic = true;
    attr.parts.push(part);
  }
  finalizeTextPart() {
    const attr = this.currentAttr;
    const text = attr.currentPart;
    if (text !== null) {
      this.currentAttr.parts.push(text);
      this.startTextPart();
    }
  }
  startTextPart() {
    this.currentAttr.currentPart = null;
  }
  ContentStatement(content) {
    updateTokenizerLocation(this.tokenizer, content);
    this.tokenizer.tokenizePart(content.value);
    this.tokenizer.flushData();
  }
  CommentStatement(rawComment) {
    const {
      tokenizer
    } = this;
    if (tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(rawComment));
      return null;
    }
    const {
      value,
      loc
    } = rawComment;
    const comment = b.mustacheComment(value, this.source.spanFor(loc));
    switch (tokenizer.state) {
      case 'beforeAttributeName':
      case 'afterAttributeName':
        this.currentStartTag.comments.push(comment);
        break;
      case 'beforeData':
      case 'data':
        appendChild(this.currentElement(), comment);
        break;
      default:
        throw generateSyntaxError(`Using a Handlebars comment when in the \`${tokenizer['state']}\` state is not supported`, this.source.spanFor(rawComment.loc));
    }
    return comment;
  }
  PartialStatement(partial) {
    throw generateSyntaxError(`Handlebars partials are not supported`, this.source.spanFor(partial.loc));
  }
  PartialBlockStatement(partialBlock) {
    throw generateSyntaxError(`Handlebars partial blocks are not supported`, this.source.spanFor(partialBlock.loc));
  }
  Decorator(decorator) {
    throw generateSyntaxError(`Handlebars decorators are not supported`, this.source.spanFor(decorator.loc));
  }
  DecoratorBlock(decoratorBlock) {
    throw generateSyntaxError(`Handlebars decorator blocks are not supported`, this.source.spanFor(decoratorBlock.loc));
  }
  SubExpression(sexpr) {
    const {
      path,
      params,
      hash
    } = acceptCallNodes(this, sexpr);
    return b.sexpr({
      path,
      params,
      hash,
      loc: this.source.spanFor(sexpr.loc)
    });
  }
  PathExpression(path) {
    const {
      original
    } = path;
    let parts;
    if (original.indexOf('/') !== -1) {
      if (original.slice(0, 2) === './') {
        throw generateSyntaxError(`Using "./" is not supported in Glimmer and unnecessary`, this.source.spanFor(path.loc));
      }
      if (original.slice(0, 3) === '../') {
        throw generateSyntaxError(`Changing context using "../" is not supported in Glimmer`, this.source.spanFor(path.loc));
      }
      if (original.indexOf('.') !== -1) {
        throw generateSyntaxError(`Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`, this.source.spanFor(path.loc));
      }
      parts = [path.parts.join('/')];
    } else if (original === '.') {
      throw generateSyntaxError(`'.' is not a supported path in Glimmer; check for a path with a trailing '.'`, this.source.spanFor(path.loc));
    } else {
      parts = path.parts;
    }
    let thisHead = false;

    // This is to fix a bug in the Handlebars AST where the path expressions in
    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
    // are simply turned into `{{foo}}`. The fix is to push it back onto the
    // parts array and let the runtime see the difference. However, we cannot
    // simply use the string `this` as it means literally the property called
    // "this" in the current context (it can be expressed in the syntax as
    // `{{[this]}}`, where the square bracket are generally for this kind of
    // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
    // named literally "bar.baz" on `this.foo`). By convention, we use `null`
    // for this purpose.
    if (/^this(?:\..+)?$/u.test(original)) {
      thisHead = true;
    }
    let pathHead;
    if (thisHead) {
      pathHead = {
        type: 'ThisHead',
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + 4
          }
        }
      };
    } else if (path.data) {
      const head = parts.shift();
      if (head === undefined) {
        throw generateSyntaxError(`Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`, this.source.spanFor(path.loc));
      }
      pathHead = {
        type: 'AtHead',
        name: `@${head}`,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length + 1
          }
        }
      };
    } else {
      const head = parts.shift();
      if (head === undefined) {
        throw generateSyntaxError(`Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`, this.source.spanFor(path.loc));
      }
      pathHead = {
        type: 'VarHead',
        name: head,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length
          }
        }
      };
    }
    return new PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));
  }
  Hash(hash) {
    const pairs = hash.pairs.map(pair => b.pair({
      key: pair.key,
      value: this.acceptNode(pair.value),
      loc: this.source.spanFor(pair.loc)
    }));
    return b.hash(pairs, this.source.spanFor(hash.loc));
  }
  StringLiteral(string) {
    return b.literal({
      type: 'StringLiteral',
      value: string.value,
      loc: string.loc
    });
  }
  BooleanLiteral(boolean) {
    return b.literal({
      type: 'BooleanLiteral',
      value: boolean.value,
      loc: boolean.loc
    });
  }
  NumberLiteral(number) {
    return b.literal({
      type: 'NumberLiteral',
      value: number.value,
      loc: number.loc
    });
  }
  UndefinedLiteral(undef) {
    return b.literal({
      type: 'UndefinedLiteral',
      value: undefined,
      loc: undef.loc
    });
  }
  NullLiteral(nul) {
    return b.literal({
      type: 'NullLiteral',
      value: null,
      loc: nul.loc
    });
  }
}
function calculateRightStrippedOffsets(original, value) {
  if (value === '') {
    // if it is empty, just return the count of newlines
    // in original
    return {
      lines: original.split('\n').length - 1,
      columns: 0
    };
  }

  // otherwise, return the number of newlines prior to
  // `value`
  const [difference] = original.split(value);
  const lines = difference.split(/\n/u);
  const lineCount = lines.length - 1;
  return {
    lines: lineCount,
    columns: unwrap(lines[lineCount]).length
  };
}
function updateTokenizerLocation(tokenizer, content) {
  let line = content.loc.start.line;
  let column = content.loc.start.column;
  const offsets = calculateRightStrippedOffsets(content.original, content.value);
  line = line + offsets.lines;
  if (offsets.lines) {
    column = offsets.columns;
  } else {
    column = column + offsets.columns;
  }
  tokenizer.line = line;
  tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
  if (node.path.type.endsWith('Literal')) {
    const path = node.path;
    let value = '';
    if (path.type === 'BooleanLiteral') {
      value = path.original.toString();
    } else if (path.type === 'StringLiteral') {
      value = `"${path.original}"`;
    } else if (path.type === 'NullLiteral') {
      value = 'null';
    } else if (path.type === 'NumberLiteral') {
      value = path.value.toString();
    } else {
      value = 'undefined';
    }
    throw generateSyntaxError(`${path.type} "${path.type === 'StringLiteral' ? path.original : value}" cannot be called as a sub-expression, replace (${value}) with ${value}`, compiler.source.spanFor(path.loc));
  }
  const path = node.path.type === 'PathExpression' ? compiler.PathExpression(node.path) : compiler.SubExpression(node.path);
  const params = node.params ? node.params.map(e => compiler.acceptNode(e)) : [];

  // if there is no hash, position it as a collapsed node immediately after the last param (or the
  // path, if there are also no params)
  const end = isPresentArray(params) ? getLast(params).loc : path.loc;
  const hash = node.hash ? compiler.Hash(node.hash) : {
    type: 'Hash',
    pairs: [],
    loc: compiler.source.spanFor(end).collapse('end')
  };
  return {
    path,
    params,
    hash
  };
}
function addElementModifier(element, mustache) {
  const {
    path,
    params,
    hash,
    loc
  } = mustache;
  if (isHBSLiteral(path)) {
    const modifier = `{{${printLiteral(path)}}}`;
    const tag = `<${element.name} ... ${modifier} ...`;
    throw generateSyntaxError(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);
  }
  const modifier = b.elementModifier({
    path,
    params,
    hash,
    loc
  });
  element.modifiers.push(modifier);
}

class TokenizerEventHandlers extends HandlebarsNodeVisitors {
  tagOpenLine = 0;
  tagOpenColumn = 0;
  reset() {
    this.currentNode = null;
  }

  // Comment

  beginComment() {
    this.currentNode = b.comment('', this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn));
  }
  appendToCommentData(char) {
    this.currentComment.value += char;
  }
  finishComment() {
    appendChild(this.currentElement(), this.finish(this.currentComment));
  }

  // Data

  beginData() {
    this.currentNode = b.text({
      chars: '',
      loc: this.offset().collapsed()
    });
  }
  appendToData(char) {
    this.currentData.chars += char;
  }
  finishData() {
    this.currentData.loc = this.currentData.loc.withEnd(this.offset());
    appendChild(this.currentElement(), this.currentData);
  }

  // Tags - basic

  tagOpen() {
    this.tagOpenLine = this.tokenizer.line;
    this.tagOpenColumn = this.tokenizer.column;
  }
  beginStartTag() {
    this.currentNode = {
      type: 'StartTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  }
  beginEndTag() {
    this.currentNode = {
      type: 'EndTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  }
  finishTag() {
    let tag = this.finish(this.currentTag);
    if (tag.type === 'StartTag') {
      this.finishStartTag();
      if (tag.name === ':') {
        throw generateSyntaxError('Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter', this.source.spanFor({
          start: this.currentTag.loc.toJSON(),
          end: this.offset().toJSON()
        }));
      }
      if (voidMap.has(tag.name) || tag.selfClosing) {
        this.finishEndTag(true);
      }
    } else if (tag.type === 'EndTag') {
      this.finishEndTag(false);
    }
  }
  finishStartTag() {
    let {
      name,
      attributes: attrs,
      modifiers,
      comments,
      selfClosing,
      loc
    } = this.finish(this.currentStartTag);
    let element = b.element({
      tag: name,
      selfClosing,
      attrs,
      modifiers,
      comments,
      children: [],
      blockParams: [],
      loc
    });
    this.elementStack.push(element);
  }
  finishEndTag(isVoid) {
    let tag = this.finish(this.currentTag);
    let element = this.elementStack.pop();
    this.validateEndTag(tag, element, isVoid);
    let parent = this.currentElement();
    element.loc = element.loc.withEnd(this.offset());
    parseElementBlockParams(element);
    appendChild(parent, element);
  }
  markTagAsSelfClosing() {
    this.currentTag.selfClosing = true;
  }

  // Tags - name

  appendToTagName(char) {
    this.currentTag.name += char;
  }

  // Tags - attributes

  beginAttribute() {
    let offset = this.offset();
    this.currentAttribute = {
      name: '',
      parts: [],
      currentPart: null,
      isQuoted: false,
      isDynamic: false,
      start: offset,
      valueSpan: offset.collapsed()
    };
  }
  appendToAttributeName(char) {
    this.currentAttr.name += char;
  }
  beginAttributeValue(isQuoted) {
    this.currentAttr.isQuoted = isQuoted;
    this.startTextPart();
    this.currentAttr.valueSpan = this.offset().collapsed();
  }
  appendToAttributeValue(char) {
    let parts = this.currentAttr.parts;
    let lastPart = parts[parts.length - 1];
    let current = this.currentAttr.currentPart;
    if (current) {
      current.chars += char;

      // update end location for each added char
      current.loc = current.loc.withEnd(this.offset());
    } else {
      // initially assume the text node is a single char
      let loc = this.offset();

      // the tokenizer line/column have already been advanced, correct location info
      if (char === '\n') {
        loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();
      } else {
        loc = loc.move(-1);
      }
      this.currentAttr.currentPart = b.text({
        chars: char,
        loc: loc.collapsed()
      });
    }
  }
  finishAttributeValue() {
    this.finalizeTextPart();
    let tag = this.currentTag;
    let tokenizerPos = this.offset();
    if (tag.type === 'EndTag') {
      throw generateSyntaxError(`Invalid end tag: closing tag must not have attributes`, this.source.spanFor({
        start: tag.loc.toJSON(),
        end: tokenizerPos.toJSON()
      }));
    }
    let {
      name,
      parts,
      start,
      isQuoted,
      isDynamic,
      valueSpan
    } = this.currentAttr;
    let value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));
    value.loc = valueSpan.withEnd(tokenizerPos);
    let attribute = b.attr({
      name,
      value,
      loc: start.until(tokenizerPos)
    });
    this.currentStartTag.attributes.push(attribute);
  }
  reportSyntaxError(message) {
    throw generateSyntaxError(message, this.offset().collapsed());
  }
  assembleConcatenatedValue(parts) {
    for (const part of parts) {
      if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
        throw generateSyntaxError(`Unsupported node in quoted attribute value: ${part['type']}`, part.loc);
      }
    }
    assertPresentArray(parts, `the concatenation parts of an element should not be empty`);
    let first = getFirst(parts);
    let last = getLast(parts);
    return b.concat(parts, this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)));
  }
  validateEndTag(tag, element, selfClosing) {
    if (voidMap.has(tag.name) && !selfClosing) {
      // EngTag is also called by StartTag for void and self-closing tags (i.e.
      // <input> or <br />, so we need to check for that here. Otherwise, we would
      // throw an error for those cases.
      throw generateSyntaxError(`<${tag.name}> elements do not need end tags. You should remove it`, tag.loc);
    } else if (element.tag === undefined) {
      throw generateSyntaxError(`Closing tag </${tag.name}> without an open tag`, tag.loc);
    } else if (element.tag !== tag.name) {
      throw generateSyntaxError(`Closing tag </${tag.name}> did not match last open tag <${element.tag}> (on line ${element.loc.startPosition.line})`, tag.loc);
    }
  }
  assembleAttributeValue(parts, isQuoted, isDynamic, span) {
    if (isDynamic) {
      if (isQuoted) {
        return this.assembleConcatenatedValue(parts);
      } else {
        assertPresentArray(parts);
        const [head, a] = parts;
        if (a === undefined || a.type === 'TextNode' && a.chars === '/') {
          return head;
        } else {
          throw generateSyntaxError(`An unquoted attribute value must be a string or a mustache, ` + `preceded by whitespace or a '=' character, and ` + `followed by whitespace, a '>' character, or '/>'`, span);
        }
      }
    } else if (isPresentArray(parts)) {
      return parts[0];
    } else {
      return b.text({
        chars: '',
        loc: span
      });
    }
  }
}

/**
  ASTPlugins can make changes to the Glimmer template AST before
  compilation begins.
*/

const syntax = {
  parse: preprocess,
  builders: publicBuilder,
  print: build,
  traverse,
  Walker
};
class CodemodEntityParser extends EntityParser {
  // match upstream types, but never match an entity
  constructor() {
    super({});
  }
  parse() {
    return undefined;
  }
}
function preprocess(input, options = {}) {
  let mode = options.mode || 'precompile';
  let source;
  let ast;
  if (typeof input === 'string') {
    source = new Source(input, options.meta?.moduleName);
    if (mode === 'codemod') {
      ast = parseWithoutProcessing(input, options.parseOptions);
    } else {
      ast = parse(input, options.parseOptions);
    }
  } else if (input instanceof Source) {
    source = input;
    if (mode === 'codemod') {
      ast = parseWithoutProcessing(input.source, options.parseOptions);
    } else {
      ast = parse(input.source, options.parseOptions);
    }
  } else {
    source = new Source('', options.meta?.moduleName);
    ast = input;
  }
  let entityParser = undefined;
  if (mode === 'codemod') {
    entityParser = new CodemodEntityParser();
  }
  let offsets = SourceSpan.forCharPositions(source, 0, source.source.length);
  ast.loc = {
    source: '(program)',
    start: offsets.startPosition,
    end: offsets.endPosition
  };
  let program = new TokenizerEventHandlers(source, entityParser, mode).acceptTemplate(ast);
  if (options.strictMode) {
    program.blockParams = options.locals ?? [];
  }
  if (options && options.plugins && options.plugins.ast) {
    for (const transform of options.plugins.ast) {
      let env = assign({}, options, {
        syntax
      }, {
        plugins: undefined
      });
      let pluginResult = transform(env);
      traverse(program, pluginResult.visitor);
    }
  }
  return program;
}

/**
 * Gets the correct Token from the Node based on it's type
 */
function tokensFromType(node, scopedTokens, options) {
  if (node.type === 'PathExpression') {
    if (node.head.type === 'AtHead' || node.head.type === 'ThisHead') {
      return;
    }
    const possbleToken = node.head.name;
    if (scopedTokens.indexOf(possbleToken) === -1) {
      return possbleToken;
    }
  } else if (node.type === 'ElementNode') {
    const {
      tag
    } = node;
    const char = tag.charAt(0);
    if (char === ':' || char === '@') {
      return;
    }
    if (!options.includeHtmlElements && tag.indexOf('.') === -1 && tag.toLowerCase() === tag) {
      return;
    }
    if (tag.substr(0, 5) === 'this.') {
      return;
    }

    // the tag may be from a yielded object
    // example:
    //   <x.button>
    // An ElementNode does not parse the "tag" in to a PathExpression
    // so we have to split on `.`, just like how `this` presence is checked.
    if (tag.includes('.')) {
      let [potentialLocal] = tag.split('.');
      if (scopedTokens.includes(potentialLocal)) return;
    }
    if (scopedTokens.includes(tag)) return;
    return tag;
  }
}

/**
 * Adds tokens to the tokensSet based on their node.type
 */
function addTokens(tokensSet, node, scopedTokens, options) {
  const maybeTokens = tokensFromType(node, scopedTokens, options);
  (Array.isArray(maybeTokens) ? maybeTokens : [maybeTokens]).forEach(maybeToken => {
    if (maybeToken !== undefined && maybeToken[0] !== '@') {
      const maybeTokenFirstSegment = maybeToken.split('.')[0];
      if (!scopedTokens.includes(maybeTokenFirstSegment)) {
        tokensSet.add(maybeToken.split('.')[0]);
      }
    }
  });
}

/**
 * Parses and traverses a given handlebars html template to extract all template locals
 * referenced that could possible come from the parent scope. Can exclude known keywords
 * optionally.
 */
function getTemplateLocals(html, options = {
  includeHtmlElements: false,
  includeKeywords: false
}) {
  const ast = preprocess(html);
  const tokensSet = new Set();
  const scopedTokens = [];
  traverse(ast, {
    Block: {
      enter({
        blockParams
      }) {
        blockParams.forEach(param => {
          scopedTokens.push(param);
        });
      },
      exit({
        blockParams
      }) {
        blockParams.forEach(() => {
          scopedTokens.pop();
        });
      }
    },
    ElementNode: {
      enter(node) {
        node.blockParams.forEach(param => {
          scopedTokens.push(param);
        });
        addTokens(tokensSet, node, scopedTokens, options);
      },
      exit({
        blockParams
      }) {
        blockParams.forEach(() => {
          scopedTokens.pop();
        });
      }
    },
    PathExpression(node) {
      addTokens(tokensSet, node, scopedTokens, options);
    }
  });
  let tokens = [];
  tokensSet.forEach(s => tokens.push(s));
  if (!options?.includeKeywords) {
    tokens = tokens.filter(token => !isKeyword(token));
  }
  return tokens;
}

/**
 * This is a convenience function for creating ASTv2 nodes, with an optional name and the node's
 * options.
 *
 * ```ts
 * export class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}
 * ```
 *
 * This creates a new ASTv2 node with the name `'HtmlText'` and one field `chars: string` (in
 * addition to a `loc: SourceOffsets` field, which all nodes have).
 *
 * ```ts
 * export class Args extends node().fields<{
 *  positional: PositionalArguments;
 *  named: NamedArguments
 * }>() {}
 * ```
 *
 * This creates a new un-named ASTv2 node with two fields (`positional: Positional` and `named:
 * Named`, in addition to the generic `loc: SourceOffsets` field).
 *
 * Once you create a node using `node`, it is instantiated with all of its fields (including `loc`):
 *
 * ```ts
 * new HtmlText({ loc: offsets, chars: someString });
 * ```
 */

function node(name) {
  if (name !== undefined) {
    const type = name;
    return {
      fields() {
        return class {
          // SAFETY: initialized via `assign` in the constructor.

          type;
          constructor(fields) {
            this.type = type;
            assign(this, fields);
          }
        };
      }
    };
  } else {
    return {
      fields() {
        return class {
          // SAFETY: initialized via `assign` in the constructor.

          constructor(fields) {
            assign(this, fields);
          }
        };
      }
    };
  }
}

/**
 * Corresponds to syntaxes with positional and named arguments:
 *
 * - SubExpression
 * - Invoking Append
 * - Invoking attributes
 * - InvokeBlock
 *
 * If `Args` is empty, the `SourceOffsets` for this node should be the collapsed position
 * immediately after the parent call node's `callee`.
 */
class Args extends node().fields() {
  static empty(loc) {
    return new Args({
      loc,
      positional: PositionalArguments.empty(loc),
      named: NamedArguments.empty(loc)
    });
  }
  static named(named) {
    return new Args({
      loc: named.loc,
      positional: PositionalArguments.empty(named.loc.collapse('end')),
      named
    });
  }
  nth(offset) {
    return this.positional.nth(offset);
  }
  get(name) {
    return this.named.get(name);
  }
  isEmpty() {
    return this.positional.isEmpty() && this.named.isEmpty();
  }
}

/**
 * Corresponds to positional arguments.
 *
 * If `PositionalArguments` is empty, the `SourceOffsets` for this node should be the collapsed
 * position immediately after the parent call node's `callee`.
 */
class PositionalArguments extends node().fields() {
  static empty(loc) {
    return new PositionalArguments({
      loc,
      exprs: []
    });
  }
  get size() {
    return this.exprs.length;
  }
  nth(offset) {
    return this.exprs[offset] || null;
  }
  isEmpty() {
    return this.exprs.length === 0;
  }
}

/**
 * Corresponds to named arguments.
 *
 * If `PositionalArguments` and `NamedArguments` are empty, the `SourceOffsets` for this node should
 * be the same as the `Args` node that contains this node.
 *
 * If `PositionalArguments` is not empty but `NamedArguments` is empty, the `SourceOffsets` for this
 * node should be the collapsed position immediately after the last positional argument.
 */
class NamedArguments extends node().fields() {
  static empty(loc) {
    return new NamedArguments({
      loc,
      entries: []
    });
  }
  get size() {
    return this.entries.length;
  }
  get(name) {
    let entry = this.entries.filter(e => e.name.chars === name)[0];
    return entry ? entry.value : null;
  }
  isEmpty() {
    return this.entries.length === 0;
  }
}

/**
 * Corresponds to a single named argument.
 *
 * ```hbs
 * x=<expr>
 * ```
 */
class NamedArgument {
  loc;
  name;
  value;
  constructor(options) {
    this.loc = options.name.loc.extend(options.value.loc);
    this.name = options.name;
    this.value = options.value;
  }
}

/**
 * Attr nodes look like HTML attributes, but are classified as:
 *
 * 1. `HtmlAttr`, which means a regular HTML attribute in Glimmer
 * 2. `SplatAttr`, which means `...attributes`
 * 3. `ComponentArg`, which means an attribute whose name begins with `@`, and it is therefore a
 *    component argument.
 */

/**
 * `HtmlAttr` and `SplatAttr` are grouped together because the order of the `SplatAttr` node,
 * relative to other attributes, matters.
 */

/**
 * "Attr Block" nodes are allowed inside an open element tag in templates. They interact with the
 * element (or component).
 */

/**
 * `HtmlAttr` nodes are valid HTML attributes, with or without a value.
 *
 * Exceptions:
 *
 * - `...attributes` is `SplatAttr`
 * - `@x=<value>` is `ComponentArg`
 */
class HtmlAttr extends node('HtmlAttr').fields() {}
class SplatAttr extends node('SplatAttr').fields() {}

/**
 * Corresponds to an argument passed by a component (`@x=<value>`)
 */
class ComponentArg extends node().fields() {
  /**
   * Convert the component argument into a named argument node
   */
  toNamedArgument() {
    return new NamedArgument({
      name: this.name,
      value: this.value
    });
  }
}

/**
 * An `ElementModifier` is just a normal call node in modifier position.
 */
class ElementModifier extends node('ElementModifier').fields() {}

/**
 * Content Nodes are allowed in content positions in templates. They correspond to behavior in the
 * [Data][data] tokenization state in HTML.
 *
 * [data]: https://html.spec.whatwg.org/multipage/parsing.html#data-state
 */

class GlimmerComment extends node('GlimmerComment').fields() {}
class HtmlText extends node('HtmlText').fields() {}
class HtmlComment extends node('HtmlComment').fields() {}
class AppendContent extends node('AppendContent').fields() {
  get callee() {
    if (this.value.type === 'Call') {
      return this.value.callee;
    } else {
      return this.value;
    }
  }
  get args() {
    if (this.value.type === 'Call') {
      return this.value.args;
    } else {
      return Args.empty(this.value.loc.collapse('end'));
    }
  }
}
class InvokeBlock extends node('InvokeBlock').fields() {}
/**
 * Corresponds to a component invocation. When the content of a component invocation contains no
 * named blocks, `blocks` contains a single named block named `"default"`. When a component
 * invocation is self-closing, `blocks` is empty.
 */
class InvokeComponent extends node('InvokeComponent').fields() {
  get args() {
    let entries = this.componentArgs.map(a => a.toNamedArgument());
    return Args.named(new NamedArguments({
      loc: SpanList.range(entries, this.callee.loc.collapse('end')),
      entries
    }));
  }
}
/**
 * Corresponds to a simple HTML element. The AST allows component arguments and modifiers to support
 * future extensions.
 */
class SimpleElement extends node('SimpleElement').fields() {
  get args() {
    let entries = this.componentArgs.map(a => a.toNamedArgument());
    return Args.named(new NamedArguments({
      loc: SpanList.range(entries, this.tag.loc.collapse('end')),
      entries
    }));
  }
}

/**
 * A Handlebars literal.
 *
 * {@link https://handlebarsjs.com/guide/expressions.html#literal-segments}
 */

/**
 * Corresponds to a Handlebars literal.
 *
 * @see {LiteralValue}
 */
class LiteralExpression extends node('Literal').fields() {
  toSlice() {
    return new SourceSlice({
      loc: this.loc,
      chars: this.value
    });
  }
}
/**
 * Returns true if an input {@see ExpressionNode} is a literal.
 */
function isLiteral(node, kind) {
  if (node.type === 'Literal') {
    if (kind === undefined) {
      return true;
    } else if (kind === 'null') {
      return node.value === null;
    } else {
      return typeof node.value === kind;
    }
  } else {
    return false;
  }
}

/**
 * Corresponds to a path in expression position.
 *
 * ```hbs
 * this
 * this.x
 * @x
 * @x.y
 * x
 * x.y
 * ```
 */
class PathExpression extends node('Path').fields() {}

/**
 * Corresponds to a parenthesized call expression.
 *
 * ```hbs
 * (x)
 * (x.y)
 * (x y)
 * (x.y z)
 * ```
 */
class CallExpression extends node('Call').fields() {}

/**
 * Corresponds to a possible deprecated helper call. Must be:
 *
 * 1. A free variable (not this.foo, not @foo, not local).
 * 2. Argument-less.
 * 3. In a component invocation's named argument position.
 * 4. Not parenthesized (not @bar={{(helper)}}).
 * 5. Not interpolated (not @bar="{{helper}}").
 *
 * ```hbs
 * <Foo @bar={{helper}} />
 * ```
 */
class DeprecatedCallExpression extends node('DeprecatedCall').fields() {}

/**
 * Corresponds to an interpolation in attribute value position.
 *
 * ```hbs
 * <a href="{{url}}.html"
 * ```
 */
class InterpolateExpression extends node('Interpolate').fields() {}

/**
 * Corresponds to an entire template.
 */
class Template extends node().fields() {}

/**
 * Represents a block. In principle this could be merged with `NamedBlock`, because all cases
 * involving blocks have at least a notional name.
 */
class Block extends node().fields() {}

/**
 * Corresponds to a collection of named blocks.
 */
class NamedBlocks extends node().fields() {
  /**
   * Get the `NamedBlock` for a given name.
   */

  get(name) {
    return this.blocks.filter(block => block.name.chars === name)[0] || null;
  }
}
/**
 * Corresponds to a single named block. This is used for anonymous named blocks (`default` and
 * `else`).
 */
class NamedBlock extends node().fields() {
  get args() {
    let entries = this.componentArgs.map(a => a.toNamedArgument());
    return Args.named(new NamedArguments({
      loc: SpanList.range(entries, this.name.loc.collapse('end')),
      entries
    }));
  }
}

/**
 * Corresponds to `this` at the head of an expression.
 */
class ThisReference extends node('This').fields() {}

/**
 * Corresponds to `@<ident>` at the beginning of an expression.
 */
class ArgReference extends node('Arg').fields() {}

/**
 * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is in the current
 * block's scope.
 */
class LocalVarReference extends node('Local').fields() {}

/**
 * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is *not* in the
 * current block's scope.
 *
 * The `resolution: FreeVarResolution` field describes how to resolve the free variable.
 *
 * Note: In strict mode, it must always be a variable that is in a concrete JavaScript scope that
 * the template will be installed into.
 */
class FreeVarReference extends node('Free').fields() {}

/**
 * A free variable is resolved according to a resolution rule:
 *
 * 1. Strict resolution
 * 2. Namespaced resolution
 * 3. Fallback resolution
 */


/**
 * Strict resolution is used:
 *
 * 1. in a strict mode template
 * 2. in an unambiguous invocation with dot paths
 */
const STRICT_RESOLUTION = {
  resolution: () => SexpOpcodes.GetStrictKeyword,
  serialize: () => 'Strict',
  isAngleBracket: false
};
const HTML_RESOLUTION = {
  ...STRICT_RESOLUTION,
  isAngleBracket: true
};
function isStrictResolution(value) {
  return value === STRICT_RESOLUTION;
}

/**
 * A `LooseModeResolution` includes:
 *
 * - 0 or more namespaces to resolve the variable in
 * - optional fallback behavior
 *
 * In practice, there are a limited number of possible combinations of these degrees of freedom,
 * and they are captured by the `Ambiguity` union below.
 */
class LooseModeResolution {
  /**
   * Namespaced resolution is used in an unambiguous syntax position:
   *
   * 1. `(sexp)` (namespace: `Helper`)
   * 2. `{{#block}}` (namespace: `Component`)
   * 3. `<a {{modifier}}>` (namespace: `Modifier`)
   * 4. `<Component />` (namespace: `Component`)
   *
   * @see {NamespacedAmbiguity}
   */
  static namespaced(namespace, isAngleBracket = false) {
    return new LooseModeResolution({
      namespaces: [namespace],
      fallback: false
    }, isAngleBracket);
  }

  /**
   * Fallback resolution is used when no namespaced resolutions are possible, but fallback
   * resolution is still allowed.
   *
   * ```hbs
   * {{x.y}}
   * ```
   *
   * @see {FallbackAmbiguity}
   */
  static fallback() {
    return new LooseModeResolution({
      namespaces: [],
      fallback: true
    });
  }

  /**
   * Append resolution is used when the variable should be resolved in both the `component` and
   * `helper` namespaces. Fallback resolution is optional.
   *
   * ```hbs
   * {{x}}
   * ```
   *
   * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
   *
   * ```hbs
   * {{x y}}
   * ```
   *
   * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
   * resolution.
   *
   * @see {ComponentOrHelperAmbiguity}
   */
  static append({
    invoke
  }) {
    return new LooseModeResolution({
      namespaces: [FreeVarNamespace.Component, FreeVarNamespace.Helper],
      fallback: !invoke
    });
  }

  /**
   * Trusting append resolution is used when the variable should be resolved in both the `component` and
   * `helper` namespaces. Fallback resolution is optional.
   *
   * ```hbs
   * {{{x}}}
   * ```
   *
   * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
   *
   * ```hbs
   * {{{x y}}}
   * ```
   *
   * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
   * resolution.
   *
   * @see {HelperAmbiguity}
   */
  static trustingAppend({
    invoke
  }) {
    return new LooseModeResolution({
      namespaces: [FreeVarNamespace.Helper],
      fallback: !invoke
    });
  }

  /**
   * Attribute resolution is used when the variable should be resolved as a `helper` with fallback
   * resolution.
   *
   * ```hbs
   * <a href={{x}} />
   * <a href="{{x}}.html" />
   * ```
   *
   * ^ resolved in the `helper` namespace with fallback
   *
   * @see {HelperAmbiguity}
   */
  static attr() {
    return new LooseModeResolution({
      namespaces: [FreeVarNamespace.Helper],
      fallback: true
    });
  }
  constructor(ambiguity, isAngleBracket = false) {
    this.ambiguity = ambiguity;
    this.isAngleBracket = isAngleBracket;
  }
  resolution() {
    if (this.ambiguity.namespaces.length === 0) {
      return SexpOpcodes.GetStrictKeyword;
    } else if (this.ambiguity.namespaces.length === 1) {
      if (this.ambiguity.fallback) {
        // simple namespaced resolution with fallback must be attr={{x}}
        return SexpOpcodes.GetFreeAsHelperHeadOrThisFallback;
      } else {
        // simple namespaced resolution without fallback
        switch (this.ambiguity.namespaces[0]) {
          case FreeVarNamespace.Helper:
            return SexpOpcodes.GetFreeAsHelperHead;
          case FreeVarNamespace.Modifier:
            return SexpOpcodes.GetFreeAsModifierHead;
          case FreeVarNamespace.Component:
            return SexpOpcodes.GetFreeAsComponentHead;
        }
      }
    } else if (this.ambiguity.fallback) {
      // component or helper + fallback ({{something}})
      return SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback;
    } else {
      // component or helper without fallback ({{something something}})
      return SexpOpcodes.GetFreeAsComponentOrHelperHead;
    }
  }
  serialize() {
    if (this.ambiguity.namespaces.length === 0) {
      return 'Loose';
    } else if (this.ambiguity.namespaces.length === 1) {
      if (this.ambiguity.fallback) {
        // simple namespaced resolution with fallback must be attr={{x}}
        return ['ambiguous', SerializedAmbiguity.Attr];
      } else {
        return ['ns', this.ambiguity.namespaces[0]];
      }
    } else if (this.ambiguity.fallback) {
      // component or helper + fallback ({{something}})
      return ['ambiguous', SerializedAmbiguity.Append];
    } else {
      // component or helper without fallback ({{something something}})
      return ['ambiguous', SerializedAmbiguity.Invoke];
    }
  }
}
const ARGUMENT_RESOLUTION = LooseModeResolution.fallback();
let FreeVarNamespace = /*#__PURE__*/function (FreeVarNamespace) {
  FreeVarNamespace["Helper"] = "Helper";
  FreeVarNamespace["Modifier"] = "Modifier";
  FreeVarNamespace["Component"] = "Component";
  return FreeVarNamespace;
}({});
const HELPER_NAMESPACE = FreeVarNamespace.Helper;
const MODIFIER_NAMESPACE = FreeVarNamespace.Modifier;
const COMPONENT_NAMESPACE = FreeVarNamespace.Component;

/**
 * A `ComponentOrHelperAmbiguity` might be a component or a helper, with an optional fallback
 *
 * ```hbs
 * {{x}}
 * ```
 *
 * ^ `x` is resolved in the `component` and `helper` namespaces, with fallback
 *
 * ```hbs
 * {{x y}}
 * ```
 *
 * ^ `x` is resolved in the `component` and `helper` namespaces, without fallback
 */

/**
 * A `HelperAmbiguity` must be a helper, but it has fallback. If it didn't have fallback, it would
 * be a `NamespacedAmbiguity`.
 *
 * ```hbs
 * <a href={{x}} />
 * <a href="{{x}}.html" />
 * ```
 *
 * ^ `x` is resolved in the `helper` namespace with fallback
 */

/**
 * A `NamespacedAmbiguity` must be resolved in a particular namespace, without fallback.
 *
 * ```hbs
 * <X />
 * ```
 *
 * ^ `X` is resolved in the `component` namespace without fallback
 *
 * ```hbs
 * (x)
 * ```
 *
 * ^ `x` is resolved in the `helper` namespace without fallback
 *
 * ```hbs
 * <a {{x}} />
 * ```
 *
 * ^ `x` is resolved in the `modifier` namespace without fallback
 */
// Serialization
var SerializedAmbiguity = /*#__PURE__*/function (SerializedAmbiguity) {
  SerializedAmbiguity["Append"] = "Append";
  SerializedAmbiguity["Attr"] = "Attr";
  SerializedAmbiguity["Invoke"] = "Invoke";
  return SerializedAmbiguity;
}(SerializedAmbiguity || {});
function loadResolution(resolution) {
  if (typeof resolution === 'string') {
    switch (resolution) {
      case 'Loose':
        return LooseModeResolution.fallback();
      case 'Strict':
        return STRICT_RESOLUTION;
    }
  }
  switch (resolution[0]) {
    case 'ambiguous':
      switch (resolution[1]) {
        case SerializedAmbiguity.Append:
          return LooseModeResolution.append({
            invoke: false
          });
        case SerializedAmbiguity.Attr:
          return LooseModeResolution.attr();
        case SerializedAmbiguity.Invoke:
          return LooseModeResolution.append({
            invoke: true
          });
      }
    case 'ns':
      return LooseModeResolution.namespaced(resolution[1]);
  }
}

var api$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARGUMENT_RESOLUTION: ARGUMENT_RESOLUTION,
  AppendContent: AppendContent,
  ArgReference: ArgReference,
  Args: Args,
  Block: Block,
  COMPONENT_NAMESPACE: COMPONENT_NAMESPACE,
  CallExpression: CallExpression,
  ComponentArg: ComponentArg,
  DeprecatedCallExpression: DeprecatedCallExpression,
  ElementModifier: ElementModifier,
  FreeVarNamespace: FreeVarNamespace,
  FreeVarReference: FreeVarReference,
  GlimmerComment: GlimmerComment,
  HELPER_NAMESPACE: HELPER_NAMESPACE,
  HTML_RESOLUTION: HTML_RESOLUTION,
  HtmlAttr: HtmlAttr,
  HtmlComment: HtmlComment,
  HtmlText: HtmlText,
  InterpolateExpression: InterpolateExpression,
  InvokeBlock: InvokeBlock,
  InvokeComponent: InvokeComponent,
  LiteralExpression: LiteralExpression,
  LocalVarReference: LocalVarReference,
  LooseModeResolution: LooseModeResolution,
  MODIFIER_NAMESPACE: MODIFIER_NAMESPACE,
  NamedArgument: NamedArgument,
  NamedArguments: NamedArguments,
  NamedBlock: NamedBlock,
  NamedBlocks: NamedBlocks,
  PathExpression: PathExpression,
  PositionalArguments: PositionalArguments,
  STRICT_RESOLUTION: STRICT_RESOLUTION,
  SimpleElement: SimpleElement,
  SplatAttr: SplatAttr,
  Template: Template,
  ThisReference: ThisReference,
  isLiteral: isLiteral,
  isStrictResolution: isStrictResolution,
  loadResolution: loadResolution,
  node: node
});

class SymbolTable {
  static top(locals, options) {
    return new ProgramSymbolTable(locals, options);
  }
  child(locals) {
    let symbols = locals.map(name => this.allocate(name));
    return new BlockSymbolTable(this, locals, symbols);
  }
}
class ProgramSymbolTable extends SymbolTable {
  constructor(templateLocals, options) {
    super();
    this.templateLocals = templateLocals;
    this.options = options;
  }
  symbols = [];
  upvars = [];
  size = 1;
  named = dict();
  blocks = dict();
  usedTemplateLocals = [];
  #hasDebugger = false;
  hasLexical(name) {
    return this.options.lexicalScope(name);
  }
  getLexical(name) {
    return this.allocateFree(name, HTML_RESOLUTION);
  }
  getUsedTemplateLocals() {
    return this.usedTemplateLocals;
  }
  setHasDebugger() {
    this.#hasDebugger = true;
  }
  get hasEval() {
    return this.#hasDebugger;
  }
  has(name) {
    return this.templateLocals.includes(name);
  }
  get(name) {
    let index = this.usedTemplateLocals.indexOf(name);
    if (index !== -1) {
      return [index, true];
    }
    index = this.usedTemplateLocals.length;
    this.usedTemplateLocals.push(name);
    return [index, true];
  }
  getLocalsMap() {
    return dict();
  }
  getDebugInfo() {
    return Object.values(this.getLocalsMap());
  }
  allocateFree(name, resolution) {
    // If the name in question is an uppercase (i.e. angle-bracket) component invocation, run
    // the optional `customizeComponentName` function provided to the precompiler.
    if (resolution.resolution() === SexpOpcodes.GetFreeAsComponentHead && resolution.isAngleBracket) {
      name = this.options.customizeComponentName(name);
    }
    let index = this.upvars.indexOf(name);
    if (index !== -1) {
      return index;
    }
    index = this.upvars.length;
    this.upvars.push(name);
    return index;
  }
  allocateNamed(name) {
    let named = this.named[name];
    if (!named) {
      named = this.named[name] = this.allocate(name);
    }
    return named;
  }
  allocateBlock(name) {
    if (name === 'inverse') {
      name = 'else';
    }
    let block = this.blocks[name];
    if (!block) {
      block = this.blocks[name] = this.allocate(`&${name}`);
    }
    return block;
  }
  allocate(identifier) {
    this.symbols.push(identifier);
    return this.size++;
  }
}
class BlockSymbolTable extends SymbolTable {
  constructor(parent, symbols, slots) {
    super();
    this.parent = parent;
    this.symbols = symbols;
    this.slots = slots;
  }
  get locals() {
    return this.symbols;
  }
  getLexical(name) {
    return this.parent.getLexical(name);
  }
  hasLexical(name) {
    return this.parent.hasLexical(name);
  }
  has(name) {
    return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
  }
  get(name) {
    let local = this.#get(name);
    return local ? [local, false] : this.parent.get(name);
  }
  #get(name) {
    let slot = this.symbols.indexOf(name);
    return slot === -1 ? null : unwrap(this.slots[slot]);
  }
  getLocalsMap() {
    let dict = this.parent.getLocalsMap();
    this.symbols.forEach(symbol => dict[symbol] = this.get(symbol)[0]);
    return dict;
  }
  getDebugInfo() {
    return Object.values(this.getLocalsMap());
  }
  setHasDebugger() {
    this.parent.setHasDebugger();
  }
  allocateFree(name, resolution) {
    return this.parent.allocateFree(name, resolution);
  }
  allocateNamed(name) {
    return this.parent.allocateNamed(name);
  }
  allocateBlock(name) {
    return this.parent.allocateBlock(name);
  }
  allocate(identifier) {
    return this.parent.allocate(identifier);
  }
}

var api = /*#__PURE__*/Object.freeze({
  __proto__: null
});

class Builder {
  // TEMPLATE //

  template(symbols, body, loc) {
    return new Template({
      table: symbols,
      body,
      loc
    });
  }

  // INTERNAL (these nodes cannot be reached when doing general-purpose visiting) //

  block(symbols, body, loc) {
    return new Block({
      scope: symbols,
      body,
      loc
    });
  }
  namedBlock(name, block, loc) {
    return new NamedBlock({
      name,
      block,
      attrs: [],
      componentArgs: [],
      modifiers: [],
      loc
    });
  }
  simpleNamedBlock(name, block, loc) {
    return new BuildElement({
      selfClosing: false,
      attrs: [],
      componentArgs: [],
      modifiers: [],
      comments: []
    }).named(name, block, loc);
  }
  slice(chars, loc) {
    return new SourceSlice({
      loc,
      chars
    });
  }
  args(positional, named, loc) {
    return new Args({
      loc,
      positional,
      named
    });
  }
  positional(exprs, loc) {
    return new PositionalArguments({
      loc,
      exprs
    });
  }
  namedArgument(key, value) {
    return new NamedArgument({
      name: key,
      value
    });
  }
  named(entries, loc) {
    return new NamedArguments({
      loc,
      entries
    });
  }
  attr({
    name,
    value,
    trusting
  }, loc) {
    return new HtmlAttr({
      loc,
      name,
      value,
      trusting
    });
  }
  splatAttr(symbol, loc) {
    return new SplatAttr({
      symbol,
      loc
    });
  }
  arg({
    name,
    value,
    trusting
  }, loc) {
    return new ComponentArg({
      name,
      value,
      trusting,
      loc
    });
  }

  // EXPRESSIONS //

  path(head, tail, loc) {
    return new PathExpression({
      loc,
      ref: head,
      tail
    });
  }
  self(loc) {
    return new ThisReference({
      loc
    });
  }
  at(name, symbol, loc) {
    // the `@` should be included so we have a complete source range
    assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);
    return new ArgReference({
      loc,
      name: new SourceSlice({
        loc,
        chars: name
      }),
      symbol
    });
  }
  freeVar({
    name,
    context,
    symbol,
    loc
  }) {
    assert(name !== 'this', `You called builders.freeVar() with 'this'. Call builders.this instead`);
    assert(name[0] !== '@', `You called builders.freeVar() with '${name}'. Call builders.at('${name}') instead`);
    return new FreeVarReference({
      name,
      resolution: context,
      symbol,
      loc
    });
  }
  localVar(name, symbol, isTemplateLocal, loc) {
    assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);
    assert(name[0] !== '@', `You called builders.var() with '${name}'. Call builders.at('${name}') instead`);
    return new LocalVarReference({
      loc,
      name,
      isTemplateLocal,
      symbol
    });
  }
  sexp(parts, loc) {
    return new CallExpression({
      loc,
      callee: parts.callee,
      args: parts.args
    });
  }
  deprecatedCall(arg, callee, loc) {
    return new DeprecatedCallExpression({
      loc,
      arg,
      callee
    });
  }
  interpolate(parts, loc) {
    assertPresentArray(parts);
    return new InterpolateExpression({
      loc,
      parts
    });
  }
  literal(value, loc) {
    return new LiteralExpression({
      loc,
      value
    });
  }

  // STATEMENTS //

  append({
    table,
    trusting,
    value
  }, loc) {
    return new AppendContent({
      table,
      trusting,
      value,
      loc
    });
  }
  modifier({
    callee,
    args
  }, loc) {
    return new ElementModifier({
      loc,
      callee,
      args
    });
  }
  namedBlocks(blocks, loc) {
    return new NamedBlocks({
      loc,
      blocks
    });
  }
  blockStatement({
    program,
    inverse = null,
    ...call
  }, loc) {
    let blocksLoc = program.loc;
    let blocks = [this.namedBlock(SourceSlice.synthetic('default'), program, program.loc)];
    if (inverse) {
      blocksLoc = blocksLoc.extend(inverse.loc);
      blocks.push(this.namedBlock(SourceSlice.synthetic('else'), inverse, inverse.loc));
    }
    return new InvokeBlock({
      loc,
      blocks: this.namedBlocks(blocks, blocksLoc),
      callee: call.callee,
      args: call.args
    });
  }
  element(options) {
    return new BuildElement(options);
  }
}
class BuildElement {
  builder;
  constructor(base) {
    this.base = base;
    this.builder = new Builder();
  }
  simple(tag, body, loc) {
    return new SimpleElement(assign({
      tag,
      body,
      componentArgs: [],
      loc
    }, this.base));
  }
  named(name, block, loc) {
    return new NamedBlock(assign({
      name,
      block,
      componentArgs: [],
      loc
    }, this.base));
  }
  selfClosingComponent(callee, loc) {
    return new InvokeComponent(assign({
      loc,
      callee,
      // point the empty named blocks at the `/` self-closing tag
      blocks: new NamedBlocks({
        blocks: [],
        loc: loc.sliceEndChars({
          skipEnd: 1,
          chars: 1
        })
      })
    }, this.base));
  }
  componentWithDefaultBlock(callee, children, symbols, loc) {
    let block = this.builder.block(symbols, children, loc);
    let namedBlock = this.builder.namedBlock(SourceSlice.synthetic('default'), block, loc); // BUILDER.simpleNamedBlock('default', children, symbols, loc);

    return new InvokeComponent(assign({
      loc,
      callee,
      blocks: this.builder.namedBlocks([namedBlock], namedBlock.loc)
    }, this.base));
  }
  componentWithNamedBlocks(callee, blocks, loc) {
    return new InvokeComponent(assign({
      loc,
      callee,
      blocks: this.builder.namedBlocks(blocks, SpanList.range(blocks))
    }, this.base));
  }
}

function SexpSyntaxContext(node) {
  if (isSimpleCallee(node)) {
    return LooseModeResolution.namespaced(HELPER_NAMESPACE);
  } else {
    return null;
  }
}
function ModifierSyntaxContext(node) {
  if (isSimpleCallee(node)) {
    return LooseModeResolution.namespaced(MODIFIER_NAMESPACE);
  } else {
    return null;
  }
}
function BlockSyntaxContext(node) {
  if (isSimpleCallee(node)) {
    return LooseModeResolution.namespaced(COMPONENT_NAMESPACE);
  } else {
    return LooseModeResolution.fallback();
  }
}
function ComponentSyntaxContext(node) {
  if (isSimplePath(node)) {
    return LooseModeResolution.namespaced(FreeVarNamespace.Component, true);
  } else {
    return null;
  }
}

/**
 * This corresponds to append positions (text curlies or attribute
 * curlies). In strict mode, this also corresponds to arg curlies.
 */
function AttrValueSyntaxContext(node) {
  let isSimple = isSimpleCallee(node);
  let isInvoke = isInvokeNode(node);
  if (isSimple) {
    return isInvoke ? LooseModeResolution.namespaced(FreeVarNamespace.Helper) : LooseModeResolution.attr();
  } else {
    return isInvoke ? STRICT_RESOLUTION : LooseModeResolution.fallback();
  }
}

/**
 * This corresponds to append positions (text curlies or attribute
 * curlies). In strict mode, this also corresponds to arg curlies.
 */
function AppendSyntaxContext(node) {
  let isSimple = isSimpleCallee(node);
  let isInvoke = isInvokeNode(node);
  let trusting = node.trusting;
  if (isSimple) {
    return trusting ? LooseModeResolution.trustingAppend({
      invoke: isInvoke
    }) : LooseModeResolution.append({
      invoke: isInvoke
    });
  } else {
    return LooseModeResolution.fallback();
  }
}
// UTILITIES
/**
 * A call node has a simple callee if its head is:
 *
 * - a `PathExpression`
 * - the `PathExpression`'s head is a `VarHead`
 * - it has no tail
 *
 * Simple heads:
 *
 * ```
 * {{x}}
 * {{x y}}
 * ```
 *
 * Not simple heads:
 *
 * ```
 * {{x.y}}
 * {{x.y z}}
 * {{@x}}
 * {{@x a}}
 * {{this}}
 * {{this a}}
 * ```
 */
function isSimpleCallee(node) {
  let path = node.path;
  return isSimplePath(path);
}
function isSimplePath(node) {
  if (node.type === 'PathExpression' && node.head.type === 'VarHead') {
    return node.tail.length === 0;
  } else {
    return false;
  }
}

/**
 * The call expression has at least one argument.
 */
function isInvokeNode(node) {
  return node.params.length > 0 || node.hash.pairs.length > 0;
}

function normalize(source, options = {
  lexicalScope: () => false
}) {
  let ast = preprocess(source, options);
  let normalizeOptions = {
    strictMode: false,
    locals: [],
    ...options
  };
  let top = SymbolTable.top(normalizeOptions.locals, {
    customizeComponentName: options.customizeComponentName ?? (name => name),
    lexicalScope: options.lexicalScope
  });
  let block = new BlockContext(source, normalizeOptions, top);
  let normalizer = new StatementNormalizer(block);
  let astV2 = new TemplateChildren(block.loc(ast.loc), ast.body.map(b => normalizer.normalize(b)), block).assertTemplate(top);
  let locals = top.getUsedTemplateLocals();
  return [astV2, locals];
}

/**
 * A `BlockContext` represents the block that a particular AST node is contained inside of.
 *
 * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings
 * that are in-scope within that block.
 *
 * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides
 * facilities for working with those options.
 *
 * `BlockContext` is stateless.
 */
class BlockContext {
  builder;
  constructor(source, options, table) {
    this.source = source;
    this.options = options;
    this.table = table;
    this.builder = new Builder();
  }
  get strict() {
    return this.options.strictMode || false;
  }
  loc(loc) {
    return this.source.spanFor(loc);
  }
  resolutionFor(node, resolution) {
    if (this.strict) {
      return {
        result: STRICT_RESOLUTION
      };
    }
    if (this.isFreeVar(node)) {
      let r = resolution(node);
      if (r === null) {
        return {
          result: 'error',
          path: printPath(node),
          head: printHead(node)
        };
      }
      return {
        result: r
      };
    } else {
      return {
        result: STRICT_RESOLUTION
      };
    }
  }
  isLexicalVar(variable) {
    return this.table.hasLexical(variable);
  }
  isFreeVar(callee) {
    if (callee.type === 'PathExpression') {
      if (callee.head.type !== 'VarHead') {
        return false;
      }
      return !this.table.has(callee.head.name);
    } else if (callee.path.type === 'PathExpression') {
      return this.isFreeVar(callee.path);
    } else {
      return false;
    }
  }
  hasBinding(name) {
    return this.table.has(name) || this.table.hasLexical(name);
  }
  child(blockParams) {
    return new BlockContext(this.source, this.options, this.table.child(blockParams));
  }
  customizeComponentName(input) {
    if (this.options.customizeComponentName) {
      return this.options.customizeComponentName(input);
    } else {
      return input;
    }
  }
}

/**
 * An `ExpressionNormalizer` normalizes expressions within a block.
 *
 * `ExpressionNormalizer` is stateless.
 */
class ExpressionNormalizer {
  constructor(block) {
    this.block = block;
  }

  /**
   * The `normalize` method takes an arbitrary expression and its original syntax context and
   * normalizes it to an ASTv2 expression.
   *
   * @see {SyntaxContext}
   */

  normalize(expr, resolution) {
    switch (expr.type) {
      case 'NullLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'UndefinedLiteral':
        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));
      case 'PathExpression':
        return this.path(expr, resolution);
      case 'SubExpression':
        {
          let resolution = this.block.resolutionFor(expr, SexpSyntaxContext);
          if (resolution.result === 'error') {
            throw generateSyntaxError(`You attempted to invoke a path (\`${resolution.path}\`) but ${resolution.head} was not in scope`, expr.loc);
          }
          return this.block.builder.sexp(this.callParts(expr, resolution.result), this.block.loc(expr.loc));
        }
    }
  }
  path(expr, resolution) {
    let headOffsets = this.block.loc(expr.head.loc);
    let tail = [];

    // start with the head
    let offset = headOffsets;
    for (let part of expr.tail) {
      offset = offset.sliceStartChars({
        chars: part.length,
        skipStart: 1
      });
      tail.push(new SourceSlice({
        loc: offset,
        chars: part
      }));
    }
    return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));
  }

  /**
   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes
   * it to an ASTv2 CallParts.
   */
  callParts(parts, context) {
    let {
      path,
      params,
      hash
    } = parts;
    let callee = this.normalize(path, context);
    let paramList = params.map(p => this.normalize(p, ARGUMENT_RESOLUTION));
    let paramLoc = SpanList.range(paramList, callee.loc.collapse('end'));
    let namedLoc = this.block.loc(hash.loc);
    let argsLoc = SpanList.range([paramLoc, namedLoc]);
    let positional = this.block.builder.positional(params.map(p => this.normalize(p, ARGUMENT_RESOLUTION)), paramLoc);
    let named = this.block.builder.named(hash.pairs.map(p => this.namedArgument(p)), this.block.loc(hash.loc));
    return {
      callee,
      args: this.block.builder.args(positional, named, argsLoc)
    };
  }
  namedArgument(pair) {
    let offsets = this.block.loc(pair.loc);
    let keyOffsets = offsets.sliceStartChars({
      chars: pair.key.length
    });
    return this.block.builder.namedArgument(new SourceSlice({
      chars: pair.key,
      loc: keyOffsets
    }), this.normalize(pair.value, ARGUMENT_RESOLUTION));
  }

  /**
   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.
   * This method is extremely important, because it is responsible for normalizing free
   * variables into an an ASTv2.PathHead *with appropriate context*.
   *
   * The syntax context is originally determined by the syntactic position that this `PathHead`
   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,
   * the `VariableReference` node bears full responsibility for loose mode rules that control
   * the behavior of free variables.
   */
  ref(head, resolution) {
    let {
      block
    } = this;
    let {
      builder,
      table
    } = block;
    let offsets = block.loc(head.loc);
    switch (head.type) {
      case 'ThisHead':
        return builder.self(offsets);
      case 'AtHead':
        {
          let symbol = table.allocateNamed(head.name);
          return builder.at(head.name, symbol, offsets);
        }
      case 'VarHead':
        {
          if (block.hasBinding(head.name)) {
            let [symbol, isRoot] = table.get(head.name);
            return block.builder.localVar(head.name, symbol, isRoot, offsets);
          } else {
            let context = block.strict ? STRICT_RESOLUTION : resolution;
            let symbol = block.table.allocateFree(head.name, context);
            return block.builder.freeVar({
              name: head.name,
              context,
              symbol,
              loc: offsets
            });
          }
        }
    }
  }
}

/**
 * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.
 */
class StatementNormalizer {
  constructor(block) {
    this.block = block;
  }
  normalize(node) {
    switch (node.type) {
      case 'PartialStatement':
        throw new Error(`Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer`);
      case 'BlockStatement':
        return this.BlockStatement(node);
      case 'ElementNode':
        return new ElementNormalizer(this.block).ElementNode(node);
      case 'MustacheStatement':
        return this.MustacheStatement(node);

      // These are the same in ASTv2
      case 'MustacheCommentStatement':
        return this.MustacheCommentStatement(node);
      case 'CommentStatement':
        {
          let loc = this.block.loc(node.loc);
          return new HtmlComment({
            loc,
            text: loc.slice({
              skipStart: 4,
              skipEnd: 3
            }).toSlice(node.value)
          });
        }
      case 'TextNode':
        return new HtmlText({
          loc: this.block.loc(node.loc),
          chars: node.chars
        });
    }
  }
  MustacheCommentStatement(node) {
    let loc = this.block.loc(node.loc);
    let textLoc;
    if (loc.asString().slice(0, 5) === '{{!--') {
      textLoc = loc.slice({
        skipStart: 5,
        skipEnd: 4
      });
    } else {
      textLoc = loc.slice({
        skipStart: 3,
        skipEnd: 2
      });
    }
    return new GlimmerComment({
      loc,
      text: textLoc.toSlice(node.value)
    });
  }

  /**
   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement
   */
  MustacheStatement(mustache) {
    let {
      escaped
    } = mustache;
    let loc = this.block.loc(mustache.loc);

    // Normalize the call parts in AppendSyntaxContext
    let callParts = this.expr.callParts({
      path: mustache.path,
      params: mustache.params,
      hash: mustache.hash
    }, AppendSyntaxContext(mustache));
    let value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);
    return this.block.builder.append({
      table: this.block.table,
      trusting: !escaped,
      value
    }, loc);
  }

  /**
   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement
   */
  BlockStatement(block) {
    let {
      program,
      inverse
    } = block;
    let loc = this.block.loc(block.loc);
    let resolution = this.block.resolutionFor(block, BlockSyntaxContext);
    if (resolution.result === 'error') {
      throw generateSyntaxError(`You attempted to invoke a path (\`{{#${resolution.path}}}\`) but ${resolution.head} was not in scope`, loc);
    }
    let callParts = this.expr.callParts(block, resolution.result);
    return this.block.builder.blockStatement(assign({
      symbols: this.block.table,
      program: this.Block(program),
      inverse: inverse ? this.Block(inverse) : null
    }, callParts), loc);
  }
  Block({
    body,
    loc,
    blockParams
  }) {
    let child = this.block.child(blockParams);
    let normalizer = new StatementNormalizer(child);
    return new BlockChildren(this.block.loc(loc), body.map(b => normalizer.normalize(b)), this.block).assertBlock(child.table);
  }
  get expr() {
    return new ExpressionNormalizer(this.block);
  }
}
class ElementNormalizer {
  constructor(ctx) {
    this.ctx = ctx;
  }

  /**
   * Normalizes an ASTv1.ElementNode to:
   *
   * - ASTv2.NamedBlock if the tag name begins with `:`
   * - ASTv2.Component if the tag name matches the component heuristics
   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics
   *
   * A tag name represents a component if:
   *
   * - it begins with `@`
   * - it is exactly `this` or begins with `this.`
   * - the part before the first `.` is a reference to an in-scope variable binding
   * - it begins with an uppercase character
   */
  ElementNode(element) {
    let {
      tag,
      selfClosing,
      comments
    } = element;
    let loc = this.ctx.loc(element.loc);
    let [tagHead, ...rest] = asPresentArray(tag.split('.'));

    // the head, attributes and modifiers are in the current scope
    let path = this.classifyTag(tagHead, rest, element.loc);
    let attrs = element.attributes.filter(a => a.name[0] !== '@').map(a => this.attr(a));
    let args = element.attributes.filter(a => a.name[0] === '@').map(a => this.arg(a));
    let modifiers = element.modifiers.map(m => this.modifier(m));

    // the element's block params are in scope for the children
    let child = this.ctx.child(element.blockParams);
    let normalizer = new StatementNormalizer(child);
    let childNodes = element.children.map(s => normalizer.normalize(s));
    let el = this.ctx.builder.element({
      selfClosing,
      attrs,
      componentArgs: args,
      modifiers,
      comments: comments.map(c => new StatementNormalizer(this.ctx).MustacheCommentStatement(c))
    });
    let children = new ElementChildren(el, loc, childNodes, this.ctx);
    let offsets = this.ctx.loc(element.loc);
    let tagOffsets = offsets.sliceStartChars({
      chars: tag.length,
      skipStart: 1
    });
    if (path === 'ElementHead') {
      if (tag[0] === ':') {
        return children.assertNamedBlock(tagOffsets.slice({
          skipStart: 1
        }).toSlice(tag.slice(1)), child.table);
      } else {
        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);
      }
    }
    if (element.selfClosing) {
      return el.selfClosingComponent(path, loc);
    } else {
      let blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);
      return el.componentWithNamedBlocks(path, blocks, loc);
    }
  }
  modifier(m) {
    let resolution = this.ctx.resolutionFor(m, ModifierSyntaxContext);
    if (resolution.result === 'error') {
      throw generateSyntaxError(`You attempted to invoke a path (\`{{#${resolution.path}}}\`) as a modifier, but ${resolution.head} was not in scope. Try adding \`this\` to the beginning of the path`, m.loc);
    }
    let callParts = this.expr.callParts(m, resolution.result);
    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));
  }

  /**
   * This method handles attribute values that are curlies, as well as curlies nested inside of
   * interpolations:
   *
   * ```hbs
   * <a href={{url}} />
   * <a href="{{url}}.html" />
   * ```
   */
  mustacheAttr(mustache) {
    // Normalize the call parts in AttrValueSyntaxContext
    let sexp = this.ctx.builder.sexp(this.expr.callParts(mustache, AttrValueSyntaxContext(mustache)), this.ctx.loc(mustache.loc));

    // If there are no params or hash, just return the function part as its own expression
    if (sexp.args.isEmpty()) {
      return sexp.callee;
    } else {
      return sexp;
    }
  }

  /**
   * attrPart is the narrowed down list of valid attribute values that are also
   * allowed as a concat part (you can't nest concats).
   */
  attrPart(part) {
    switch (part.type) {
      case 'MustacheStatement':
        return {
          expr: this.mustacheAttr(part),
          trusting: !part.escaped
        };
      case 'TextNode':
        return {
          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),
          trusting: true
        };
    }
  }
  attrValue(part) {
    switch (part.type) {
      case 'ConcatStatement':
        {
          let parts = part.parts.map(p => this.attrPart(p).expr);
          return {
            expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),
            trusting: false
          };
        }
      default:
        return this.attrPart(part);
    }
  }
  attr(m) {
    assert(m.name[0] !== '@', 'An attr name must not start with `@`');
    if (m.name === '...attributes') {
      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));
    }
    let offsets = this.ctx.loc(m.loc);
    let nameSlice = offsets.sliceStartChars({
      chars: m.name.length
    }).toSlice(m.name);
    let value = this.attrValue(m.value);
    return this.ctx.builder.attr({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }
  maybeDeprecatedCall(arg, part) {
    if (this.ctx.strict) {
      return null;
    }
    if (part.type !== 'MustacheStatement') {
      return null;
    }
    let {
      path
    } = part;
    if (path.type !== 'PathExpression') {
      return null;
    }
    if (path.head.type !== 'VarHead') {
      return null;
    }
    let {
      name
    } = path.head;
    if (name === 'has-block' || name === 'has-block-params') {
      return null;
    }
    if (this.ctx.hasBinding(name)) {
      return null;
    }
    if (path.tail.length !== 0) {
      return null;
    }
    if (part.params.length !== 0 || part.hash.pairs.length !== 0) {
      return null;
    }
    let context = LooseModeResolution.attr();
    let callee = this.ctx.builder.freeVar({
      name,
      context,
      symbol: this.ctx.table.allocateFree(name, context),
      loc: path.loc
    });
    return {
      expr: this.ctx.builder.deprecatedCall(arg, callee, part.loc),
      trusting: false
    };
  }
  arg(arg) {
    assert(arg.name[0] === '@', 'An arg name must start with `@`');
    let offsets = this.ctx.loc(arg.loc);
    let nameSlice = offsets.sliceStartChars({
      chars: arg.name.length
    }).toSlice(arg.name);
    let value = this.maybeDeprecatedCall(nameSlice, arg.value) || this.attrValue(arg.value);
    return this.ctx.builder.arg({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }

  /**
   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the
   * element is a component) or `'ElementHead'` (if the element is a simple element).
   *
   * Rules:
   *
   * 1. If the variable is an `@arg`, return an `AtHead`
   * 2. If the variable is `this`, return a `ThisHead`
   * 3. If the variable is in the current scope:
   *   a. If the scope is the root scope, then return a Free `LocalVarHead`
   *   b. Else, return a standard `LocalVarHead`
   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error
   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)
   * 6. Otherwise, return `'ElementHead'`
   */
  classifyTag(variable, tail, loc) {
    let uppercase = isUpperCase(variable);
    let inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);
    if (this.ctx.strict && !inScope) {
      if (uppercase) {
        throw generateSyntaxError(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${variable}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${variable.toLowerCase()}>\``, loc);
      }

      // In strict mode, values are always elements unless they are in scope
      return 'ElementHead';
    }

    // Since the parser handed us the HTML element name as a string, we need
    // to convert it into an ASTv1 path so it can be processed using the
    // expression normalizer.
    let isComponent = inScope || uppercase;
    let variableLoc = loc.sliceStartChars({
      skipStart: 1,
      chars: variable.length
    });
    let tailLength = tail.reduce((accum, part) => accum + 1 + part.length, 0);
    let pathEnd = variableLoc.getEnd().move(tailLength);
    let pathLoc = variableLoc.withEnd(pathEnd);
    if (isComponent) {
      let path = b.path({
        head: b.head(variable, variableLoc),
        tail,
        loc: pathLoc
      });
      let resolution = this.ctx.isLexicalVar(variable) ? {
        result: STRICT_RESOLUTION
      } : this.ctx.resolutionFor(path, ComponentSyntaxContext);
      if (resolution.result === 'error') {
        throw generateSyntaxError(`You attempted to invoke a path (\`<${resolution.path}>\`) but ${resolution.head} was not in scope`, loc);
      }
      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.result);
    } else {
      this.ctx.table.allocateFree(variable, STRICT_RESOLUTION);
    }

    // If the tag name wasn't a valid component but contained a `.`, it's
    // a syntax error.
    if (tail.length > 0) {
      throw generateSyntaxError(`You used ${variable}.${tail.join('.')} as a tag name, but ${variable} is not in scope`, loc);
    }
    return 'ElementHead';
  }
  get expr() {
    return new ExpressionNormalizer(this.ctx);
  }
}
class Children {
  namedBlocks;
  hasSemanticContent;
  nonBlockChildren;
  constructor(loc, children, block) {
    this.loc = loc;
    this.children = children;
    this.block = block;
    this.namedBlocks = children.filter(c => c instanceof NamedBlock);
    this.hasSemanticContent = Boolean(children.filter(c => {
      if (c instanceof NamedBlock) {
        return false;
      }
      switch (c.type) {
        case 'GlimmerComment':
        case 'HtmlComment':
          return false;
        case 'HtmlText':
          return !/^\s*$/u.test(c.chars);
        default:
          return true;
      }
    }).length);
    this.nonBlockChildren = children.filter(c => !(c instanceof NamedBlock));
  }
}
class TemplateChildren extends Children {
  assertTemplate(table) {
    if (isPresentArray(this.namedBlocks)) {
      throw generateSyntaxError(`Unexpected named block at the top-level of a template`, this.loc);
    }
    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));
  }
}
class BlockChildren extends Children {
  assertBlock(table) {
    if (isPresentArray(this.namedBlocks)) {
      throw generateSyntaxError(`Unexpected named block nested in a normal block`, this.loc);
    }
    return this.block.builder.block(table, this.nonBlockChildren, this.loc);
  }
}
class ElementChildren extends Children {
  constructor(el, loc, children, block) {
    super(loc, children, block);
    this.el = el;
  }
  assertNamedBlock(name, table) {
    if (this.el.base.selfClosing) {
      throw generateSyntaxError(`<:${name.chars}/> is not a valid named block: named blocks cannot be self-closing`, this.loc);
    }
    if (isPresentArray(this.namedBlocks)) {
      throw generateSyntaxError(`Unexpected named block inside <:${name.chars}> named block: named blocks cannot contain nested named blocks`, this.loc);
    }
    if (!isLowerCase(name.chars)) {
      throw generateSyntaxError(`<:${name.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`, this.loc);
    }
    if (this.el.base.attrs.length > 0 || this.el.base.componentArgs.length > 0 || this.el.base.modifiers.length > 0) {
      throw generateSyntaxError(`named block <:${name.chars}> cannot have attributes, arguments, or modifiers`, this.loc);
    }
    let offsets = SpanList.range(this.nonBlockChildren, this.loc);
    return this.block.builder.namedBlock(name, this.block.builder.block(table, this.nonBlockChildren, offsets), this.loc);
  }
  assertElement(name, hasBlockParams) {
    if (hasBlockParams) {
      throw generateSyntaxError(`Unexpected block params in <${name}>: simple elements cannot have block params`, this.loc);
    }
    if (isPresentArray(this.namedBlocks)) {
      let names = this.namedBlocks.map(b => b.name);
      if (names.length === 1) {
        throw generateSyntaxError(`Unexpected named block <:foo> inside <${name.chars}> HTML element`, this.loc);
      } else {
        let printedNames = names.map(n => `<:${n.chars}>`).join(', ');
        throw generateSyntaxError(`Unexpected named blocks inside <${name.chars}> HTML element (${printedNames})`, this.loc);
      }
    }
    return this.el.simple(name, this.nonBlockChildren, this.loc);
  }
  assertComponent(name, table, hasBlockParams) {
    if (isPresentArray(this.namedBlocks) && this.hasSemanticContent) {
      throw generateSyntaxError(`Unexpected content inside <${name}> component invocation: when using named blocks, the tag cannot contain other content`, this.loc);
    }
    if (isPresentArray(this.namedBlocks)) {
      if (hasBlockParams) {
        throw generateSyntaxError(`Unexpected block params list on <${name}> component invocation: when passing named blocks, the invocation tag cannot take block params`, this.loc);
      }
      let seenNames = new Set();
      for (let block of this.namedBlocks) {
        let name = block.name.chars;
        if (seenNames.has(name)) {
          throw generateSyntaxError(`Component had two named blocks with the same name, \`<:${name}>\`. Only one block with a given name may be passed`, this.loc);
        }
        if (name === 'inverse' && seenNames.has('else') || name === 'else' && seenNames.has('inverse')) {
          throw generateSyntaxError(`Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>`, this.loc);
        }
        seenNames.add(name);
      }
      return this.namedBlocks;
    } else {
      return [this.block.builder.namedBlock(SourceSlice.synthetic('default'), this.block.builder.block(table, this.nonBlockChildren, this.loc), this.loc)];
    }
  }
}
function printPath(node) {
  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {
    return printPath(node.path);
  } else {
    return new Printer({
      entityEncoding: 'raw'
    }).print(node);
  }
}
function printHead(node) {
  if (node.type === 'PathExpression') {
    switch (node.head.type) {
      case 'AtHead':
      case 'VarHead':
        return node.head.name;
      case 'ThisHead':
        return 'this';
    }
  } else if (node.path.type === 'PathExpression') {
    return printHead(node.path);
  } else {
    return new Printer({
      entityEncoding: 'raw'
    }).print(node);
  }
}

export { api as AST, api as ASTv1, api$1 as ASTv2, BlockSymbolTable, KEYWORDS_TYPES, Walker as Path, ProgramSymbolTable, SourceSlice, SpanList, SymbolTable, Walker, WalkerPath, publicBuilder as builders, cannotRemoveNode, cannotReplaceNode, generateSyntaxError, getTemplateLocals, getVoidTags, hasSpan, isKeyword, isVoidTag, loc, maybeLoc, node, normalize, preprocess, build as print, sortByLoc, api$2 as src, traverse, visitorKeys };
//# sourceMappingURL=index.js.map
