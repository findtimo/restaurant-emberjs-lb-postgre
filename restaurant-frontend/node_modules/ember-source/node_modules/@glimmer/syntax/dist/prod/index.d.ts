import { Dict, Nullable, PresentArray, WireFormat, Core, GetContextualFreeOpcode } from "@glimmer/interfaces";
import { EntityParser, EventedTokenizer } from "simple-html-tokenizer";
declare namespace HBS {
    interface CommonNode {
        loc: SourceLocation;
    }
    interface NodeMap {
        Program: {
            input: Program;
            output: ASTv1.Template | ASTv1.Block;
        };
        MustacheStatement: {
            input: MustacheStatement;
            output: ASTv1.MustacheStatement | void;
        };
        Decorator: {
            input: Decorator;
            output: never;
        };
        BlockStatement: {
            input: BlockStatement;
            output: ASTv1.BlockStatement | void;
        };
        DecoratorBlock: {
            input: DecoratorBlock;
            output: never;
        };
        PartialStatement: {
            input: PartialStatement;
            output: never;
        };
        PartialBlockStatement: {
            input: PartialBlockStatement;
            output: never;
        };
        ContentStatement: {
            input: ContentStatement;
            output: void;
        };
        CommentStatement: {
            input: CommentStatement;
            output: ASTv1.MustacheCommentStatement | null;
        };
        SubExpression: {
            input: SubExpression;
            output: ASTv1.SubExpression;
        };
        PathExpression: {
            input: PathExpression;
            output: ASTv1.PathExpression;
        };
        StringLiteral: {
            input: StringLiteral;
            output: ASTv1.StringLiteral;
        };
        BooleanLiteral: {
            input: BooleanLiteral;
            output: ASTv1.BooleanLiteral;
        };
        NumberLiteral: {
            input: NumberLiteral;
            output: ASTv1.NumberLiteral;
        };
        UndefinedLiteral: {
            input: UndefinedLiteral;
            output: ASTv1.UndefinedLiteral;
        };
        NullLiteral: {
            input: NullLiteral;
            output: ASTv1.NullLiteral;
        };
    }
    type NodeType = keyof NodeMap;
    type Node<T extends NodeType = NodeType> = NodeMap[T]["input"];
    type Output<T extends NodeType> = NodeMap[T]["output"];
    interface SourceLocation {
        source: string;
        start: Position;
        end: Position;
    }
    interface Position {
        line: number;
        column: number;
    }
    interface Program extends CommonNode {
        type: "Program";
        body: Statement[];
        blockParams: string[];
        chained?: boolean;
    }
    type Statement = MustacheStatement | BlockStatement | DecoratorBlock | PartialStatement | PartialBlockStatement | ContentStatement | CommentStatement;
    interface CommonMustache extends CommonNode {
        path: Expression;
        params: Expression[];
        hash: Hash;
        escaped: boolean;
        strip: StripFlags;
    }
    interface MustacheStatement extends CommonMustache {
        type: "MustacheStatement";
    }
    interface Decorator extends CommonMustache {
        type: "DecoratorStatement";
    }
    interface CommonBlock extends CommonNode {
        chained: boolean;
        path: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
        program: Program;
        inverse: Program;
        openStrip: StripFlags;
        inverseStrip: StripFlags;
        closeStrip: StripFlags;
    }
    interface BlockStatement extends CommonBlock {
        type: "BlockStatement";
    }
    interface DecoratorBlock extends CommonBlock {
        type: "DecoratorBlock";
    }
    interface PartialStatement extends CommonNode {
        type: "PartialStatement";
        name: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
        indent: string;
        strip: StripFlags;
    }
    interface PartialBlockStatement extends CommonNode {
        type: "PartialBlockStatement";
        name: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
        program: Program;
        openStrip: StripFlags;
        closeStrip: StripFlags;
    }
    interface ContentStatement extends CommonNode {
        type: "ContentStatement";
        value: string;
        original: StripFlags;
    }
    interface CommentStatement extends CommonNode {
        type: "CommentStatement";
        value: string;
        strip: StripFlags;
    }
    type Expression = SubExpression | PathExpression | Literal;
    interface SubExpression extends CommonNode {
        type: "SubExpression";
        path: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
    }
    interface PathExpression extends CommonNode {
        type: "PathExpression";
        data: boolean;
        depth: number;
        parts: string[];
        original: string;
    }
    type Literal = StringLiteral | BooleanLiteral | NumberLiteral | UndefinedLiteral | NullLiteral;
    interface StringLiteral extends CommonNode {
        type: "StringLiteral";
        value: string;
        original: string;
    }
    interface BooleanLiteral extends CommonNode {
        type: "BooleanLiteral";
        value: boolean;
        original: boolean;
    }
    interface NumberLiteral extends CommonNode {
        type: "NumberLiteral";
        value: number;
        original: number;
    }
    interface UndefinedLiteral extends CommonNode {
        type: "UndefinedLiteral";
    }
    interface NullLiteral extends CommonNode {
        type: "NullLiteral";
    }
    interface Hash extends CommonNode {
        pairs: HashPair[];
    }
    interface HashPair extends CommonNode {
        key: string;
        value: Expression;
    }
    interface StripFlags {
        open: boolean;
        close: boolean;
    }
}
declare namespace src {
    type ParserNodeBuilder<N extends {
        loc: src.SourceSpan;
    }> = Omit<N, "loc"> & {
        loc: src.SourceOffset;
    };
    interface Tag<T extends "StartTag" | "EndTag"> {
        readonly type: T;
        name: string;
        readonly attributes: ASTv1.AttrNode[];
        readonly modifiers: ASTv1.ElementModifierStatement[];
        readonly comments: ASTv1.MustacheCommentStatement[];
        selfClosing: boolean;
        readonly loc: src.SourceSpan;
    }
    interface Attribute {
        name: string;
        currentPart: ASTv1.TextNode | null;
        parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];
        isQuoted: boolean;
        isDynamic: boolean;
        start: src.SourceOffset;
        valueSpan: src.SourceSpan;
    }
    abstract class Parser {
        protected elementStack: ASTv1.ParentNode[];
        private lines;
        readonly source: src.Source;
        currentAttribute: Nullable<Attribute>;
        currentNode: Nullable<Readonly<ParserNodeBuilder<ASTv1.CommentStatement> | ASTv1.TextNode | ParserNodeBuilder<Tag<"StartTag">> | ParserNodeBuilder<Tag<"EndTag">>>>;
        tokenizer: EventedTokenizer;
        constructor(source: src.Source, entityParser?: EntityParser, mode?: "precompile" | "codemod");
        offset(): src.SourceOffset;
        pos({ line, column }: src.SourcePosition): src.SourceOffset;
        finish<T extends {
            loc: src.SourceSpan;
        }>(node: ParserNodeBuilder<T>): T;
        abstract Program(node: HBS.Program): HBS.Output<"Program">;
        abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<"MustacheStatement">;
        abstract Decorator(node: HBS.Decorator): HBS.Output<"Decorator">;
        abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<"BlockStatement">;
        abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<"DecoratorBlock">;
        abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<"PartialStatement">;
        abstract PartialBlockStatement(node: HBS.PartialBlockStatement): HBS.Output<"PartialBlockStatement">;
        abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<"ContentStatement">;
        abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<"CommentStatement">;
        abstract SubExpression(node: HBS.SubExpression): HBS.Output<"SubExpression">;
        abstract PathExpression(node: HBS.PathExpression): HBS.Output<"PathExpression">;
        abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<"StringLiteral">;
        abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<"BooleanLiteral">;
        abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<"NumberLiteral">;
        abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<"UndefinedLiteral">;
        abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<"NullLiteral">;
        abstract reset(): void;
        abstract finishData(): void;
        abstract tagOpen(): void;
        abstract beginData(): void;
        abstract appendToData(char: string): void;
        abstract beginStartTag(): void;
        abstract appendToTagName(char: string): void;
        abstract beginAttribute(): void;
        abstract appendToAttributeName(char: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract appendToAttributeValue(char: string): void;
        abstract finishAttributeValue(): void;
        abstract markTagAsSelfClosing(): void;
        abstract beginEndTag(): void;
        abstract finishTag(): void;
        abstract beginComment(): void;
        abstract appendToCommentData(char: string): void;
        abstract finishComment(): void;
        abstract reportSyntaxError(error: string): void;
        get currentAttr(): Attribute;
        get currentTag(): ParserNodeBuilder<Tag<"StartTag" | "EndTag">>;
        get currentStartTag(): ParserNodeBuilder<Tag<"StartTag">>;
        get currentEndTag(): ParserNodeBuilder<Tag<"EndTag">>;
        get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement>;
        get currentData(): ASTv1.TextNode;
        acceptTemplate(node: HBS.Program): ASTv1.Template;
        acceptNode(node: HBS.Program): ASTv1.Block | ASTv1.Template;
        acceptNode<U extends HBS.Node | ASTv1.Node>(node: HBS.Node): U;
        currentElement(): ASTv1.ParentNode;
        sourceForNode(node: HBS.Node, endNode?: {
            loc: HBS.SourceLocation;
        }): string;
    }
    // ensure stays in sync with typing
    // ParentNode and ChildKey types are derived from VisitorKeysMap
    const visitorKeys: {
        readonly Program: readonly [
            "body"
        ];
        readonly Template: readonly [
            "body"
        ];
        readonly Block: readonly [
            "body"
        ];
        readonly MustacheStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly BlockStatement: readonly [
            "path",
            "params",
            "hash",
            "program",
            "inverse"
        ];
        readonly ElementModifierStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PartialStatement: readonly [
            "name",
            "params",
            "hash"
        ];
        readonly CommentStatement: readonly [
        ];
        readonly MustacheCommentStatement: readonly [
        ];
        readonly ElementNode: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly AttrNode: readonly [
            "value"
        ];
        readonly TextNode: readonly [
        ];
        readonly ConcatStatement: readonly [
            "parts"
        ];
        readonly SubExpression: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PathExpression: readonly [
        ];
        readonly PathHead: readonly [
        ];
        readonly StringLiteral: readonly [
        ];
        readonly BooleanLiteral: readonly [
        ];
        readonly NumberLiteral: readonly [
        ];
        readonly NullLiteral: readonly [
        ];
        readonly UndefinedLiteral: readonly [
        ];
        readonly Hash: readonly [
            "pairs"
        ];
        readonly HashPair: readonly [
            "value"
        ];
        readonly NamedBlock: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly SimpleElement: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly Component: readonly [
            "head",
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
    };
    type VisitorKeysMap = typeof visitorKeys;
    type VisitorKeys = {
        [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number];
    };
    type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N["type"]] & keyof N;
    class WalkerPath<N extends ASTv1.Node> {
        node: N;
        parent: WalkerPath<ASTv1.Node> | null;
        parentKey: string | null;
        constructor(node: N, parent?: WalkerPath<ASTv1.Node> | null, parentKey?: string | null);
        get parentNode(): ASTv1.Node | null;
        parents(): Iterable<WalkerPath<ASTv1.Node> | null>;
    }
    interface FullNodeTraversal<N extends ASTv1.Node> {
        enter?(node: N, path: WalkerPath<N>): void;
        exit?(node: N, path: WalkerPath<N>): void;
        keys?: KeysVisitor<N>;
    }
    type NodeHandler<N extends ASTv1.Node> = (node: N, path: WalkerPath<N>) => void;
    type NodeTraversal<N extends ASTv1.Node> = FullNodeTraversal<N> | NodeHandler<N>;
    type NodeVisitor = {
        [P in keyof ASTv1.Nodes]?: NodeTraversal<ASTv1.Nodes[P]>;
    } & {
        All?: NodeTraversal<ASTv1.Node>;
    };
    interface FullKeyTraversal<N extends ASTv1.Node, K extends string> {
        enter?(node: N, key: K): void;
        exit?(node: N, key: K): void;
    }
    type KeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>> = (node: N, key: K) => void;
    type KeyTraversal<N extends ASTv1.Node, K extends VisitorKey<N>> = FullKeyTraversal<N, K> | KeyHandler<N, K>;
    type KeysVisitor<N extends ASTv1.Node> = {
        [P in VisitorKey<N>]?: KeyTraversal<N, P>;
    } & {
        All?: KeyTraversal<N, VisitorKey<N>>;
    };
    const voidMap: Set<string>;
    function getVoidTags(): string[];
    interface PrinterOptions {
        entityEncoding: "transformed" | "raw";
        /**
         * Used to override the mechanism of printing a given AST.Node.
         *
         * This will generally only be useful to source -> source codemods
         * where you would like to specialize/override the way a given node is
         * printed (e.g. you would like to preserve as much of the original
         * formatting as possible).
         *
         * When the provided override returns undefined, the default built in printing
         * will be done for the AST.Node.
         *
         * @param ast the ast node to be printed
         * @param options the options specified during the print() invocation
         */
        override?(ast: ASTv1.Node, options: PrinterOptions): void | string;
    }
    /**
     * Examples when true:
     *  - link
     *  - liNK
     *
     * Examples when false:
     *  - Link (component)
     */
    function isVoidTag(tag: string): boolean;
    class Printer {
        private buffer;
        private options;
        constructor(options: PrinterOptions);
        /*
        This is used by _all_ methods on this Printer class that add to `this.buffer`,
        it allows consumers of the printer to use alternate string representations for
        a given node.
        
        The primary use case for this are things like source -> source codemod utilities.
        For example, ember-template-recast attempts to always preserve the original string
        formatting in each AST node if no modifications are made to it.
        */
        handledByOverride(node: ASTv1.Node, ensureLeadingWhitespace?: boolean): boolean;
        Node(node: ASTv1.Node): void;
        Expression(expression: ASTv1.Expression): void;
        Literal(literal: ASTv1.Literal): void;
        TopLevelStatement(statement: ASTv1.TopLevelStatement | ASTv1.Template | ASTv1.AttrNode): void;
        Block(block: ASTv1.Block | ASTv1.Program | ASTv1.Template): void;
        TopLevelStatements(statements: ASTv1.TopLevelStatement[]): void;
        ElementNode(el: ASTv1.ElementNode): void;
        OpenElementNode(el: ASTv1.ElementNode): void;
        CloseElementNode(el: ASTv1.ElementNode): void;
        AttrNode(attr: ASTv1.AttrNode): void;
        AttrNodeValue(value: ASTv1.AttrNode["value"]): void;
        TextNode(text: ASTv1.TextNode, isAttr?: boolean): void;
        MustacheStatement(mustache: ASTv1.MustacheStatement): void;
        BlockStatement(block: ASTv1.BlockStatement): void;
        BlockParams(blockParams: string[]): void;
        PartialStatement(partial: ASTv1.PartialStatement): void;
        ConcatStatement(concat: ASTv1.ConcatStatement): void;
        MustacheCommentStatement(comment: ASTv1.MustacheCommentStatement): void;
        ElementModifierStatement(mod: ASTv1.ElementModifierStatement): void;
        CommentStatement(comment: ASTv1.CommentStatement): void;
        PathExpression(path: ASTv1.PathExpression): void;
        SubExpression(sexp: ASTv1.SubExpression): void;
        Params(params: ASTv1.Expression[]): void;
        Hash(hash: ASTv1.Hash): void;
        HashPair(pair: ASTv1.HashPair): void;
        StringLiteral(str: ASTv1.StringLiteral): void;
        BooleanLiteral(bool: ASTv1.BooleanLiteral): void;
        NumberLiteral(number: ASTv1.NumberLiteral): void;
        UndefinedLiteral(node: ASTv1.UndefinedLiteral): void;
        NullLiteral(node: ASTv1.NullLiteral): void;
        print(node: ASTv1.Node): string;
    }
    function build(ast: ASTv1.Node, options?: PrinterOptions): string;
    const print: typeof build;
    function traverse(node: ASTv1.Node, visitor: NodeVisitor): void;
    type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;
    class Walker {
        order?: unknown;
        stack: unknown[];
        constructor(order?: unknown);
        visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void;
        children<N extends ASTv1.Node>(node: N & ASTv1.Node, callback: NodeCallback<N & ASTv1.Node>): void;
    }
    // const SOURCE = new Source('', '(tests)');
    // Statements
    type BuilderHead = string | ASTv1.Expression;
    type TagDescriptor = string | {
        name: string;
        selfClosing: boolean;
    };
    function buildMustache(path: BuilderHead | ASTv1.Literal, params?: ASTv1.Expression[], hash?: ASTv1.Hash, raw?: boolean, loc?: SourceLocation, strip?: ASTv1.StripFlags): ASTv1.MustacheStatement;
    function buildBlock(path: BuilderHead, params: Nullable<ASTv1.Expression[]>, hash: Nullable<ASTv1.Hash>, _defaultBlock: ASTv1.PossiblyDeprecatedBlock, _elseBlock?: Nullable<ASTv1.PossiblyDeprecatedBlock>, loc?: SourceLocation, openStrip?: ASTv1.StripFlags, inverseStrip?: ASTv1.StripFlags, closeStrip?: ASTv1.StripFlags): ASTv1.BlockStatement;
    function buildElementModifier(path: BuilderHead | ASTv1.Expression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: Nullable<SourceLocation>): ASTv1.ElementModifierStatement;
    function buildPartial(name: ASTv1.PathExpression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, indent?: string, loc?: SourceLocation): ASTv1.PartialStatement;
    function buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement;
    function buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement;
    function buildConcat(parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[], loc?: SourceLocation): ASTv1.ConcatStatement;
    // Nodes
    type ElementParts = [
        "attrs",
        ...AttrSexp[]
    ] | [
        "modifiers",
        ...ModifierSexp[]
    ] | [
        "body",
        ...ASTv1.Statement[]
    ] | [
        "comments",
        ...ElementComment[]
    ] | [
        "as",
        ...string[]
    ] | [
        "loc",
        SourceLocation
    ];
    type PathSexp = string | [
        "path",
        string,
        LocSexp?
    ];
    type ModifierSexp = string | [
        PathSexp,
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        Dict<ASTv1.Expression>,
        LocSexp?
    ];
    type AttrSexp = [
        string,
        ASTv1.AttrNode["value"] | string,
        LocSexp?
    ];
    type LocSexp = [
        "loc",
        SourceLocation
    ];
    type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;
    type SexpValue = string | ASTv1.Expression[] | Dict<ASTv1.Expression> | LocSexp | PathSexp | undefined;
    interface BuildElementOptions {
        attrs?: ASTv1.AttrNode[];
        modifiers?: ASTv1.ElementModifierStatement[];
        children?: ASTv1.Statement[];
        comments?: ElementComment[];
        blockParams?: string[];
        loc?: SourceSpan;
    }
    function buildElement(tag: TagDescriptor, options?: BuildElementOptions): ASTv1.ElementNode;
    function buildAttr(name: string, value: ASTv1.AttrNode["value"], loc?: SourceLocation): ASTv1.AttrNode;
    function buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode;
    // Expressions
    function buildSexpr(path: BuilderHead, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: SourceLocation): ASTv1.SubExpression;
    function buildThis(loc: SourceLocation): ASTv1.PathHead;
    function buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildVar(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead;
    function buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName;
    function buildCleanPath(head: ASTv1.PathHead, tail: string[], loc: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.PathExpression | string | {
        head: string;
        tail: string[];
    }, loc?: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildLiteral<T extends ASTv1.Literal>(type: T["type"], value: T["value"], loc?: SourceLocation): T;
    // Miscellaneous
    function buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash;
    function buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair;
    function buildProgram(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildBlockItself(body?: ASTv1.Statement[], blockParams?: string[], chained?: boolean, loc?: SourceLocation): ASTv1.Block;
    function buildTemplate(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildPosition(line: number, column: number): SourcePosition;
    function buildLoc(loc: Nullable<SourceLocation>): SourceSpan;
    function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): SourceSpan;
    const _default: {
        mustache: typeof buildMustache;
        block: typeof buildBlock;
        partial: typeof buildPartial;
        comment: typeof buildComment;
        mustacheComment: typeof buildMustacheComment;
        element: typeof buildElement;
        elementModifier: typeof buildElementModifier;
        attr: typeof buildAttr;
        text: typeof buildText;
        sexpr: typeof buildSexpr;
        concat: typeof buildConcat;
        hash: typeof buildHash;
        pair: typeof buildPair;
        literal: typeof buildLiteral;
        program: typeof buildProgram;
        blockItself: typeof buildBlockItself;
        template: typeof buildTemplate;
        loc: typeof buildLoc;
        pos: typeof buildPosition;
        path: typeof buildPath;
        fullPath: typeof buildCleanPath;
        head: typeof buildHeadFromString;
        at: typeof buildAtName;
        var: typeof buildVar;
        this: typeof buildThis;
        blockName: typeof buildNamedBlockName;
        string: (value: string) => ASTv1.StringLiteral;
        boolean: (value: boolean) => ASTv1.BooleanLiteral;
        number: (value: number) => ASTv1.NumberLiteral;
        undefined(): ASTv1.UndefinedLiteral;
        null(): ASTv1.NullLiteral;
    };
    const publicBuilder: typeof _default;
    abstract class HandlebarsNodeVisitors extends Parser {
        abstract appendToCommentData(s: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract finishAttributeValue(): void;
        private get isTopLevel();
        Program(program: HBS.Program): ASTv1.Block;
        Program(program: HBS.Program): ASTv1.Template;
        Program(program: HBS.Program): ASTv1.Template | ASTv1.Block;
        BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void;
        MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void;
        appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void;
        finalizeTextPart(): void;
        startTextPart(): void;
        ContentStatement(content: HBS.ContentStatement): void;
        CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement>;
        PartialStatement(partial: HBS.PartialStatement): never;
        PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never;
        Decorator(decorator: HBS.Decorator): never;
        DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never;
        SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression;
        PathExpression(path: HBS.PathExpression): ASTv1.PathExpression;
        Hash(hash: HBS.Hash): ASTv1.Hash;
        StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral;
        BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral;
        NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral;
        UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral;
        NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral;
    }
    class TokenizerEventHandlers extends HandlebarsNodeVisitors {
        private tagOpenLine;
        private tagOpenColumn;
        reset(): void;
        // Comment
        beginComment(): void;
        appendToCommentData(char: string): void;
        finishComment(): void;
        // Data
        beginData(): void;
        appendToData(char: string): void;
        finishData(): void;
        // Tags - basic
        tagOpen(): void;
        beginStartTag(): void;
        beginEndTag(): void;
        finishTag(): void;
        finishStartTag(): void;
        finishEndTag(isVoid: boolean): void;
        markTagAsSelfClosing(): void;
        // Tags - name
        appendToTagName(char: string): void;
        // Tags - attributes
        beginAttribute(): void;
        appendToAttributeName(char: string): void;
        beginAttributeValue(isQuoted: boolean): void;
        appendToAttributeValue(char: string): void;
        finishAttributeValue(): void;
        reportSyntaxError(message: string): void;
        assembleConcatenatedValue(parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[]): ASTv1.ConcatStatement;
        validateEndTag(tag: Tag<"StartTag" | "EndTag">, element: ASTv1.ElementNode, selfClosing: boolean): void;
        assembleAttributeValue(parts: ASTv1.AttrPart[], isQuoted: boolean, isDynamic: boolean, span: src.SourceSpan): ASTv1.AttrValue;
    }
    /**
     ASTPlugins can make changes to the Glimmer template AST before
     compilation begins.
     */
    interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {
        (env: TEnv): ASTPlugin;
    }
    interface ASTPlugin {
        name: string;
        visitor: NodeVisitor;
    }
    interface ASTPluginEnvironment {
        meta?: object;
        syntax: Syntax;
    }
    interface HandlebarsParseOptions {
        srcName?: string;
        ignoreStandalone?: boolean;
    }
    interface TemplateIdFn {
        (src: string): Nullable<string>;
    }
    interface PrecompileOptions extends PreprocessOptions {
        id?: TemplateIdFn;
        customizeComponentName?: ((input: string) => string) | undefined;
    }
    interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {
        lexicalScope: (variable: string) => boolean;
    }
    interface PreprocessOptions {
        strictMode?: boolean;
        locals?: string[];
        meta?: {
            moduleName?: string;
        };
        plugins?: {
            ast?: ASTPluginBuilder[];
        };
        parseOptions?: HandlebarsParseOptions;
        customizeComponentName?: ((input: string) => string) | undefined;
        /**
         Useful for specifying a group of options together.
         
         When `'codemod'` we disable all whitespace control in handlebars
         (to preserve as much as possible) and we also avoid any
         escaping/unescaping of HTML entity codes.
         */
        mode?: "codemod" | "precompile";
    }
    interface Syntax {
        parse: typeof preprocess;
        builders: typeof publicBuilder;
        print: typeof print;
        traverse: typeof traverse;
        Walker: typeof Walker;
    }
    function preprocess(input: string | src.Source | HBS.Program, options?: PreprocessOptions): ASTv1.Template;
    class Source {
        readonly source: string;
        readonly module: string;
        static from(source: string, options?: PrecompileOptions): Source;
        constructor(source: string, module?: string);
        /**
         * Validate that the character offset represents a position in the source string.
         */
        check(offset: number): boolean;
        slice(start: number, end: number): string;
        offsetFor(line: number, column: number): SourceOffset;
        spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan;
        hbsPosFor(offset: number): Nullable<SourcePosition>;
        charPosFor(position: SourcePosition): number | null;
    }
    enum OffsetKind {
        /**
         * We have already computed the character position of this offset or span.
         */
        CharPosition = "CharPosition",
        /**
         * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its
         * character position will be computed on demand.
         */
        HbsPosition = "HbsPosition",
        /**
         * for (rare) situations where a node is created but there was no source location (e.g. the name
         * "default" in default blocks when the word "default" never appeared in source). This is used
         * by the internals when there is a legitimate reason for the internals to synthesize a node
         * with no location.
         */
        InternalsSynthetic = "InternalsSynthetic",
        /**
         * For situations where a node represents zero parts of the source (for example, empty arguments).
         * In general, we attempt to assign these nodes *some* position (empty arguments can be
         * positioned immediately after the callee), but it's not always possible
         */
        NonExistent = "NonExistent",
        /**
         * For situations where a source location was expected, but it didn't correspond to the node in
         * the source. This happens if a plugin creates broken locations.
         */
        Broken = "Broken"
    }
    /**
     * This file implements the DSL used by span and offset in places where they need to exhaustively
     * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
     * offsets).
     *
     * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
     * removed.
     */
    const MatchAny = "MATCH_ANY";
    type MatchAny = "MATCH_ANY";
    type Matches = "Char,Hbs" | "Hbs,Char" | "Hbs,Hbs" | "Char,Char" | "Invisible,Any" | "Any,Invisible";
    const IsInvisible = "IS_INVISIBLE";
    type IsInvisible = "IS_INVISIBLE";
    type Pattern = OffsetKind | IsInvisible | MatchAny;
    class When<Out> {
        _map: Map<Pattern, Out>;
        get(pattern: Pattern, or: () => Out): Out;
        add(pattern: Pattern, out: Out): void;
        match(kind: OffsetKind): Out[];
    }
    type ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> = Exclude<In, Removed> extends never ? ExhaustiveMatcher<Out> : Matcher<Out, Exclude<In, Removed>>;
    type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;
    interface ExhaustiveMatcher<Out> {
        check(): MatchFn<Out>;
    }
    function match<Out>(callback: (m: Matcher<Out>) => ExhaustiveMatcher<Out>): MatchFn<Out>;
    class Matcher<Out, M extends Matches = Matches> {
        _whens: When<When<(left: PositionData, right: PositionData) => Out>>;
        /**
         * You didn't exhaustively match all possibilities.
         */
        protected check(): MatchFn<Out>;
        private matchFor;
        // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness
        // checking so that matchers can ensure they've actually covered all the cases (and TypeScript
        // will treat it as an exhaustive match).
        when(left: OffsetKind.CharPosition, right: OffsetKind.HbsPosition, callback: (left: CharPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Char,Hbs">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.CharPosition, callback: (left: HbsPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Char">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.HbsPosition, callback: (left: HbsPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Hbs">;
        when(left: OffsetKind.CharPosition, right: OffsetKind.CharPosition, callback: (left: CharPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Char,Char">;
        when(left: IsInvisible, right: MatchAny, callback: (left: InvisiblePosition, right: PositionData) => Out): Matcher<Out, Exclude<M, "Invisible,Any">>;
        when(left: MatchAny, right: IsInvisible, callback: (left: PositionData, right: InvisiblePosition) => Out): ExhaustiveCheck<Out, M, "Any,Invisible">;
        when(left: MatchAny, right: MatchAny, callback: (left: PositionData, right: PositionData) => Out): ExhaustiveMatcher<Out>;
    }
    type SerializedSourceSlice<Chars extends string = string> = [
        chars: Chars,
        span: src.SerializedSourceSpan
    ];
    class SourceSlice<Chars extends string = string> {
        static synthetic<S extends string>(chars: S): SourceSlice<S>;
        static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice;
        readonly chars: Chars;
        readonly loc: src.SourceSpan;
        constructor(options: {
            loc: src.SourceSpan;
            chars: Chars;
        });
        getString(): string;
        serialize(): SerializedSourceSlice<Chars>;
    }
    /**
     * All spans have these details in common.
     */
    interface SpanData {
        readonly kind: OffsetKind;
        /**
         * Convert this span into a string. If the span is broken, return `''`.
         */
        asString(): string;
        /**
         * Gets the module the span was located in.
         */
        getModule(): string;
        /**
         * Get the starting position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getStart(): AnyPosition;
        /**
         * Get the ending position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getEnd(): AnyPosition;
        /**
         * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.
         */
        toHbsSpan(): HbsSpan | null;
        /**
         * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are
         * notified of the change so they can update themselves. This shouldn't happen outside of AST
         * plugins.
         */
        locDidUpdate(changes: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        /**
         * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in
         * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.
         */
        serialize(): SerializedSourceSpan;
    }
    /**
     * A `SourceSpan` object represents a span of characters inside of a template source.
     *
     * There are three kinds of `SourceSpan` objects:
     *
     * - `ConcreteSourceSpan`, which contains byte offsets
     * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
     *   converted to byte offsets on demand.
     * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
     *   because:
     *     - they were created synthetically
     *     - their location is nonsensical (the span is broken)
     *     - they represent nothing in the source (this currently happens only when a bug in the
     *       upstream Handlebars parser fails to assign a location to empty blocks)
     *
     * At a high level, all `SourceSpan` objects provide:
     *
     * - byte offsets
     * - source in column and line format
     *
     * And you can do these operations on `SourceSpan`s:
     *
     * - collapse it to a `SourceSpan` representing its starting or ending position
     * - slice out some characters, optionally skipping some characters at the beginning or end
     * - create a new `SourceSpan` with a different starting or ending offset
     *
     * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
     * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
     *
     * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
     * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
     *
     * The goal is to avoid creating any problems for use-cases like AST Explorer.
     */
    class SourceSpan implements SourceLocation {
        private data;
        static get NON_EXISTENT(): SourceSpan;
        static load(source: Source, serialized: SerializedSourceSpan): SourceSpan;
        static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan;
        static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan;
        static synthetic(chars: string): SourceSpan;
        static broken(pos?: SourceLocation): SourceSpan;
        readonly isInvisible: boolean;
        constructor(data: SpanData & AnySpan);
        getStart(): SourceOffset;
        getEnd(): SourceOffset;
        get loc(): SourceLocation;
        get module(): string;
        /**
         * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get startPosition(): SourcePosition;
        /**
         * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get endPosition(): SourcePosition;
        /**
         * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
         */
        toJSON(): SourceLocation;
        /**
         * Create a new span with the current span's end and a new beginning.
         */
        withStart(other: SourceOffset): SourceSpan;
        /**
         * Create a new span with the current span's beginning and a new ending.
         */
        withEnd(this: SourceSpan, other: SourceOffset): SourceSpan;
        asString(): string;
        /**
         * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
         * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
         * string.
         */
        toSlice(expected?: string): SourceSlice;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use startPosition instead
         */
        get start(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withStart instead
         */
        set start(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use endPosition instead
         */
        get end(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withEnd instead
         */
        set end(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use module instead
         */
        get source(): string;
        collapse(where: "start" | "end"): SourceSpan;
        extend(other: SourceSpan): SourceSpan;
        serialize(): SerializedSourceSpan;
        slice({ skipStart, skipEnd }: {
            skipStart?: number;
            skipEnd?: number;
        }): SourceSpan;
        sliceStartChars({ skipStart, chars }: {
            skipStart?: number;
            chars: number;
        }): SourceSpan;
        sliceEndChars({ skipEnd, chars }: {
            skipEnd?: number;
            chars: number;
        }): SourceSpan;
    }
    type AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;
    class CharPositionSpan implements SpanData {
        readonly source: Source;
        readonly charPositions: {
            start: CharPosition;
            end: CharPosition;
        };
        readonly kind = OffsetKind.CharPosition;
        _locPosSpan: HbsSpan | BROKEN | null;
        constructor(source: Source, charPositions: {
            start: CharPosition;
            end: CharPosition;
        });
        wrap(): SourceSpan;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        locDidUpdate(): void;
        toHbsSpan(): HbsSpan | null;
        serialize(): SerializedSourceSpan;
        toCharPosSpan(): CharPositionSpan;
    }
    class HbsSpan implements SpanData {
        readonly source: Source;
        readonly hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        };
        readonly kind = OffsetKind.HbsPosition;
        _charPosSpan: CharPositionSpan | BROKEN | null;
        // the source location from Handlebars + AST Plugins -- could be wrong
        _providedHbsLoc: SourceLocation | null;
        constructor(source: Source, hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        }, providedHbsLoc?: SourceLocation | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        private updateProvided;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toHbsLoc(): SourceLocation;
        toHbsSpan(): HbsSpan;
        toCharPosSpan(): CharPositionSpan | null;
    }
    class InvisibleSpan implements SpanData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly loc: SourceLocation;
        // if the span represents a synthetic string
        readonly string: string | null;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, loc: SourceLocation, string?: string | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        asString(): string;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toCharPosSpan(): InvisibleSpan;
        toHbsSpan(): null;
        toHbsLoc(): SourceLocation;
    }
    const span: MatchFn<SourceSpan>;
    type SerializedConcreteSourceSpan = /** collapsed */ number | /** normal */ [
        start: number,
        size: number
    ] | /** synthetic */ string;
    type SerializedSourceSpan = SerializedConcreteSourceSpan | OffsetKind.NonExistent | OffsetKind.Broken;
    interface SourceLocation {
        start: SourcePosition;
        end: SourcePosition;
    }
    interface SourcePosition {
        /** >= 1 */
        line: number;
        /** >= 0 */
        column: number;
    }
    const UNKNOWN_POSITION: Readonly<{
        readonly line: 1;
        readonly column: 0;
    }>;
    const SYNTHETIC_LOCATION: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    /** @deprecated */
    const SYNTHETIC: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const TEMPORARY_LOCATION: Readonly<{
        readonly source: "(temporary)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const NON_EXISTENT_LOCATION: Readonly<{
        readonly source: "(nonexistent)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const BROKEN_LOCATION: Readonly<{
        readonly source: "(broken)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    type LocatedWithSpan = {
        offsets: SourceSpan;
    };
    type LocatedWithOptionalSpan = {
        offsets: SourceSpan | null;
    };
    type LocatedWithPositions = {
        loc: SourceLocation;
    };
    type LocatedWithOptionalPositions = {
        loc?: SourceLocation;
    };
    function isLocatedWithPositionsArray(location: LocatedWithOptionalPositions[]): location is PresentArray<LocatedWithPositions>;
    function isLocatedWithPositions(location: LocatedWithOptionalPositions): location is LocatedWithPositions;
    type HasSourceLocation = SourceLocation | LocatedWithPositions | PresentArray<LocatedWithPositions>;
    type MaybeHasSourceLocation = null | LocatedWithOptionalPositions | LocatedWithOptionalPositions[];
    /**
     * All positions have these details in common. Most notably, all three kinds of positions can
     * must be able to attempt to convert themselves into {@see CharPosition}.
     */
    interface PositionData {
        readonly kind: OffsetKind;
        toCharPos(): CharPosition | null;
        toJSON(): SourcePosition;
    }
    /**
     * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
     * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
     * attempted (and therefore to cache the failure)
     */
    const BROKEN = "BROKEN";
    type BROKEN = "BROKEN";
    type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;
    /**
     * A `SourceOffset` represents a single position in the source.
     *
     * There are three kinds of backing data for `SourceOffset` objects:
     *
     * - `CharPosition`, which contains a character offset into the raw source string
     * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
     *   converted to a `CharPosition` on demand.
     * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
     */
    class SourceOffset {
        readonly data: PositionData & AnyPosition;
        /**
         * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
         * into a character offset on demand, which avoids unnecessarily computing the offset of every
         * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
         */
        static forHbsPos(source: Source, pos: SourcePosition): SourceOffset;
        /**
         * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
         * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
         * any part of the source.
         */
        static broken(pos?: SourcePosition): SourceOffset;
        constructor(data: PositionData & AnyPosition);
        /**
         * Get the character offset for this `SourceOffset`, if possible.
         */
        get offset(): number | null;
        /**
         * Compare this offset with another one.
         *
         * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
         * the same. This avoids computing offsets unnecessarily.
         *
         * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
         * are the same.
         */
        eql(right: SourceOffset): boolean;
        /**
         * Create a span that starts from this source offset and ends with another source offset. Avoid
         * computing character offsets if both `SourceOffset`s are still lazy.
         */
        until(other: SourceOffset): SourceSpan;
        /**
         * Create a `SourceOffset` by moving the character position represented by this source offset
         * forward or backward (if `by` is negative), if possible.
         *
         * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
         *
         * If the resulting character offset is less than 0 or greater than the size of the source, `move`
         * returns a broken offset.
         */
        move(by: number): SourceOffset;
        /**
         * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
         * computing the character offset if it has not already been computed.
         */
        collapsed(): SourceSpan;
        /**
         * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
         * existing plugins.
         */
        toJSON(): SourcePosition;
    }
    class CharPosition implements PositionData {
        readonly source: Source;
        readonly charPos: number;
        readonly kind = OffsetKind.CharPosition;
        /** Computed from char offset */
        _locPos: HbsPosition | BROKEN | null;
        constructor(source: Source, charPos: number);
        /**
         * This is already a `CharPosition`.
         *
         * {@see HbsPosition} for the alternative.
         */
        toCharPos(): CharPosition;
        /**
         * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
         * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * A `CharPosition` always has an offset it can produce without any additional computation.
         */
        get offset(): number;
        /**
         * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
         * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
         * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
         * computing the `HbsPosition` should be a one-time operation.
         */
        toHbsPos(): HbsPosition | null;
    }
    class HbsPosition implements PositionData {
        readonly source: Source;
        readonly hbsPos: SourcePosition;
        readonly kind = OffsetKind.HbsPosition;
        _charPos: CharPosition | BROKEN | null;
        constructor(source: Source, hbsPos: SourcePosition, charPos?: number | null);
        /**
         * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
         * computed its `CharPosition`, it will not need to do compute it again, and the same
         * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
         * `CharPosition` should be a one-time operation.
         */
        toCharPos(): CharPosition | null;
        /**
         * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
         * does not need to compute anything.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * This is already an `HbsPosition`.
         *
         * {@see CharPosition} for the alternative.
         */
        toHbsPos(): HbsPosition;
    }
    class InvisiblePosition implements PositionData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly pos: SourcePosition;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, pos: SourcePosition);
        /**
         * A broken position cannot be turned into a {@see CharacterPosition}.
         */
        toCharPos(): null;
        /**
         * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
         * originally identified as broken, non-existent or synthetic.
         *
         * If an `InvisiblePosition` never had an source offset at all, this method returns
         * {@see UNKNOWN_POSITION} for compatibility.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        get offset(): null;
    }
    type HasSpan = SourceSpan | LocatedWithSpan | PresentArray<LocatedWithSpan>;
    type MaybeHasSpan = SourceSpan | LocatedWithOptionalSpan | LocatedWithOptionalSpan[] | null;
    type ToSourceOffset = number | SourceOffset;
    class SpanList {
        static range(span: PresentArray<HasSourceSpan>): SourceSpan;
        static range(span: HasSourceSpan[], fallback: SourceSpan): SourceSpan;
        _span: SourceSpan[];
        constructor(span?: SourceSpan[]);
        add(offset: SourceSpan): void;
        getRangeOffset(fallback: SourceSpan): SourceSpan;
    }
    type HasSourceSpan = {
        loc: SourceSpan;
    } | SourceSpan | [
        HasSourceSpan,
        ...HasSourceSpan[]
    ];
    function loc(span: HasSourceSpan): SourceSpan;
    type MaybeHasSourceSpan = {
        loc: SourceSpan;
    } | SourceSpan | MaybeHasSourceSpan[];
    function hasSpan(span: MaybeHasSourceSpan): span is HasSourceSpan;
    function maybeLoc(location: MaybeHasSourceSpan, fallback: SourceSpan): SourceSpan;
}
declare namespace ASTv1 {
    type ParserNodeBuilder<N extends {
        loc: src.SourceSpan;
    }> = Omit<N, "loc"> & {
        loc: src.SourceOffset;
    };
    interface Tag<T extends "StartTag" | "EndTag"> {
        readonly type: T;
        name: string;
        readonly attributes: ASTv1.AttrNode[];
        readonly modifiers: ASTv1.ElementModifierStatement[];
        readonly comments: ASTv1.MustacheCommentStatement[];
        selfClosing: boolean;
        readonly loc: src.SourceSpan;
    }
    interface Attribute {
        name: string;
        currentPart: ASTv1.TextNode | null;
        parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];
        isQuoted: boolean;
        isDynamic: boolean;
        start: src.SourceOffset;
        valueSpan: src.SourceSpan;
    }
    abstract class Parser {
        protected elementStack: ASTv1.ParentNode[];
        private lines;
        readonly source: src.Source;
        currentAttribute: Nullable<Attribute>;
        currentNode: Nullable<Readonly<ParserNodeBuilder<ASTv1.CommentStatement> | ASTv1.TextNode | ParserNodeBuilder<Tag<"StartTag">> | ParserNodeBuilder<Tag<"EndTag">>>>;
        tokenizer: EventedTokenizer;
        constructor(source: src.Source, entityParser?: EntityParser, mode?: "precompile" | "codemod");
        offset(): src.SourceOffset;
        pos({ line, column }: src.SourcePosition): src.SourceOffset;
        finish<T extends {
            loc: src.SourceSpan;
        }>(node: ParserNodeBuilder<T>): T;
        abstract Program(node: HBS.Program): HBS.Output<"Program">;
        abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<"MustacheStatement">;
        abstract Decorator(node: HBS.Decorator): HBS.Output<"Decorator">;
        abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<"BlockStatement">;
        abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<"DecoratorBlock">;
        abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<"PartialStatement">;
        abstract PartialBlockStatement(node: HBS.PartialBlockStatement): HBS.Output<"PartialBlockStatement">;
        abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<"ContentStatement">;
        abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<"CommentStatement">;
        abstract SubExpression(node: HBS.SubExpression): HBS.Output<"SubExpression">;
        abstract PathExpression(node: HBS.PathExpression): HBS.Output<"PathExpression">;
        abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<"StringLiteral">;
        abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<"BooleanLiteral">;
        abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<"NumberLiteral">;
        abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<"UndefinedLiteral">;
        abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<"NullLiteral">;
        abstract reset(): void;
        abstract finishData(): void;
        abstract tagOpen(): void;
        abstract beginData(): void;
        abstract appendToData(char: string): void;
        abstract beginStartTag(): void;
        abstract appendToTagName(char: string): void;
        abstract beginAttribute(): void;
        abstract appendToAttributeName(char: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract appendToAttributeValue(char: string): void;
        abstract finishAttributeValue(): void;
        abstract markTagAsSelfClosing(): void;
        abstract beginEndTag(): void;
        abstract finishTag(): void;
        abstract beginComment(): void;
        abstract appendToCommentData(char: string): void;
        abstract finishComment(): void;
        abstract reportSyntaxError(error: string): void;
        get currentAttr(): Attribute;
        get currentTag(): ParserNodeBuilder<Tag<"StartTag" | "EndTag">>;
        get currentStartTag(): ParserNodeBuilder<Tag<"StartTag">>;
        get currentEndTag(): ParserNodeBuilder<Tag<"EndTag">>;
        get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement>;
        get currentData(): ASTv1.TextNode;
        acceptTemplate(node: HBS.Program): ASTv1.Template;
        acceptNode(node: HBS.Program): ASTv1.Block | ASTv1.Template;
        acceptNode<U extends HBS.Node | ASTv1.Node>(node: HBS.Node): U;
        currentElement(): ASTv1.ParentNode;
        sourceForNode(node: HBS.Node, endNode?: {
            loc: HBS.SourceLocation;
        }): string;
    }
    // ensure stays in sync with typing
    // ParentNode and ChildKey types are derived from VisitorKeysMap
    const visitorKeys: {
        readonly Program: readonly [
            "body"
        ];
        readonly Template: readonly [
            "body"
        ];
        readonly Block: readonly [
            "body"
        ];
        readonly MustacheStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly BlockStatement: readonly [
            "path",
            "params",
            "hash",
            "program",
            "inverse"
        ];
        readonly ElementModifierStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PartialStatement: readonly [
            "name",
            "params",
            "hash"
        ];
        readonly CommentStatement: readonly [
        ];
        readonly MustacheCommentStatement: readonly [
        ];
        readonly ElementNode: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly AttrNode: readonly [
            "value"
        ];
        readonly TextNode: readonly [
        ];
        readonly ConcatStatement: readonly [
            "parts"
        ];
        readonly SubExpression: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PathExpression: readonly [
        ];
        readonly PathHead: readonly [
        ];
        readonly StringLiteral: readonly [
        ];
        readonly BooleanLiteral: readonly [
        ];
        readonly NumberLiteral: readonly [
        ];
        readonly NullLiteral: readonly [
        ];
        readonly UndefinedLiteral: readonly [
        ];
        readonly Hash: readonly [
            "pairs"
        ];
        readonly HashPair: readonly [
            "value"
        ];
        readonly NamedBlock: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly SimpleElement: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly Component: readonly [
            "head",
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
    };
    type VisitorKeysMap = typeof visitorKeys;
    type VisitorKeys = {
        [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number];
    };
    type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N["type"]] & keyof N;
    class WalkerPath<N extends ASTv1.Node> {
        node: N;
        parent: WalkerPath<ASTv1.Node> | null;
        parentKey: string | null;
        constructor(node: N, parent?: WalkerPath<ASTv1.Node> | null, parentKey?: string | null);
        get parentNode(): ASTv1.Node | null;
        parents(): Iterable<WalkerPath<ASTv1.Node> | null>;
    }
    interface FullNodeTraversal<N extends ASTv1.Node> {
        enter?(node: N, path: WalkerPath<N>): void;
        exit?(node: N, path: WalkerPath<N>): void;
        keys?: KeysVisitor<N>;
    }
    type NodeHandler<N extends ASTv1.Node> = (node: N, path: WalkerPath<N>) => void;
    type NodeTraversal<N extends ASTv1.Node> = FullNodeTraversal<N> | NodeHandler<N>;
    type NodeVisitor = {
        [P in keyof ASTv1.Nodes]?: NodeTraversal<ASTv1.Nodes[P]>;
    } & {
        All?: NodeTraversal<ASTv1.Node>;
    };
    interface FullKeyTraversal<N extends ASTv1.Node, K extends string> {
        enter?(node: N, key: K): void;
        exit?(node: N, key: K): void;
    }
    type KeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>> = (node: N, key: K) => void;
    type KeyTraversal<N extends ASTv1.Node, K extends VisitorKey<N>> = FullKeyTraversal<N, K> | KeyHandler<N, K>;
    type KeysVisitor<N extends ASTv1.Node> = {
        [P in VisitorKey<N>]?: KeyTraversal<N, P>;
    } & {
        All?: KeyTraversal<N, VisitorKey<N>>;
    };
    const voidMap: Set<string>;
    function getVoidTags(): string[];
    interface PrinterOptions {
        entityEncoding: "transformed" | "raw";
        /**
         * Used to override the mechanism of printing a given AST.Node.
         *
         * This will generally only be useful to source -> source codemods
         * where you would like to specialize/override the way a given node is
         * printed (e.g. you would like to preserve as much of the original
         * formatting as possible).
         *
         * When the provided override returns undefined, the default built in printing
         * will be done for the AST.Node.
         *
         * @param ast the ast node to be printed
         * @param options the options specified during the print() invocation
         */
        override?(ast: ASTv1.Node, options: PrinterOptions): void | string;
    }
    /**
     * Examples when true:
     *  - link
     *  - liNK
     *
     * Examples when false:
     *  - Link (component)
     */
    function isVoidTag(tag: string): boolean;
    class Printer {
        private buffer;
        private options;
        constructor(options: PrinterOptions);
        /*
        This is used by _all_ methods on this Printer class that add to `this.buffer`,
        it allows consumers of the printer to use alternate string representations for
        a given node.
        
        The primary use case for this are things like source -> source codemod utilities.
        For example, ember-template-recast attempts to always preserve the original string
        formatting in each AST node if no modifications are made to it.
        */
        handledByOverride(node: ASTv1.Node, ensureLeadingWhitespace?: boolean): boolean;
        Node(node: ASTv1.Node): void;
        Expression(expression: ASTv1.Expression): void;
        Literal(literal: ASTv1.Literal): void;
        TopLevelStatement(statement: ASTv1.TopLevelStatement | ASTv1.Template | ASTv1.AttrNode): void;
        Block(block: ASTv1.Block | ASTv1.Program | ASTv1.Template): void;
        TopLevelStatements(statements: ASTv1.TopLevelStatement[]): void;
        ElementNode(el: ASTv1.ElementNode): void;
        OpenElementNode(el: ASTv1.ElementNode): void;
        CloseElementNode(el: ASTv1.ElementNode): void;
        AttrNode(attr: ASTv1.AttrNode): void;
        AttrNodeValue(value: ASTv1.AttrNode["value"]): void;
        TextNode(text: ASTv1.TextNode, isAttr?: boolean): void;
        MustacheStatement(mustache: ASTv1.MustacheStatement): void;
        BlockStatement(block: ASTv1.BlockStatement): void;
        BlockParams(blockParams: string[]): void;
        PartialStatement(partial: ASTv1.PartialStatement): void;
        ConcatStatement(concat: ASTv1.ConcatStatement): void;
        MustacheCommentStatement(comment: ASTv1.MustacheCommentStatement): void;
        ElementModifierStatement(mod: ASTv1.ElementModifierStatement): void;
        CommentStatement(comment: ASTv1.CommentStatement): void;
        PathExpression(path: ASTv1.PathExpression): void;
        SubExpression(sexp: ASTv1.SubExpression): void;
        Params(params: ASTv1.Expression[]): void;
        Hash(hash: ASTv1.Hash): void;
        HashPair(pair: ASTv1.HashPair): void;
        StringLiteral(str: ASTv1.StringLiteral): void;
        BooleanLiteral(bool: ASTv1.BooleanLiteral): void;
        NumberLiteral(number: ASTv1.NumberLiteral): void;
        UndefinedLiteral(node: ASTv1.UndefinedLiteral): void;
        NullLiteral(node: ASTv1.NullLiteral): void;
        print(node: ASTv1.Node): string;
    }
    function build(ast: ASTv1.Node, options?: PrinterOptions): string;
    const print: typeof build;
    function traverse(node: ASTv1.Node, visitor: NodeVisitor): void;
    type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;
    class Walker {
        order?: unknown;
        stack: unknown[];
        constructor(order?: unknown);
        visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void;
        children<N extends ASTv1.Node>(node: N & ASTv1.Node, callback: NodeCallback<N & ASTv1.Node>): void;
    }
    // const SOURCE = new Source('', '(tests)');
    // Statements
    type BuilderHead = string | ASTv1.Expression;
    type TagDescriptor = string | {
        name: string;
        selfClosing: boolean;
    };
    function buildMustache(path: BuilderHead | ASTv1.Literal, params?: ASTv1.Expression[], hash?: ASTv1.Hash, raw?: boolean, loc?: SourceLocation, strip?: ASTv1.StripFlags): ASTv1.MustacheStatement;
    function buildBlock(path: BuilderHead, params: Nullable<ASTv1.Expression[]>, hash: Nullable<ASTv1.Hash>, _defaultBlock: ASTv1.PossiblyDeprecatedBlock, _elseBlock?: Nullable<ASTv1.PossiblyDeprecatedBlock>, loc?: SourceLocation, openStrip?: ASTv1.StripFlags, inverseStrip?: ASTv1.StripFlags, closeStrip?: ASTv1.StripFlags): ASTv1.BlockStatement;
    function buildElementModifier(path: BuilderHead | ASTv1.Expression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: Nullable<SourceLocation>): ASTv1.ElementModifierStatement;
    function buildPartial(name: ASTv1.PathExpression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, indent?: string, loc?: SourceLocation): ASTv1.PartialStatement;
    function buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement;
    function buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement;
    function buildConcat(parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[], loc?: SourceLocation): ASTv1.ConcatStatement;
    // Nodes
    type ElementParts = [
        "attrs",
        ...AttrSexp[]
    ] | [
        "modifiers",
        ...ModifierSexp[]
    ] | [
        "body",
        ...ASTv1.Statement[]
    ] | [
        "comments",
        ...ElementComment[]
    ] | [
        "as",
        ...string[]
    ] | [
        "loc",
        SourceLocation
    ];
    type PathSexp = string | [
        "path",
        string,
        LocSexp?
    ];
    type ModifierSexp = string | [
        PathSexp,
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        Dict<ASTv1.Expression>,
        LocSexp?
    ];
    type AttrSexp = [
        string,
        ASTv1.AttrNode["value"] | string,
        LocSexp?
    ];
    type LocSexp = [
        "loc",
        SourceLocation
    ];
    type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;
    type SexpValue = string | ASTv1.Expression[] | Dict<ASTv1.Expression> | LocSexp | PathSexp | undefined;
    interface BuildElementOptions {
        attrs?: ASTv1.AttrNode[];
        modifiers?: ASTv1.ElementModifierStatement[];
        children?: ASTv1.Statement[];
        comments?: ElementComment[];
        blockParams?: string[];
        loc?: SourceSpan;
    }
    function buildElement(tag: TagDescriptor, options?: BuildElementOptions): ASTv1.ElementNode;
    function buildAttr(name: string, value: ASTv1.AttrNode["value"], loc?: SourceLocation): ASTv1.AttrNode;
    function buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode;
    // Expressions
    function buildSexpr(path: BuilderHead, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: SourceLocation): ASTv1.SubExpression;
    function buildThis(loc: SourceLocation): ASTv1.PathHead;
    function buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildVar(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead;
    function buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName;
    function buildCleanPath(head: ASTv1.PathHead, tail: string[], loc: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.PathExpression | string | {
        head: string;
        tail: string[];
    }, loc?: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildLiteral<T extends ASTv1.Literal>(type: T["type"], value: T["value"], loc?: SourceLocation): T;
    // Miscellaneous
    function buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash;
    function buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair;
    function buildProgram(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildBlockItself(body?: ASTv1.Statement[], blockParams?: string[], chained?: boolean, loc?: SourceLocation): ASTv1.Block;
    function buildTemplate(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildPosition(line: number, column: number): SourcePosition;
    function buildLoc(loc: Nullable<SourceLocation>): SourceSpan;
    function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): SourceSpan;
    const _default: {
        mustache: typeof buildMustache;
        block: typeof buildBlock;
        partial: typeof buildPartial;
        comment: typeof buildComment;
        mustacheComment: typeof buildMustacheComment;
        element: typeof buildElement;
        elementModifier: typeof buildElementModifier;
        attr: typeof buildAttr;
        text: typeof buildText;
        sexpr: typeof buildSexpr;
        concat: typeof buildConcat;
        hash: typeof buildHash;
        pair: typeof buildPair;
        literal: typeof buildLiteral;
        program: typeof buildProgram;
        blockItself: typeof buildBlockItself;
        template: typeof buildTemplate;
        loc: typeof buildLoc;
        pos: typeof buildPosition;
        path: typeof buildPath;
        fullPath: typeof buildCleanPath;
        head: typeof buildHeadFromString;
        at: typeof buildAtName;
        var: typeof buildVar;
        this: typeof buildThis;
        blockName: typeof buildNamedBlockName;
        string: (value: string) => ASTv1.StringLiteral;
        boolean: (value: boolean) => ASTv1.BooleanLiteral;
        number: (value: number) => ASTv1.NumberLiteral;
        undefined(): ASTv1.UndefinedLiteral;
        null(): ASTv1.NullLiteral;
    };
    const publicBuilder: typeof _default;
    abstract class HandlebarsNodeVisitors extends Parser {
        abstract appendToCommentData(s: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract finishAttributeValue(): void;
        private get isTopLevel();
        Program(program: HBS.Program): ASTv1.Block;
        Program(program: HBS.Program): ASTv1.Template;
        Program(program: HBS.Program): ASTv1.Template | ASTv1.Block;
        BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void;
        MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void;
        appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void;
        finalizeTextPart(): void;
        startTextPart(): void;
        ContentStatement(content: HBS.ContentStatement): void;
        CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement>;
        PartialStatement(partial: HBS.PartialStatement): never;
        PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never;
        Decorator(decorator: HBS.Decorator): never;
        DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never;
        SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression;
        PathExpression(path: HBS.PathExpression): ASTv1.PathExpression;
        Hash(hash: HBS.Hash): ASTv1.Hash;
        StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral;
        BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral;
        NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral;
        UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral;
        NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral;
    }
    class TokenizerEventHandlers extends HandlebarsNodeVisitors {
        private tagOpenLine;
        private tagOpenColumn;
        reset(): void;
        // Comment
        beginComment(): void;
        appendToCommentData(char: string): void;
        finishComment(): void;
        // Data
        beginData(): void;
        appendToData(char: string): void;
        finishData(): void;
        // Tags - basic
        tagOpen(): void;
        beginStartTag(): void;
        beginEndTag(): void;
        finishTag(): void;
        finishStartTag(): void;
        finishEndTag(isVoid: boolean): void;
        markTagAsSelfClosing(): void;
        // Tags - name
        appendToTagName(char: string): void;
        // Tags - attributes
        beginAttribute(): void;
        appendToAttributeName(char: string): void;
        beginAttributeValue(isQuoted: boolean): void;
        appendToAttributeValue(char: string): void;
        finishAttributeValue(): void;
        reportSyntaxError(message: string): void;
        assembleConcatenatedValue(parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[]): ASTv1.ConcatStatement;
        validateEndTag(tag: Tag<"StartTag" | "EndTag">, element: ASTv1.ElementNode, selfClosing: boolean): void;
        assembleAttributeValue(parts: ASTv1.AttrPart[], isQuoted: boolean, isDynamic: boolean, span: src.SourceSpan): ASTv1.AttrValue;
    }
    /**
     ASTPlugins can make changes to the Glimmer template AST before
     compilation begins.
     */
    interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {
        (env: TEnv): ASTPlugin;
    }
    interface ASTPlugin {
        name: string;
        visitor: NodeVisitor;
    }
    interface ASTPluginEnvironment {
        meta?: object;
        syntax: Syntax;
    }
    interface HandlebarsParseOptions {
        srcName?: string;
        ignoreStandalone?: boolean;
    }
    interface TemplateIdFn {
        (src: string): Nullable<string>;
    }
    interface PrecompileOptions extends PreprocessOptions {
        id?: TemplateIdFn;
        customizeComponentName?: ((input: string) => string) | undefined;
    }
    interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {
        lexicalScope: (variable: string) => boolean;
    }
    interface PreprocessOptions {
        strictMode?: boolean;
        locals?: string[];
        meta?: {
            moduleName?: string;
        };
        plugins?: {
            ast?: ASTPluginBuilder[];
        };
        parseOptions?: HandlebarsParseOptions;
        customizeComponentName?: ((input: string) => string) | undefined;
        /**
         Useful for specifying a group of options together.
         
         When `'codemod'` we disable all whitespace control in handlebars
         (to preserve as much as possible) and we also avoid any
         escaping/unescaping of HTML entity codes.
         */
        mode?: "codemod" | "precompile";
    }
    interface Syntax {
        parse: typeof preprocess;
        builders: typeof publicBuilder;
        print: typeof print;
        traverse: typeof traverse;
        Walker: typeof Walker;
    }
    function preprocess(input: string | src.Source | HBS.Program, options?: PreprocessOptions): ASTv1.Template;
    class Source {
        readonly source: string;
        readonly module: string;
        static from(source: string, options?: PrecompileOptions): Source;
        constructor(source: string, module?: string);
        /**
         * Validate that the character offset represents a position in the source string.
         */
        check(offset: number): boolean;
        slice(start: number, end: number): string;
        offsetFor(line: number, column: number): SourceOffset;
        spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan;
        hbsPosFor(offset: number): Nullable<SourcePosition>;
        charPosFor(position: SourcePosition): number | null;
    }
    enum OffsetKind {
        /**
         * We have already computed the character position of this offset or span.
         */
        CharPosition = "CharPosition",
        /**
         * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its
         * character position will be computed on demand.
         */
        HbsPosition = "HbsPosition",
        /**
         * for (rare) situations where a node is created but there was no source location (e.g. the name
         * "default" in default blocks when the word "default" never appeared in source). This is used
         * by the internals when there is a legitimate reason for the internals to synthesize a node
         * with no location.
         */
        InternalsSynthetic = "InternalsSynthetic",
        /**
         * For situations where a node represents zero parts of the source (for example, empty arguments).
         * In general, we attempt to assign these nodes *some* position (empty arguments can be
         * positioned immediately after the callee), but it's not always possible
         */
        NonExistent = "NonExistent",
        /**
         * For situations where a source location was expected, but it didn't correspond to the node in
         * the source. This happens if a plugin creates broken locations.
         */
        Broken = "Broken"
    }
    /**
     * This file implements the DSL used by span and offset in places where they need to exhaustively
     * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
     * offsets).
     *
     * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
     * removed.
     */
    const MatchAny = "MATCH_ANY";
    type MatchAny = "MATCH_ANY";
    type Matches = "Char,Hbs" | "Hbs,Char" | "Hbs,Hbs" | "Char,Char" | "Invisible,Any" | "Any,Invisible";
    const IsInvisible = "IS_INVISIBLE";
    type IsInvisible = "IS_INVISIBLE";
    type Pattern = OffsetKind | IsInvisible | MatchAny;
    class When<Out> {
        _map: Map<Pattern, Out>;
        get(pattern: Pattern, or: () => Out): Out;
        add(pattern: Pattern, out: Out): void;
        match(kind: OffsetKind): Out[];
    }
    type ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> = Exclude<In, Removed> extends never ? ExhaustiveMatcher<Out> : Matcher<Out, Exclude<In, Removed>>;
    type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;
    interface ExhaustiveMatcher<Out> {
        check(): MatchFn<Out>;
    }
    function match<Out>(callback: (m: Matcher<Out>) => ExhaustiveMatcher<Out>): MatchFn<Out>;
    class Matcher<Out, M extends Matches = Matches> {
        _whens: When<When<(left: PositionData, right: PositionData) => Out>>;
        /**
         * You didn't exhaustively match all possibilities.
         */
        protected check(): MatchFn<Out>;
        private matchFor;
        // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness
        // checking so that matchers can ensure they've actually covered all the cases (and TypeScript
        // will treat it as an exhaustive match).
        when(left: OffsetKind.CharPosition, right: OffsetKind.HbsPosition, callback: (left: CharPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Char,Hbs">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.CharPosition, callback: (left: HbsPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Char">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.HbsPosition, callback: (left: HbsPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Hbs">;
        when(left: OffsetKind.CharPosition, right: OffsetKind.CharPosition, callback: (left: CharPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Char,Char">;
        when(left: IsInvisible, right: MatchAny, callback: (left: InvisiblePosition, right: PositionData) => Out): Matcher<Out, Exclude<M, "Invisible,Any">>;
        when(left: MatchAny, right: IsInvisible, callback: (left: PositionData, right: InvisiblePosition) => Out): ExhaustiveCheck<Out, M, "Any,Invisible">;
        when(left: MatchAny, right: MatchAny, callback: (left: PositionData, right: PositionData) => Out): ExhaustiveMatcher<Out>;
    }
    type SerializedSourceSlice<Chars extends string = string> = [
        chars: Chars,
        span: src.SerializedSourceSpan
    ];
    class SourceSlice<Chars extends string = string> {
        static synthetic<S extends string>(chars: S): SourceSlice<S>;
        static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice;
        readonly chars: Chars;
        readonly loc: src.SourceSpan;
        constructor(options: {
            loc: src.SourceSpan;
            chars: Chars;
        });
        getString(): string;
        serialize(): SerializedSourceSlice<Chars>;
    }
    /**
     * All spans have these details in common.
     */
    interface SpanData {
        readonly kind: OffsetKind;
        /**
         * Convert this span into a string. If the span is broken, return `''`.
         */
        asString(): string;
        /**
         * Gets the module the span was located in.
         */
        getModule(): string;
        /**
         * Get the starting position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getStart(): AnyPosition;
        /**
         * Get the ending position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getEnd(): AnyPosition;
        /**
         * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.
         */
        toHbsSpan(): HbsSpan | null;
        /**
         * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are
         * notified of the change so they can update themselves. This shouldn't happen outside of AST
         * plugins.
         */
        locDidUpdate(changes: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        /**
         * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in
         * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.
         */
        serialize(): SerializedSourceSpan;
    }
    /**
     * A `SourceSpan` object represents a span of characters inside of a template source.
     *
     * There are three kinds of `SourceSpan` objects:
     *
     * - `ConcreteSourceSpan`, which contains byte offsets
     * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
     *   converted to byte offsets on demand.
     * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
     *   because:
     *     - they were created synthetically
     *     - their location is nonsensical (the span is broken)
     *     - they represent nothing in the source (this currently happens only when a bug in the
     *       upstream Handlebars parser fails to assign a location to empty blocks)
     *
     * At a high level, all `SourceSpan` objects provide:
     *
     * - byte offsets
     * - source in column and line format
     *
     * And you can do these operations on `SourceSpan`s:
     *
     * - collapse it to a `SourceSpan` representing its starting or ending position
     * - slice out some characters, optionally skipping some characters at the beginning or end
     * - create a new `SourceSpan` with a different starting or ending offset
     *
     * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
     * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
     *
     * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
     * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
     *
     * The goal is to avoid creating any problems for use-cases like AST Explorer.
     */
    class SourceSpan implements SourceLocation {
        private data;
        static get NON_EXISTENT(): SourceSpan;
        static load(source: Source, serialized: SerializedSourceSpan): SourceSpan;
        static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan;
        static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan;
        static synthetic(chars: string): SourceSpan;
        static broken(pos?: SourceLocation): SourceSpan;
        readonly isInvisible: boolean;
        constructor(data: SpanData & AnySpan);
        getStart(): SourceOffset;
        getEnd(): SourceOffset;
        get loc(): SourceLocation;
        get module(): string;
        /**
         * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get startPosition(): SourcePosition;
        /**
         * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get endPosition(): SourcePosition;
        /**
         * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
         */
        toJSON(): SourceLocation;
        /**
         * Create a new span with the current span's end and a new beginning.
         */
        withStart(other: SourceOffset): SourceSpan;
        /**
         * Create a new span with the current span's beginning and a new ending.
         */
        withEnd(this: SourceSpan, other: SourceOffset): SourceSpan;
        asString(): string;
        /**
         * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
         * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
         * string.
         */
        toSlice(expected?: string): SourceSlice;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use startPosition instead
         */
        get start(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withStart instead
         */
        set start(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use endPosition instead
         */
        get end(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withEnd instead
         */
        set end(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use module instead
         */
        get source(): string;
        collapse(where: "start" | "end"): SourceSpan;
        extend(other: SourceSpan): SourceSpan;
        serialize(): SerializedSourceSpan;
        slice({ skipStart, skipEnd }: {
            skipStart?: number;
            skipEnd?: number;
        }): SourceSpan;
        sliceStartChars({ skipStart, chars }: {
            skipStart?: number;
            chars: number;
        }): SourceSpan;
        sliceEndChars({ skipEnd, chars }: {
            skipEnd?: number;
            chars: number;
        }): SourceSpan;
    }
    type AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;
    class CharPositionSpan implements SpanData {
        readonly source: Source;
        readonly charPositions: {
            start: CharPosition;
            end: CharPosition;
        };
        readonly kind = OffsetKind.CharPosition;
        _locPosSpan: HbsSpan | BROKEN | null;
        constructor(source: Source, charPositions: {
            start: CharPosition;
            end: CharPosition;
        });
        wrap(): SourceSpan;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        locDidUpdate(): void;
        toHbsSpan(): HbsSpan | null;
        serialize(): SerializedSourceSpan;
        toCharPosSpan(): CharPositionSpan;
    }
    class HbsSpan implements SpanData {
        readonly source: Source;
        readonly hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        };
        readonly kind = OffsetKind.HbsPosition;
        _charPosSpan: CharPositionSpan | BROKEN | null;
        // the source location from Handlebars + AST Plugins -- could be wrong
        _providedHbsLoc: SourceLocation | null;
        constructor(source: Source, hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        }, providedHbsLoc?: SourceLocation | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        private updateProvided;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toHbsLoc(): SourceLocation;
        toHbsSpan(): HbsSpan;
        toCharPosSpan(): CharPositionSpan | null;
    }
    class InvisibleSpan implements SpanData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly loc: SourceLocation;
        // if the span represents a synthetic string
        readonly string: string | null;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, loc: SourceLocation, string?: string | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        asString(): string;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toCharPosSpan(): InvisibleSpan;
        toHbsSpan(): null;
        toHbsLoc(): SourceLocation;
    }
    const span: MatchFn<SourceSpan>;
    type SerializedConcreteSourceSpan = /** collapsed */ number | /** normal */ [
        start: number,
        size: number
    ] | /** synthetic */ string;
    type SerializedSourceSpan = SerializedConcreteSourceSpan | OffsetKind.NonExistent | OffsetKind.Broken;
    interface SourceLocation {
        start: SourcePosition;
        end: SourcePosition;
    }
    interface SourcePosition {
        /** >= 1 */
        line: number;
        /** >= 0 */
        column: number;
    }
    const UNKNOWN_POSITION: Readonly<{
        readonly line: 1;
        readonly column: 0;
    }>;
    const SYNTHETIC_LOCATION: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    /** @deprecated */
    const SYNTHETIC: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const TEMPORARY_LOCATION: Readonly<{
        readonly source: "(temporary)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const NON_EXISTENT_LOCATION: Readonly<{
        readonly source: "(nonexistent)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const BROKEN_LOCATION: Readonly<{
        readonly source: "(broken)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    type LocatedWithSpan = {
        offsets: SourceSpan;
    };
    type LocatedWithOptionalSpan = {
        offsets: SourceSpan | null;
    };
    type LocatedWithPositions = {
        loc: SourceLocation;
    };
    type LocatedWithOptionalPositions = {
        loc?: SourceLocation;
    };
    function isLocatedWithPositionsArray(location: LocatedWithOptionalPositions[]): location is PresentArray<LocatedWithPositions>;
    function isLocatedWithPositions(location: LocatedWithOptionalPositions): location is LocatedWithPositions;
    type HasSourceLocation = SourceLocation | LocatedWithPositions | PresentArray<LocatedWithPositions>;
    type MaybeHasSourceLocation = null | LocatedWithOptionalPositions | LocatedWithOptionalPositions[];
    /**
     * All positions have these details in common. Most notably, all three kinds of positions can
     * must be able to attempt to convert themselves into {@see CharPosition}.
     */
    interface PositionData {
        readonly kind: OffsetKind;
        toCharPos(): CharPosition | null;
        toJSON(): SourcePosition;
    }
    /**
     * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
     * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
     * attempted (and therefore to cache the failure)
     */
    const BROKEN = "BROKEN";
    type BROKEN = "BROKEN";
    type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;
    /**
     * A `SourceOffset` represents a single position in the source.
     *
     * There are three kinds of backing data for `SourceOffset` objects:
     *
     * - `CharPosition`, which contains a character offset into the raw source string
     * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
     *   converted to a `CharPosition` on demand.
     * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
     */
    class SourceOffset {
        readonly data: PositionData & AnyPosition;
        /**
         * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
         * into a character offset on demand, which avoids unnecessarily computing the offset of every
         * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
         */
        static forHbsPos(source: Source, pos: SourcePosition): SourceOffset;
        /**
         * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
         * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
         * any part of the source.
         */
        static broken(pos?: SourcePosition): SourceOffset;
        constructor(data: PositionData & AnyPosition);
        /**
         * Get the character offset for this `SourceOffset`, if possible.
         */
        get offset(): number | null;
        /**
         * Compare this offset with another one.
         *
         * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
         * the same. This avoids computing offsets unnecessarily.
         *
         * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
         * are the same.
         */
        eql(right: SourceOffset): boolean;
        /**
         * Create a span that starts from this source offset and ends with another source offset. Avoid
         * computing character offsets if both `SourceOffset`s are still lazy.
         */
        until(other: SourceOffset): SourceSpan;
        /**
         * Create a `SourceOffset` by moving the character position represented by this source offset
         * forward or backward (if `by` is negative), if possible.
         *
         * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
         *
         * If the resulting character offset is less than 0 or greater than the size of the source, `move`
         * returns a broken offset.
         */
        move(by: number): SourceOffset;
        /**
         * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
         * computing the character offset if it has not already been computed.
         */
        collapsed(): SourceSpan;
        /**
         * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
         * existing plugins.
         */
        toJSON(): SourcePosition;
    }
    class CharPosition implements PositionData {
        readonly source: Source;
        readonly charPos: number;
        readonly kind = OffsetKind.CharPosition;
        /** Computed from char offset */
        _locPos: HbsPosition | BROKEN | null;
        constructor(source: Source, charPos: number);
        /**
         * This is already a `CharPosition`.
         *
         * {@see HbsPosition} for the alternative.
         */
        toCharPos(): CharPosition;
        /**
         * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
         * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * A `CharPosition` always has an offset it can produce without any additional computation.
         */
        get offset(): number;
        /**
         * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
         * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
         * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
         * computing the `HbsPosition` should be a one-time operation.
         */
        toHbsPos(): HbsPosition | null;
    }
    class HbsPosition implements PositionData {
        readonly source: Source;
        readonly hbsPos: SourcePosition;
        readonly kind = OffsetKind.HbsPosition;
        _charPos: CharPosition | BROKEN | null;
        constructor(source: Source, hbsPos: SourcePosition, charPos?: number | null);
        /**
         * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
         * computed its `CharPosition`, it will not need to do compute it again, and the same
         * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
         * `CharPosition` should be a one-time operation.
         */
        toCharPos(): CharPosition | null;
        /**
         * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
         * does not need to compute anything.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * This is already an `HbsPosition`.
         *
         * {@see CharPosition} for the alternative.
         */
        toHbsPos(): HbsPosition;
    }
    class InvisiblePosition implements PositionData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly pos: SourcePosition;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, pos: SourcePosition);
        /**
         * A broken position cannot be turned into a {@see CharacterPosition}.
         */
        toCharPos(): null;
        /**
         * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
         * originally identified as broken, non-existent or synthetic.
         *
         * If an `InvisiblePosition` never had an source offset at all, this method returns
         * {@see UNKNOWN_POSITION} for compatibility.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        get offset(): null;
    }
    type HasSpan = SourceSpan | LocatedWithSpan | PresentArray<LocatedWithSpan>;
    type MaybeHasSpan = SourceSpan | LocatedWithOptionalSpan | LocatedWithOptionalSpan[] | null;
    type ToSourceOffset = number | SourceOffset;
    class SpanList {
        static range(span: PresentArray<HasSourceSpan>): SourceSpan;
        static range(span: HasSourceSpan[], fallback: SourceSpan): SourceSpan;
        _span: SourceSpan[];
        constructor(span?: SourceSpan[]);
        add(offset: SourceSpan): void;
        getRangeOffset(fallback: SourceSpan): SourceSpan;
    }
    type HasSourceSpan = {
        loc: SourceSpan;
    } | SourceSpan | [
        HasSourceSpan,
        ...HasSourceSpan[]
    ];
    function loc(span: HasSourceSpan): SourceSpan;
    type MaybeHasSourceSpan = {
        loc: SourceSpan;
    } | SourceSpan | MaybeHasSourceSpan[];
    function hasSpan(span: MaybeHasSourceSpan): span is HasSourceSpan;
    function maybeLoc(location: MaybeHasSourceSpan, fallback: SourceSpan): SourceSpan;
    interface Symbols {
        symbols: string[];
        has(name: string): boolean;
        get(name: string): number;
        getLocalsMap(): Dict<number>;
        getDebugInfo(): WireFormat.Core.DebugInfo;
        allocateFree(name: string): number;
        allocateNamed(name: string): number;
        allocateBlock(name: string): number;
        allocate(identifier: string): number;
        child(locals: string[]): BlockSymbols;
    }
    interface BlockSymbols extends Symbols {
        slots: number[];
    }
    interface ProgramSymbols extends Symbols {
        freeVariables: string[];
    }
    interface BaseNode {
        // Every leaf interface that extends BaseNode must specify a type property.
        // The type property should be a string literal. For example, Identifier
        // has: `type: "Identifier"`
        type: NodeType;
        loc: src.SourceSpan;
    }
    interface CommonProgram extends BaseNode {
        body: Statement[];
        blockParams: string[];
        chained?: boolean;
    }
    interface Program extends CommonProgram {
        type: "Program";
        symbols?: Symbols;
    }
    interface Block extends CommonProgram {
        type: "Block";
    }
    type EntityEncodingState = "transformed" | "raw";
    interface Template extends CommonProgram {
        type: "Template";
    }
    type PossiblyDeprecatedBlock = Block | Template;
    interface CallParts {
        path: Expression;
        params: Expression[];
        hash: Hash;
    }
    interface Call extends BaseNode {
        name?: Expression;
        path: Expression;
        params: Expression[];
        hash: Hash;
    }
    type CallNode = MustacheStatement | BlockStatement | ElementModifierStatement | SubExpression;
    interface MustacheStatement extends BaseNode {
        type: "MustacheStatement";
        path: Expression;
        params: Expression[];
        hash: Hash;
        /** @deprecated */
        escaped: boolean;
        trusting: boolean;
        strip: StripFlags;
    }
    interface BlockStatement extends BaseNode {
        type: "BlockStatement";
        path: Expression;
        params: Expression[];
        hash: Hash;
        program: Block;
        inverse?: Nullable<Block>;
        openStrip: StripFlags;
        inverseStrip: StripFlags;
        closeStrip: StripFlags;
        // Printer extension
        chained?: boolean;
    }
    interface ElementModifierStatement extends BaseNode {
        type: "ElementModifierStatement";
        path: Expression;
        params: Expression[];
        hash: Hash;
    }
    interface PartialStatement extends BaseNode {
        type: "PartialStatement";
        name: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
        indent: string;
        strip: StripFlags;
    }
    interface CommentStatement extends BaseNode {
        type: "CommentStatement";
        value: string;
    }
    interface MustacheCommentStatement extends BaseNode {
        type: "MustacheCommentStatement";
        value: string;
    }
    interface NamedBlockName {
        type: "NamedBlockName";
        name: string;
        loc: src.SourceLocation;
    }
    interface ElementName {
        type: "ElementName";
        name: string;
        loc: src.SourceLocation;
    }
    interface ElementNode extends BaseNode {
        type: "ElementNode";
        tag: string;
        selfClosing: boolean;
        attributes: AttrNode[];
        blockParams: string[];
        modifiers: ElementModifierStatement[];
        comments: MustacheCommentStatement[];
        children: Statement[];
    }
    type StatementName = "MustacheStatement" | "CommentStatement" | "BlockStatement" | "PartialStatement" | "MustacheCommentStatement" | "TextNode" | "ElementNode";
    interface AttrNode extends BaseNode {
        type: "AttrNode";
        name: string;
        value: AttrValue;
    }
    type AttrValue = TextNode | MustacheStatement | ConcatStatement;
    type AttrPart = TextNode | MustacheStatement;
    interface TextNode extends BaseNode {
        type: "TextNode";
        chars: string;
    }
    interface ConcatStatement extends BaseNode {
        type: "ConcatStatement";
        parts: PresentArray<TextNode | MustacheStatement>;
    }
    type ExpressionName = "SubExpression" | "PathExpression" | LiteralName;
    interface SubExpression extends Call {
        type: "SubExpression";
        path: Expression;
        params: Expression[];
        hash: Hash;
    }
    interface ThisHead {
        type: "ThisHead";
        loc: src.SourceLocation;
    }
    interface AtHead {
        type: "AtHead";
        name: string;
        loc: src.SourceLocation;
    }
    interface VarHead {
        type: "VarHead";
        name: string;
        loc: src.SourceLocation;
    }
    interface FreeVarHead {
        type: "FreeVarHead";
        name: string;
        loc: src.SourceLocation;
    }
    interface LocalVarHead {
        type: "LocalVarHead";
        name: string;
        loc: src.SourceLocation;
    }
    type PathHead = ThisHead | AtHead | VarHead;
    interface MinimalPathExpression extends BaseNode {
        type: "PathExpression";
        head: PathHead;
        tail: string[];
    }
    interface PathExpression extends MinimalPathExpression {
        type: "PathExpression";
        original: string;
        head: PathHead;
        tail: string[];
        /**
         * @deprecated use `head` and `tail` instead
         */
        parts: string[];
        /**
         * @deprecated use `head.type` instead
         */
        this: boolean;
        /**
         * @deprecated use `head.type' instead
         */
        data: boolean;
    }
    type LiteralName = "StringLiteral" | "BooleanLiteral" | "NumberLiteral" | "UndefinedLiteral" | "NullLiteral";
    interface StringLiteral extends BaseNode {
        type: "StringLiteral";
        value: string;
        original: string;
    }
    interface BooleanLiteral extends BaseNode {
        type: "BooleanLiteral";
        value: boolean;
        original: boolean;
    }
    interface NumberLiteral extends BaseNode {
        type: "NumberLiteral";
        value: number;
        original: number;
    }
    interface UndefinedLiteral extends BaseNode {
        type: "UndefinedLiteral";
        value: undefined;
        original: undefined;
    }
    interface NullLiteral extends BaseNode {
        type: "NullLiteral";
        value: null;
        original: null;
    }
    interface Hash extends BaseNode {
        type: "Hash";
        pairs: HashPair[];
    }
    interface HashPair extends BaseNode {
        type: "HashPair";
        key: string;
        value: Expression;
    }
    interface StripFlags {
        open: boolean;
        close: boolean;
    }
    type SharedNodes = {
        CommentStatement: CommentStatement;
        MustacheCommentStatement: MustacheCommentStatement;
        TextNode: TextNode;
        StringLiteral: StringLiteral;
        BooleanLiteral: BooleanLiteral;
        NumberLiteral: NumberLiteral;
        NullLiteral: NullLiteral;
        UndefinedLiteral: UndefinedLiteral;
        MustacheStatement: MustacheStatement;
        ElementModifierStatement: ElementModifierStatement;
        PartialStatement: PartialStatement;
        AttrNode: AttrNode;
        ConcatStatement: ConcatStatement;
    };
    type Nodes = SharedNodes & {
        Program: Program;
        Template: Template;
        Block: Block;
        BlockStatement: BlockStatement;
        ElementNode: ElementNode;
        SubExpression: SubExpression;
        PathExpression: PathExpression;
        Hash: Hash;
        HashPair: HashPair;
    };
    type NodeType = keyof Nodes;
    type Node = Nodes[NodeType];
    type Statement = Nodes[StatementName];
    type Statements = Pick<Nodes, StatementName>;
    type Literal = Nodes[LiteralName];
    type Expression = Nodes[ExpressionName];
    type Expressions = Pick<Nodes, ExpressionName>;
    type TopLevelStatement = Statement | Nodes["Block"];
    type ParentNode = Template | Block | ElementNode;
}
declare function getVoidTags(): string[];
interface PrinterOptions {
    entityEncoding: "transformed" | "raw";
    /**
     * Used to override the mechanism of printing a given AST.Node.
     *
     * This will generally only be useful to source -> source codemods
     * where you would like to specialize/override the way a given node is
     * printed (e.g. you would like to preserve as much of the original
     * formatting as possible).
     *
     * When the provided override returns undefined, the default built in printing
     * will be done for the AST.Node.
     *
     * @param ast the ast node to be printed
     * @param options the options specified during the print() invocation
     */
    override?(ast: ASTv1.Node, options: PrinterOptions): void | string;
}
/**
 * Examples when true:
 *  - link
 *  - liNK
 *
 * Examples when false:
 *  - Link (component)
 */
declare function isVoidTag(tag: string): boolean;
declare function build(ast: ASTv1.Node, options?: PrinterOptions): string;
declare function sortByLoc(a: ASTv1.Node, b: ASTv1.Node): -1 | 0 | 1;
interface GetTemplateLocalsOptions {
    includeKeywords?: boolean;
    includeHtmlElements?: boolean;
}
/**
 * Parses and traverses a given handlebars html template to extract all template locals
 * referenced that could possible come from the parent scope. Can exclude known keywords
 * optionally.
 */
declare function getTemplateLocals(html: string, options?: GetTemplateLocalsOptions): string[];
type KeywordType = "Call" | "Modifier" | "Append" | "Block";
declare function isKeyword(word: string): boolean;
/**
 * This includes the full list of keywords currently in use in the template
 * language, and where their valid usages are.
 */
declare const KEYWORDS_TYPES: {
    component: ("Block" | "Call" | "Append")[];
    debugger: "Append"[];
    "each-in": "Block"[];
    each: "Block"[];
    "has-block-params": ("Call" | "Append")[];
    "has-block": ("Call" | "Append")[];
    helper: ("Call" | "Append")[];
    if: ("Block" | "Call" | "Append")[];
    "in-element": "Block"[];
    let: "Block"[];
    "link-to": ("Block" | "Append")[];
    log: ("Call" | "Append")[];
    modifier: "Call"[];
    mount: "Append"[];
    mut: ("Call" | "Append")[];
    outlet: "Append"[];
    "query-params": "Call"[];
    readonly: ("Call" | "Append")[];
    unbound: ("Call" | "Append")[];
    unless: ("Block" | "Call" | "Append")[];
    with: "Block"[];
    yield: "Append"[];
};
type ParserNodeBuilder<N extends {
    loc: src.SourceSpan;
}> = Omit<N, "loc"> & {
    loc: src.SourceOffset;
};
interface Tag<T extends "StartTag" | "EndTag"> {
    readonly type: T;
    name: string;
    readonly attributes: ASTv1.AttrNode[];
    readonly modifiers: ASTv1.ElementModifierStatement[];
    readonly comments: ASTv1.MustacheCommentStatement[];
    selfClosing: boolean;
    readonly loc: src.SourceSpan;
}
interface Attribute {
    name: string;
    currentPart: ASTv1.TextNode | null;
    parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];
    isQuoted: boolean;
    isDynamic: boolean;
    start: src.SourceOffset;
    valueSpan: src.SourceSpan;
}
declare abstract class Parser {
    protected elementStack: ASTv1.ParentNode[];
    private lines;
    readonly source: src.Source;
    currentAttribute: Nullable<Attribute>;
    currentNode: Nullable<Readonly<ParserNodeBuilder<ASTv1.CommentStatement> | ASTv1.TextNode | ParserNodeBuilder<Tag<"StartTag">> | ParserNodeBuilder<Tag<"EndTag">>>>;
    tokenizer: EventedTokenizer;
    constructor(source: src.Source, entityParser?: EntityParser, mode?: "precompile" | "codemod");
    offset(): src.SourceOffset;
    pos({ line, column }: src.SourcePosition): src.SourceOffset;
    finish<T extends {
        loc: src.SourceSpan;
    }>(node: ParserNodeBuilder<T>): T;
    abstract Program(node: HBS.Program): HBS.Output<"Program">;
    abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<"MustacheStatement">;
    abstract Decorator(node: HBS.Decorator): HBS.Output<"Decorator">;
    abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<"BlockStatement">;
    abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<"DecoratorBlock">;
    abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<"PartialStatement">;
    abstract PartialBlockStatement(node: HBS.PartialBlockStatement): HBS.Output<"PartialBlockStatement">;
    abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<"ContentStatement">;
    abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<"CommentStatement">;
    abstract SubExpression(node: HBS.SubExpression): HBS.Output<"SubExpression">;
    abstract PathExpression(node: HBS.PathExpression): HBS.Output<"PathExpression">;
    abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<"StringLiteral">;
    abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<"BooleanLiteral">;
    abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<"NumberLiteral">;
    abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<"UndefinedLiteral">;
    abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<"NullLiteral">;
    abstract reset(): void;
    abstract finishData(): void;
    abstract tagOpen(): void;
    abstract beginData(): void;
    abstract appendToData(char: string): void;
    abstract beginStartTag(): void;
    abstract appendToTagName(char: string): void;
    abstract beginAttribute(): void;
    abstract appendToAttributeName(char: string): void;
    abstract beginAttributeValue(quoted: boolean): void;
    abstract appendToAttributeValue(char: string): void;
    abstract finishAttributeValue(): void;
    abstract markTagAsSelfClosing(): void;
    abstract beginEndTag(): void;
    abstract finishTag(): void;
    abstract beginComment(): void;
    abstract appendToCommentData(char: string): void;
    abstract finishComment(): void;
    abstract reportSyntaxError(error: string): void;
    get currentAttr(): Attribute;
    get currentTag(): ParserNodeBuilder<Tag<"StartTag" | "EndTag">>;
    get currentStartTag(): ParserNodeBuilder<Tag<"StartTag">>;
    get currentEndTag(): ParserNodeBuilder<Tag<"EndTag">>;
    get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement>;
    get currentData(): ASTv1.TextNode;
    acceptTemplate(node: HBS.Program): ASTv1.Template;
    acceptNode(node: HBS.Program): ASTv1.Block | ASTv1.Template;
    acceptNode<U extends HBS.Node | ASTv1.Node>(node: HBS.Node): U;
    currentElement(): ASTv1.ParentNode;
    sourceForNode(node: HBS.Node, endNode?: {
        loc: HBS.SourceLocation;
    }): string;
}
// ensure stays in sync with typing
// ParentNode and ChildKey types are derived from VisitorKeysMap
declare const visitorKeys: {
    readonly Program: readonly [
        "body"
    ];
    readonly Template: readonly [
        "body"
    ];
    readonly Block: readonly [
        "body"
    ];
    readonly MustacheStatement: readonly [
        "path",
        "params",
        "hash"
    ];
    readonly BlockStatement: readonly [
        "path",
        "params",
        "hash",
        "program",
        "inverse"
    ];
    readonly ElementModifierStatement: readonly [
        "path",
        "params",
        "hash"
    ];
    readonly PartialStatement: readonly [
        "name",
        "params",
        "hash"
    ];
    readonly CommentStatement: readonly [
    ];
    readonly MustacheCommentStatement: readonly [
    ];
    readonly ElementNode: readonly [
        "attributes",
        "modifiers",
        "children",
        "comments"
    ];
    readonly AttrNode: readonly [
        "value"
    ];
    readonly TextNode: readonly [
    ];
    readonly ConcatStatement: readonly [
        "parts"
    ];
    readonly SubExpression: readonly [
        "path",
        "params",
        "hash"
    ];
    readonly PathExpression: readonly [
    ];
    readonly PathHead: readonly [
    ];
    readonly StringLiteral: readonly [
    ];
    readonly BooleanLiteral: readonly [
    ];
    readonly NumberLiteral: readonly [
    ];
    readonly NullLiteral: readonly [
    ];
    readonly UndefinedLiteral: readonly [
    ];
    readonly Hash: readonly [
        "pairs"
    ];
    readonly HashPair: readonly [
        "value"
    ];
    readonly NamedBlock: readonly [
        "attributes",
        "modifiers",
        "children",
        "comments"
    ];
    readonly SimpleElement: readonly [
        "attributes",
        "modifiers",
        "children",
        "comments"
    ];
    readonly Component: readonly [
        "head",
        "attributes",
        "modifiers",
        "children",
        "comments"
    ];
};
type VisitorKeysMap = typeof visitorKeys;
type VisitorKeys = {
    [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number];
};
type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N["type"]] & keyof N;
declare class WalkerPath<N extends ASTv1.Node> {
    node: N;
    parent: WalkerPath<ASTv1.Node> | null;
    parentKey: string | null;
    constructor(node: N, parent?: WalkerPath<ASTv1.Node> | null, parentKey?: string | null);
    get parentNode(): ASTv1.Node | null;
    parents(): Iterable<WalkerPath<ASTv1.Node> | null>;
}
interface FullNodeTraversal<N extends ASTv1.Node> {
    enter?(node: N, path: WalkerPath<N>): void;
    exit?(node: N, path: WalkerPath<N>): void;
    keys?: KeysVisitor<N>;
}
type NodeHandler<N extends ASTv1.Node> = (node: N, path: WalkerPath<N>) => void;
type NodeTraversal<N extends ASTv1.Node> = FullNodeTraversal<N> | NodeHandler<N>;
type NodeVisitor = {
    [P in keyof ASTv1.Nodes]?: NodeTraversal<ASTv1.Nodes[P]>;
} & {
    All?: NodeTraversal<ASTv1.Node>;
};
interface FullKeyTraversal<N extends ASTv1.Node, K extends string> {
    enter?(node: N, key: K): void;
    exit?(node: N, key: K): void;
}
type KeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>> = (node: N, key: K) => void;
type KeyTraversal<N extends ASTv1.Node, K extends VisitorKey<N>> = FullKeyTraversal<N, K> | KeyHandler<N, K>;
type KeysVisitor<N extends ASTv1.Node> = {
    [P in VisitorKey<N>]?: KeyTraversal<N, P>;
} & {
    All?: KeyTraversal<N, VisitorKey<N>>;
};
declare const print: typeof build;
declare function traverse(node: ASTv1.Node, visitor: NodeVisitor): void;
type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;
declare class Walker {
    order?: unknown;
    stack: unknown[];
    constructor(order?: unknown);
    visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void;
    children<N extends ASTv1.Node>(node: N & ASTv1.Node, callback: NodeCallback<N & ASTv1.Node>): void;
}
declare class Source {
    readonly source: string;
    readonly module: string;
    static from(source: string, options?: PrecompileOptions): Source;
    constructor(source: string, module?: string);
    /**
     * Validate that the character offset represents a position in the source string.
     */
    check(offset: number): boolean;
    slice(start: number, end: number): string;
    offsetFor(line: number, column: number): SourceOffset;
    spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan;
    hbsPosFor(offset: number): Nullable<SourcePosition>;
    charPosFor(position: SourcePosition): number | null;
}
declare enum OffsetKind {
    /**
     * We have already computed the character position of this offset or span.
     */
    CharPosition = "CharPosition",
    /**
     * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its
     * character position will be computed on demand.
     */
    HbsPosition = "HbsPosition",
    /**
     * for (rare) situations where a node is created but there was no source location (e.g. the name
     * "default" in default blocks when the word "default" never appeared in source). This is used
     * by the internals when there is a legitimate reason for the internals to synthesize a node
     * with no location.
     */
    InternalsSynthetic = "InternalsSynthetic",
    /**
     * For situations where a node represents zero parts of the source (for example, empty arguments).
     * In general, we attempt to assign these nodes *some* position (empty arguments can be
     * positioned immediately after the callee), but it's not always possible
     */
    NonExistent = "NonExistent",
    /**
     * For situations where a source location was expected, but it didn't correspond to the node in
     * the source. This happens if a plugin creates broken locations.
     */
    Broken = "Broken"
}
/**
 * This file implements the DSL used by span and offset in places where they need to exhaustively
 * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
 * offsets).
 *
 * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
 * removed.
 */
declare const MatchAny = "MATCH_ANY";
type MatchAny = "MATCH_ANY";
type Matches = "Char,Hbs" | "Hbs,Char" | "Hbs,Hbs" | "Char,Char" | "Invisible,Any" | "Any,Invisible";
declare const IsInvisible = "IS_INVISIBLE";
type IsInvisible = "IS_INVISIBLE";
type Pattern = OffsetKind | IsInvisible | MatchAny;
declare class When<Out> {
    _map: Map<Pattern, Out>;
    get(pattern: Pattern, or: () => Out): Out;
    add(pattern: Pattern, out: Out): void;
    match(kind: OffsetKind): Out[];
}
type ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> = Exclude<In, Removed> extends never ? ExhaustiveMatcher<Out> : Matcher<Out, Exclude<In, Removed>>;
type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;
interface ExhaustiveMatcher<Out> {
    check(): MatchFn<Out>;
}
declare class Matcher<Out, M extends Matches = Matches> {
    _whens: When<When<(left: PositionData, right: PositionData) => Out>>;
    /**
     * You didn't exhaustively match all possibilities.
     */
    protected check(): MatchFn<Out>;
    private matchFor;
    // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness
    // checking so that matchers can ensure they've actually covered all the cases (and TypeScript
    // will treat it as an exhaustive match).
    when(left: OffsetKind.CharPosition, right: OffsetKind.HbsPosition, callback: (left: CharPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Char,Hbs">;
    when(left: OffsetKind.HbsPosition, right: OffsetKind.CharPosition, callback: (left: HbsPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Char">;
    when(left: OffsetKind.HbsPosition, right: OffsetKind.HbsPosition, callback: (left: HbsPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Hbs">;
    when(left: OffsetKind.CharPosition, right: OffsetKind.CharPosition, callback: (left: CharPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Char,Char">;
    when(left: IsInvisible, right: MatchAny, callback: (left: InvisiblePosition, right: PositionData) => Out): Matcher<Out, Exclude<M, "Invisible,Any">>;
    when(left: MatchAny, right: IsInvisible, callback: (left: PositionData, right: InvisiblePosition) => Out): ExhaustiveCheck<Out, M, "Any,Invisible">;
    when(left: MatchAny, right: MatchAny, callback: (left: PositionData, right: PositionData) => Out): ExhaustiveMatcher<Out>;
}
type SerializedSourceSlice<Chars extends string = string> = [
    chars: Chars,
    span: src.SerializedSourceSpan
];
declare class SourceSlice<Chars extends string = string> {
    static synthetic<S extends string>(chars: S): SourceSlice<S>;
    static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice;
    readonly chars: Chars;
    readonly loc: src.SourceSpan;
    constructor(options: {
        loc: src.SourceSpan;
        chars: Chars;
    });
    getString(): string;
    serialize(): SerializedSourceSlice<Chars>;
}
/**
 * All spans have these details in common.
 */
interface SpanData {
    readonly kind: OffsetKind;
    /**
     * Convert this span into a string. If the span is broken, return `''`.
     */
    asString(): string;
    /**
     * Gets the module the span was located in.
     */
    getModule(): string;
    /**
     * Get the starting position for this span. Try to avoid creating new position objects, as they
     * cache computations.
     */
    getStart(): AnyPosition;
    /**
     * Get the ending position for this span. Try to avoid creating new position objects, as they
     * cache computations.
     */
    getEnd(): AnyPosition;
    /**
     * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.
     */
    toHbsSpan(): HbsSpan | null;
    /**
     * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are
     * notified of the change so they can update themselves. This shouldn't happen outside of AST
     * plugins.
     */
    locDidUpdate(changes: {
        start?: SourcePosition;
        end?: SourcePosition;
    }): void;
    /**
     * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in
     * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.
     */
    serialize(): SerializedSourceSpan;
}
/**
 * A `SourceSpan` object represents a span of characters inside of a template source.
 *
 * There are three kinds of `SourceSpan` objects:
 *
 * - `ConcreteSourceSpan`, which contains byte offsets
 * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
 *   converted to byte offsets on demand.
 * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
 *   because:
 *     - they were created synthetically
 *     - their location is nonsensical (the span is broken)
 *     - they represent nothing in the source (this currently happens only when a bug in the
 *       upstream Handlebars parser fails to assign a location to empty blocks)
 *
 * At a high level, all `SourceSpan` objects provide:
 *
 * - byte offsets
 * - source in column and line format
 *
 * And you can do these operations on `SourceSpan`s:
 *
 * - collapse it to a `SourceSpan` representing its starting or ending position
 * - slice out some characters, optionally skipping some characters at the beginning or end
 * - create a new `SourceSpan` with a different starting or ending offset
 *
 * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
 * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
 *
 * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
 * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
 *
 * The goal is to avoid creating any problems for use-cases like AST Explorer.
 */
declare class SourceSpan implements SourceLocation {
    private data;
    static get NON_EXISTENT(): SourceSpan;
    static load(source: Source, serialized: SerializedSourceSpan): SourceSpan;
    static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan;
    static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan;
    static synthetic(chars: string): SourceSpan;
    static broken(pos?: SourceLocation): SourceSpan;
    readonly isInvisible: boolean;
    constructor(data: SpanData & AnySpan);
    getStart(): SourceOffset;
    getEnd(): SourceOffset;
    get loc(): SourceLocation;
    get module(): string;
    /**
     * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
     */
    get startPosition(): SourcePosition;
    /**
     * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
     */
    get endPosition(): SourcePosition;
    /**
     * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
     */
    toJSON(): SourceLocation;
    /**
     * Create a new span with the current span's end and a new beginning.
     */
    withStart(other: SourceOffset): SourceSpan;
    /**
     * Create a new span with the current span's beginning and a new ending.
     */
    withEnd(this: SourceSpan, other: SourceOffset): SourceSpan;
    asString(): string;
    /**
     * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
     * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
     * string.
     */
    toSlice(expected?: string): SourceSlice;
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use startPosition instead
     */
    get start(): SourcePosition;
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use withStart instead
     */
    set start(position: SourcePosition);
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use endPosition instead
     */
    get end(): SourcePosition;
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use withEnd instead
     */
    set end(position: SourcePosition);
    /**
     * For compatibility with SourceLocation in AST plugins
     *
     * @deprecated use module instead
     */
    get source(): string;
    collapse(where: "start" | "end"): SourceSpan;
    extend(other: SourceSpan): SourceSpan;
    serialize(): SerializedSourceSpan;
    slice({ skipStart, skipEnd }: {
        skipStart?: number;
        skipEnd?: number;
    }): SourceSpan;
    sliceStartChars({ skipStart, chars }: {
        skipStart?: number;
        chars: number;
    }): SourceSpan;
    sliceEndChars({ skipEnd, chars }: {
        skipEnd?: number;
        chars: number;
    }): SourceSpan;
}
type AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;
declare class CharPositionSpan implements SpanData {
    readonly source: Source;
    readonly charPositions: {
        start: CharPosition;
        end: CharPosition;
    };
    readonly kind = OffsetKind.CharPosition;
    _locPosSpan: HbsSpan | BROKEN | null;
    constructor(source: Source, charPositions: {
        start: CharPosition;
        end: CharPosition;
    });
    wrap(): SourceSpan;
    asString(): string;
    getModule(): string;
    getStart(): AnyPosition;
    getEnd(): AnyPosition;
    locDidUpdate(): void;
    toHbsSpan(): HbsSpan | null;
    serialize(): SerializedSourceSpan;
    toCharPosSpan(): CharPositionSpan;
}
declare class HbsSpan implements SpanData {
    readonly source: Source;
    readonly hbsPositions: {
        start: HbsPosition;
        end: HbsPosition;
    };
    readonly kind = OffsetKind.HbsPosition;
    _charPosSpan: CharPositionSpan | BROKEN | null;
    // the source location from Handlebars + AST Plugins -- could be wrong
    _providedHbsLoc: SourceLocation | null;
    constructor(source: Source, hbsPositions: {
        start: HbsPosition;
        end: HbsPosition;
    }, providedHbsLoc?: SourceLocation | null);
    serialize(): SerializedConcreteSourceSpan;
    wrap(): SourceSpan;
    private updateProvided;
    locDidUpdate({ start, end }: {
        start?: SourcePosition;
        end?: SourcePosition;
    }): void;
    asString(): string;
    getModule(): string;
    getStart(): AnyPosition;
    getEnd(): AnyPosition;
    toHbsLoc(): SourceLocation;
    toHbsSpan(): HbsSpan;
    toCharPosSpan(): CharPositionSpan | null;
}
declare class InvisibleSpan implements SpanData {
    readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
    // whatever was provided, possibly broken
    readonly loc: SourceLocation;
    // if the span represents a synthetic string
    readonly string: string | null;
    constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, loc: SourceLocation, string?: string | null);
    serialize(): SerializedConcreteSourceSpan;
    wrap(): SourceSpan;
    asString(): string;
    locDidUpdate({ start, end }: {
        start?: SourcePosition;
        end?: SourcePosition;
    }): void;
    getModule(): string;
    getStart(): AnyPosition;
    getEnd(): AnyPosition;
    toCharPosSpan(): InvisibleSpan;
    toHbsSpan(): null;
    toHbsLoc(): SourceLocation;
}
declare const span: MatchFn<SourceSpan>;
type SerializedConcreteSourceSpan = /** collapsed */ number | /** normal */ [
    start: number,
    size: number
] | /** synthetic */ string;
type SerializedSourceSpan = SerializedConcreteSourceSpan | OffsetKind.NonExistent | OffsetKind.Broken;
/**
 * All positions have these details in common. Most notably, all three kinds of positions can
 * must be able to attempt to convert themselves into {@see CharPosition}.
 */
interface PositionData {
    readonly kind: OffsetKind;
    toCharPos(): CharPosition | null;
    toJSON(): SourcePosition;
}
/**
 * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
 * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
 * attempted (and therefore to cache the failure)
 */
declare const BROKEN = "BROKEN";
type BROKEN = "BROKEN";
type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;
/**
 * A `SourceOffset` represents a single position in the source.
 *
 * There are three kinds of backing data for `SourceOffset` objects:
 *
 * - `CharPosition`, which contains a character offset into the raw source string
 * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
 *   converted to a `CharPosition` on demand.
 * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
 */
declare class SourceOffset {
    readonly data: PositionData & AnyPosition;
    /**
     * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
     * into a character offset on demand, which avoids unnecessarily computing the offset of every
     * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
     */
    static forHbsPos(source: Source, pos: SourcePosition): SourceOffset;
    /**
     * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
     * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
     * any part of the source.
     */
    static broken(pos?: SourcePosition): SourceOffset;
    constructor(data: PositionData & AnyPosition);
    /**
     * Get the character offset for this `SourceOffset`, if possible.
     */
    get offset(): number | null;
    /**
     * Compare this offset with another one.
     *
     * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
     * the same. This avoids computing offsets unnecessarily.
     *
     * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
     * are the same.
     */
    eql(right: SourceOffset): boolean;
    /**
     * Create a span that starts from this source offset and ends with another source offset. Avoid
     * computing character offsets if both `SourceOffset`s are still lazy.
     */
    until(other: SourceOffset): SourceSpan;
    /**
     * Create a `SourceOffset` by moving the character position represented by this source offset
     * forward or backward (if `by` is negative), if possible.
     *
     * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
     *
     * If the resulting character offset is less than 0 or greater than the size of the source, `move`
     * returns a broken offset.
     */
    move(by: number): SourceOffset;
    /**
     * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
     * computing the character offset if it has not already been computed.
     */
    collapsed(): SourceSpan;
    /**
     * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
     * existing plugins.
     */
    toJSON(): SourcePosition;
}
declare class CharPosition implements PositionData {
    readonly source: Source;
    readonly charPos: number;
    readonly kind = OffsetKind.CharPosition;
    /** Computed from char offset */
    _locPos: HbsPosition | BROKEN | null;
    constructor(source: Source, charPos: number);
    /**
     * This is already a `CharPosition`.
     *
     * {@see HbsPosition} for the alternative.
     */
    toCharPos(): CharPosition;
    /**
     * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
     * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
     */
    toJSON(): SourcePosition;
    wrap(): SourceOffset;
    /**
     * A `CharPosition` always has an offset it can produce without any additional computation.
     */
    get offset(): number;
    /**
     * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
     * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
     * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
     * computing the `HbsPosition` should be a one-time operation.
     */
    toHbsPos(): HbsPosition | null;
}
declare class HbsPosition implements PositionData {
    readonly source: Source;
    readonly hbsPos: SourcePosition;
    readonly kind = OffsetKind.HbsPosition;
    _charPos: CharPosition | BROKEN | null;
    constructor(source: Source, hbsPos: SourcePosition, charPos?: number | null);
    /**
     * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
     * computed its `CharPosition`, it will not need to do compute it again, and the same
     * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
     * `CharPosition` should be a one-time operation.
     */
    toCharPos(): CharPosition | null;
    /**
     * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
     * does not need to compute anything.
     */
    toJSON(): SourcePosition;
    wrap(): SourceOffset;
    /**
     * This is already an `HbsPosition`.
     *
     * {@see CharPosition} for the alternative.
     */
    toHbsPos(): HbsPosition;
}
declare class InvisiblePosition implements PositionData {
    readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
    // whatever was provided, possibly broken
    readonly pos: SourcePosition;
    constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, pos: SourcePosition);
    /**
     * A broken position cannot be turned into a {@see CharacterPosition}.
     */
    toCharPos(): null;
    /**
     * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
     * originally identified as broken, non-existent or synthetic.
     *
     * If an `InvisiblePosition` never had an source offset at all, this method returns
     * {@see UNKNOWN_POSITION} for compatibility.
     */
    toJSON(): SourcePosition;
    wrap(): SourceOffset;
    get offset(): null;
}
interface SourceLocation {
    start: SourcePosition;
    end: SourcePosition;
}
interface SourcePosition {
    /** >= 1 */
    line: number;
    /** >= 0 */
    column: number;
}
type LocatedWithSpan = {
    offsets: SourceSpan;
};
type LocatedWithOptionalSpan = {
    offsets: SourceSpan | null;
};
type LocatedWithPositions = {
    loc: SourceLocation;
};
type LocatedWithOptionalPositions = {
    loc?: SourceLocation;
};
// const SOURCE = new Source('', '(tests)');
// Statements
type BuilderHead = string | ASTv1.Expression;
type TagDescriptor = string | {
    name: string;
    selfClosing: boolean;
};
declare function buildMustache(path: BuilderHead | ASTv1.Literal, params?: ASTv1.Expression[], hash?: ASTv1.Hash, raw?: boolean, loc?: SourceLocation, strip?: ASTv1.StripFlags): ASTv1.MustacheStatement;
declare function buildBlock(path: BuilderHead, params: Nullable<ASTv1.Expression[]>, hash: Nullable<ASTv1.Hash>, _defaultBlock: ASTv1.PossiblyDeprecatedBlock, _elseBlock?: Nullable<ASTv1.PossiblyDeprecatedBlock>, loc?: SourceLocation, openStrip?: ASTv1.StripFlags, inverseStrip?: ASTv1.StripFlags, closeStrip?: ASTv1.StripFlags): ASTv1.BlockStatement;
declare function buildElementModifier(path: BuilderHead | ASTv1.Expression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: Nullable<SourceLocation>): ASTv1.ElementModifierStatement;
declare function buildPartial(name: ASTv1.PathExpression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, indent?: string, loc?: SourceLocation): ASTv1.PartialStatement;
declare function buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement;
declare function buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement;
declare function buildConcat(parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[], loc?: SourceLocation): ASTv1.ConcatStatement;
type PathSexp = string | [
    "path",
    string,
    LocSexp?
];
type ModifierSexp = string | [
    PathSexp,
    LocSexp?
] | [
    PathSexp,
    ASTv1.Expression[],
    LocSexp?
] | [
    PathSexp,
    ASTv1.Expression[],
    Dict<ASTv1.Expression>,
    LocSexp?
];
type AttrSexp = [
    string,
    ASTv1.AttrNode["value"] | string,
    LocSexp?
];
type LocSexp = [
    "loc",
    SourceLocation
];
type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;
interface BuildElementOptions {
    attrs?: ASTv1.AttrNode[];
    modifiers?: ASTv1.ElementModifierStatement[];
    children?: ASTv1.Statement[];
    comments?: ElementComment[];
    blockParams?: string[];
    loc?: SourceSpan;
}
declare function buildElement(tag: TagDescriptor, options?: BuildElementOptions): ASTv1.ElementNode;
declare function buildAttr(name: string, value: ASTv1.AttrNode["value"], loc?: SourceLocation): ASTv1.AttrNode;
declare function buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode;
// Expressions
declare function buildSexpr(path: BuilderHead, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: SourceLocation): ASTv1.SubExpression;
declare function buildThis(loc: SourceLocation): ASTv1.PathHead;
declare function buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildVar(name: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead;
declare function buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName;
declare function buildCleanPath(head: ASTv1.PathHead, tail: string[], loc: SourceLocation): ASTv1.PathExpression;
declare function buildPath(path: ASTv1.PathExpression | string | {
    head: string;
    tail: string[];
}, loc?: SourceLocation): ASTv1.PathExpression;
declare function buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
declare function buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
declare function buildLiteral<T extends ASTv1.Literal>(type: T["type"], value: T["value"], loc?: SourceLocation): T;
// Miscellaneous
declare function buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash;
declare function buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair;
declare function buildProgram(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
declare function buildBlockItself(body?: ASTv1.Statement[], blockParams?: string[], chained?: boolean, loc?: SourceLocation): ASTv1.Block;
declare function buildTemplate(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
declare function buildPosition(line: number, column: number): SourcePosition;
declare function buildLoc(loc: Nullable<SourceLocation>): SourceSpan;
declare function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): SourceSpan;
declare const _default: {
    mustache: typeof buildMustache;
    block: typeof buildBlock;
    partial: typeof buildPartial;
    comment: typeof buildComment;
    mustacheComment: typeof buildMustacheComment;
    element: typeof buildElement;
    elementModifier: typeof buildElementModifier;
    attr: typeof buildAttr;
    text: typeof buildText;
    sexpr: typeof buildSexpr;
    concat: typeof buildConcat;
    hash: typeof buildHash;
    pair: typeof buildPair;
    literal: typeof buildLiteral;
    program: typeof buildProgram;
    blockItself: typeof buildBlockItself;
    template: typeof buildTemplate;
    loc: typeof buildLoc;
    pos: typeof buildPosition;
    path: typeof buildPath;
    fullPath: typeof buildCleanPath;
    head: typeof buildHeadFromString;
    at: typeof buildAtName;
    var: typeof buildVar;
    this: typeof buildThis;
    blockName: typeof buildNamedBlockName;
    string: (value: string) => ASTv1.StringLiteral;
    boolean: (value: boolean) => ASTv1.BooleanLiteral;
    number: (value: number) => ASTv1.NumberLiteral;
    undefined(): ASTv1.UndefinedLiteral;
    null(): ASTv1.NullLiteral;
};
declare const publicBuilder: typeof _default;
declare abstract class HandlebarsNodeVisitors extends Parser {
    abstract appendToCommentData(s: string): void;
    abstract beginAttributeValue(quoted: boolean): void;
    abstract finishAttributeValue(): void;
    private get isTopLevel();
    Program(program: HBS.Program): ASTv1.Block;
    Program(program: HBS.Program): ASTv1.Template;
    Program(program: HBS.Program): ASTv1.Template | ASTv1.Block;
    BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void;
    MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void;
    appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void;
    finalizeTextPart(): void;
    startTextPart(): void;
    ContentStatement(content: HBS.ContentStatement): void;
    CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement>;
    PartialStatement(partial: HBS.PartialStatement): never;
    PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never;
    Decorator(decorator: HBS.Decorator): never;
    DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never;
    SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression;
    PathExpression(path: HBS.PathExpression): ASTv1.PathExpression;
    Hash(hash: HBS.Hash): ASTv1.Hash;
    StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral;
    BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral;
    NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral;
    UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral;
    NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral;
}
/**
 ASTPlugins can make changes to the Glimmer template AST before
 compilation begins.
 */
interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {
    (env: TEnv): ASTPlugin;
}
interface ASTPlugin {
    name: string;
    visitor: NodeVisitor;
}
interface ASTPluginEnvironment {
    meta?: object;
    syntax: Syntax;
}
interface HandlebarsParseOptions {
    srcName?: string;
    ignoreStandalone?: boolean;
}
interface TemplateIdFn {
    (src: string): Nullable<string>;
}
interface PrecompileOptions extends PreprocessOptions {
    id?: TemplateIdFn;
    customizeComponentName?: ((input: string) => string) | undefined;
}
interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {
    lexicalScope: (variable: string) => boolean;
}
interface PreprocessOptions {
    strictMode?: boolean;
    locals?: string[];
    meta?: {
        moduleName?: string;
    };
    plugins?: {
        ast?: ASTPluginBuilder[];
    };
    parseOptions?: HandlebarsParseOptions;
    customizeComponentName?: ((input: string) => string) | undefined;
    /**
     Useful for specifying a group of options together.
     
     When `'codemod'` we disable all whitespace control in handlebars
     (to preserve as much as possible) and we also avoid any
     escaping/unescaping of HTML entity codes.
     */
    mode?: "codemod" | "precompile";
}
interface Syntax {
    parse: typeof preprocess;
    builders: typeof publicBuilder;
    print: typeof print;
    traverse: typeof traverse;
    Walker: typeof Walker;
}
declare function preprocess(input: string | src.Source | HBS.Program, options?: PreprocessOptions): ASTv1.Template;
declare class SpanList {
    static range(span: PresentArray<HasSourceSpan>): SourceSpan;
    static range(span: HasSourceSpan[], fallback: SourceSpan): SourceSpan;
    _span: SourceSpan[];
    constructor(span?: SourceSpan[]);
    add(offset: SourceSpan): void;
    getRangeOffset(fallback: SourceSpan): SourceSpan;
}
type HasSourceSpan = {
    loc: SourceSpan;
} | SourceSpan | [
    HasSourceSpan,
    ...HasSourceSpan[]
];
declare function loc(span: HasSourceSpan): SourceSpan;
type MaybeHasSourceSpan = {
    loc: SourceSpan;
} | SourceSpan | MaybeHasSourceSpan[];
declare function hasSpan(span: MaybeHasSourceSpan): span is HasSourceSpan;
declare function maybeLoc(location: MaybeHasSourceSpan, fallback: SourceSpan): SourceSpan;
declare namespace ASTv2 {
    type SerializedSourceSlice<Chars extends string = string> = [
        chars: Chars,
        span: src.SerializedSourceSpan
    ];
    class SourceSlice<Chars extends string = string> {
        static synthetic<S extends string>(chars: S): SourceSlice<S>;
        static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice;
        readonly chars: Chars;
        readonly loc: src.SourceSpan;
        constructor(options: {
            loc: src.SourceSpan;
            chars: Chars;
        });
        getString(): string;
        serialize(): SerializedSourceSlice<Chars>;
    }
    interface SourceLocation {
        start: SourcePosition;
        end: SourcePosition;
    }
    interface SourcePosition {
        /** >= 1 */
        line: number;
        /** >= 0 */
        column: number;
    }
    const UNKNOWN_POSITION: Readonly<{
        readonly line: 1;
        readonly column: 0;
    }>;
    const SYNTHETIC_LOCATION: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    /** @deprecated */
    const SYNTHETIC: Readonly<{
        readonly source: "(synthetic)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const TEMPORARY_LOCATION: Readonly<{
        readonly source: "(temporary)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const NON_EXISTENT_LOCATION: Readonly<{
        readonly source: "(nonexistent)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    const BROKEN_LOCATION: Readonly<{
        readonly source: "(broken)";
        readonly start: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
        readonly end: Readonly<{
            readonly line: 1;
            readonly column: 0;
        }>;
    }>;
    type LocatedWithSpan = {
        offsets: SourceSpan;
    };
    type LocatedWithOptionalSpan = {
        offsets: SourceSpan | null;
    };
    type LocatedWithPositions = {
        loc: SourceLocation;
    };
    type LocatedWithOptionalPositions = {
        loc?: SourceLocation;
    };
    function isLocatedWithPositionsArray(location: LocatedWithOptionalPositions[]): location is PresentArray<LocatedWithPositions>;
    function isLocatedWithPositions(location: LocatedWithOptionalPositions): location is LocatedWithPositions;
    type HasSourceLocation = SourceLocation | LocatedWithPositions | PresentArray<LocatedWithPositions>;
    type MaybeHasSourceLocation = null | LocatedWithOptionalPositions | LocatedWithOptionalPositions[];
    type ParserNodeBuilder<N extends {
        loc: src.SourceSpan;
    }> = Omit<N, "loc"> & {
        loc: src.SourceOffset;
    };
    interface Tag<T extends "StartTag" | "EndTag"> {
        readonly type: T;
        name: string;
        readonly attributes: ASTv1.AttrNode[];
        readonly modifiers: ASTv1.ElementModifierStatement[];
        readonly comments: ASTv1.MustacheCommentStatement[];
        selfClosing: boolean;
        readonly loc: src.SourceSpan;
    }
    interface Attribute {
        name: string;
        currentPart: ASTv1.TextNode | null;
        parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];
        isQuoted: boolean;
        isDynamic: boolean;
        start: src.SourceOffset;
        valueSpan: src.SourceSpan;
    }
    abstract class Parser {
        protected elementStack: ASTv1.ParentNode[];
        private lines;
        readonly source: src.Source;
        currentAttribute: Nullable<Attribute>;
        currentNode: Nullable<Readonly<ParserNodeBuilder<ASTv1.CommentStatement> | ASTv1.TextNode | ParserNodeBuilder<Tag<"StartTag">> | ParserNodeBuilder<Tag<"EndTag">>>>;
        tokenizer: EventedTokenizer;
        constructor(source: src.Source, entityParser?: EntityParser, mode?: "precompile" | "codemod");
        offset(): src.SourceOffset;
        pos({ line, column }: src.SourcePosition): src.SourceOffset;
        finish<T extends {
            loc: src.SourceSpan;
        }>(node: ParserNodeBuilder<T>): T;
        abstract Program(node: HBS.Program): HBS.Output<"Program">;
        abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<"MustacheStatement">;
        abstract Decorator(node: HBS.Decorator): HBS.Output<"Decorator">;
        abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<"BlockStatement">;
        abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<"DecoratorBlock">;
        abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<"PartialStatement">;
        abstract PartialBlockStatement(node: HBS.PartialBlockStatement): HBS.Output<"PartialBlockStatement">;
        abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<"ContentStatement">;
        abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<"CommentStatement">;
        abstract SubExpression(node: HBS.SubExpression): HBS.Output<"SubExpression">;
        abstract PathExpression(node: HBS.PathExpression): HBS.Output<"PathExpression">;
        abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<"StringLiteral">;
        abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<"BooleanLiteral">;
        abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<"NumberLiteral">;
        abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<"UndefinedLiteral">;
        abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<"NullLiteral">;
        abstract reset(): void;
        abstract finishData(): void;
        abstract tagOpen(): void;
        abstract beginData(): void;
        abstract appendToData(char: string): void;
        abstract beginStartTag(): void;
        abstract appendToTagName(char: string): void;
        abstract beginAttribute(): void;
        abstract appendToAttributeName(char: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract appendToAttributeValue(char: string): void;
        abstract finishAttributeValue(): void;
        abstract markTagAsSelfClosing(): void;
        abstract beginEndTag(): void;
        abstract finishTag(): void;
        abstract beginComment(): void;
        abstract appendToCommentData(char: string): void;
        abstract finishComment(): void;
        abstract reportSyntaxError(error: string): void;
        get currentAttr(): Attribute;
        get currentTag(): ParserNodeBuilder<Tag<"StartTag" | "EndTag">>;
        get currentStartTag(): ParserNodeBuilder<Tag<"StartTag">>;
        get currentEndTag(): ParserNodeBuilder<Tag<"EndTag">>;
        get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement>;
        get currentData(): ASTv1.TextNode;
        acceptTemplate(node: HBS.Program): ASTv1.Template;
        acceptNode(node: HBS.Program): ASTv1.Block | ASTv1.Template;
        acceptNode<U extends HBS.Node | ASTv1.Node>(node: HBS.Node): U;
        currentElement(): ASTv1.ParentNode;
        sourceForNode(node: HBS.Node, endNode?: {
            loc: HBS.SourceLocation;
        }): string;
    }
    // ensure stays in sync with typing
    // ParentNode and ChildKey types are derived from VisitorKeysMap
    const visitorKeys: {
        readonly Program: readonly [
            "body"
        ];
        readonly Template: readonly [
            "body"
        ];
        readonly Block: readonly [
            "body"
        ];
        readonly MustacheStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly BlockStatement: readonly [
            "path",
            "params",
            "hash",
            "program",
            "inverse"
        ];
        readonly ElementModifierStatement: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PartialStatement: readonly [
            "name",
            "params",
            "hash"
        ];
        readonly CommentStatement: readonly [
        ];
        readonly MustacheCommentStatement: readonly [
        ];
        readonly ElementNode: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly AttrNode: readonly [
            "value"
        ];
        readonly TextNode: readonly [
        ];
        readonly ConcatStatement: readonly [
            "parts"
        ];
        readonly SubExpression: readonly [
            "path",
            "params",
            "hash"
        ];
        readonly PathExpression: readonly [
        ];
        readonly PathHead: readonly [
        ];
        readonly StringLiteral: readonly [
        ];
        readonly BooleanLiteral: readonly [
        ];
        readonly NumberLiteral: readonly [
        ];
        readonly NullLiteral: readonly [
        ];
        readonly UndefinedLiteral: readonly [
        ];
        readonly Hash: readonly [
            "pairs"
        ];
        readonly HashPair: readonly [
            "value"
        ];
        readonly NamedBlock: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly SimpleElement: readonly [
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
        readonly Component: readonly [
            "head",
            "attributes",
            "modifiers",
            "children",
            "comments"
        ];
    };
    type VisitorKeysMap = typeof visitorKeys;
    type VisitorKeys = {
        [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number];
    };
    type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N["type"]] & keyof N;
    class WalkerPath<N extends ASTv1.Node> {
        node: N;
        parent: WalkerPath<ASTv1.Node> | null;
        parentKey: string | null;
        constructor(node: N, parent?: WalkerPath<ASTv1.Node> | null, parentKey?: string | null);
        get parentNode(): ASTv1.Node | null;
        parents(): Iterable<WalkerPath<ASTv1.Node> | null>;
    }
    interface FullNodeTraversal<N extends ASTv1.Node> {
        enter?(node: N, path: WalkerPath<N>): void;
        exit?(node: N, path: WalkerPath<N>): void;
        keys?: KeysVisitor<N>;
    }
    type NodeHandler<N extends ASTv1.Node> = (node: N, path: WalkerPath<N>) => void;
    type NodeTraversal<N extends ASTv1.Node> = FullNodeTraversal<N> | NodeHandler<N>;
    type NodeVisitor = {
        [P in keyof ASTv1.Nodes]?: NodeTraversal<ASTv1.Nodes[P]>;
    } & {
        All?: NodeTraversal<ASTv1.Node>;
    };
    interface FullKeyTraversal<N extends ASTv1.Node, K extends string> {
        enter?(node: N, key: K): void;
        exit?(node: N, key: K): void;
    }
    type KeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>> = (node: N, key: K) => void;
    type KeyTraversal<N extends ASTv1.Node, K extends VisitorKey<N>> = FullKeyTraversal<N, K> | KeyHandler<N, K>;
    type KeysVisitor<N extends ASTv1.Node> = {
        [P in VisitorKey<N>]?: KeyTraversal<N, P>;
    } & {
        All?: KeyTraversal<N, VisitorKey<N>>;
    };
    const voidMap: Set<string>;
    function getVoidTags(): string[];
    interface PrinterOptions {
        entityEncoding: "transformed" | "raw";
        /**
         * Used to override the mechanism of printing a given AST.Node.
         *
         * This will generally only be useful to source -> source codemods
         * where you would like to specialize/override the way a given node is
         * printed (e.g. you would like to preserve as much of the original
         * formatting as possible).
         *
         * When the provided override returns undefined, the default built in printing
         * will be done for the AST.Node.
         *
         * @param ast the ast node to be printed
         * @param options the options specified during the print() invocation
         */
        override?(ast: ASTv1.Node, options: PrinterOptions): void | string;
    }
    /**
     * Examples when true:
     *  - link
     *  - liNK
     *
     * Examples when false:
     *  - Link (component)
     */
    function isVoidTag(tag: string): boolean;
    class Printer {
        private buffer;
        private options;
        constructor(options: PrinterOptions);
        /*
        This is used by _all_ methods on this Printer class that add to `this.buffer`,
        it allows consumers of the printer to use alternate string representations for
        a given node.
        
        The primary use case for this are things like source -> source codemod utilities.
        For example, ember-template-recast attempts to always preserve the original string
        formatting in each AST node if no modifications are made to it.
        */
        handledByOverride(node: ASTv1.Node, ensureLeadingWhitespace?: boolean): boolean;
        Node(node: ASTv1.Node): void;
        Expression(expression: ASTv1.Expression): void;
        Literal(literal: ASTv1.Literal): void;
        TopLevelStatement(statement: ASTv1.TopLevelStatement | ASTv1.Template | ASTv1.AttrNode): void;
        Block(block: ASTv1.Block | ASTv1.Program | ASTv1.Template): void;
        TopLevelStatements(statements: ASTv1.TopLevelStatement[]): void;
        ElementNode(el: ASTv1.ElementNode): void;
        OpenElementNode(el: ASTv1.ElementNode): void;
        CloseElementNode(el: ASTv1.ElementNode): void;
        AttrNode(attr: ASTv1.AttrNode): void;
        AttrNodeValue(value: ASTv1.AttrNode["value"]): void;
        TextNode(text: ASTv1.TextNode, isAttr?: boolean): void;
        MustacheStatement(mustache: ASTv1.MustacheStatement): void;
        BlockStatement(block: ASTv1.BlockStatement): void;
        BlockParams(blockParams: string[]): void;
        PartialStatement(partial: ASTv1.PartialStatement): void;
        ConcatStatement(concat: ASTv1.ConcatStatement): void;
        MustacheCommentStatement(comment: ASTv1.MustacheCommentStatement): void;
        ElementModifierStatement(mod: ASTv1.ElementModifierStatement): void;
        CommentStatement(comment: ASTv1.CommentStatement): void;
        PathExpression(path: ASTv1.PathExpression): void;
        SubExpression(sexp: ASTv1.SubExpression): void;
        Params(params: ASTv1.Expression[]): void;
        Hash(hash: ASTv1.Hash): void;
        HashPair(pair: ASTv1.HashPair): void;
        StringLiteral(str: ASTv1.StringLiteral): void;
        BooleanLiteral(bool: ASTv1.BooleanLiteral): void;
        NumberLiteral(number: ASTv1.NumberLiteral): void;
        UndefinedLiteral(node: ASTv1.UndefinedLiteral): void;
        NullLiteral(node: ASTv1.NullLiteral): void;
        print(node: ASTv1.Node): string;
    }
    function build(ast: ASTv1.Node, options?: PrinterOptions): string;
    const print: typeof build;
    function traverse(node: ASTv1.Node, visitor: NodeVisitor): void;
    type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;
    class Walker {
        order?: unknown;
        stack: unknown[];
        constructor(order?: unknown);
        visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void;
        children<N extends ASTv1.Node>(node: N & ASTv1.Node, callback: NodeCallback<N & ASTv1.Node>): void;
    }
    // const SOURCE = new Source('', '(tests)');
    // Statements
    type BuilderHead = string | ASTv1.Expression;
    type TagDescriptor = string | {
        name: string;
        selfClosing: boolean;
    };
    function buildMustache(path: BuilderHead | ASTv1.Literal, params?: ASTv1.Expression[], hash?: ASTv1.Hash, raw?: boolean, loc?: SourceLocation, strip?: ASTv1.StripFlags): ASTv1.MustacheStatement;
    function buildBlock(path: BuilderHead, params: Nullable<ASTv1.Expression[]>, hash: Nullable<ASTv1.Hash>, _defaultBlock: ASTv1.PossiblyDeprecatedBlock, _elseBlock?: Nullable<ASTv1.PossiblyDeprecatedBlock>, loc?: SourceLocation, openStrip?: ASTv1.StripFlags, inverseStrip?: ASTv1.StripFlags, closeStrip?: ASTv1.StripFlags): ASTv1.BlockStatement;
    function buildElementModifier(path: BuilderHead | ASTv1.Expression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: Nullable<SourceLocation>): ASTv1.ElementModifierStatement;
    function buildPartial(name: ASTv1.PathExpression, params?: ASTv1.Expression[], hash?: ASTv1.Hash, indent?: string, loc?: SourceLocation): ASTv1.PartialStatement;
    function buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement;
    function buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement;
    function buildConcat(parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[], loc?: SourceLocation): ASTv1.ConcatStatement;
    // Nodes
    type ElementParts = [
        "attrs",
        ...AttrSexp[]
    ] | [
        "modifiers",
        ...ModifierSexp[]
    ] | [
        "body",
        ...ASTv1.Statement[]
    ] | [
        "comments",
        ...ElementComment[]
    ] | [
        "as",
        ...string[]
    ] | [
        "loc",
        SourceLocation
    ];
    type PathSexp = string | [
        "path",
        string,
        LocSexp?
    ];
    type ModifierSexp = string | [
        PathSexp,
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        LocSexp?
    ] | [
        PathSexp,
        ASTv1.Expression[],
        Dict<ASTv1.Expression>,
        LocSexp?
    ];
    type AttrSexp = [
        string,
        ASTv1.AttrNode["value"] | string,
        LocSexp?
    ];
    type LocSexp = [
        "loc",
        SourceLocation
    ];
    type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;
    type SexpValue = string | ASTv1.Expression[] | Dict<ASTv1.Expression> | LocSexp | PathSexp | undefined;
    interface BuildElementOptions {
        attrs?: ASTv1.AttrNode[];
        modifiers?: ASTv1.ElementModifierStatement[];
        children?: ASTv1.Statement[];
        comments?: ElementComment[];
        blockParams?: string[];
        loc?: SourceSpan;
    }
    function buildElement(tag: TagDescriptor, options?: BuildElementOptions): ASTv1.ElementNode;
    function buildAttr(name: string, value: ASTv1.AttrNode["value"], loc?: SourceLocation): ASTv1.AttrNode;
    function buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode;
    // Expressions
    function buildSexpr(path: BuilderHead, params?: ASTv1.Expression[], hash?: ASTv1.Hash, loc?: SourceLocation): ASTv1.SubExpression;
    function buildThis(loc: SourceLocation): ASTv1.PathHead;
    function buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildVar(name: string, loc: SourceLocation): ASTv1.PathHead;
    function buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead;
    function buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName;
    function buildCleanPath(head: ASTv1.PathHead, tail: string[], loc: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.PathExpression | string | {
        head: string;
        tail: string[];
    }, loc?: SourceLocation): ASTv1.PathExpression;
    function buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;
    function buildLiteral<T extends ASTv1.Literal>(type: T["type"], value: T["value"], loc?: SourceLocation): T;
    // Miscellaneous
    function buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash;
    function buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair;
    function buildProgram(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildBlockItself(body?: ASTv1.Statement[], blockParams?: string[], chained?: boolean, loc?: SourceLocation): ASTv1.Block;
    function buildTemplate(body?: ASTv1.Statement[], blockParams?: string[], loc?: SourceLocation): ASTv1.Template;
    function buildPosition(line: number, column: number): SourcePosition;
    function buildLoc(loc: Nullable<SourceLocation>): SourceSpan;
    function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): SourceSpan;
    const _default: {
        mustache: typeof buildMustache;
        block: typeof buildBlock;
        partial: typeof buildPartial;
        comment: typeof buildComment;
        mustacheComment: typeof buildMustacheComment;
        element: typeof buildElement;
        elementModifier: typeof buildElementModifier;
        attr: typeof buildAttr;
        text: typeof buildText;
        sexpr: typeof buildSexpr;
        concat: typeof buildConcat;
        hash: typeof buildHash;
        pair: typeof buildPair;
        literal: typeof buildLiteral;
        program: typeof buildProgram;
        blockItself: typeof buildBlockItself;
        template: typeof buildTemplate;
        loc: typeof buildLoc;
        pos: typeof buildPosition;
        path: typeof buildPath;
        fullPath: typeof buildCleanPath;
        head: typeof buildHeadFromString;
        at: typeof buildAtName;
        var: typeof buildVar;
        this: typeof buildThis;
        blockName: typeof buildNamedBlockName;
        string: (value: string) => ASTv1.StringLiteral;
        boolean: (value: boolean) => ASTv1.BooleanLiteral;
        number: (value: number) => ASTv1.NumberLiteral;
        undefined(): ASTv1.UndefinedLiteral;
        null(): ASTv1.NullLiteral;
    };
    const publicBuilder: typeof _default;
    abstract class HandlebarsNodeVisitors extends Parser {
        abstract appendToCommentData(s: string): void;
        abstract beginAttributeValue(quoted: boolean): void;
        abstract finishAttributeValue(): void;
        private get isTopLevel();
        Program(program: HBS.Program): ASTv1.Block;
        Program(program: HBS.Program): ASTv1.Template;
        Program(program: HBS.Program): ASTv1.Template | ASTv1.Block;
        BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void;
        MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void;
        appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void;
        finalizeTextPart(): void;
        startTextPart(): void;
        ContentStatement(content: HBS.ContentStatement): void;
        CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement>;
        PartialStatement(partial: HBS.PartialStatement): never;
        PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never;
        Decorator(decorator: HBS.Decorator): never;
        DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never;
        SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression;
        PathExpression(path: HBS.PathExpression): ASTv1.PathExpression;
        Hash(hash: HBS.Hash): ASTv1.Hash;
        StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral;
        BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral;
        NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral;
        UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral;
        NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral;
    }
    class TokenizerEventHandlers extends HandlebarsNodeVisitors {
        private tagOpenLine;
        private tagOpenColumn;
        reset(): void;
        // Comment
        beginComment(): void;
        appendToCommentData(char: string): void;
        finishComment(): void;
        // Data
        beginData(): void;
        appendToData(char: string): void;
        finishData(): void;
        // Tags - basic
        tagOpen(): void;
        beginStartTag(): void;
        beginEndTag(): void;
        finishTag(): void;
        finishStartTag(): void;
        finishEndTag(isVoid: boolean): void;
        markTagAsSelfClosing(): void;
        // Tags - name
        appendToTagName(char: string): void;
        // Tags - attributes
        beginAttribute(): void;
        appendToAttributeName(char: string): void;
        beginAttributeValue(isQuoted: boolean): void;
        appendToAttributeValue(char: string): void;
        finishAttributeValue(): void;
        reportSyntaxError(message: string): void;
        assembleConcatenatedValue(parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[]): ASTv1.ConcatStatement;
        validateEndTag(tag: Tag<"StartTag" | "EndTag">, element: ASTv1.ElementNode, selfClosing: boolean): void;
        assembleAttributeValue(parts: ASTv1.AttrPart[], isQuoted: boolean, isDynamic: boolean, span: src.SourceSpan): ASTv1.AttrValue;
    }
    /**
     ASTPlugins can make changes to the Glimmer template AST before
     compilation begins.
     */
    interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {
        (env: TEnv): ASTPlugin;
    }
    interface ASTPlugin {
        name: string;
        visitor: NodeVisitor;
    }
    interface ASTPluginEnvironment {
        meta?: object;
        syntax: Syntax;
    }
    interface HandlebarsParseOptions {
        srcName?: string;
        ignoreStandalone?: boolean;
    }
    interface TemplateIdFn {
        (src: string): Nullable<string>;
    }
    interface PrecompileOptions extends PreprocessOptions {
        id?: TemplateIdFn;
        customizeComponentName?: ((input: string) => string) | undefined;
    }
    interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {
        lexicalScope: (variable: string) => boolean;
    }
    interface PreprocessOptions {
        strictMode?: boolean;
        locals?: string[];
        meta?: {
            moduleName?: string;
        };
        plugins?: {
            ast?: ASTPluginBuilder[];
        };
        parseOptions?: HandlebarsParseOptions;
        customizeComponentName?: ((input: string) => string) | undefined;
        /**
         Useful for specifying a group of options together.
         
         When `'codemod'` we disable all whitespace control in handlebars
         (to preserve as much as possible) and we also avoid any
         escaping/unescaping of HTML entity codes.
         */
        mode?: "codemod" | "precompile";
    }
    interface Syntax {
        parse: typeof preprocess;
        builders: typeof publicBuilder;
        print: typeof print;
        traverse: typeof traverse;
        Walker: typeof Walker;
    }
    function preprocess(input: string | src.Source | HBS.Program, options?: PreprocessOptions): ASTv1.Template;
    class Source {
        readonly source: string;
        readonly module: string;
        static from(source: string, options?: PrecompileOptions): Source;
        constructor(source: string, module?: string);
        /**
         * Validate that the character offset represents a position in the source string.
         */
        check(offset: number): boolean;
        slice(start: number, end: number): string;
        offsetFor(line: number, column: number): SourceOffset;
        spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan;
        hbsPosFor(offset: number): Nullable<SourcePosition>;
        charPosFor(position: SourcePosition): number | null;
    }
    enum OffsetKind {
        /**
         * We have already computed the character position of this offset or span.
         */
        CharPosition = "CharPosition",
        /**
         * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its
         * character position will be computed on demand.
         */
        HbsPosition = "HbsPosition",
        /**
         * for (rare) situations where a node is created but there was no source location (e.g. the name
         * "default" in default blocks when the word "default" never appeared in source). This is used
         * by the internals when there is a legitimate reason for the internals to synthesize a node
         * with no location.
         */
        InternalsSynthetic = "InternalsSynthetic",
        /**
         * For situations where a node represents zero parts of the source (for example, empty arguments).
         * In general, we attempt to assign these nodes *some* position (empty arguments can be
         * positioned immediately after the callee), but it's not always possible
         */
        NonExistent = "NonExistent",
        /**
         * For situations where a source location was expected, but it didn't correspond to the node in
         * the source. This happens if a plugin creates broken locations.
         */
        Broken = "Broken"
    }
    /**
     * This file implements the DSL used by span and offset in places where they need to exhaustively
     * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
     * offsets).
     *
     * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
     * removed.
     */
    const MatchAny = "MATCH_ANY";
    type MatchAny = "MATCH_ANY";
    type Matches = "Char,Hbs" | "Hbs,Char" | "Hbs,Hbs" | "Char,Char" | "Invisible,Any" | "Any,Invisible";
    const IsInvisible = "IS_INVISIBLE";
    type IsInvisible = "IS_INVISIBLE";
    type Pattern = OffsetKind | IsInvisible | MatchAny;
    class When<Out> {
        _map: Map<Pattern, Out>;
        get(pattern: Pattern, or: () => Out): Out;
        add(pattern: Pattern, out: Out): void;
        match(kind: OffsetKind): Out[];
    }
    type ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> = Exclude<In, Removed> extends never ? ExhaustiveMatcher<Out> : Matcher<Out, Exclude<In, Removed>>;
    type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;
    interface ExhaustiveMatcher<Out> {
        check(): MatchFn<Out>;
    }
    function match<Out>(callback: (m: Matcher<Out>) => ExhaustiveMatcher<Out>): MatchFn<Out>;
    class Matcher<Out, M extends Matches = Matches> {
        _whens: When<When<(left: PositionData, right: PositionData) => Out>>;
        /**
         * You didn't exhaustively match all possibilities.
         */
        protected check(): MatchFn<Out>;
        private matchFor;
        // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness
        // checking so that matchers can ensure they've actually covered all the cases (and TypeScript
        // will treat it as an exhaustive match).
        when(left: OffsetKind.CharPosition, right: OffsetKind.HbsPosition, callback: (left: CharPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Char,Hbs">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.CharPosition, callback: (left: HbsPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Char">;
        when(left: OffsetKind.HbsPosition, right: OffsetKind.HbsPosition, callback: (left: HbsPosition, right: HbsPosition) => Out): ExhaustiveCheck<Out, M, "Hbs,Hbs">;
        when(left: OffsetKind.CharPosition, right: OffsetKind.CharPosition, callback: (left: CharPosition, right: CharPosition) => Out): ExhaustiveCheck<Out, M, "Char,Char">;
        when(left: IsInvisible, right: MatchAny, callback: (left: InvisiblePosition, right: PositionData) => Out): Matcher<Out, Exclude<M, "Invisible,Any">>;
        when(left: MatchAny, right: IsInvisible, callback: (left: PositionData, right: InvisiblePosition) => Out): ExhaustiveCheck<Out, M, "Any,Invisible">;
        when(left: MatchAny, right: MatchAny, callback: (left: PositionData, right: PositionData) => Out): ExhaustiveMatcher<Out>;
    }
    /**
     * All spans have these details in common.
     */
    interface SpanData {
        readonly kind: OffsetKind;
        /**
         * Convert this span into a string. If the span is broken, return `''`.
         */
        asString(): string;
        /**
         * Gets the module the span was located in.
         */
        getModule(): string;
        /**
         * Get the starting position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getStart(): AnyPosition;
        /**
         * Get the ending position for this span. Try to avoid creating new position objects, as they
         * cache computations.
         */
        getEnd(): AnyPosition;
        /**
         * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.
         */
        toHbsSpan(): HbsSpan | null;
        /**
         * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are
         * notified of the change so they can update themselves. This shouldn't happen outside of AST
         * plugins.
         */
        locDidUpdate(changes: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        /**
         * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in
         * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.
         */
        serialize(): SerializedSourceSpan;
    }
    /**
     * A `SourceSpan` object represents a span of characters inside of a template source.
     *
     * There are three kinds of `SourceSpan` objects:
     *
     * - `ConcreteSourceSpan`, which contains byte offsets
     * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
     *   converted to byte offsets on demand.
     * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
     *   because:
     *     - they were created synthetically
     *     - their location is nonsensical (the span is broken)
     *     - they represent nothing in the source (this currently happens only when a bug in the
     *       upstream Handlebars parser fails to assign a location to empty blocks)
     *
     * At a high level, all `SourceSpan` objects provide:
     *
     * - byte offsets
     * - source in column and line format
     *
     * And you can do these operations on `SourceSpan`s:
     *
     * - collapse it to a `SourceSpan` representing its starting or ending position
     * - slice out some characters, optionally skipping some characters at the beginning or end
     * - create a new `SourceSpan` with a different starting or ending offset
     *
     * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
     * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
     *
     * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
     * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
     *
     * The goal is to avoid creating any problems for use-cases like AST Explorer.
     */
    class SourceSpan implements SourceLocation {
        private data;
        static get NON_EXISTENT(): SourceSpan;
        static load(source: Source, serialized: SerializedSourceSpan): SourceSpan;
        static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan;
        static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan;
        static synthetic(chars: string): SourceSpan;
        static broken(pos?: SourceLocation): SourceSpan;
        readonly isInvisible: boolean;
        constructor(data: SpanData & AnySpan);
        getStart(): SourceOffset;
        getEnd(): SourceOffset;
        get loc(): SourceLocation;
        get module(): string;
        /**
         * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get startPosition(): SourcePosition;
        /**
         * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
         */
        get endPosition(): SourcePosition;
        /**
         * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
         */
        toJSON(): SourceLocation;
        /**
         * Create a new span with the current span's end and a new beginning.
         */
        withStart(other: SourceOffset): SourceSpan;
        /**
         * Create a new span with the current span's beginning and a new ending.
         */
        withEnd(this: SourceSpan, other: SourceOffset): SourceSpan;
        asString(): string;
        /**
         * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
         * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
         * string.
         */
        toSlice(expected?: string): SourceSlice;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use startPosition instead
         */
        get start(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withStart instead
         */
        set start(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use endPosition instead
         */
        get end(): SourcePosition;
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use withEnd instead
         */
        set end(position: SourcePosition);
        /**
         * For compatibility with SourceLocation in AST plugins
         *
         * @deprecated use module instead
         */
        get source(): string;
        collapse(where: "start" | "end"): SourceSpan;
        extend(other: SourceSpan): SourceSpan;
        serialize(): SerializedSourceSpan;
        slice({ skipStart, skipEnd }: {
            skipStart?: number;
            skipEnd?: number;
        }): SourceSpan;
        sliceStartChars({ skipStart, chars }: {
            skipStart?: number;
            chars: number;
        }): SourceSpan;
        sliceEndChars({ skipEnd, chars }: {
            skipEnd?: number;
            chars: number;
        }): SourceSpan;
    }
    type AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;
    class CharPositionSpan implements SpanData {
        readonly source: Source;
        readonly charPositions: {
            start: CharPosition;
            end: CharPosition;
        };
        readonly kind = OffsetKind.CharPosition;
        _locPosSpan: HbsSpan | BROKEN | null;
        constructor(source: Source, charPositions: {
            start: CharPosition;
            end: CharPosition;
        });
        wrap(): SourceSpan;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        locDidUpdate(): void;
        toHbsSpan(): HbsSpan | null;
        serialize(): SerializedSourceSpan;
        toCharPosSpan(): CharPositionSpan;
    }
    class HbsSpan implements SpanData {
        readonly source: Source;
        readonly hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        };
        readonly kind = OffsetKind.HbsPosition;
        _charPosSpan: CharPositionSpan | BROKEN | null;
        // the source location from Handlebars + AST Plugins -- could be wrong
        _providedHbsLoc: SourceLocation | null;
        constructor(source: Source, hbsPositions: {
            start: HbsPosition;
            end: HbsPosition;
        }, providedHbsLoc?: SourceLocation | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        private updateProvided;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        asString(): string;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toHbsLoc(): SourceLocation;
        toHbsSpan(): HbsSpan;
        toCharPosSpan(): CharPositionSpan | null;
    }
    class InvisibleSpan implements SpanData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly loc: SourceLocation;
        // if the span represents a synthetic string
        readonly string: string | null;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, loc: SourceLocation, string?: string | null);
        serialize(): SerializedConcreteSourceSpan;
        wrap(): SourceSpan;
        asString(): string;
        locDidUpdate({ start, end }: {
            start?: SourcePosition;
            end?: SourcePosition;
        }): void;
        getModule(): string;
        getStart(): AnyPosition;
        getEnd(): AnyPosition;
        toCharPosSpan(): InvisibleSpan;
        toHbsSpan(): null;
        toHbsLoc(): SourceLocation;
    }
    const span: MatchFn<SourceSpan>;
    type SerializedConcreteSourceSpan = /** collapsed */ number | /** normal */ [
        start: number,
        size: number
    ] | /** synthetic */ string;
    type SerializedSourceSpan = SerializedConcreteSourceSpan | OffsetKind.NonExistent | OffsetKind.Broken;
    /**
     * All positions have these details in common. Most notably, all three kinds of positions can
     * must be able to attempt to convert themselves into {@see CharPosition}.
     */
    interface PositionData {
        readonly kind: OffsetKind;
        toCharPos(): CharPosition | null;
        toJSON(): SourcePosition;
    }
    /**
     * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It
     * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet
     * attempted (and therefore to cache the failure)
     */
    const BROKEN = "BROKEN";
    type BROKEN = "BROKEN";
    type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;
    /**
     * A `SourceOffset` represents a single position in the source.
     *
     * There are three kinds of backing data for `SourceOffset` objects:
     *
     * - `CharPosition`, which contains a character offset into the raw source string
     * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be
     *   converted to a `CharPosition` on demand.
     * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})
     */
    class SourceOffset {
        readonly data: PositionData & AnyPosition;
        /**
         * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted
         * into a character offset on demand, which avoids unnecessarily computing the offset of every
         * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.
         */
        static forHbsPos(source: Source, pos: SourcePosition): SourceOffset;
        /**
         * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the
         * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to
         * any part of the source.
         */
        static broken(pos?: SourcePosition): SourceOffset;
        constructor(data: PositionData & AnyPosition);
        /**
         * Get the character offset for this `SourceOffset`, if possible.
         */
        get offset(): number | null;
        /**
         * Compare this offset with another one.
         *
         * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are
         * the same. This avoids computing offsets unnecessarily.
         *
         * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets
         * are the same.
         */
        eql(right: SourceOffset): boolean;
        /**
         * Create a span that starts from this source offset and ends with another source offset. Avoid
         * computing character offsets if both `SourceOffset`s are still lazy.
         */
        until(other: SourceOffset): SourceSpan;
        /**
         * Create a `SourceOffset` by moving the character position represented by this source offset
         * forward or backward (if `by` is negative), if possible.
         *
         * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.
         *
         * If the resulting character offset is less than 0 or greater than the size of the source, `move`
         * returns a broken offset.
         */
        move(by: number): SourceOffset;
        /**
         * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid
         * computing the character offset if it has not already been computed.
         */
        collapsed(): SourceSpan;
        /**
         * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with
         * existing plugins.
         */
        toJSON(): SourcePosition;
    }
    class CharPosition implements PositionData {
        readonly source: Source;
        readonly charPos: number;
        readonly kind = OffsetKind.CharPosition;
        /** Computed from char offset */
        _locPos: HbsPosition | BROKEN | null;
        constructor(source: Source, charPos: number);
        /**
         * This is already a `CharPosition`.
         *
         * {@see HbsPosition} for the alternative.
         */
        toCharPos(): CharPosition;
        /**
         * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was
         * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * A `CharPosition` always has an offset it can produce without any additional computation.
         */
        get offset(): number;
        /**
         * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once
         * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and
         * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so
         * computing the `HbsPosition` should be a one-time operation.
         */
        toHbsPos(): HbsPosition | null;
    }
    class HbsPosition implements PositionData {
        readonly source: Source;
        readonly hbsPos: SourcePosition;
        readonly kind = OffsetKind.HbsPosition;
        _charPos: CharPosition | BROKEN | null;
        constructor(source: Source, hbsPos: SourcePosition, charPos?: number | null);
        /**
         * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has
         * computed its `CharPosition`, it will not need to do compute it again, and the same
         * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the
         * `CharPosition` should be a one-time operation.
         */
        toCharPos(): CharPosition | null;
        /**
         * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation
         * does not need to compute anything.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        /**
         * This is already an `HbsPosition`.
         *
         * {@see CharPosition} for the alternative.
         */
        toHbsPos(): HbsPosition;
    }
    class InvisiblePosition implements PositionData {
        readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent;
        // whatever was provided, possibly broken
        readonly pos: SourcePosition;
        constructor(kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent, pos: SourcePosition);
        /**
         * A broken position cannot be turned into a {@see CharacterPosition}.
         */
        toCharPos(): null;
        /**
         * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was
         * originally identified as broken, non-existent or synthetic.
         *
         * If an `InvisiblePosition` never had an source offset at all, this method returns
         * {@see UNKNOWN_POSITION} for compatibility.
         */
        toJSON(): SourcePosition;
        wrap(): SourceOffset;
        get offset(): null;
    }
    /**
     * Attr nodes look like HTML attributes, but are classified as:
     *
     * 1. `HtmlAttr`, which means a regular HTML attribute in Glimmer
     * 2. `SplatAttr`, which means `...attributes`
     * 3. `ComponentArg`, which means an attribute whose name begins with `@`, and it is therefore a
     *    component argument.
     */
    type AttrNode = HtmlAttr | SplatAttr | ComponentArg;
    /**
     * `HtmlAttr` and `SplatAttr` are grouped together because the order of the `SplatAttr` node,
     * relative to other attributes, matters.
     */
    type HtmlOrSplatAttr = HtmlAttr | SplatAttr;
    /**
     * "Attr Block" nodes are allowed inside an open element tag in templates. They interact with the
     * element (or component).
     */
    type AttrBlockNode = AttrNode | ElementModifier;
    interface BaseNodeFields {
        loc: SourceSpan;
    }
    /**
     * This is a convenience function for creating ASTv2 nodes, with an optional name and the node's
     * options.
     *
     * ```ts
     * export class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}
     * ```
     *
     * This creates a new ASTv2 node with the name `'HtmlText'` and one field `chars: string` (in
     * addition to a `loc: SourceOffsets` field, which all nodes have).
     *
     * ```ts
     * export class Args extends node().fields<{
     *  positional: PositionalArguments;
     *  named: NamedArguments
     * }>() {}
     * ```
     *
     * This creates a new un-named ASTv2 node with two fields (`positional: Positional` and `named:
     * Named`, in addition to the generic `loc: SourceOffsets` field).
     *
     * Once you create a node using `node`, it is instantiated with all of its fields (including `loc`):
     *
     * ```ts
     * new HtmlText({ loc: offsets, chars: someString });
     * ```
     */
    function node(): {
        fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;
    };
    function node<T extends string>(name: T): {
        fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;
    };
    interface NodeConstructor<Fields> {
        new (fields: Fields): Readonly<Fields>;
    }
    type TypedNode<T extends string, Fields> = {
        type: T;
    } & Readonly<Fields>;
    interface TypedNodeConstructor<T extends string, Fields> {
        new (options: Fields): TypedNode<T, Fields>;
    }
    const HtmlAttr_base: TypedNodeConstructor<"HtmlAttr", AttrNodeOptions & BaseNodeFields>;
    /**
     * `HtmlAttr` nodes are valid HTML attributes, with or without a value.
     *
     * Exceptions:
     *
     * - `...attributes` is `SplatAttr`
     * - `@x=<value>` is `ComponentArg`
     */
    class HtmlAttr extends HtmlAttr_base {
    }
    const SplatAttr_base: TypedNodeConstructor<"SplatAttr", {
        symbol: number;
    } & BaseNodeFields>;
    class SplatAttr extends SplatAttr_base {
    }
    const ComponentArg_base: NodeConstructor<AttrNodeOptions & BaseNodeFields>;
    /**
     * Corresponds to an argument passed by a component (`@x=<value>`)
     */
    class ComponentArg extends ComponentArg_base {
        /**
         * Convert the component argument into a named argument node
         */
        toNamedArgument(): NamedArgument;
    }
    const ElementModifier_base: TypedNodeConstructor<"ElementModifier", CallFields & BaseNodeFields>;
    /**
     * An `ElementModifier` is just a normal call node in modifier position.
     */
    class ElementModifier extends ElementModifier_base {
    }
    interface AttrNodeOptions {
        name: SourceSlice;
        value: ExpressionNode;
        trusting: boolean;
    }
    interface Upvar {
        readonly name: string;
        readonly resolution: ASTv2.FreeVarResolution;
    }
    interface SymbolTableOptions {
        customizeComponentName: (input: string) => string;
        lexicalScope: (variable: string) => boolean;
    }
    abstract class SymbolTable {
        static top(locals: string[], options: SymbolTableOptions): ProgramSymbolTable;
        abstract has(name: string): boolean;
        abstract get(name: string): [
            symbol: number,
            isRoot: boolean
        ];
        abstract hasLexical(name: string): boolean;
        abstract getLexical(name: string): number;
        abstract getLocalsMap(): Dict<number>;
        abstract getDebugInfo(): Core.DebugInfo;
        abstract setHasDebugger(): void;
        abstract allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
        abstract allocateNamed(name: string): number;
        abstract allocateBlock(name: string): number;
        abstract allocate(identifier: string): number;
        child(locals: string[]): BlockSymbolTable;
    }
    class ProgramSymbolTable extends SymbolTable {
        #private;
        private templateLocals;
        private options;
        constructor(templateLocals: string[], options: SymbolTableOptions);
        symbols: string[];
        upvars: string[];
        private size;
        private named;
        private blocks;
        private usedTemplateLocals;
        hasLexical(name: string): boolean;
        getLexical(name: string): number;
        getUsedTemplateLocals(): string[];
        setHasDebugger(): void;
        get hasEval(): boolean;
        has(name: string): boolean;
        get(name: string): [
            number,
            boolean
        ];
        getLocalsMap(): Dict<number>;
        getDebugInfo(): Core.DebugInfo;
        allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
        allocateNamed(name: string): number;
        allocateBlock(name: string): number;
        allocate(identifier: string): number;
    }
    class BlockSymbolTable extends SymbolTable {
        #private;
        private parent;
        symbols: string[];
        slots: number[];
        constructor(parent: SymbolTable, symbols: string[], slots: number[]);
        get locals(): string[];
        getLexical(name: string): number;
        hasLexical(name: string): boolean;
        has(name: string): boolean;
        get(name: string): [
            number,
            boolean
        ];
        getLocalsMap(): Dict<number>;
        getDebugInfo(): Core.DebugInfo;
        setHasDebugger(): void;
        allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
        allocateNamed(name: string): number;
        allocateBlock(name: string): number;
        allocate(identifier: string): number;
    }
    const Template_base: NodeConstructor<{
        table: ProgramSymbolTable;
    } & GlimmerParentNodeOptions & BaseNodeFields>;
    /**
     * Corresponds to an entire template.
     */
    class Template extends Template_base {
    }
    const Block_base: NodeConstructor<{
        scope: BlockSymbolTable;
    } & GlimmerParentNodeOptions & BaseNodeFields>;
    /**
     * Represents a block. In principle this could be merged with `NamedBlock`, because all cases
     * involving blocks have at least a notional name.
     */
    class Block extends Block_base {
    }
    const NamedBlocks_base: NodeConstructor<{
        blocks: readonly NamedBlock[];
    } & BaseNodeFields>;
    /**
     * Corresponds to a collection of named blocks.
     */
    class NamedBlocks extends NamedBlocks_base {
        /**
         * Get the `NamedBlock` for a given name.
         */
        get(name: "default"): NamedBlock;
        get(name: string): NamedBlock | null;
    }
    interface NamedBlockFields extends BaseNodeFields {
        name: SourceSlice;
        block: Block;
        // these are not currently supported, but are here for future expansion
        attrs: readonly HtmlOrSplatAttr[];
        componentArgs: readonly ComponentArg[];
        modifiers: readonly ElementModifier[];
    }
    const NamedBlock_base: NodeConstructor<NamedBlockFields & BaseNodeFields>;
    /**
     * Corresponds to a single named block. This is used for anonymous named blocks (`default` and
     * `else`).
     */
    class NamedBlock extends NamedBlock_base {
        get args(): Args;
    }
    /**
     * Content Nodes are allowed in content positions in templates. They correspond to behavior in the
     * [Data][data] tokenization state in HTML.
     *
     * [data]: https://html.spec.whatwg.org/multipage/parsing.html#data-state
     */
    type ContentNode = HtmlText | HtmlComment | AppendContent | InvokeBlock | InvokeComponent | SimpleElement | GlimmerComment;
    const GlimmerComment_base: TypedNodeConstructor<"GlimmerComment", {
        text: SourceSlice;
    } & BaseNodeFields>;
    class GlimmerComment extends GlimmerComment_base {
    }
    const HtmlText_base: TypedNodeConstructor<"HtmlText", {
        chars: string;
    } & BaseNodeFields>;
    class HtmlText extends HtmlText_base {
    }
    const HtmlComment_base: TypedNodeConstructor<"HtmlComment", {
        text: SourceSlice;
    } & BaseNodeFields>;
    class HtmlComment extends HtmlComment_base {
    }
    const AppendContent_base: TypedNodeConstructor<"AppendContent", {
        value: ExpressionNode;
        trusting: boolean;
        table: SymbolTable;
    } & BaseNodeFields>;
    class AppendContent extends AppendContent_base {
        get callee(): ExpressionNode;
        get args(): Args;
    }
    const InvokeBlock_base: TypedNodeConstructor<"InvokeBlock", CallFields & {
        blocks: NamedBlocks;
    } & BaseNodeFields>;
    class InvokeBlock extends InvokeBlock_base {
    }
    interface InvokeComponentFields {
        callee: ExpressionNode;
        blocks: NamedBlocks;
        attrs: readonly HtmlOrSplatAttr[];
        componentArgs: readonly ComponentArg[];
        modifiers: readonly ElementModifier[];
    }
    const InvokeComponent_base: TypedNodeConstructor<"InvokeComponent", InvokeComponentFields & BaseNodeFields>;
    /**
     * Corresponds to a component invocation. When the content of a component invocation contains no
     * named blocks, `blocks` contains a single named block named `"default"`. When a component
     * invocation is self-closing, `blocks` is empty.
     */
    class InvokeComponent extends InvokeComponent_base {
        get args(): Args;
    }
    interface SimpleElementOptions extends BaseNodeFields {
        tag: SourceSlice;
        body: readonly ContentNode[];
        attrs: readonly HtmlOrSplatAttr[];
        componentArgs: readonly ComponentArg[];
        modifiers: readonly ElementModifier[];
    }
    const SimpleElement_base: TypedNodeConstructor<"SimpleElement", SimpleElementOptions & BaseNodeFields>;
    /**
     * Corresponds to a simple HTML element. The AST allows component arguments and modifiers to support
     * future extensions.
     */
    class SimpleElement extends SimpleElement_base {
        get args(): Args;
    }
    type ElementNode = NamedBlock | InvokeComponent | SimpleElement;
    interface SerializedBaseNode {
        loc: SerializedSourceSpan;
    }
    interface GlimmerParentNodeOptions extends BaseNodeFields {
        body: readonly ContentNode[];
    }
    interface CallFields extends BaseNodeFields {
        callee: ExpressionNode;
        args: Args;
    }
    type CallNode = CallExpression | InvokeBlock | AppendContent | InvokeComponent | ElementModifier;
    /**
     * Strict resolution is used:
     *
     * 1. in a strict mode template
     * 2. in an unambiguous invocation with dot paths
     */
    const STRICT_RESOLUTION: {
        resolution: () => GetContextualFreeOpcode;
        serialize: () => SerializedResolution;
        isAngleBracket: false;
    };
    type StrictResolution = typeof STRICT_RESOLUTION;
    const HTML_RESOLUTION: {
        isAngleBracket: true;
        resolution: () => GetContextualFreeOpcode;
        serialize: () => SerializedResolution;
    };
    type HtmlResolution = typeof HTML_RESOLUTION;
    function isStrictResolution(value: unknown): value is StrictResolution;
    /**
     * A `LooseModeResolution` includes:
     *
     * - 0 or more namespaces to resolve the variable in
     * - optional fallback behavior
     *
     * In practice, there are a limited number of possible combinations of these degrees of freedom,
     * and they are captured by the `Ambiguity` union below.
     */
    class LooseModeResolution {
        readonly ambiguity: Ambiguity;
        readonly isAngleBracket: boolean;
        /**
         * Namespaced resolution is used in an unambiguous syntax position:
         *
         * 1. `(sexp)` (namespace: `Helper`)
         * 2. `{{#block}}` (namespace: `Component`)
         * 3. `<a {{modifier}}>` (namespace: `Modifier`)
         * 4. `<Component />` (namespace: `Component`)
         *
         * @see {NamespacedAmbiguity}
         */
        static namespaced(namespace: FreeVarNamespace, isAngleBracket?: boolean): LooseModeResolution;
        /**
         * Fallback resolution is used when no namespaced resolutions are possible, but fallback
         * resolution is still allowed.
         *
         * ```hbs
         * {{x.y}}
         * ```
         *
         * @see {FallbackAmbiguity}
         */
        static fallback(): LooseModeResolution;
        /**
         * Append resolution is used when the variable should be resolved in both the `component` and
         * `helper` namespaces. Fallback resolution is optional.
         *
         * ```hbs
         * {{x}}
         * ```
         *
         * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
         *
         * ```hbs
         * {{x y}}
         * ```
         *
         * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
         * resolution.
         *
         * @see {ComponentOrHelperAmbiguity}
         */
        static append({ invoke }: {
            invoke: boolean;
        }): LooseModeResolution;
        /**
         * Trusting append resolution is used when the variable should be resolved in both the `component` and
         * `helper` namespaces. Fallback resolution is optional.
         *
         * ```hbs
         * {{{x}}}
         * ```
         *
         * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.
         *
         * ```hbs
         * {{{x y}}}
         * ```
         *
         * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback
         * resolution.
         *
         * @see {HelperAmbiguity}
         */
        static trustingAppend({ invoke }: {
            invoke: boolean;
        }): LooseModeResolution;
        /**
         * Attribute resolution is used when the variable should be resolved as a `helper` with fallback
         * resolution.
         *
         * ```hbs
         * <a href={{x}} />
         * <a href="{{x}}.html" />
         * ```
         *
         * ^ resolved in the `helper` namespace with fallback
         *
         * @see {HelperAmbiguity}
         */
        static attr(): LooseModeResolution;
        constructor(ambiguity: Ambiguity, isAngleBracket?: boolean);
        resolution(): GetContextualFreeOpcode;
        serialize(): SerializedResolution;
    }
    const ARGUMENT_RESOLUTION: LooseModeResolution;
    enum FreeVarNamespace {
        Helper = "Helper",
        Modifier = "Modifier",
        Component = "Component"
    }
    const HELPER_NAMESPACE = FreeVarNamespace.Helper;
    const MODIFIER_NAMESPACE = FreeVarNamespace.Modifier;
    const COMPONENT_NAMESPACE = FreeVarNamespace.Component;
    /**
     * A `ComponentOrHelperAmbiguity` might be a component or a helper, with an optional fallback
     *
     * ```hbs
     * {{x}}
     * ```
     *
     * ^ `x` is resolved in the `component` and `helper` namespaces, with fallback
     *
     * ```hbs
     * {{x y}}
     * ```
     *
     * ^ `x` is resolved in the `component` and `helper` namespaces, without fallback
     */
    type ComponentOrHelperAmbiguity = {
        namespaces: [
            FreeVarNamespace.Component,
            FreeVarNamespace.Helper
        ];
        fallback: boolean;
    };
    /**
     * A `HelperAmbiguity` must be a helper, but it has fallback. If it didn't have fallback, it would
     * be a `NamespacedAmbiguity`.
     *
     * ```hbs
     * <a href={{x}} />
     * <a href="{{x}}.html" />
     * ```
     *
     * ^ `x` is resolved in the `helper` namespace with fallback
     */
    type HelperAmbiguity = {
        namespaces: [
            FreeVarNamespace.Helper
        ];
        fallback: boolean;
    };
    /**
     * A `NamespacedAmbiguity` must be resolved in a particular namespace, without fallback.
     *
     * ```hbs
     * <X />
     * ```
     *
     * ^ `X` is resolved in the `component` namespace without fallback
     *
     * ```hbs
     * (x)
     * ```
     *
     * ^ `x` is resolved in the `helper` namespace without fallback
     *
     * ```hbs
     * <a {{x}} />
     * ```
     *
     * ^ `x` is resolved in the `modifier` namespace without fallback
     */
    type NamespacedAmbiguity = {
        namespaces: [
            FreeVarNamespace.Component | FreeVarNamespace.Helper | FreeVarNamespace.Modifier
        ];
        fallback: false;
    };
    type FallbackAmbiguity = {
        namespaces: [
        ];
        fallback: true;
    };
    type Ambiguity = ComponentOrHelperAmbiguity | HelperAmbiguity | NamespacedAmbiguity | FallbackAmbiguity;
    type FreeVarResolution = StrictResolution | HtmlResolution | LooseModeResolution;
    // Serialization
    const enum SerializedAmbiguity {
        // {{x}}
        Append = "Append",
        // href={{x}}
        Attr = "Attr",
        // {{x y}} (not attr)
        Invoke = "Invoke"
    }
    type SerializedResolution = "Strict" | "Loose" | [
        "ns",
        FreeVarNamespace
    ] | [
        "ambiguous",
        SerializedAmbiguity
    ];
    function loadResolution(resolution: SerializedResolution): FreeVarResolution;
    const ThisReference_base: TypedNodeConstructor<"This", object & BaseNodeFields>;
    /**
     * Corresponds to `this` at the head of an expression.
     */
    class ThisReference extends ThisReference_base {
    }
    const ArgReference_base: TypedNodeConstructor<"Arg", {
        name: SourceSlice;
        symbol: number;
    } & BaseNodeFields>;
    /**
     * Corresponds to `@<ident>` at the beginning of an expression.
     */
    class ArgReference extends ArgReference_base {
    }
    const LocalVarReference_base: TypedNodeConstructor<"Local", {
        name: string;
        isTemplateLocal: boolean;
        symbol: number;
    } & BaseNodeFields>;
    /**
     * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is in the current
     * block's scope.
     */
    class LocalVarReference extends LocalVarReference_base {
    }
    const FreeVarReference_base: TypedNodeConstructor<"Free", {
        name: string;
        resolution: FreeVarResolution;
        symbol: number;
    } & BaseNodeFields>;
    /**
     * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is *not* in the
     * current block's scope.
     *
     * The `resolution: FreeVarResolution` field describes how to resolve the free variable.
     *
     * Note: In strict mode, it must always be a variable that is in a concrete JavaScript scope that
     * the template will be installed into.
     */
    class FreeVarReference extends FreeVarReference_base {
    }
    type VariableReference = ThisReference | ArgReference | LocalVarReference | FreeVarReference;
    /**
     * A Handlebars literal.
     *
     * {@link https://handlebarsjs.com/guide/expressions.html#literal-segments}
     */
    type LiteralValue = string | boolean | number | undefined | null;
    interface LiteralTypes {
        string: string;
        boolean: boolean;
        number: number;
        null: null;
        undefined: undefined;
    }
    const LiteralExpression_base: TypedNodeConstructor<"Literal", {
        value: LiteralValue;
    } & BaseNodeFields>;
    /**
     * Corresponds to a Handlebars literal.
     *
     * @see {LiteralValue}
     */
    class LiteralExpression extends LiteralExpression_base {
        toSlice(this: StringLiteral): SourceSlice;
    }
    type StringLiteral = LiteralExpression & {
        value: string;
    };
    /**
     * Returns true if an input {@see ExpressionNode} is a literal.
     */
    function isLiteral<K extends keyof LiteralTypes = keyof LiteralTypes>(node: ExpressionNode, kind?: K): node is StringLiteral;
    const PathExpression_base: TypedNodeConstructor<"Path", {
        ref: VariableReference;
        tail: readonly SourceSlice[];
    } & BaseNodeFields>;
    /**
     * Corresponds to a path in expression position.
     *
     * ```hbs
     * this
     * this.x
     * @x
     * @x.y
     * x
     * x.y
     * ```
     */
    class PathExpression extends PathExpression_base {
    }
    const CallExpression_base: TypedNodeConstructor<"Call", CallFields & BaseNodeFields>;
    /**
     * Corresponds to a parenthesized call expression.
     *
     * ```hbs
     * (x)
     * (x.y)
     * (x y)
     * (x.y z)
     * ```
     */
    class CallExpression extends CallExpression_base {
    }
    const DeprecatedCallExpression_base: TypedNodeConstructor<"DeprecatedCall", {
        arg: SourceSlice;
        callee: FreeVarReference;
    } & BaseNodeFields>;
    /**
     * Corresponds to a possible deprecated helper call. Must be:
     *
     * 1. A free variable (not this.foo, not @foo, not local).
     * 2. Argument-less.
     * 3. In a component invocation's named argument position.
     * 4. Not parenthesized (not @bar={{(helper)}}).
     * 5. Not interpolated (not @bar="{{helper}}").
     *
     * ```hbs
     * <Foo @bar={{helper}} />
     * ```
     */
    class DeprecatedCallExpression extends DeprecatedCallExpression_base {
    }
    const InterpolateExpression_base: TypedNodeConstructor<"Interpolate", {
        parts: PresentArray<ExpressionNode>;
    } & BaseNodeFields>;
    /**
     * Corresponds to an interpolation in attribute value position.
     *
     * ```hbs
     * <a href="{{url}}.html"
     * ```
     */
    class InterpolateExpression extends InterpolateExpression_base {
    }
    type ExpressionNode = LiteralExpression | PathExpression | CallExpression | DeprecatedCallExpression | InterpolateExpression;
    const Args_base: NodeConstructor<{
        positional: PositionalArguments;
        named: NamedArguments;
    } & BaseNodeFields>;
    /**
     * Corresponds to syntaxes with positional and named arguments:
     *
     * - SubExpression
     * - Invoking Append
     * - Invoking attributes
     * - InvokeBlock
     *
     * If `Args` is empty, the `SourceOffsets` for this node should be the collapsed position
     * immediately after the parent call node's `callee`.
     */
    class Args extends Args_base {
        static empty(loc: SourceSpan): Args;
        static named(named: NamedArguments): Args;
        nth(offset: number): ExpressionNode | null;
        get(name: string): ExpressionNode | null;
        isEmpty(): boolean;
    }
    const PositionalArguments_base: NodeConstructor<{
        exprs: readonly ExpressionNode[];
    } & BaseNodeFields>;
    /**
     * Corresponds to positional arguments.
     *
     * If `PositionalArguments` is empty, the `SourceOffsets` for this node should be the collapsed
     * position immediately after the parent call node's `callee`.
     */
    class PositionalArguments extends PositionalArguments_base {
        static empty(loc: SourceSpan): PositionalArguments;
        get size(): number;
        nth(offset: number): ExpressionNode | null;
        isEmpty(): boolean;
    }
    const NamedArguments_base: NodeConstructor<{
        entries: readonly NamedArgument[];
    } & BaseNodeFields>;
    /**
     * Corresponds to named arguments.
     *
     * If `PositionalArguments` and `NamedArguments` are empty, the `SourceOffsets` for this node should
     * be the same as the `Args` node that contains this node.
     *
     * If `PositionalArguments` is not empty but `NamedArguments` is empty, the `SourceOffsets` for this
     * node should be the collapsed position immediately after the last positional argument.
     */
    class NamedArguments extends NamedArguments_base {
        static empty(loc: SourceSpan): NamedArguments;
        get size(): number;
        get(name: string): ExpressionNode | null;
        isEmpty(): boolean;
    }
    /**
     * Corresponds to a single named argument.
     *
     * ```hbs
     * x=<expr>
     * ```
     */
    class NamedArgument {
        readonly loc: SourceSpan;
        readonly name: SourceSlice;
        readonly value: ExpressionNode;
        constructor(options: {
            name: SourceSlice;
            value: ExpressionNode;
        });
    }
}
interface SymbolTableOptions {
    customizeComponentName: (input: string) => string;
    lexicalScope: (variable: string) => boolean;
}
declare abstract class SymbolTable {
    static top(locals: string[], options: SymbolTableOptions): ProgramSymbolTable;
    abstract has(name: string): boolean;
    abstract get(name: string): [
        symbol: number,
        isRoot: boolean
    ];
    abstract hasLexical(name: string): boolean;
    abstract getLexical(name: string): number;
    abstract getLocalsMap(): Dict<number>;
    abstract getDebugInfo(): Core.DebugInfo;
    abstract setHasDebugger(): void;
    abstract allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
    abstract allocateNamed(name: string): number;
    abstract allocateBlock(name: string): number;
    abstract allocate(identifier: string): number;
    child(locals: string[]): BlockSymbolTable;
}
declare class ProgramSymbolTable extends SymbolTable {
    #private;
    private templateLocals;
    private options;
    constructor(templateLocals: string[], options: SymbolTableOptions);
    symbols: string[];
    upvars: string[];
    private size;
    private named;
    private blocks;
    private usedTemplateLocals;
    hasLexical(name: string): boolean;
    getLexical(name: string): number;
    getUsedTemplateLocals(): string[];
    setHasDebugger(): void;
    get hasEval(): boolean;
    has(name: string): boolean;
    get(name: string): [
        number,
        boolean
    ];
    getLocalsMap(): Dict<number>;
    getDebugInfo(): Core.DebugInfo;
    allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
declare class BlockSymbolTable extends SymbolTable {
    #private;
    private parent;
    symbols: string[];
    slots: number[];
    constructor(parent: SymbolTable, symbols: string[], slots: number[]);
    get locals(): string[];
    getLexical(name: string): number;
    hasLexical(name: string): boolean;
    has(name: string): boolean;
    get(name: string): [
        number,
        boolean
    ];
    getLocalsMap(): Dict<number>;
    getDebugInfo(): Core.DebugInfo;
    setHasDebugger(): void;
    allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
interface GlimmerSyntaxError extends Error {
    location: src.SourceSpan | null;
    code: string | null;
}
declare function generateSyntaxError(message: string, location: src.SourceSpan): GlimmerSyntaxError;
interface TraversalError extends Error {
    constructor: TraversalErrorConstructor;
    key: string;
    node: ASTv1.Node;
    parent: Nullable<ASTv1.Node>;
    stack?: string;
}
interface TraversalErrorConstructor {
    new (message: string, node: ASTv1.Node, parent: Nullable<ASTv1.Node>, key: string): TraversalError;
    readonly prototype: TraversalError;
}
declare const TraversalError: TraversalErrorConstructor;
declare function cannotRemoveNode(node: ASTv1.Node, parent: ASTv1.Node, key: string): TraversalError;
declare function cannotReplaceNode(node: ASTv1.Node, parent: ASTv1.Node, key: string): TraversalError;
interface CallParts {
    callee: ASTv2.ExpressionNode;
    args: ASTv2.Args;
}
declare class Builder {
    // TEMPLATE //
    template(symbols: ProgramSymbolTable, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.Template;
    // INTERNAL (these nodes cannot be reached when doing general-purpose visiting) //
    block(symbols: BlockSymbolTable, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.Block;
    namedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock;
    simpleNamedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock;
    slice(chars: string, loc: SourceSpan): SourceSlice;
    args(positional: ASTv2.PositionalArguments, named: ASTv2.NamedArguments, loc: SourceSpan): ASTv2.Args;
    positional(exprs: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.PositionalArguments;
    namedArgument(key: SourceSlice, value: ASTv2.ExpressionNode): ASTv2.NamedArgument;
    named(entries: ASTv2.NamedArgument[], loc: SourceSpan): ASTv2.NamedArguments;
    attr({ name, value, trusting }: {
        name: SourceSlice;
        value: ASTv2.ExpressionNode;
        trusting: boolean;
    }, loc: SourceSpan): ASTv2.HtmlAttr;
    splatAttr(symbol: number, loc: SourceSpan): ASTv2.SplatAttr;
    arg({ name, value, trusting }: {
        name: SourceSlice;
        value: ASTv2.ExpressionNode;
        trusting: boolean;
    }, loc: SourceSpan): ASTv2.ComponentArg;
    // EXPRESSIONS //
    path(head: ASTv2.VariableReference, tail: SourceSlice[], loc: SourceSpan): ASTv2.PathExpression;
    self(loc: SourceSpan): ASTv2.VariableReference;
    at(name: string, symbol: number, loc: SourceSpan): ASTv2.VariableReference;
    freeVar({ name, context, symbol, loc }: {
        name: string;
        context: ASTv2.FreeVarResolution;
        symbol: number;
        loc: SourceSpan;
    }): ASTv2.FreeVarReference;
    localVar(name: string, symbol: number, isTemplateLocal: boolean, loc: SourceSpan): ASTv2.VariableReference;
    sexp(parts: CallParts, loc: SourceSpan): ASTv2.CallExpression;
    deprecatedCall(arg: SourceSlice, callee: ASTv2.FreeVarReference, loc: SourceSpan): ASTv2.DeprecatedCallExpression;
    interpolate(parts: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.InterpolateExpression;
    literal(value: string, loc: SourceSpan): ASTv2.LiteralExpression & {
        value: string;
    };
    literal(value: number, loc: SourceSpan): ASTv2.LiteralExpression & {
        value: number;
    };
    literal(value: boolean, loc: SourceSpan): ASTv2.LiteralExpression & {
        value: boolean;
    };
    literal(value: null, loc: SourceSpan): ASTv2.LiteralExpression & {
        value: null;
    };
    literal(value: undefined, loc: SourceSpan): ASTv2.LiteralExpression & {
        value: undefined;
    };
    literal(value: string | number | boolean | null | undefined, loc: SourceSpan): ASTv2.LiteralExpression;
    // STATEMENTS //
    append({ table, trusting, value }: {
        table: SymbolTable;
        trusting: boolean;
        value: ASTv2.ExpressionNode;
    }, loc: SourceSpan): ASTv2.AppendContent;
    modifier({ callee, args }: CallParts, loc: SourceSpan): ASTv2.ElementModifier;
    namedBlocks(blocks: ASTv2.NamedBlock[], loc: SourceSpan): ASTv2.NamedBlocks;
    blockStatement({ program, inverse, ...call }: {
        symbols: SymbolTable;
        program: ASTv2.Block;
        inverse?: ASTv2.Block | null;
    } & CallParts, loc: SourceSpan): ASTv2.InvokeBlock;
    element(options: BuildBaseElement): BuildElement;
}
interface BuildBaseElement {
    selfClosing: boolean;
    attrs: ASTv2.HtmlOrSplatAttr[];
    componentArgs: ASTv2.ComponentArg[];
    modifiers: ASTv2.ElementModifier[];
    comments: ASTv2.GlimmerComment[];
}
declare class BuildElement {
    readonly base: BuildBaseElement;
    readonly builder: Builder;
    constructor(base: BuildBaseElement);
    simple(tag: SourceSlice, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.SimpleElement;
    named(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock;
    selfClosingComponent(callee: ASTv2.ExpressionNode, loc: SourceSpan): ASTv2.InvokeComponent;
    componentWithDefaultBlock(callee: ASTv2.ExpressionNode, children: ASTv2.ContentNode[], symbols: BlockSymbolTable, loc: SourceSpan): ASTv2.InvokeComponent;
    componentWithNamedBlocks(callee: ASTv2.ExpressionNode, blocks: PresentArray<ASTv2.NamedBlock>, loc: SourceSpan): ASTv2.InvokeComponent;
}
declare function normalize(source: Source, options?: PrecompileOptionsWithLexicalScope): [
    ast: ASTv2.Template,
    locals: string[]
];
interface BaseNodeFields {
    loc: SourceSpan;
}
/**
 * This is a convenience function for creating ASTv2 nodes, with an optional name and the node's
 * options.
 *
 * ```ts
 * export class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}
 * ```
 *
 * This creates a new ASTv2 node with the name `'HtmlText'` and one field `chars: string` (in
 * addition to a `loc: SourceOffsets` field, which all nodes have).
 *
 * ```ts
 * export class Args extends node().fields<{
 *  positional: PositionalArguments;
 *  named: NamedArguments
 * }>() {}
 * ```
 *
 * This creates a new un-named ASTv2 node with two fields (`positional: Positional` and `named:
 * Named`, in addition to the generic `loc: SourceOffsets` field).
 *
 * Once you create a node using `node`, it is instantiated with all of its fields (including `loc`):
 *
 * ```ts
 * new HtmlText({ loc: offsets, chars: someString });
 * ```
 */
declare function node(): {
    fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;
};
declare function node<T extends string>(name: T): {
    fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;
};
interface NodeConstructor<Fields> {
    new (fields: Fields): Readonly<Fields>;
}
type TypedNode<T extends string, Fields> = {
    type: T;
} & Readonly<Fields>;
interface TypedNodeConstructor<T extends string, Fields> {
    new (options: Fields): TypedNode<T, Fields>;
}
export { build as print, getVoidTags, isVoidTag, sortByLoc, getTemplateLocals, isKeyword, KEYWORDS_TYPES, KeywordType, ASTPlugin, ASTPluginBuilder, ASTPluginEnvironment, PrecompileOptions, PrecompileOptionsWithLexicalScope, preprocess, Syntax, TemplateIdFn, src, SourceSlice, HasSourceSpan, hasSpan, loc, MaybeHasSourceSpan, maybeLoc, SpanList, BlockSymbolTable, ProgramSymbolTable, SymbolTable, generateSyntaxError, GlimmerSyntaxError, cannotRemoveNode, cannotReplaceNode, WalkerPath, traverse, Walker, Walker as Path, ASTv1, ASTv1 as AST, _default as builders, visitorKeys, ASTv2, normalize, node };
export type { PreprocessOptions, NodeVisitor };
//# sourceMappingURL=index.d.ts.map