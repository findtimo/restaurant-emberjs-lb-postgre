<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../packages/graph/src/-private/-edge-definition.ts - EmberData Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="EmberData Documentation" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.3.3+58cd284b</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/&lt;Interface&gt; Adapter.html">&lt;Interface&gt; Adapter</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Cache.html">&lt;Interface&gt; Cache</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Handler.html">&lt;Interface&gt; Handler</a></li>
                                <li><a href="../classes/&lt;Interface&gt; LifetimesService.html">&lt;Interface&gt; LifetimesService</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Serializer.html">&lt;Interface&gt; Serializer</a></li>
                                <li><a href="../classes/@ember-data/active-record/request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../classes/@ember-data/adapter/rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../classes/@ember-data/json-api/request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/@ember-data/request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../classes/@ember-data/rest/request.html">@ember-data/rest/request</a></li>
                                <li><a href="../classes/@ember-data/store.html">@ember-data/store</a></li>
                                <li><a href="../classes/@ember-data/tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/CacheCapabilitiesManager.html">CacheCapabilitiesManager</a></li>
                                <li><a href="../classes/CacheManager.html">CacheManager</a></li>
                                <li><a href="../classes/CanaryFeatureFlags.html">CanaryFeatureFlags</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/CurrentDeprecations.html">CurrentDeprecations</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/DebugLogging.html">DebugLogging</a></li>
                                <li><a href="../classes/Document.html">Document</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/Fetch.html">Fetch</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/Future.html">Future</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentifierCache.html">IdentifierCache</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/LifetimesService.html">LifetimesService</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NotificationManager.html">NotificationManager</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/PromiseBelongsTo.html">PromiseBelongsTo</a></li>
                                <li><a href="../classes/PromiseManyArray.html">PromiseManyArray</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/RequestManager.html">RequestManager</a></li>
                                <li><a href="../classes/RequestStateService.html">RequestStateService</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/SchemaService.html">SchemaService</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/StableRecordIdentifier.html">StableRecordIdentifier</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data_active-record_request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_adapter_error.html">@ember-data/adapter/error</a></li>
                                <li><a href="../modules/@ember-data_adapter_json-api.html">@ember-data/adapter/json-api</a></li>
                                <li><a href="../modules/@ember-data_adapter_rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../modules/@ember-data_canary-features.html">@ember-data/canary-features</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_deprecations.html">@ember-data/deprecations</a></li>
                                <li><a href="../modules/@ember-data_experimental-preview-types.html">@ember-data/experimental-preview-types</a></li>
                                <li><a href="../modules/@ember-data_graph.html">@ember-data/graph</a></li>
                                <li><a href="../modules/@ember-data_json-api.html">@ember-data/json-api</a></li>
                                <li><a href="../modules/@ember-data_json-api_request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../modules/@ember-data_legacy-compat.html">@ember-data/legacy-compat</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_request.html">@ember-data/request</a></li>
                                <li><a href="../modules/@ember-data_request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../modules/@ember-data_request_fetch.html">@ember-data/request/fetch</a></li>
                                <li><a href="../modules/@ember-data_rest_request.html">@ember-data/rest/request</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_serializer_json.html">@ember-data/serializer/json</a></li>
                                <li><a href="../modules/@ember-data_serializer_json-api.html">@ember-data/serializer/json-api</a></li>
                                <li><a href="../modules/@ember-data_serializer_rest.html">@ember-data/serializer/rest</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                                <li><a href="../modules/@ember-data_tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../modules/ember-data-overview.html">ember-data-overview</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../packages/graph/src/-private/-edge-definition.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { assert } from &#x27;@ember/debug&#x27;;

import { DEBUG } from &#x27;@ember-data/env&#x27;;
import type Store from &#x27;@ember-data/store&#x27;;
import type { StableRecordIdentifier } from &#x27;@warp-drive/core-types&#x27;;
import type { RelationshipSchema } from &#x27;@warp-drive/core-types/schema&#x27;;

import { expandingGet, expandingSet, getStore } from &#x27;./-utils&#x27;;
import { assertInheritedSchema } from &#x27;./debug/assert-polymorphic-type&#x27;;
import type { Graph } from &#x27;./graph&#x27;;

export type EdgeCache = Record&lt;string, Record&lt;string, EdgeDefinition | null&gt;&gt;;

/**
 *
 * Given RHS (Right Hand Side)
 *
 * &#x60;&#x60;&#x60;ts
 * class User extends Model {
 *   @hasMany(&#x27;animal&#x27;, { async: false, inverse: &#x27;owner&#x27; }) pets;
 * }
 * &#x60;&#x60;&#x60;
 *
 * Given LHS (Left Hand Side)
 *
 * &#x60;&#x60;&#x60;ts
 * class Animal extends Model {
 *  @belongsTo(&#x27;user&#x27;, { async: false, inverse: &#x27;pets&#x27; }) owner;
 * }
 * &#x60;&#x60;&#x60;
 *
 * The UpgradedMeta for the RHS would be:
 *
 * &#x60;&#x60;&#x60;ts
 * {
 *   kind: &#x27;hasMany&#x27;,
 *   key: &#x27;pets&#x27;,
 *   type: &#x27;animal&#x27;,
 *   isAsync: false,
 *   isImplicit: false,
 *   isCollection: true,
 *   isPolymorphic: false,
 *   inverseKind: &#x27;belongsTo&#x27;,
 *   inverseKey: &#x27;owner&#x27;,
 *   inverseType: &#x27;user&#x27;,
 *   inverseIsAsync: false,
 *   inverseIsImplicit: false,
 *   inverseIsCollection: false,
 *   inverseIsPolymorphic: false,
 * }
 * &#x60;&#x60;&#x60;
 *
 * The UpgradeMeta for the LHS would be:
 *
 * &#x60;&#x60;&#x60;ts
 * {
 *   kind: &#x27;belongsTo&#x27;,
 *   key: &#x27;owner&#x27;,
 *   type: &#x27;user&#x27;,
 *   isAsync: false,
 *   isImplicit: false,
 *   isCollection: false,
 *   isPolymorphic: false,
 *   inverseKind: &#x27;hasMany&#x27;,
 *   inverseKey: &#x27;pets&#x27;,
 *   inverseType: &#x27;animal&#x27;,
 *   inverseIsAsync: false,
 *   inverseIsImplicit: false,
 *   inverseIsCollection: true,
 *   inverseIsPolymorphic: false,
 * }
 * &#x60;&#x60;&#x60;
 *
 *
 * @class UpgradedMeta
 * @internal
 */
export interface UpgradedMeta {
  kind: &#x27;hasMany&#x27; | &#x27;belongsTo&#x27; | &#x27;implicit&#x27;;
  /**
   * The field name on &#x60;this&#x60; record
   *
   * @internal
   */
  key: string;
  /**
   * The &#x60;type&#x60; of the related record
   *
   * @internal
   */
  type: string;
  isAsync: boolean;
  isImplicit: boolean;
  isCollection: boolean;
  isPolymorphic: boolean;
  resetOnRemoteUpdate: boolean;

  inverseKind: &#x27;hasMany&#x27; | &#x27;belongsTo&#x27; | &#x27;implicit&#x27;;
  /**
   * The field name on the opposing record
   * @internal
   */
  inverseKey: string;
  /**
   * The &#x60;type&#x60; of &#x60;this&#x60; record
   * @internal
   */
  inverseType: string;
  inverseIsAsync: boolean;
  inverseIsImplicit: boolean;
  inverseIsCollection: boolean;
  inverseIsPolymorphic: boolean;
}

export interface EdgeDefinition {
  lhs_key: string;
  lhs_modelNames: string[];
  lhs_baseModelName: string;
  lhs_relationshipName: string;
  lhs_definition: UpgradedMeta;
  lhs_isPolymorphic: boolean;

  rhs_key: string;
  rhs_modelNames: string[];
  rhs_baseModelName: string;
  rhs_relationshipName: string;
  rhs_definition: UpgradedMeta | null;
  rhs_isPolymorphic: boolean;

  hasInverse: boolean;

  /**
   * Whether this relationship points back at the same type.
   *
   * If the relationship is polymorphic, this will be true if
   * it points back at the same abstract type.
   *
   * @internal
   */
  isSelfReferential: boolean;

  /**
   * If this is a reflexive relationship, this is true
   * if the relationship also points back at the same
   * field.
   *
   * @internal
   */
  isReflexive: boolean;
}

const BOOL_LATER = null as unknown as boolean;
const STR_LATER = &#x27;&#x27;;
const IMPLICIT_KEY_RAND = Date.now();

function implicitKeyFor(type: string, key: string): string {
  return &#x60;implicit-${type}:${key}${IMPLICIT_KEY_RAND}&#x60;;
}

function syncMeta(definition: UpgradedMeta, inverseDefinition: UpgradedMeta) {
  definition.inverseKind = inverseDefinition.kind;
  definition.inverseKey = inverseDefinition.key;
  definition.inverseType = inverseDefinition.type;
  definition.inverseIsAsync = inverseDefinition.isAsync;
  definition.inverseIsCollection = inverseDefinition.isCollection;
  definition.inverseIsPolymorphic = inverseDefinition.isPolymorphic;
  definition.inverseIsImplicit = inverseDefinition.isImplicit;
  const resetOnRemoteUpdate =
    definition.resetOnRemoteUpdate === false || inverseDefinition.resetOnRemoteUpdate === false ? false : true;
  definition.resetOnRemoteUpdate = resetOnRemoteUpdate;
  inverseDefinition.resetOnRemoteUpdate = resetOnRemoteUpdate;
}

function upgradeMeta(meta: RelationshipSchema): UpgradedMeta {
  const niceMeta: UpgradedMeta = {} as UpgradedMeta;
  const options = meta.options;
  niceMeta.kind = meta.kind;
  niceMeta.key = meta.name;
  niceMeta.type = meta.type;
  assert(&#x60;Expected relationship definition to specify async&#x60;, typeof options?.async === &#x27;boolean&#x27;);
  niceMeta.isAsync = options.async;
  niceMeta.isImplicit = false;
  niceMeta.isCollection = meta.kind === &#x27;hasMany&#x27;;
  niceMeta.isPolymorphic = options &amp;&amp; !!options.polymorphic;

  niceMeta.inverseKey = (options &amp;&amp; options.inverse) || STR_LATER;
  niceMeta.inverseType = STR_LATER;
  niceMeta.inverseIsAsync = BOOL_LATER;
  niceMeta.inverseIsImplicit = (options &amp;&amp; options.inverse === null) || BOOL_LATER;
  niceMeta.inverseIsCollection = BOOL_LATER;

  niceMeta.resetOnRemoteUpdate = options &amp;&amp; options.resetOnRemoteUpdate === false ? false : true;

  return niceMeta;
}

function assertConfiguration(info: EdgeDefinition, type: string, key: string) {
  if (DEBUG) {
    const isSelfReferential = info.isSelfReferential;

    if (isSelfReferential) {
      return true;
    }

    const _isRHS =
      key === info.rhs_relationshipName &amp;&amp;
      (type === info.rhs_baseModelName || // base or non-polymorphic
        // if the other side is polymorphic then we need to scan our modelNames
        (info.lhs_isPolymorphic &amp;&amp; info.rhs_modelNames.includes(type))); // polymorphic
    const _isLHS =
      key === info.lhs_relationshipName &amp;&amp;
      (type === info.lhs_baseModelName || // base or non-polymorphic
        // if the other side is polymorphic then we need to scan our modelNames
        (info.rhs_isPolymorphic &amp;&amp; info.lhs_modelNames.includes(type))); // polymorphic;

    if (!_isRHS &amp;&amp; !_isLHS) {
      /*
        this occurs when we are likely polymorphic but not configured to be polymorphic
        most often due to extending a class that has a relationship definition on it.

        e.g.

        &#x60;&#x60;&#x60;ts
        class Pet extends Model {
          @belongsTo(&#x27;human&#x27;, { async: false, inverse: &#x27;pet&#x27; }) owner;
        }
        class Human extends Model {
          @belongsTo(&#x27;pet&#x27;, { async: false, inverse: &#x27;owner&#x27; }) pet;
        }
        class Farmer extends Human {}
        &#x60;&#x60;&#x60;

        In the above case, the following would trigger this error:

        &#x60;&#x60;&#x60;ts
        let pet = store.createRecord(&#x27;pet&#x27;);
        let farmer = store.createRecord(&#x27;farmer&#x27;);
        farmer.pet = pet; // error
        &#x60;&#x60;&#x60;

        The correct way to fix this is to specify the polymorphic option on Pet
        and to specify the abstract type &#x27;human&#x27; on the Human base class.

        &#x60;&#x60;&#x60;ts
        class Pet extends Model {
          @belongsTo(&#x27;human&#x27;, { async: false, inverse: &#x27;pet&#x27;, polymorphic: true }) owner;
        }
        class Human extends Model {
          @belongsTo(&#x27;pet&#x27;, { async: false, inverse: &#x27;owner&#x27;, as: &#x27;human&#x27; }) pet;
        }
        class Farmer extends Human {}
        &#x60;&#x60;&#x60;

        Alternatively both Human and Farmer could declare the relationship, because relationship
        definitions are &quot;structural&quot;.

        &#x60;&#x60;&#x60;ts
        class Pet extends Model {
          @belongsTo(&#x27;human&#x27;, { async: false, inverse: &#x27;pet&#x27;, polymorphic: true }) owner;
        }
        class Human extends Model {
          @belongsTo(&#x27;pet&#x27;, { async: false, inverse: &#x27;owner&#x27;, as: &#x27;human&#x27; }) pet;
        }
        class Farmer extends Model {
          @belongsTo(&#x27;pet&#x27;, { async: false, inverse: &#x27;owner&#x27;, as: &#x27;human&#x27; }) pet;
        }
        &#x60;&#x60;&#x60;

       */
      if (key === info.lhs_relationshipName &amp;&amp; info.lhs_modelNames.includes(type)) {
        // parentIdentifier, parentDefinition, addedIdentifier, store
        assertInheritedSchema(info.lhs_definition, type);
      } else if (key === info.rhs_relationshipName &amp;&amp; info.rhs_modelNames.includes(type)) {
        assertInheritedSchema(info.lhs_definition, type);
      }
      // OPEN AN ISSUE :: we would like to improve our errors but need to understand what corner case got us here
      throw new Error(
        &#x60;PLEASE OPEN AN ISSUE :: Found a relationship that is neither the LHS nor RHS of the same edge. This is not supported. Please report this to the EmberData team.&#x60;
      );
    }

    if (_isRHS &amp;&amp; _isLHS) {
      // not sure how we get here but it&#x27;s probably the result of some form of inheritance
      // without having specified polymorphism correctly leading to it not being self-referential
      // OPEN AN ISSUE :: we would like to improve our errors but need to understand what corner case got us here
      throw new Error(
        &#x60;PLEASE OPEN AN ISSUE :: Found a relationship that is both the LHS and RHS of the same edge but is not self-referential. This is not supported. Please report this to the EmberData team.&#x60;
      );
    }
  }
}

export function isLHS(info: EdgeDefinition, type: string, key: string): boolean {
  const isSelfReferential = info.isSelfReferential;
  const isRelationship = key === info.lhs_relationshipName;

  if (DEBUG) {
    assertConfiguration(info, type, key);
  }

  if (isRelationship === true) {
    return (
      isSelfReferential === true || // itself
      type === info.lhs_baseModelName || // base or non-polymorphic
      // if the other side is polymorphic then we need to scan our modelNames
      (info.rhs_isPolymorphic &amp;&amp; info.lhs_modelNames.includes(type)) // polymorphic
    );
  }

  return false;
}

export function isRHS(info: EdgeDefinition, type: string, key: string): boolean {
  const isSelfReferential = info.isSelfReferential;
  const isRelationship = key === info.rhs_relationshipName;

  if (DEBUG) {
    assertConfiguration(info, type, key);
  }

  if (isRelationship === true) {
    return (
      isSelfReferential === true || // itself
      type === info.rhs_baseModelName || // base or non-polymorphic
      // if the other side is polymorphic then we need to scan our modelNames
      (info.lhs_isPolymorphic &amp;&amp; info.rhs_modelNames.includes(type)) // polymorphic
    );
  }

  return false;
}

export function upgradeDefinition(
  graph: Graph,
  identifier: StableRecordIdentifier,
  propertyName: string,
  isImplicit = false
): EdgeDefinition | null {
  const cache = graph._definitionCache;
  const storeWrapper = graph.store;
  const polymorphicLookup = graph._potentialPolymorphicTypes;

  const { type } = identifier;
  let cached = /*#__NOINLINE__*/ expandingGet&lt;EdgeDefinition | null&gt;(cache, type, propertyName);

  // CASE: We have a cached resolution (null if no relationship exists)
  if (cached !== undefined) {
    return cached;
  }

  assert(
    &#x60;Expected to find relationship definition in the cache for the implicit relationship ${propertyName}&#x60;,
    !isImplicit
  );

  const relationships = storeWrapper.getSchemaDefinitionService().relationshipsDefinitionFor(identifier);
  assert(&#x60;Expected to have a relationship definition for ${type} but none was found.&#x60;, relationships);
  const meta = relationships[propertyName];

  if (!meta) {
    // TODO potentially we should just be permissive here since this is an implicit relationship
    // and not require the lookup table to be populated
    if (polymorphicLookup[type]) {
      const altTypes = Object.keys(polymorphicLookup[type]);
      for (let i = 0; i &lt; altTypes.length; i++) {
        const _cached = expandingGet&lt;EdgeDefinition | null&gt;(cache, altTypes[i], propertyName);
        if (_cached) {
          /*#__NOINLINE__*/ expandingSet&lt;EdgeDefinition | null&gt;(cache, type, propertyName, _cached);
          _cached.rhs_modelNames.push(type);
          return _cached;
        }
      }
    }

    // CASE: We don&#x27;t have a relationship at all
    // we should only hit this in prod
    assert(&#x60;Expected a relationship schema for &#x27;${type}.${propertyName}&#x27;, but no relationship schema was found.&#x60;, meta);

    cache[type]![propertyName] = null;
    return null;
  }
  const definition = /*#__NOINLINE__*/ upgradeMeta(meta);

  let inverseDefinition: UpgradedMeta | null;
  let inverseKey: string | null;
  const inverseType = definition.type;

  // CASE: Inverse is explicitly null
  if (definition.inverseKey === null) {
    // TODO probably dont need this assertion if polymorphic
    assert(&#x60;Expected the inverse model to exist&#x60;, getStore(storeWrapper).modelFor(inverseType));
    inverseDefinition = null;
  } else {
    inverseKey = /*#__NOINLINE__*/ inverseForRelationship(getStore(storeWrapper), identifier, propertyName);

    // CASE: If we are polymorphic, and we declared an inverse that is non-null
    // we must assume that the lack of inverseKey means that there is no
    // concrete type as the baseType, so we must construct and artificial
    // placeholder
    if (!inverseKey &amp;&amp; definition.isPolymorphic &amp;&amp; definition.inverseKey) {
      inverseDefinition = {
        kind: &#x27;belongsTo&#x27;, // this must be updated when we find the first belongsTo or hasMany definition that matches
        key: definition.inverseKey,
        type: type,
        isAsync: false, // this must be updated when we find the first belongsTo or hasMany definition that matches
        isImplicit: false,
        isCollection: false, // this must be updated when we find the first belongsTo or hasMany definition that matches
        isPolymorphic: false,
      } as UpgradedMeta; // the rest of the fields are populated by syncMeta

      // CASE: Inverse resolves to null
    } else if (!inverseKey) {
      inverseDefinition = null;
    } else {
      // CASE: We have an explicit inverse or were able to resolve one
      const inverseDefinitions = storeWrapper
        .getSchemaDefinitionService()
        .relationshipsDefinitionFor({ type: inverseType });
      assert(&#x60;Expected to have a relationship definition for ${inverseType} but none was found.&#x60;, inverseDefinitions);
      const metaFromInverse = inverseDefinitions[inverseKey];
      assert(
        &#x60;Expected a relationship schema for &#x27;${inverseType}.${inverseKey}&#x27; to match the inverse of &#x27;${type}.${propertyName}&#x27;, but no relationship schema was found.&#x60;,
        metaFromInverse
      );

      inverseDefinition = upgradeMeta(metaFromInverse);
    }
  }

  // CASE: We have no inverse
  if (!inverseDefinition) {
    // polish off meta
    inverseKey = /*#__NOINLINE__*/ implicitKeyFor(type, propertyName);
    inverseDefinition = {
      kind: &#x27;implicit&#x27;,
      key: inverseKey,
      type: type,
      isAsync: false,
      isImplicit: true,
      isCollection: true, // with implicits any number of records could point at us
      isPolymorphic: false,
    } as UpgradedMeta; // the rest of the fields are populated by syncMeta

    syncMeta(definition, inverseDefinition);
    syncMeta(inverseDefinition, definition);

    const info = {
      lhs_key: &#x60;${type}:${propertyName}&#x60;,
      lhs_modelNames: [type],
      lhs_baseModelName: type,
      lhs_relationshipName: propertyName,
      lhs_definition: definition,
      lhs_isPolymorphic: definition.isPolymorphic,

      rhs_key: inverseDefinition.key,
      rhs_modelNames: [inverseType],
      rhs_baseModelName: inverseType,
      rhs_relationshipName: inverseDefinition.key,
      rhs_definition: inverseDefinition,
      rhs_isPolymorphic: false,

      hasInverse: false,
      isSelfReferential: type === inverseType, // this could be wrong if we are self-referential but also polymorphic
      isReflexive: false, // we can&#x27;t be reflexive if we don&#x27;t define an inverse
    };

    expandingSet&lt;EdgeDefinition | null&gt;(cache, inverseType, inverseKey, info);
    expandingSet&lt;EdgeDefinition | null&gt;(cache, type, propertyName, info);
    return info;
  }

  // CASE: We do have an inverse
  const baseType = inverseDefinition.type;

  // TODO we want to assert this but this breaks all of our shoddily written tests
  /*
    if (DEBUG) {
      let inverseDoubleCheck = inverseFor(inverseRelationshipName, store);

      assert(&#x60;The ${inverseBaseModelName}:${inverseRelationshipName} relationship declares &#x27;inverse: null&#x27;, but it was resolved as the inverse for ${baseModelName}:${relationshipName}.&#x60;, inverseDoubleCheck);
    }
  */
  // CASE: We may have already discovered the inverse for the baseModelName
  // CASE: We have already discovered the inverse
  assert(
    &#x60;We should have determined an inverseKey by now, open an issue if this is hit&#x60;,
    typeof inverseKey! === &#x27;string&#x27; &amp;&amp; inverseKey.length &gt; 0
  );
  cached = expandingGet(cache, baseType, propertyName) || expandingGet(cache, inverseType, inverseKey);

  if (cached) {
    // TODO this assert can be removed if the above assert is enabled
    assert(
      &#x60;The ${inverseType}:${inverseKey} relationship declares &#x27;inverse: null&#x27;, but it was resolved as the inverse for ${type}:${propertyName}.&#x60;,
      cached.hasInverse !== false
    );

    const _isLHS = cached.lhs_baseModelName === baseType;
    const modelNames = _isLHS ? cached.lhs_modelNames : cached.rhs_modelNames;
    // make this lookup easier in the future by caching the key
    modelNames.push(type);
    expandingSet&lt;EdgeDefinition | null&gt;(cache, type, propertyName, cached);

    return cached;
  }

  // this is our first time so polish off the metas
  syncMeta(definition, inverseDefinition);
  syncMeta(inverseDefinition, definition);

  const lhs_modelNames = [type];
  if (type !== baseType) {
    lhs_modelNames.push(baseType);
  }
  const isSelfReferential = baseType === inverseType;
  const info = {
    lhs_key: &#x60;${baseType}:${propertyName}&#x60;,
    lhs_modelNames,
    lhs_baseModelName: baseType,
    lhs_relationshipName: propertyName,
    lhs_definition: definition,
    lhs_isPolymorphic: definition.isPolymorphic,

    rhs_key: &#x60;${inverseType}:${inverseKey}&#x60;,
    rhs_modelNames: [inverseType],
    rhs_baseModelName: inverseType,
    rhs_relationshipName: inverseKey,
    rhs_definition: inverseDefinition,
    rhs_isPolymorphic: inverseDefinition.isPolymorphic,
    hasInverse: true,
    isSelfReferential,
    isReflexive: isSelfReferential &amp;&amp; propertyName === inverseKey,
  };

  // Create entries for the baseModelName as well as modelName to speed up
  //  inverse lookups
  expandingSet&lt;EdgeDefinition | null&gt;(cache, baseType, propertyName, info);
  expandingSet&lt;EdgeDefinition | null&gt;(cache, type, propertyName, info);

  // Greedily populate the inverse
  expandingSet&lt;EdgeDefinition | null&gt;(cache, inverseType, inverseKey, info);

  return info;
}

function inverseForRelationship(store: Store, identifier: StableRecordIdentifier | { type: string }, key: string) {
  const definition = store.getSchemaDefinitionService().relationshipsDefinitionFor(identifier)[key];
  if (!definition) {
    return null;
  }

  assert(
    &#x60;Expected the relationship defintion to specify the inverse type or null.&#x60;,
    definition.options?.inverse === null ||
      (typeof definition.options?.inverse === &#x27;string&#x27; &amp;&amp; definition.options.inverse.length &gt; 0)
  );
  return definition.options.inverse;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
