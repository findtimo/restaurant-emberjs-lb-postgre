<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../packages/store/src/-private/cache-handler.ts - EmberData Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="EmberData Documentation" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.3.3+58cd284b</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/&lt;Interface&gt; Adapter.html">&lt;Interface&gt; Adapter</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Cache.html">&lt;Interface&gt; Cache</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Handler.html">&lt;Interface&gt; Handler</a></li>
                                <li><a href="../classes/&lt;Interface&gt; LifetimesService.html">&lt;Interface&gt; LifetimesService</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Serializer.html">&lt;Interface&gt; Serializer</a></li>
                                <li><a href="../classes/@ember-data/active-record/request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../classes/@ember-data/adapter/rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../classes/@ember-data/json-api/request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/@ember-data/request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../classes/@ember-data/rest/request.html">@ember-data/rest/request</a></li>
                                <li><a href="../classes/@ember-data/store.html">@ember-data/store</a></li>
                                <li><a href="../classes/@ember-data/tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/CacheCapabilitiesManager.html">CacheCapabilitiesManager</a></li>
                                <li><a href="../classes/CacheManager.html">CacheManager</a></li>
                                <li><a href="../classes/CanaryFeatureFlags.html">CanaryFeatureFlags</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/CurrentDeprecations.html">CurrentDeprecations</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/DebugLogging.html">DebugLogging</a></li>
                                <li><a href="../classes/Document.html">Document</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/Fetch.html">Fetch</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/Future.html">Future</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentifierCache.html">IdentifierCache</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/LifetimesService.html">LifetimesService</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NotificationManager.html">NotificationManager</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/PromiseBelongsTo.html">PromiseBelongsTo</a></li>
                                <li><a href="../classes/PromiseManyArray.html">PromiseManyArray</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/RequestManager.html">RequestManager</a></li>
                                <li><a href="../classes/RequestStateService.html">RequestStateService</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/SchemaService.html">SchemaService</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/StableRecordIdentifier.html">StableRecordIdentifier</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data_active-record_request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_adapter_error.html">@ember-data/adapter/error</a></li>
                                <li><a href="../modules/@ember-data_adapter_json-api.html">@ember-data/adapter/json-api</a></li>
                                <li><a href="../modules/@ember-data_adapter_rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../modules/@ember-data_canary-features.html">@ember-data/canary-features</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_deprecations.html">@ember-data/deprecations</a></li>
                                <li><a href="../modules/@ember-data_experimental-preview-types.html">@ember-data/experimental-preview-types</a></li>
                                <li><a href="../modules/@ember-data_graph.html">@ember-data/graph</a></li>
                                <li><a href="../modules/@ember-data_json-api.html">@ember-data/json-api</a></li>
                                <li><a href="../modules/@ember-data_json-api_request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../modules/@ember-data_legacy-compat.html">@ember-data/legacy-compat</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_request.html">@ember-data/request</a></li>
                                <li><a href="../modules/@ember-data_request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../modules/@ember-data_request_fetch.html">@ember-data/request/fetch</a></li>
                                <li><a href="../modules/@ember-data_rest_request.html">@ember-data/rest/request</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_serializer_json.html">@ember-data/serializer/json</a></li>
                                <li><a href="../modules/@ember-data_serializer_json-api.html">@ember-data/serializer/json-api</a></li>
                                <li><a href="../modules/@ember-data_serializer_rest.html">@ember-data/serializer/rest</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                                <li><a href="../modules/@ember-data_tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../modules/ember-data-overview.html">ember-data-overview</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../packages/store/src/-private/cache-handler.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @module @ember-data/store
 */
import { assert } from &#x27;@ember/debug&#x27;;

import type { Future, Handler, NextFn } from &#x27;@ember-data/request/-private/types&#x27;;
import type { StableDocumentIdentifier } from &#x27;@warp-drive/core-types/identifier&#x27;;
import type {
  ImmutableCreateRequestOptions,
  ImmutableDeleteRequestOptions,
  ImmutableRequestInfo,
  ImmutableUpdateRequestOptions,
  RequestContext,
  ResponseInfo,
  StructuredDataDocument,
  StructuredErrorDocument,
} from &#x27;@warp-drive/core-types/request&#x27;;
import { EnableHydration, SkipCache } from &#x27;@warp-drive/core-types/request&#x27;;
import type {
  CollectionResourceDataDocument,
  ResourceDataDocument,
  ResourceErrorDocument,
} from &#x27;@warp-drive/core-types/spec/document&#x27;;
import type { ApiError } from &#x27;@warp-drive/core-types/spec/error&#x27;;
import type { ResourceIdentifierObject } from &#x27;@warp-drive/core-types/spec/raw&#x27;;

import type { RecordInstance } from &#x27;../-types/q/record-instance&#x27;;
import { Document } from &#x27;./document&#x27;;
import type Store from &#x27;./store-service&#x27;;

/**
 * A service which an application may provide to the store via
 * the store&#x27;s &#x60;lifetimes&#x60; property to configure the behavior
 * of the CacheHandler.
 *
 * The default behavior for request lifetimes is to never expire
 * unless manually refreshed via &#x60;cacheOptions.reload&#x60; or &#x60;cacheOptions.backgroundReload&#x60;.
 *
 * Implementing this service allows you to programatically define
 * when a request should be considered expired.
 *
 * @class &lt;Interface&gt; LifetimesService
 * @public
 */
export interface LifetimesService {
  /**
   * Invoked to determine if the request may be fulfilled from cache
   * if possible.
   *
   * Note, this is only invoked if the request has a cache-key.
   *
   * If no cache entry is found or the entry is hard expired,
   * the request will be fulfilled from the configured request handlers
   * and the cache will be updated before returning the response.
   *
   * @method isHardExpired
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {boolean} true if the request is considered hard expired
   */
  isHardExpired(identifier: StableDocumentIdentifier, store: Store): boolean;
  /**
   * Invoked if &#x60;isHardExpired&#x60; is false to determine if the request
   * should be update behind the scenes if cache data is already available.
   *
   * Note, this is only invoked if the request has a cache-key.
   *
   * If true, the request will be fulfilled from cache while a backgrounded
   * request is made to update the cache via the configured request handlers.
   *
   * @method isSoftExpired
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {boolean} true if the request is considered soft expired
   */
  isSoftExpired(identifier: StableDocumentIdentifier, store: Store): boolean;

  /**
   * Invoked when a request will be sent to the configured request handlers.
   * This is invoked for both foreground and background requests.
   *
   * Note, this is invoked regardless of whether the request has a cache-key.
   *
   * @method willRequest [Optional]
   * @public
   * @param {ImmutableRequestInfo} request
   * @param {StableDocumentIdentifier | null} identifier
   * @param {Store} store
   * @return {void}
   */
  willRequest?(request: ImmutableRequestInfo, identifier: StableDocumentIdentifier | null, store: Store): void;

  /**
   * Invoked when a request has been fulfilled from the configured request handlers.
   * This is invoked for both foreground and background requests once the cache has
   * been updated.
   *
   * Note, this is invoked regardless of whether the request has a cache-key.
   *
   * @method didRequest [Optional]
   * @public
   * @param {ImmutableRequestInfo} request
   * @param {ImmutableResponse} response
   * @param {StableDocumentIdentifier | null} identifier
   * @param {Store} store
   * @return {void}
   */
  didRequest?(
    request: ImmutableRequestInfo,
    response: Response | ResponseInfo | null,
    identifier: StableDocumentIdentifier | null,
    store: Store
  ): void;
}

export type StoreRequestInfo = ImmutableRequestInfo;
export type LooseStoreRequestInfo = Omit&lt;StoreRequestInfo, &#x27;records&#x27; | &#x27;headers&#x27;&gt; &amp; {
  records?: ResourceIdentifierObject[];
  headers?: Headers;
};

export type StoreRequestInput = StoreRequestInfo | LooseStoreRequestInfo;

export interface StoreRequestContext extends RequestContext {
  request: StoreRequestInfo &amp; { store: Store; [EnableHydration]?: boolean };
}

const MUTATION_OPS = new Set([&#x27;createRecord&#x27;, &#x27;updateRecord&#x27;, &#x27;deleteRecord&#x27;]);

function isErrorDocument(document: ResourceDataDocument | ResourceErrorDocument): document is ResourceErrorDocument {
  return &#x27;errors&#x27; in document;
}

function maybeUpdateUiObjects&lt;T&gt;(
  store: Store,
  request: StoreRequestInfo,
  options: {
    shouldHydrate?: boolean;
    shouldFetch?: boolean;
    shouldBackgroundFetch?: boolean;
    identifier: StableDocumentIdentifier | null;
  },
  document: ResourceDataDocument | ResourceErrorDocument,
  isFromCache: boolean
): T {
  const { identifier } = options;

  if (isErrorDocument(document)) {
    if (!identifier &amp;&amp; !options.shouldHydrate) {
      return document as T;
    }
    let doc: Document&lt;undefined&gt; | undefined;
    if (identifier) {
      doc = store._documentCache.get(identifier) as Document&lt;undefined&gt; | undefined;
    }

    if (!doc) {
      doc = new Document&lt;undefined&gt;(store, identifier);
      copyDocumentProperties(doc, document);

      if (identifier) {
        store._documentCache.set(identifier, doc);
      }
    } else if (!isFromCache) {
      doc.data = undefined;
      copyDocumentProperties(doc, document);
    }

    return options.shouldHydrate ? (doc as T) : (document as T);
  }

  if (Array.isArray(document.data)) {
    const { recordArrayManager } = store;
    if (!identifier) {
      if (!options.shouldHydrate) {
        return document as T;
      }
      const data = recordArrayManager.createArray({
        type: request.url,
        identifiers: document.data,
        doc: document as CollectionResourceDataDocument,
        query: request,
      }) as T;

      const doc = new Document(store, null);
      doc.data = data;
      doc.meta = document.meta;
      doc.links = document.links;

      return doc as T;
    }
    let managed = recordArrayManager._keyedArrays.get(identifier.lid);

    if (!managed) {
      managed = recordArrayManager.createArray({
        type: identifier.lid,
        identifiers: document.data,
        doc: document as CollectionResourceDataDocument,
      });
      recordArrayManager._keyedArrays.set(identifier.lid, managed);
      const doc = new Document&lt;RecordInstance[]&gt;(store, identifier);
      doc.data = managed;
      doc.meta = document.meta;
      doc.links = document.links;
      store._documentCache.set(identifier, doc);

      return options.shouldHydrate ? (doc as T) : (document as T);
    } else {
      const doc = store._documentCache.get(identifier)!;
      if (!isFromCache) {
        recordArrayManager.populateManagedArray(managed, document.data, document as CollectionResourceDataDocument);
        doc.data = managed;
        doc.meta = document.meta;
        doc.links = document.links;
      }

      return options.shouldHydrate ? (doc as T) : (document as T);
    }
  } else {
    if (!identifier &amp;&amp; !options.shouldHydrate) {
      return document as T;
    }
    const data = document.data ? store.peekRecord(document.data) : null;
    let doc: Document&lt;RecordInstance | null&gt; | undefined;
    if (identifier) {
      doc = store._documentCache.get(identifier);
    }

    if (!doc) {
      doc = new Document&lt;RecordInstance | null&gt;(store, identifier);
      doc.data = data;
      copyDocumentProperties(doc, document);

      if (identifier) {
        store._documentCache.set(identifier, doc);
      }
    } else if (!isFromCache) {
      doc.data = data;
      copyDocumentProperties(doc, document);
    }

    return options.shouldHydrate ? (doc as T) : (document as T);
  }
}

function calcShouldFetch(
  store: Store,
  request: StoreRequestInfo,
  hasCachedValue: boolean,
  identifier: StableDocumentIdentifier | null
): boolean {
  const { cacheOptions } = request;
  return (
    (request.op &amp;&amp; MUTATION_OPS.has(request.op)) ||
    cacheOptions?.reload ||
    !hasCachedValue ||
    (store.lifetimes &amp;&amp; identifier ? store.lifetimes.isHardExpired(identifier, store) : false)
  );
}

function calcShouldBackgroundFetch(
  store: Store,
  request: StoreRequestInfo,
  willFetch: boolean,
  identifier: StableDocumentIdentifier | null
): boolean {
  const { cacheOptions } = request;
  return (
    !willFetch &amp;&amp;
    (cacheOptions?.backgroundReload ||
      (store.lifetimes &amp;&amp; identifier ? store.lifetimes.isSoftExpired(identifier, store) : false))
  );
}

function isMutation(
  request: Partial&lt;StoreRequestInfo&gt;
): request is ImmutableUpdateRequestOptions | ImmutableCreateRequestOptions | ImmutableDeleteRequestOptions {
  return Boolean(request.op &amp;&amp; MUTATION_OPS.has(request.op));
}

function fetchContentAndHydrate&lt;T&gt;(
  next: NextFn&lt;T&gt;,
  context: StoreRequestContext,
  identifier: StableDocumentIdentifier | null,
  shouldFetch: boolean,
  shouldBackgroundFetch: boolean
): Promise&lt;T&gt; {
  const { store } = context.request;
  const shouldHydrate: boolean = (context.request[EnableHydration] as boolean | undefined) || false;

  let isMut = false;
  if (isMutation(context.request)) {
    isMut = true;
    // TODO should we handle multiple records in request.records by iteratively calling willCommit for each
    const record = context.request.data?.record || context.request.records?.[0];
    assert(&#x60;Expected to receive a list of records included in the ${context.request.op} request&#x60;, record);
    store.cache.willCommit(record, context);
  }

  if (store.lifetimes?.willRequest) {
    store.lifetimes.willRequest(context.request, identifier, store);
  }

  const promise = next(context.request).then(
    (document) =&gt; {
      store.requestManager._pending.delete(context.id);
      store._enableAsyncFlush = true;
      let response: ResourceDataDocument;
      store._join(() =&gt; {
        if (isMutation(context.request)) {
          const record = context.request.data?.record || context.request.records?.[0];
          response = store.cache.didCommit(record, document) as ResourceDataDocument;
        } else {
          response = store.cache.put(document) as ResourceDataDocument;
        }
        response = maybeUpdateUiObjects(
          store,
          context.request,
          { shouldHydrate, shouldFetch, shouldBackgroundFetch, identifier },
          response,
          false
        );
      });
      store._enableAsyncFlush = null;

      if (store.lifetimes?.didRequest) {
        store.lifetimes.didRequest(context.request, document.response, identifier, store);
      }

      if (shouldFetch) {
        return response!;
      } else if (shouldBackgroundFetch) {
        store.notifications._flush();
      }
    },
    (error: StructuredErrorDocument) =&gt; {
      store.requestManager._pending.delete(context.id);
      if (context.request.signal?.aborted) {
        throw error;
      }
      store.requestManager._pending.delete(context.id);
      store._enableAsyncFlush = true;
      let response: ResourceErrorDocument | undefined;
      store._join(() =&gt; {
        if (isMutation(context.request)) {
          // TODO similar to didCommit we should spec this to be similar to cache.put for handling full response
          // currently we let the response remain undefiend.
          const errors =
            error &amp;&amp;
            error.content &amp;&amp;
            typeof error.content === &#x27;object&#x27; &amp;&amp;
            &#x27;errors&#x27; in error.content &amp;&amp;
            Array.isArray(error.content.errors)
              ? (error.content.errors as ApiError[])
              : undefined;

          const record = context.request.data?.record || context.request.records?.[0];

          store.cache.commitWasRejected(record, errors);
          // re-throw the original error to preserve &#x60;errors&#x60; property.
          throw error;
        } else {
          response = store.cache.put(error) as ResourceErrorDocument;
          response = maybeUpdateUiObjects(
            store,
            context.request,
            { shouldHydrate, shouldFetch, shouldBackgroundFetch, identifier },
            response,
            false
          );
        }
      });
      store._enableAsyncFlush = null;

      if (identifier &amp;&amp; store.lifetimes?.didRequest) {
        store.lifetimes.didRequest(context.request, error.response, identifier, store);
      }

      if (!shouldBackgroundFetch) {
        const newError = cloneError(error);
        newError.content = response;
        throw newError;
      } else {
        store.notifications._flush();
      }
    }
  ) as Promise&lt;T&gt;;

  if (!isMut) {
    return promise;
  }
  assert(&#x60;Expected a mutation&#x60;, isMutation(context.request));

  // for mutations we need to enqueue the promise with the requestStateService
  // TODO should we enque a request per record in records?
  const record = context.request.data?.record || context.request.records?.[0];

  return store._requestCache._enqueue(promise, {
    data: [{ op: &#x27;saveRecord&#x27;, recordIdentifier: record, options: undefined }],
  });
}

function cloneError(error: Error &amp; { error: string | object }) {
  const cloned: Error &amp; { error: string | object; content?: object } = new Error(error.message) as Error &amp; {
    error: string | object;
    content?: object;
  };
  cloned.stack = error.stack;
  cloned.error = error.error;
  return cloned;
}

export const CacheHandler: Handler = {
  request&lt;T&gt;(context: StoreRequestContext, next: NextFn&lt;T&gt;): Promise&lt;T | StructuredDataDocument&lt;T&gt;&gt; | Future&lt;T&gt; {
    // if we have no cache or no cache-key skip cache handling
    if (!context.request.store || context.request.cacheOptions?.[SkipCache]) {
      return next(context.request);
    }

    const { store } = context.request;
    const identifier = store.identifierCache.getOrCreateDocumentIdentifier(context.request);

    const peeked = identifier ? store.cache.peekRequest(identifier) : null;

    // determine if we should skip cache
    if (calcShouldFetch(store, context.request, !!peeked, identifier)) {
      return fetchContentAndHydrate(next, context, identifier, true, false);
    }

    // if we have not skipped cache, determine if we should update behind the scenes
    if (calcShouldBackgroundFetch(store, context.request, false, identifier)) {
      const promise = fetchContentAndHydrate(next, context, identifier, false, true);
      store.requestManager._pending.set(context.id, promise);
    }

    const shouldHydrate: boolean = (context.request[EnableHydration] as boolean | undefined) || false;

    if (&#x27;error&#x27; in peeked!) {
      const content = shouldHydrate
        ? maybeUpdateUiObjects&lt;T&gt;(
            store,
            context.request,
            { shouldHydrate, identifier },
            peeked.content as ResourceErrorDocument,
            true
          )
        : peeked.content;
      const newError = cloneError(peeked);
      newError.content = content as object;
      throw newError;
    }

    return Promise.resolve(
      shouldHydrate
        ? maybeUpdateUiObjects&lt;T&gt;(
            store,
            context.request,
            { shouldHydrate, identifier },
            peeked!.content as ResourceDataDocument,
            true
          )
        : (peeked!.content as T)
    );
  },
};

function copyDocumentProperties(target: { links?: unknown; meta?: unknown; errors?: unknown }, source: object) {
  if (&#x27;links&#x27; in source) {
    target.links = source.links;
  }
  if (&#x27;meta&#x27; in source) {
    target.meta = source.meta;
  }
  if (&#x27;errors&#x27; in source) {
    target.errors = source.errors;
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
