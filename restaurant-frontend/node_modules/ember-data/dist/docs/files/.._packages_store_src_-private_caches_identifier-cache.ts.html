<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../packages/store/src/-private/caches/identifier-cache.ts - EmberData Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="EmberData Documentation" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.3.3+58cd284b</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/&lt;Interface&gt; Adapter.html">&lt;Interface&gt; Adapter</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Cache.html">&lt;Interface&gt; Cache</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Handler.html">&lt;Interface&gt; Handler</a></li>
                                <li><a href="../classes/&lt;Interface&gt; LifetimesService.html">&lt;Interface&gt; LifetimesService</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Serializer.html">&lt;Interface&gt; Serializer</a></li>
                                <li><a href="../classes/@ember-data/active-record/request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../classes/@ember-data/adapter/rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../classes/@ember-data/json-api/request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/@ember-data/request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../classes/@ember-data/rest/request.html">@ember-data/rest/request</a></li>
                                <li><a href="../classes/@ember-data/store.html">@ember-data/store</a></li>
                                <li><a href="../classes/@ember-data/tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/CacheCapabilitiesManager.html">CacheCapabilitiesManager</a></li>
                                <li><a href="../classes/CacheManager.html">CacheManager</a></li>
                                <li><a href="../classes/CanaryFeatureFlags.html">CanaryFeatureFlags</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/CurrentDeprecations.html">CurrentDeprecations</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/DebugLogging.html">DebugLogging</a></li>
                                <li><a href="../classes/Document.html">Document</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/Fetch.html">Fetch</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/Future.html">Future</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentifierCache.html">IdentifierCache</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/LifetimesService.html">LifetimesService</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NotificationManager.html">NotificationManager</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/PromiseBelongsTo.html">PromiseBelongsTo</a></li>
                                <li><a href="../classes/PromiseManyArray.html">PromiseManyArray</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/RequestManager.html">RequestManager</a></li>
                                <li><a href="../classes/RequestStateService.html">RequestStateService</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/SchemaService.html">SchemaService</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/StableRecordIdentifier.html">StableRecordIdentifier</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data_active-record_request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_adapter_error.html">@ember-data/adapter/error</a></li>
                                <li><a href="../modules/@ember-data_adapter_json-api.html">@ember-data/adapter/json-api</a></li>
                                <li><a href="../modules/@ember-data_adapter_rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../modules/@ember-data_canary-features.html">@ember-data/canary-features</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_deprecations.html">@ember-data/deprecations</a></li>
                                <li><a href="../modules/@ember-data_experimental-preview-types.html">@ember-data/experimental-preview-types</a></li>
                                <li><a href="../modules/@ember-data_graph.html">@ember-data/graph</a></li>
                                <li><a href="../modules/@ember-data_json-api.html">@ember-data/json-api</a></li>
                                <li><a href="../modules/@ember-data_json-api_request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../modules/@ember-data_legacy-compat.html">@ember-data/legacy-compat</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_request.html">@ember-data/request</a></li>
                                <li><a href="../modules/@ember-data_request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../modules/@ember-data_request_fetch.html">@ember-data/request/fetch</a></li>
                                <li><a href="../modules/@ember-data_rest_request.html">@ember-data/rest/request</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_serializer_json.html">@ember-data/serializer/json</a></li>
                                <li><a href="../modules/@ember-data_serializer_json-api.html">@ember-data/serializer/json-api</a></li>
                                <li><a href="../modules/@ember-data_serializer_rest.html">@ember-data/serializer/rest</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                                <li><a href="../modules/@ember-data_tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../modules/ember-data-overview.html">ember-data-overview</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../packages/store/src/-private/caches/identifier-cache.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
  @module @ember-data/store
*/
import { assert, warn } from &#x27;@ember/debug&#x27;;

import { getOwnConfig, macroCondition } from &#x27;@embroider/macros&#x27;;

import { LOG_IDENTIFIERS } from &#x27;@ember-data/debugging&#x27;;
import { DEBUG } from &#x27;@ember-data/env&#x27;;
import {
  CACHE_OWNER,
  DEBUG_CLIENT_ORIGINATED,
  DEBUG_IDENTIFIER_BUCKET,
  DEBUG_STALE_CACHE_OWNER,
  type Identifier,
  type IdentifierBucket,
  type RecordIdentifier,
  type StableDocumentIdentifier,
  type StableIdentifier,
  type StableRecordIdentifier,
} from &#x27;@warp-drive/core-types/identifier&#x27;;
import type { ImmutableRequestInfo } from &#x27;@warp-drive/core-types/request&#x27;;
import type { ExistingResourceObject, ResourceIdentifierObject } from &#x27;@warp-drive/core-types/spec/raw&#x27;;

import type {
  ForgetMethod,
  GenerationMethod,
  ResetMethod,
  ResourceData,
  UpdateMethod,
} from &#x27;../../-types/q/identifier&#x27;;
import coerceId from &#x27;../utils/coerce-id&#x27;;
import normalizeModelName from &#x27;../utils/normalize-model-name&#x27;;
import installPolyfill from &#x27;../utils/uuid-polyfill&#x27;;
import { hasId, hasLid, hasType } from &#x27;./resource-utils&#x27;;

const IDENTIFIERS = new Set();
const DOCUMENTS = new Set();

export function isStableIdentifier(identifier: unknown): identifier is StableRecordIdentifier {
  return (identifier as StableRecordIdentifier)[CACHE_OWNER] !== undefined || IDENTIFIERS.has(identifier);
}

export function isDocumentIdentifier(identifier: unknown): identifier is StableDocumentIdentifier {
  return DOCUMENTS.has(identifier);
}

const isFastBoot = typeof FastBoot !== &#x27;undefined&#x27;;
const _crypto: Crypto = isFastBoot ? (FastBoot.require(&#x27;crypto&#x27;) as Crypto) : window.crypto;

if (macroCondition(getOwnConfig&lt;{ polyfillUUID: boolean }&gt;().polyfillUUID)) {
  installPolyfill();
}

function uuidv4(): string {
  assert(
    &#x27;crypto.randomUUID needs to be avaliable. Some browsers incorrectly disallow it in insecure contexts. You maybe want to enable the polyfill: https://github.com/emberjs/data#randomuuid-polyfill&#x27;,
    typeof _crypto.randomUUID === &#x27;function&#x27;
  );
  return _crypto.randomUUID();
}

function freeze&lt;T&gt;(obj: T): T {
  if (typeof Object.freeze === &#x27;function&#x27;) {
    return Object.freeze(obj);
  }
  return obj;
}

interface KeyOptions {
  lid: IdentifierMap;
  id: IdentifierMap;
}
type TypeMap = { [key: string]: KeyOptions };

// type IdentifierTypeLookup = { all: Set&lt;StableRecordIdentifier&gt;; id: Map&lt;string, StableRecordIdentifier&gt; };
// type IdentifiersByType = Map&lt;string, IdentifierTypeLookup&gt;;
type IdentifierMap = Map&lt;string, StableRecordIdentifier&gt;;
type KeyInfo = {
  id: string | null;
  type: string;
};
type StableCache = {
  resources: IdentifierMap;
  documents: Map&lt;string, StableDocumentIdentifier&gt;;
  resourcesByType: TypeMap;
  polymorphicLidBackMap: Map&lt;string, string[]&gt;;
};

export type KeyInfoMethod = (resource: unknown, known: StableRecordIdentifier | null) =&gt; KeyInfo;

export type MergeMethod = (
  targetIdentifier: StableRecordIdentifier,
  matchedIdentifier: StableRecordIdentifier,
  resourceData: unknown
) =&gt; StableRecordIdentifier;

let configuredForgetMethod: ForgetMethod | null;
let configuredGenerationMethod: GenerationMethod | null;
let configuredResetMethod: ResetMethod | null;
let configuredUpdateMethod: UpdateMethod | null;
let configuredKeyInfoMethod: KeyInfoMethod | null;

export function setIdentifierGenerationMethod(method: GenerationMethod | null): void {
  configuredGenerationMethod = method;
}

export function setIdentifierUpdateMethod(method: UpdateMethod | null): void {
  configuredUpdateMethod = method;
}

export function setIdentifierForgetMethod(method: ForgetMethod | null): void {
  configuredForgetMethod = method;
}

export function setIdentifierResetMethod(method: ResetMethod | null): void {
  configuredResetMethod = method;
}

export function setKeyInfoForResource(method: KeyInfoMethod | null): void {
  configuredKeyInfoMethod = method;
}

function assertIsRequest(request: unknown): asserts request is ImmutableRequestInfo {
  return;
}

// Map&lt;type, Map&lt;id, lid&gt;&gt;
type TypeIdMap = Map&lt;string, Map&lt;string, string&gt;&gt;;
const NEW_IDENTIFIERS: TypeIdMap = new Map();
let IDENTIFIER_CACHE_ID = 0;

function updateTypeIdMapping(typeMap: TypeIdMap, identifier: StableRecordIdentifier, id: string): void {
  let idMap = typeMap.get(identifier.type);
  if (!idMap) {
    idMap = new Map();
    typeMap.set(identifier.type, idMap);
  }
  idMap.set(id, identifier.lid);
}

function defaultUpdateMethod(identifier: StableRecordIdentifier, data: unknown, bucket: &#x27;record&#x27;): void;
function defaultUpdateMethod(identifier: StableIdentifier, newData: unknown, bucket: never): void;
function defaultUpdateMethod(
  identifier: StableIdentifier | StableRecordIdentifier,
  data: unknown,
  bucket: &#x27;record&#x27;
): void {
  if (bucket === &#x27;record&#x27;) {
    assert(&#x60;Expected identifier to be a StableRecordIdentifier&#x60;, isStableIdentifier(identifier));
    if (!identifier.id &amp;&amp; hasId(data)) {
      updateTypeIdMapping(NEW_IDENTIFIERS, identifier, data.id);
    }
  }
}

function defaultKeyInfoMethod(resource: unknown, known: StableRecordIdentifier | null): KeyInfo {
  // TODO RFC something to make this configurable
  const id = hasId(resource) ? coerceId(resource.id) : null;
  const type = hasType(resource) ? normalizeModelName(resource.type) : known ? known.type : null;

  assert(&#x60;Expected keyInfoForResource to provide a type for the resource&#x60;, type);

  return { type, id };
}

function defaultGenerationMethod(data: ImmutableRequestInfo, bucket: &#x27;document&#x27;): string | null;
function defaultGenerationMethod(data: ResourceData | { type: string }, bucket: &#x27;record&#x27;): string;
function defaultGenerationMethod(
  data: ImmutableRequestInfo | ResourceData | { type: string },
  bucket: IdentifierBucket
): string | null {
  if (bucket === &#x27;record&#x27;) {
    if (hasLid(data)) {
      return data.lid;
    }

    assert(&#x60;Cannot generate an identifier for a resource without a type&#x60;, hasType(data));

    if (hasId(data)) {
      const type = normalizeModelName(data.type);
      const lid = NEW_IDENTIFIERS.get(type)?.get(data.id);

      return lid || &#x60;@lid:${type}-${data.id}&#x60;;
    }

    return uuidv4();
  } else if (bucket === &#x27;document&#x27;) {
    assertIsRequest(data);
    if (!data.url) {
      return null;
    }
    if (!data.method || data.method.toUpperCase() === &#x27;GET&#x27;) {
      return data.url;
    }
    return null;
  }
  assert(&#x60;Unknown bucket ${bucket as string}&#x60;, false);
}

function defaultEmptyCallback(...args: unknown[]): void {}
function defaultMergeMethod(
  a: StableRecordIdentifier,
  _b: StableRecordIdentifier,
  _c: unknown
): StableRecordIdentifier {
  return a;
}

let DEBUG_MAP: WeakMap&lt;StableRecordIdentifier, StableRecordIdentifier&gt;;
if (DEBUG) {
  DEBUG_MAP = new WeakMap&lt;StableRecordIdentifier, StableRecordIdentifier&gt;();
}

/**
 * Each instance of {Store} receives a unique instance of a IdentifierCache.
 *
 * This cache is responsible for assigning or retrieving the unique identify
 * for arbitrary resource data encountered by the store. Data representing
 * a unique resource or record should always be represented by the same
 * identifier.
 *
 * It can be configured by consuming applications.
 *
 * @class IdentifierCache
   @public
 */
export class IdentifierCache {
  declare _cache: StableCache;
  declare _generate: GenerationMethod;
  declare _update: UpdateMethod;
  declare _forget: ForgetMethod;
  declare _reset: ResetMethod;
  declare _merge: MergeMethod;
  declare _keyInfoForResource: KeyInfoMethod;
  declare _isDefaultConfig: boolean;
  declare _id: number;

  constructor() {
    // we cache the user configuredGenerationMethod at init because it must
    // be configured prior and is not allowed to be changed
    this._generate = configuredGenerationMethod || (defaultGenerationMethod as GenerationMethod);
    this._update = configuredUpdateMethod || defaultUpdateMethod;
    this._forget = configuredForgetMethod || defaultEmptyCallback;
    this._reset = configuredResetMethod || defaultEmptyCallback;
    this._merge = defaultMergeMethod;
    this._keyInfoForResource = configuredKeyInfoMethod || defaultKeyInfoMethod;
    this._isDefaultConfig = !configuredGenerationMethod;
    this._id = IDENTIFIER_CACHE_ID++;

    this._cache = {
      resources: new Map&lt;string, StableRecordIdentifier&gt;(),
      resourcesByType: Object.create(null) as TypeMap,
      documents: new Map&lt;string, StableDocumentIdentifier&gt;(),
      polymorphicLidBackMap: new Map&lt;string, string[]&gt;(),
    };
  }

  /**
   * Internal hook to allow management of merge conflicts with identifiers.
   *
   * we allow late binding of this private internal merge so that
   * the cache can insert itself here to handle elimination of duplicates
   *
   * @method __configureMerge
   * @private
   */
  __configureMerge(method: MergeMethod | null) {
    this._merge = method || defaultMergeMethod;
  }

  upgradeIdentifier(resource: { type: string; id: string | null; lid?: string }): StableRecordIdentifier {
    return this._getRecordIdentifier(resource, 2);
  }

  /**
   * @method _getRecordIdentifier
   * @private
   */
  _getRecordIdentifier(
    resource: { type: string; id: string | null; lid?: string },
    shouldGenerate: 2
  ): StableRecordIdentifier;
  _getRecordIdentifier(resource: unknown, shouldGenerate: 1): StableRecordIdentifier;
  _getRecordIdentifier(resource: unknown, shouldGenerate: 0): StableRecordIdentifier | undefined;
  _getRecordIdentifier(resource: unknown, shouldGenerate: 0 | 1 | 2): StableRecordIdentifier | undefined {
    if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.groupCollapsed(&#x60;Identifiers: ${shouldGenerate ? &#x27;Generating&#x27; : &#x27;Peeking&#x27;} Identifier&#x60;, resource);
    }
    // short circuit if we&#x27;re already the stable version
    if (isStableIdentifier(resource)) {
      if (DEBUG) {
        // TODO should we instead just treat this case as a new generation skipping the short circuit?
        if (!this._cache.resources.has(resource.lid) || this._cache.resources.get(resource.lid) !== resource) {
          throw new Error(&#x60;The supplied identifier ${JSON.stringify(resource)} does not belong to this store instance&#x60;);
        }
      }
      if (LOG_IDENTIFIERS) {
        // eslint-disable-next-line no-console
        console.log(&#x60;Identifiers: cache HIT - Stable ${resource.lid}&#x60;);
        // eslint-disable-next-line no-console
        console.groupEnd();
      }
      return resource;
    }

    // the resource is unknown, ask the application to identify this data for us
    const lid = this._generate(resource, &#x27;record&#x27;);
    if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.log(&#x60;Identifiers: ${lid ? &#x27;no &#x27; : &#x27;&#x27;}lid ${lid ? lid + &#x27; &#x27; : &#x27;&#x27;}determined for resource&#x60;, resource);
    }

    let identifier: StableRecordIdentifier | null = /*#__NOINLINE__*/ getIdentifierFromLid(this._cache, lid, resource);
    if (identifier !== null) {
      if (LOG_IDENTIFIERS) {
        // eslint-disable-next-line no-console
        console.groupEnd();
      }
      return identifier;
    }

    if (shouldGenerate === 0) {
      if (LOG_IDENTIFIERS) {
        // eslint-disable-next-line no-console
        console.groupEnd();
      }
      return;
    }

    // if we still don&#x27;t have an identifier, time to generate one
    if (shouldGenerate === 2) {
      (resource as StableRecordIdentifier).lid = lid;
      (resource as StableRecordIdentifier)[CACHE_OWNER] = this._id;
      identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(resource as StableRecordIdentifier, &#x27;record&#x27;, false);
    } else {
      // we lie a bit here as a memory optimization
      const keyInfo = this._keyInfoForResource(resource, null) as StableRecordIdentifier;
      keyInfo.lid = lid;
      keyInfo[CACHE_OWNER] = this._id;
      identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(keyInfo, &#x27;record&#x27;, false);
    }

    addResourceToCache(this._cache, identifier);

    if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.groupEnd();
    }

    return identifier;
  }

  /**
   * allows us to peek without generating when needed
   * useful for the &quot;create&quot; case when we need to see if
   * we are accidentally overwritting something
   *
   * @method peekRecordIdentifier
   * @param resource
   * @return {StableRecordIdentifier | undefined}
   * @private
   */
  peekRecordIdentifier(resource: ResourceIdentifierObject | Identifier): StableRecordIdentifier | undefined {
    return this._getRecordIdentifier(resource, 0);
  }

  /**
    Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.
    Returns &#x60;null&#x60; if the request does not have a &#x60;cacheKey&#x60; or &#x60;url&#x60;.

    @method getOrCreateDocumentIdentifier
    @param request
    @return {StableDocumentIdentifier | null}
    @public
  */
  getOrCreateDocumentIdentifier(request: ImmutableRequestInfo): StableDocumentIdentifier | null {
    let cacheKey: string | null | undefined = request.cacheOptions?.key;

    if (!cacheKey) {
      cacheKey = this._generate(request, &#x27;document&#x27;);
    }

    if (!cacheKey) {
      return null;
    }

    let identifier = this._cache.documents.get(cacheKey);

    if (identifier === undefined) {
      identifier = { lid: cacheKey };
      if (DEBUG) {
        Object.freeze(identifier);
      }
      DOCUMENTS.add(identifier);
      this._cache.documents.set(cacheKey, identifier);
    }

    return identifier;
  }

  /**
    Returns the Identifier for the given Resource, creates one if it does not yet exist.

    Specifically this means that we:

    - validate the &#x60;id&#x60; &#x60;type&#x60; and &#x60;lid&#x60; combo against known identifiers
    - return an object with an &#x60;lid&#x60; that is stable (repeated calls with the same
      &#x60;id&#x60; + &#x60;type&#x60; or &#x60;lid&#x60; will return the same &#x60;lid&#x60; value)
    - this referential stability of the object itself is guaranteed

    @method getOrCreateRecordIdentifier
    @param resource
    @return {StableRecordIdentifier}
    @public
  */
  getOrCreateRecordIdentifier(resource: unknown): StableRecordIdentifier {
    return this._getRecordIdentifier(resource, 1);
  }

  /**
   Returns a new Identifier for the supplied data. Call this method to generate
   an identifier when a new resource is being created local to the client and
   potentially does not have an &#x60;id&#x60;.

   Delegates generation to the user supplied &#x60;GenerateMethod&#x60; if one has been provided
   with the signature &#x60;generateMethod({ type }, &#x27;record&#x27;)&#x60;.

   @method createIdentifierForNewRecord
   @param data
   @return {StableRecordIdentifier}
   @public
  */
  createIdentifierForNewRecord(data: { type: string; id?: string | null }): StableRecordIdentifier {
    const newLid = this._generate(data, &#x27;record&#x27;);
    const identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(
      { id: data.id || null, type: data.type, lid: newLid, [CACHE_OWNER]: this._id },
      &#x27;record&#x27;,
      true
    );

    // populate our unique table
    if (DEBUG) {
      if (this._cache.resources.has(identifier.lid)) {
        throw new Error(&#x60;The lid generated for the new record is not unique as it matches an existing identifier&#x60;);
      }
    }

    /*#__NOINLINE__*/ addResourceToCache(this._cache, identifier);

    if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.log(&#x60;Identifiers: created identifier ${String(identifier)} for newly generated resource&#x60;, data);
    }

    return identifier;
  }

  /**
   Provides the opportunity to update secondary lookup tables for existing identifiers
   Called after an identifier created with &#x60;createIdentifierForNewRecord&#x60; has been
   committed.

   Assigned &#x60;id&#x60; to an &#x60;Identifier&#x60; if &#x60;id&#x60; has not previously existed; however,
   attempting to change the &#x60;id&#x60; or calling update without providing an &#x60;id&#x60; when
   one is missing will throw an error.

    - sets &#x60;id&#x60; (if &#x60;id&#x60; was previously &#x60;null&#x60;)
    - &#x60;lid&#x60; and &#x60;type&#x60; MUST NOT be altered post creation

    If a merge occurs, it is possible the returned identifier does not match the originally
    provided identifier. In this case the abandoned identifier will go through the usual
    &#x60;forgetRecordIdentifier&#x60; codepaths.

    @method updateRecordIdentifier
    @param identifierObject
    @param data
    @return {StableRecordIdentifier}
    @public
  */
  updateRecordIdentifier(identifierObject: RecordIdentifier, data: unknown): StableRecordIdentifier {
    let identifier = this.getOrCreateRecordIdentifier(identifierObject);

    const keyInfo = this._keyInfoForResource(data, identifier);
    let existingIdentifier = /*#__NOINLINE__*/ detectMerge(this._cache, keyInfo, identifier, data);
    const hadLid = hasLid(data);

    if (!existingIdentifier) {
      // If the incoming type does not match the identifier type, we need to create an identifier for the incoming
      // data so we can merge the incoming data with the existing identifier, see #7325 and #7363
      if (identifier.type !== keyInfo.type) {
        if (hadLid) {
          // Strip the lid to ensure we force a new identifier creation
          delete (data as { lid?: string }).lid;
        }
        existingIdentifier = this.getOrCreateRecordIdentifier(data);
      }
    }

    if (existingIdentifier) {
      const generatedIdentifier = identifier;
      identifier = this._mergeRecordIdentifiers(keyInfo, generatedIdentifier, existingIdentifier, data);

      // make sure that the &#x60;lid&#x60; on the data we are processing matches the lid we kept
      if (hadLid) {
        data.lid = identifier.lid;
      }

      if (LOG_IDENTIFIERS) {
        // eslint-disable-next-line no-console
        console.log(
          &#x60;Identifiers: merged identifiers ${generatedIdentifier.lid} and ${existingIdentifier.lid} for resource into ${identifier.lid}&#x60;,
          data
        );
      }
    }

    const id = identifier.id;
    /*#__NOINLINE__*/ performRecordIdentifierUpdate(identifier, keyInfo, data, this._update);
    const newId = identifier.id;

    // add to our own secondary lookup table
    if (id !== newId &amp;&amp; newId !== null) {
      if (LOG_IDENTIFIERS) {
        // eslint-disable-next-line no-console
        console.log(
          &#x60;Identifiers: updated id for identifier ${identifier.lid} from &#x27;${String(id)}&#x27; to &#x27;${String(
            newId
          )}&#x27; for resource&#x60;,
          data
        );
      }

      const typeSet = this._cache.resourcesByType[identifier.type];
      assert(&#x60;Expected to find a typeSet for ${identifier.type}&#x60;, typeSet);
      typeSet.id.set(newId, identifier);

      if (id !== null) {
        typeSet.id.delete(id);
      }
    } else if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.log(&#x60;Identifiers: updated identifier ${identifier.lid} resource&#x60;, data);
    }

    return identifier;
  }

  /**
   * @method _mergeRecordIdentifiers
   * @private
   */
  _mergeRecordIdentifiers(
    keyInfo: KeyInfo,
    identifier: StableRecordIdentifier,
    existingIdentifier: StableRecordIdentifier,
    data: unknown
  ): StableRecordIdentifier {
    assert(&#x60;Expected keyInfo to contain an id&#x60;, hasId(keyInfo));
    // delegate determining which identifier to keep to the configured MergeMethod
    const kept = this._merge(identifier, existingIdentifier, data);
    const abandoned = kept === identifier ? existingIdentifier : identifier;

    // get any backreferences before forgetting this identifier, as it will be removed from the cache
    // and we will no longer be able to find them
    const abandonedBackReferences = this._cache.polymorphicLidBackMap.get(abandoned.lid);
    // delete the backreferences for the abandoned identifier so that forgetRecordIdentifier
    // does not try to remove them.
    if (abandonedBackReferences) this._cache.polymorphicLidBackMap.delete(abandoned.lid);

    // cleanup the identifier we no longer need
    this.forgetRecordIdentifier(abandoned);

    // ensure a secondary cache entry for the original lid for the abandoned identifier
    this._cache.resources.set(abandoned.lid, kept);

    // backReferences let us know which other identifiers are pointing at this identifier
    // so we can delete them later if we forget this identifier
    const keptBackReferences = this._cache.polymorphicLidBackMap.get(kept.lid) ?? [];
    keptBackReferences.push(abandoned.lid);

    // update the backreferences from the abandoned identifier to be for the kept identifier
    if (abandonedBackReferences) {
      abandonedBackReferences.forEach((lid) =&gt; {
        keptBackReferences.push(lid);
        this._cache.resources.set(lid, kept);
      });
    }

    this._cache.polymorphicLidBackMap.set(kept.lid, keptBackReferences);
    return kept;
  }

  /**
   Provides the opportunity to eliminate an identifier from secondary lookup tables
   as well as eliminates it from ember-data&#x27;s own lookup tables and book keeping.

   Useful when a record has been deleted and the deletion has been persisted and
   we do not care about the record anymore. Especially useful when an &#x60;id&#x60; of a
   deleted record might be reused later for a new record.

   @method forgetRecordIdentifier
   @param identifierObject
   @public
  */
  forgetRecordIdentifier(identifierObject: RecordIdentifier): void {
    const identifier = this.getOrCreateRecordIdentifier(identifierObject);
    const typeSet = this._cache.resourcesByType[identifier.type];
    assert(&#x60;Expected to find a typeSet for ${identifier.type}&#x60;, typeSet);

    if (identifier.id !== null) {
      typeSet.id.delete(identifier.id);
    }
    this._cache.resources.delete(identifier.lid);
    typeSet.lid.delete(identifier.lid);

    const backReferences = this._cache.polymorphicLidBackMap.get(identifier.lid);
    if (backReferences) {
      backReferences.forEach((lid) =&gt; {
        this._cache.resources.delete(lid);
      });
      this._cache.polymorphicLidBackMap.delete(identifier.lid);
    }

    if (DEBUG) {
      identifier[DEBUG_STALE_CACHE_OWNER] = identifier[CACHE_OWNER];
    }
    identifier[CACHE_OWNER] = undefined;
    IDENTIFIERS.delete(identifier);
    this._forget(identifier, &#x27;record&#x27;);
    if (LOG_IDENTIFIERS) {
      // eslint-disable-next-line no-console
      console.log(&#x60;Identifiers: released identifier ${identifierObject.lid}&#x60;);
    }
  }

  destroy() {
    NEW_IDENTIFIERS.clear();
    this._cache.documents.forEach((identifier) =&gt; {
      DOCUMENTS.delete(identifier);
    });
    this._reset();
  }
}

function makeStableRecordIdentifier(
  recordIdentifier: {
    type: string;
    id: string | null;
    lid: string;
    [CACHE_OWNER]: number | undefined;
  },
  bucket: IdentifierBucket,
  clientOriginated: boolean
): StableRecordIdentifier {
  IDENTIFIERS.add(recordIdentifier);

  if (DEBUG) {
    // we enforce immutability in dev
    //  but preserve our ability to do controlled updates to the reference
    let wrapper: StableRecordIdentifier = {
      get lid() {
        return recordIdentifier.lid;
      },
      get id() {
        return recordIdentifier.id;
      },
      get type() {
        return recordIdentifier.type;
      },
      get [CACHE_OWNER](): number | undefined {
        return recordIdentifier[CACHE_OWNER];
      },
      set [CACHE_OWNER](value: number) {
        recordIdentifier[CACHE_OWNER] = value;
      },
      get [DEBUG_STALE_CACHE_OWNER](): number | undefined {
        return (recordIdentifier as StableRecordIdentifier)[DEBUG_STALE_CACHE_OWNER];
      },
      set [DEBUG_STALE_CACHE_OWNER](value: number | undefined) {
        (recordIdentifier as StableRecordIdentifier)[DEBUG_STALE_CACHE_OWNER] = value;
      },
    };
    Object.defineProperty(wrapper, &#x27;toString&#x27;, {
      enumerable: false,
      value: () =&gt; {
        const { type, id, lid } = recordIdentifier;
        return &#x60;${clientOriginated ? &#x27;[CLIENT_ORIGINATED] &#x27; : &#x27;&#x27;}${String(type)}:${String(id)} (${lid})&#x60;;
      },
    });
    Object.defineProperty(wrapper, &#x27;toJSON&#x27;, {
      enumerable: false,
      value: () =&gt; {
        const { type, id, lid } = recordIdentifier;
        return { type, id, lid };
      },
    });
    wrapper[DEBUG_CLIENT_ORIGINATED] = clientOriginated;
    wrapper[DEBUG_IDENTIFIER_BUCKET] = bucket;
    IDENTIFIERS.add(wrapper);
    DEBUG_MAP.set(wrapper, recordIdentifier);
    wrapper = freeze(wrapper);
    return wrapper;
  }

  return recordIdentifier;
}

function performRecordIdentifierUpdate(
  identifier: StableRecordIdentifier,
  keyInfo: KeyInfo,
  data: unknown,
  updateFn: UpdateMethod
) {
  if (DEBUG) {
    const { id, type } = keyInfo;

    // get the mutable instance behind our proxy wrapper
    const wrapper = identifier;
    identifier = DEBUG_MAP.get(wrapper)!;

    if (hasLid(data)) {
      const lid = data.lid;
      if (lid !== identifier.lid) {
        throw new Error(
          &#x60;The &#x27;lid&#x27; for a RecordIdentifier cannot be updated once it has been created. Attempted to set lid for &#x27;${wrapper.lid}&#x27; to &#x27;${lid}&#x27;.&#x60;
        );
      }
    }

    if (id &amp;&amp; identifier.id !== null &amp;&amp; identifier.id !== id) {
      // here we warn and ignore, as this may be a mistake, but we allow the user
      // to have multiple cache-keys pointing at a single lid so we cannot error
      warn(
        &#x60;The &#x27;id&#x27; for a RecordIdentifier should not be updated once it has been set. Attempted to set id for &#x27;${wrapper.lid}&#x27; to &#x27;${id}&#x27;.&#x60;,
        false,
        { id: &#x27;ember-data:multiple-ids-for-identifier&#x27; }
      );
    }

    // TODO consider just ignoring here to allow flexible polymorphic support
    if (type &amp;&amp; type !== identifier.type) {
      throw new Error(
        &#x60;The &#x27;type&#x27; for a RecordIdentifier cannot be updated once it has been set. Attempted to set type for &#x27;${wrapper.lid}&#x27; to &#x27;${type}&#x27;.&#x60;
      );
    }

    updateFn(wrapper, data, &#x27;record&#x27;);
  } else {
    updateFn(identifier, data, &#x27;record&#x27;);
  }

  // upgrade the ID, this is a &quot;one time only&quot; ability
  // for the multiple-cache-key scenario we &quot;could&quot;
  // use a heuristic to guess the best id for display
  // (usually when &#x60;data.id&#x60; is available and &#x60;data.attributes&#x60; is not)
  if ((data as ExistingResourceObject).id !== undefined) {
    identifier.id = coerceId((data as ExistingResourceObject).id);
  }
}

function detectMerge(
  cache: StableCache,
  keyInfo: KeyInfo,
  identifier: StableRecordIdentifier,
  data: unknown
): StableRecordIdentifier | false {
  const newId = keyInfo.id;
  const { id, type, lid } = identifier;
  const typeSet = cache.resourcesByType[identifier.type];

  // if the IDs are present but do not match
  // then check if we have an existing identifier
  // for the newer ID.
  if (id !== null &amp;&amp; id !== newId &amp;&amp; newId !== null) {
    const existingIdentifier = typeSet &amp;&amp; typeSet.id.get(newId);

    return existingIdentifier !== undefined ? existingIdentifier : false;
  } else {
    const newType = keyInfo.type;

    // If the ids and type are the same but lid is not the same, we should trigger a merge of the identifiers
    // we trigger a merge of the identifiers
    // though probably we should just throw an error here
    if (id !== null &amp;&amp; id === newId &amp;&amp; newType === type &amp;&amp; hasLid(data) &amp;&amp; data.lid !== lid) {
      return getIdentifierFromLid(cache, data.lid, data) || false;

      // If the lids are the same, and ids are the same, but types are different we should trigger a merge of the identifiers
    } else if (id !== null &amp;&amp; id === newId &amp;&amp; newType &amp;&amp; newType !== type &amp;&amp; hasLid(data) &amp;&amp; data.lid === lid) {
      const newTypeSet = cache.resourcesByType[newType];
      const existingIdentifier = newTypeSet &amp;&amp; newTypeSet.id.get(newId);

      return existingIdentifier !== undefined ? existingIdentifier : false;
    }
  }

  return false;
}

function getIdentifierFromLid(cache: StableCache, lid: string, resource: unknown): StableRecordIdentifier | null {
  const identifier = cache.resources.get(lid);
  if (LOG_IDENTIFIERS) {
    // eslint-disable-next-line no-console
    console.log(&#x60;Identifiers: cache ${identifier ? &#x27;HIT&#x27; : &#x27;MISS&#x27;} - Non-Stable ${lid}&#x60;, resource);
  }
  return identifier || null;
}

function addResourceToCache(cache: StableCache, identifier: StableRecordIdentifier): void {
  cache.resources.set(identifier.lid, identifier);
  let typeSet = cache.resourcesByType[identifier.type];

  if (!typeSet) {
    typeSet = { lid: new Map(), id: new Map() };
    cache.resourcesByType[identifier.type] = typeSet;
  }

  typeSet.lid.set(identifier.lid, identifier);
  if (identifier.id) {
    typeSet.id.set(identifier.id, identifier);
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
