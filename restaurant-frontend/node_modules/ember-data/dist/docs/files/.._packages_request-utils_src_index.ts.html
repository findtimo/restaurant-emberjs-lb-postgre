<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../packages/request-utils/src/index.ts - EmberData Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="EmberData Documentation" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.3.3+58cd284b</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/&lt;Interface&gt; Adapter.html">&lt;Interface&gt; Adapter</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Cache.html">&lt;Interface&gt; Cache</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Handler.html">&lt;Interface&gt; Handler</a></li>
                                <li><a href="../classes/&lt;Interface&gt; LifetimesService.html">&lt;Interface&gt; LifetimesService</a></li>
                                <li><a href="../classes/&lt;Interface&gt; Serializer.html">&lt;Interface&gt; Serializer</a></li>
                                <li><a href="../classes/@ember-data/active-record/request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../classes/@ember-data/adapter/rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../classes/@ember-data/json-api/request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../classes/@ember-data/model.html">@ember-data/model</a></li>
                                <li><a href="../classes/@ember-data/request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../classes/@ember-data/rest/request.html">@ember-data/rest/request</a></li>
                                <li><a href="../classes/@ember-data/store.html">@ember-data/store</a></li>
                                <li><a href="../classes/@ember-data/tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../classes/AbortError.html">AbortError</a></li>
                                <li><a href="../classes/Adapter.html">Adapter</a></li>
                                <li><a href="../classes/AdapterError.html">AdapterError</a></li>
                                <li><a href="../classes/BelongsToReference.html">BelongsToReference</a></li>
                                <li><a href="../classes/BooleanTransform.html">BooleanTransform</a></li>
                                <li><a href="../classes/BuildURLMixin.html">BuildURLMixin</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/CacheCapabilitiesManager.html">CacheCapabilitiesManager</a></li>
                                <li><a href="../classes/CacheManager.html">CacheManager</a></li>
                                <li><a href="../classes/CanaryFeatureFlags.html">CanaryFeatureFlags</a></li>
                                <li><a href="../classes/ConflictError.html">ConflictError</a></li>
                                <li><a href="../classes/CurrentDeprecations.html">CurrentDeprecations</a></li>
                                <li><a href="../classes/DateTransform.html">DateTransform</a></li>
                                <li><a href="../classes/DebugLogging.html">DebugLogging</a></li>
                                <li><a href="../classes/Document.html">Document</a></li>
                                <li><a href="../classes/EmbeddedRecordsMixin.html">EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/Errors.html">Errors</a></li>
                                <li><a href="../classes/Fetch.html">Fetch</a></li>
                                <li><a href="../classes/ForbiddenError.html">ForbiddenError</a></li>
                                <li><a href="../classes/Future.html">Future</a></li>
                                <li><a href="../classes/HasManyReference.html">HasManyReference</a></li>
                                <li><a href="../classes/IdentifierCache.html">IdentifierCache</a></li>
                                <li><a href="../classes/InspectorDataAdapter.html">InspectorDataAdapter</a></li>
                                <li><a href="../classes/InvalidError.html">InvalidError</a></li>
                                <li><a href="../classes/JSONAPIAdapter.html">JSONAPIAdapter</a></li>
                                <li><a href="../classes/JSONAPISerializer.html">JSONAPISerializer</a></li>
                                <li><a href="../classes/JSONSerializer.html">JSONSerializer</a></li>
                                <li><a href="../classes/LifetimesService.html">LifetimesService</a></li>
                                <li><a href="../classes/ManyArray.html">ManyArray</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/NotFoundError.html">NotFoundError</a></li>
                                <li><a href="../classes/NotificationManager.html">NotificationManager</a></li>
                                <li><a href="../classes/NumberTransform.html">NumberTransform</a></li>
                                <li><a href="../classes/PromiseBelongsTo.html">PromiseBelongsTo</a></li>
                                <li><a href="../classes/PromiseManyArray.html">PromiseManyArray</a></li>
                                <li><a href="../classes/RecordArray.html">RecordArray</a></li>
                                <li><a href="../classes/RecordReference.html">RecordReference</a></li>
                                <li><a href="../classes/RequestManager.html">RequestManager</a></li>
                                <li><a href="../classes/RequestStateService.html">RequestStateService</a></li>
                                <li><a href="../classes/RESTAdapter.html">RESTAdapter</a></li>
                                <li><a href="../classes/RESTSerializer.html">RESTSerializer</a></li>
                                <li><a href="../classes/SchemaService.html">SchemaService</a></li>
                                <li><a href="../classes/Serializer.html">Serializer</a></li>
                                <li><a href="../classes/ServerError.html">ServerError</a></li>
                                <li><a href="../classes/Snapshot.html">Snapshot</a></li>
                                <li><a href="../classes/SnapshotRecordArray.html">SnapshotRecordArray</a></li>
                                <li><a href="../classes/StableRecordIdentifier.html">StableRecordIdentifier</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                                <li><a href="../classes/StringTransform.html">StringTransform</a></li>
                                <li><a href="../classes/TimeoutError.html">TimeoutError</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/UnauthorizedError.html">UnauthorizedError</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/@ember-data_active-record_request.html">@ember-data/active-record/request</a></li>
                                <li><a href="../modules/@ember-data_adapter.html">@ember-data/adapter</a></li>
                                <li><a href="../modules/@ember-data_adapter_error.html">@ember-data/adapter/error</a></li>
                                <li><a href="../modules/@ember-data_adapter_json-api.html">@ember-data/adapter/json-api</a></li>
                                <li><a href="../modules/@ember-data_adapter_rest.html">@ember-data/adapter/rest</a></li>
                                <li><a href="../modules/@ember-data_canary-features.html">@ember-data/canary-features</a></li>
                                <li><a href="../modules/@ember-data_debug.html">@ember-data/debug</a></li>
                                <li><a href="../modules/@ember-data_deprecations.html">@ember-data/deprecations</a></li>
                                <li><a href="../modules/@ember-data_experimental-preview-types.html">@ember-data/experimental-preview-types</a></li>
                                <li><a href="../modules/@ember-data_graph.html">@ember-data/graph</a></li>
                                <li><a href="../modules/@ember-data_json-api.html">@ember-data/json-api</a></li>
                                <li><a href="../modules/@ember-data_json-api_request.html">@ember-data/json-api/request</a></li>
                                <li><a href="../modules/@ember-data_legacy-compat.html">@ember-data/legacy-compat</a></li>
                                <li><a href="../modules/@ember-data_model.html">@ember-data/model</a></li>
                                <li><a href="../modules/@ember-data_request.html">@ember-data/request</a></li>
                                <li><a href="../modules/@ember-data_request-utils.html">@ember-data/request-utils</a></li>
                                <li><a href="../modules/@ember-data_request_fetch.html">@ember-data/request/fetch</a></li>
                                <li><a href="../modules/@ember-data_rest_request.html">@ember-data/rest/request</a></li>
                                <li><a href="../modules/@ember-data_serializer.html">@ember-data/serializer</a></li>
                                <li><a href="../modules/@ember-data_serializer_json.html">@ember-data/serializer/json</a></li>
                                <li><a href="../modules/@ember-data_serializer_json-api.html">@ember-data/serializer/json-api</a></li>
                                <li><a href="../modules/@ember-data_serializer_rest.html">@ember-data/serializer/rest</a></li>
                                <li><a href="../modules/@ember-data_store.html">@ember-data/store</a></li>
                                <li><a href="../modules/@ember-data_tracking.html">@ember-data/tracking</a></li>
                                <li><a href="../modules/ember-data-overview.html">ember-data-overview</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../packages/request-utils/src/index.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { assert, deprecate } from &#x27;@ember/debug&#x27;;

import type { Cache } from &#x27;@warp-drive/core-types/cache&#x27;;
import type { StableDocumentIdentifier } from &#x27;@warp-drive/core-types/identifier&#x27;;
import type { QueryParamsSerializationOptions, QueryParamsSource, Serializable } from &#x27;@warp-drive/core-types/params&#x27;;
import type { ImmutableRequestInfo, ResponseInfo } from &#x27;@warp-drive/core-types/request&#x27;;

type Store = {
  cache: Cache;
};

/**
 * Simple utility function to assist in url building,
 * query params, and other common request operations.
 *
 * These primitives may be used directly or composed
 * by request builders to provide a consistent interface
 * for building requests.
 *
 * For instance:
 *
 * &#x60;&#x60;&#x60;ts
 * import { buildBaseURL, buildQueryParams } from &#x27;@ember-data/request-utils&#x27;;
 *
 * const baseURL = buildBaseURL({
 *   host: &#x27;https://api.example.com&#x27;,
 *   namespace: &#x27;api/v1&#x27;,
 *   resourcePath: &#x27;emberDevelopers&#x27;,
 *   op: &#x27;query&#x27;,
 *   identifier: { type: &#x27;ember-developer&#x27; }
 * });
 * const url = &#x60;${baseURL}?${buildQueryParams({ name: &#x27;Chris&#x27;, include:[&#x27;pets&#x27;] })}&#x60;;
 * // =&gt; &#x27;https://api.example.com/api/v1/emberDevelopers?include=pets&amp;name=Chris&#x27;
 * &#x60;&#x60;&#x60;
 *
 * This is useful, but not as useful as the REST request builder for query which is sugar
 * over this (and more!):
 *
 * &#x60;&#x60;&#x60;ts
 * import { query } from &#x27;@ember-data/rest/request&#x27;;
 *
 * const options = query(&#x27;ember-developer&#x27;, { name: &#x27;Chris&#x27;, include:[&#x27;pets&#x27;] });
 * // =&gt; { url: &#x27;https://api.example.com/api/v1/emberDevelopers?include=pets&amp;name=Chris&#x27; }
 * // Note: options will also include other request options like headers, method, etc.
 * &#x60;&#x60;&#x60;
 *
 * @module @ember-data/request-utils
 * @main @ember-data/request-utils
 * @public
 */

// prevents the final constructed object from needing to add
// host and namespace which are provided by the final consuming
// class to the prototype which can result in overwrite errors

export interface BuildURLConfig {
  host: string | null;
  namespace: string | null;
}

const CONFIG: BuildURLConfig = {
  host: &#x27;&#x27;,
  namespace: &#x27;&#x27;,
};

/**
 * Sets the global configuration for &#x60;buildBaseURL&#x60;
 * for host and namespace values for the application.
 *
 * These values may still be overridden by passing
 * them to buildBaseURL directly.
 *
 * This method may be called as many times as needed.
 * host values of &#x60;&#x27;&#x27;&#x60; or &#x60;&#x27;/&#x27;&#x60; are equivalent.
 *
 * Except for the value of &#x60;/&#x60; as host, host should not
 * end with &#x60;/&#x60;.
 *
 * namespace should not start or end with a &#x60;/&#x60;.
 *
 * &#x60;&#x60;&#x60;ts
 * type BuildURLConfig = {
 *   host: string;
 *   namespace: string&#x27;
 * }
 * &#x60;&#x60;&#x60;
 *
 * Example:
 *
 * &#x60;&#x60;&#x60;ts
 * import { setBuildURLConfig } from &#x27;@ember-data/request-utils&#x27;;
 *
 * setBuildURLConfig({
 *   host: &#x27;https://api.example.com&#x27;,
 *   namespace: &#x27;api/v1&#x27;
 * });
 * &#x60;&#x60;&#x60;
 *
 * @method setBuildURLConfig
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param {BuildURLConfig} config
 * @return void
 */
export function setBuildURLConfig(config: BuildURLConfig) {
  assert(&#x60;setBuildURLConfig: You must pass a config object&#x60;, config);
  assert(
    &#x60;setBuildURLConfig: You must pass a config object with a &#x27;host&#x27; or &#x27;namespace&#x27; property&#x60;,
    &#x27;host&#x27; in config || &#x27;namespace&#x27; in config
  );

  CONFIG.host = config.host || &#x27;&#x27;;
  CONFIG.namespace = config.namespace || &#x27;&#x27;;

  assert(
    &#x60;buildBaseURL: host must NOT end with &#x27;/&#x27;, received &#x27;${CONFIG.host}&#x27;&#x60;,
    CONFIG.host === &#x27;/&#x27; || !CONFIG.host.endsWith(&#x27;/&#x27;)
  );
  assert(
    &#x60;buildBaseURL: namespace must NOT start with &#x27;/&#x27;, received &#x27;${CONFIG.namespace}&#x27;&#x60;,
    !CONFIG.namespace.startsWith(&#x27;/&#x27;)
  );
  assert(
    &#x60;buildBaseURL: namespace must NOT end with &#x27;/&#x27;, received &#x27;${CONFIG.namespace}&#x27;&#x60;,
    !CONFIG.namespace.endsWith(&#x27;/&#x27;)
  );
}

export interface FindRecordUrlOptions {
  op: &#x27;findRecord&#x27;;
  identifier: { type: string; id: string };
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface QueryUrlOptions {
  op: &#x27;query&#x27;;
  identifier: { type: string };
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface FindManyUrlOptions {
  op: &#x27;findMany&#x27;;
  identifiers: { type: string; id: string }[];
  resourcePath?: string;
  host?: string;
  namespace?: string;
}
export interface FindRelatedCollectionUrlOptions {
  op: &#x27;findRelatedCollection&#x27;;
  identifier: { type: string; id: string };
  fieldPath: string;
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface FindRelatedResourceUrlOptions {
  op: &#x27;findRelatedRecord&#x27;;
  identifier: { type: string; id: string };
  fieldPath: string;
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface CreateRecordUrlOptions {
  op: &#x27;createRecord&#x27;;
  identifier: { type: string };
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface UpdateRecordUrlOptions {
  op: &#x27;updateRecord&#x27;;
  identifier: { type: string; id: string };
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface DeleteRecordUrlOptions {
  op: &#x27;deleteRecord&#x27;;
  identifier: { type: string; id: string };
  resourcePath?: string;
  host?: string;
  namespace?: string;
}

export interface GenericUrlOptions {
  resourcePath: string;
  host?: string;
  namespace?: string;
}

export type UrlOptions =
  | FindRecordUrlOptions
  | QueryUrlOptions
  | FindManyUrlOptions
  | FindRelatedCollectionUrlOptions
  | FindRelatedResourceUrlOptions
  | CreateRecordUrlOptions
  | UpdateRecordUrlOptions
  | DeleteRecordUrlOptions
  | GenericUrlOptions;

const OPERATIONS_WITH_PRIMARY_RECORDS = new Set([
  &#x27;findRecord&#x27;,
  &#x27;findRelatedRecord&#x27;,
  &#x27;findRelatedCollection&#x27;,
  &#x27;updateRecord&#x27;,
  &#x27;deleteRecord&#x27;,
]);

function isOperationWithPrimaryRecord(
  options: UrlOptions
): options is
  | FindRecordUrlOptions
  | FindRelatedCollectionUrlOptions
  | FindRelatedResourceUrlOptions
  | UpdateRecordUrlOptions
  | DeleteRecordUrlOptions {
  return &#x27;op&#x27; in options &amp;&amp; OPERATIONS_WITH_PRIMARY_RECORDS.has(options.op);
}

function hasResourcePath(options: UrlOptions): options is GenericUrlOptions {
  return &#x27;resourcePath&#x27; in options &amp;&amp; typeof options.resourcePath === &#x27;string&#x27; &amp;&amp; options.resourcePath.length &gt; 0;
}

function resourcePathForType(options: UrlOptions): string {
  assert(
    &#x60;resourcePathForType: You must pass a valid op as part of options&#x60;,
    &#x27;op&#x27; in options &amp;&amp; typeof options.op === &#x27;string&#x27;
  );
  return options.op === &#x27;findMany&#x27; ? options.identifiers[0].type : options.identifier.type;
}

/**
 * Builds a URL for a request based on the provided options.
 * Does not include support for building query params (see &#x60;buildQueryParams&#x60;)
 * so that it may be composed cleanly with other query-params strategies.
 *
 * Usage:
 *
 * &#x60;&#x60;&#x60;ts
 * import { buildBaseURL } from &#x27;@ember-data/request-utils&#x27;;
 *
 * const url = buildBaseURL({
 *   host: &#x27;https://api.example.com&#x27;,
 *   namespace: &#x27;api/v1&#x27;,
 *   resourcePath: &#x27;emberDevelopers&#x27;,
 *   op: &#x27;query&#x27;,
 *   identifier: { type: &#x27;ember-developer&#x27; }
 * });
 *
 * // =&gt; &#x27;https://api.example.com/api/v1/emberDevelopers&#x27;
 * &#x60;&#x60;&#x60;
 *
 * On the surface this may seem like a lot of work to do something simple, but
 * it is designed to be composable with other utilities and interfaces that the
 * average product engineer will never need to see or use.
 *
 * A few notes:
 *
 * - &#x60;resourcePath&#x60; is optional, but if it is not provided, &#x60;identifier.type&#x60; will be used.
 * - &#x60;host&#x60; and &#x60;namespace&#x60; are optional, but if they are not provided, the values globally
 *    configured via &#x60;setBuildURLConfig&#x60; will be used.
 * - &#x60;op&#x60; is required and must be one of the following:
 *   - &#x27;findRecord&#x27; &#x27;query&#x27; &#x27;findMany&#x27; &#x27;findRelatedCollection&#x27; &#x27;findRelatedRecord&#x27;&#x60; &#x27;createRecord&#x27; &#x27;updateRecord&#x27; &#x27;deleteRecord&#x27;
 * - Depending on the value of &#x60;op&#x60;, &#x60;identifier&#x60; or &#x60;identifiers&#x60; will be required.
 *
 * @method buildBaseURL
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param urlOptions
 * @return string
 */
export function buildBaseURL(urlOptions: UrlOptions): string {
  const options = Object.assign(
    {
      host: CONFIG.host,
      namespace: CONFIG.namespace,
    },
    urlOptions
  );
  assert(
    &#x60;buildBaseURL: You must pass \&#x60;op\&#x60; as part of options&#x60;,
    hasResourcePath(options) || (typeof options.op === &#x27;string&#x27; &amp;&amp; options.op.length &gt; 0)
  );
  assert(
    &#x60;buildBaseURL: You must pass \&#x60;identifier\&#x60; as part of options&#x60;,
    hasResourcePath(options) ||
      options.op === &#x27;findMany&#x27; ||
      (options.identifier &amp;&amp; typeof options.identifier === &#x27;object&#x27;)
  );
  assert(
    &#x60;buildBaseURL: You must pass \&#x60;identifiers\&#x60; as part of options&#x60;,
    hasResourcePath(options) ||
      options.op !== &#x27;findMany&#x27; ||
      (options.identifiers &amp;&amp;
        Array.isArray(options.identifiers) &amp;&amp;
        options.identifiers.length &gt; 0 &amp;&amp;
        options.identifiers.every((i) =&gt; i &amp;&amp; typeof i === &#x27;object&#x27;))
  );
  assert(
    &#x60;buildBaseURL: You must pass valid \&#x60;identifier\&#x60; as part of options, expected &#x27;id&#x27;&#x60;,
    hasResourcePath(options) ||
      !isOperationWithPrimaryRecord(options) ||
      (typeof options.identifier.id === &#x27;string&#x27; &amp;&amp; options.identifier.id.length &gt; 0)
  );
  assert(
    &#x60;buildBaseURL: You must pass \&#x60;identifiers\&#x60; as part of options&#x60;,
    hasResourcePath(options) ||
      options.op !== &#x27;findMany&#x27; ||
      options.identifiers.every((i) =&gt; typeof i.id === &#x27;string&#x27; &amp;&amp; i.id.length &gt; 0)
  );
  assert(
    &#x60;buildBaseURL: You must pass valid \&#x60;identifier\&#x60; as part of options, expected &#x27;type&#x27;&#x60;,
    hasResourcePath(options) ||
      options.op === &#x27;findMany&#x27; ||
      (typeof options.identifier.type === &#x27;string&#x27; &amp;&amp; options.identifier.type.length &gt; 0)
  );
  assert(
    &#x60;buildBaseURL: You must pass valid \&#x60;identifiers\&#x60; as part of options, expected &#x27;type&#x27;&#x60;,
    hasResourcePath(options) ||
      options.op !== &#x27;findMany&#x27; ||
      (typeof options.identifiers[0].type === &#x27;string&#x27; &amp;&amp; options.identifiers[0].type.length &gt; 0)
  );

  // prettier-ignore
  const idPath: string =
      isOperationWithPrimaryRecord(options) ? encodeURIComponent(options.identifier.id)
      : &#x27;&#x27;;
  const resourcePath = options.resourcePath || resourcePathForType(options);
  const { host, namespace } = options;
  const fieldPath = &#x27;fieldPath&#x27; in options ? options.fieldPath : &#x27;&#x27;;

  assert(
    &#x60;buildBaseURL: You tried to build a url for a ${String(
      &#x27;op&#x27; in options ? options.op + &#x27; &#x27; : &#x27;&#x27;
    )}request to ${resourcePath} but resourcePath must be set or op must be one of &quot;${[
      &#x27;findRecord&#x27;,
      &#x27;findRelatedRecord&#x27;,
      &#x27;findRelatedCollection&#x27;,
      &#x27;updateRecord&#x27;,
      &#x27;deleteRecord&#x27;,
      &#x27;createRecord&#x27;,
      &#x27;query&#x27;,
      &#x27;findMany&#x27;,
    ].join(&#x27;&quot;,&quot;&#x27;)}&quot;.&#x60;,
    hasResourcePath(options) ||
      [
        &#x27;findRecord&#x27;,
        &#x27;query&#x27;,
        &#x27;findMany&#x27;,
        &#x27;findRelatedCollection&#x27;,
        &#x27;findRelatedRecord&#x27;,
        &#x27;createRecord&#x27;,
        &#x27;updateRecord&#x27;,
        &#x27;deleteRecord&#x27;,
      ].includes(options.op)
  );

  assert(&#x60;buildBaseURL: host must NOT end with &#x27;/&#x27;, received &#x27;${host}&#x27;&#x60;, host === &#x27;/&#x27; || !host.endsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: namespace must NOT start with &#x27;/&#x27;, received &#x27;${namespace}&#x27;&#x60;, !namespace.startsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: namespace must NOT end with &#x27;/&#x27;, received &#x27;${namespace}&#x27;&#x60;, !namespace.endsWith(&#x27;/&#x27;));
  assert(
    &#x60;buildBaseURL: resourcePath must NOT start with &#x27;/&#x27;, received &#x27;${resourcePath}&#x27;&#x60;,
    !resourcePath.startsWith(&#x27;/&#x27;)
  );
  assert(&#x60;buildBaseURL: resourcePath must NOT end with &#x27;/&#x27;, received &#x27;${resourcePath}&#x27;&#x60;, !resourcePath.endsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: fieldPath must NOT start with &#x27;/&#x27;, received &#x27;${fieldPath}&#x27;&#x60;, !fieldPath.startsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: fieldPath must NOT end with &#x27;/&#x27;, received &#x27;${fieldPath}&#x27;&#x60;, !fieldPath.endsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: idPath must NOT start with &#x27;/&#x27;, received &#x27;${idPath}&#x27;&#x60;, !idPath.startsWith(&#x27;/&#x27;));
  assert(&#x60;buildBaseURL: idPath must NOT end with &#x27;/&#x27;, received &#x27;${idPath}&#x27;&#x60;, !idPath.endsWith(&#x27;/&#x27;));

  const hasHost = host !== &#x27;&#x27; &amp;&amp; host !== &#x27;/&#x27;;
  const url = [hasHost ? host : &#x27;&#x27;, namespace, resourcePath, idPath, fieldPath].filter(Boolean).join(&#x27;/&#x27;);
  return hasHost ? url : &#x60;/${url}&#x60;;
}

const DEFAULT_QUERY_PARAMS_SERIALIZATION_OPTIONS: QueryParamsSerializationOptions = {
  arrayFormat: &#x27;comma&#x27;,
};

function handleInclude(include: string | string[]): string[] {
  assert(
    &#x60;Expected include to be a string or array, got ${typeof include}&#x60;,
    typeof include === &#x27;string&#x27; || Array.isArray(include)
  );
  return typeof include === &#x27;string&#x27; ? include.split(&#x27;,&#x27;) : include;
}

/**
 * filter out keys of an object that have falsy values or point to empty arrays
 * returning a new object with only those keys that have truthy values / non-empty arrays
 *
 * @method filterEmpty
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param {Record&lt;string, Serializable&gt;} source object to filter keys with empty values from
 * @return {Record&lt;string, Serializable&gt;} A new object with the keys that contained empty values removed
 */
export function filterEmpty(source: Record&lt;string, Serializable&gt;): Record&lt;string, Serializable&gt; {
  const result: Record&lt;string, Serializable&gt; = {};
  for (const key in source) {
    const value = source[key];
    // Allow &#x60;0&#x60; and &#x60;false&#x60; but filter falsy values that indicate &quot;empty&quot;
    if (value !== undefined &amp;&amp; value !== null &amp;&amp; value !== &#x27;&#x27;) {
      if (!Array.isArray(value) || value.length &gt; 0) {
        result[key] = source[key];
      }
    }
  }
  return result;
}

/**
 * Sorts query params by both key and value returning a new URLSearchParams
 * object with the keys inserted in sorted order.
 *
 * Treats &#x60;included&#x60; specially, splicing it into an array if it is a string and sorting the array.
 *
 * Options:
 * - arrayFormat: &#x27;bracket&#x27; | &#x27;indices&#x27; | &#x27;repeat&#x27; | &#x27;comma&#x27;
 *
 * &#x27;bracket&#x27;: appends [] to the key for every value e.g. &#x60;&amp;ids[]=1&amp;ids[]=2&#x60;
 * &#x27;indices&#x27;: appends [i] to the key for every value e.g. &#x60;&amp;ids[0]=1&amp;ids[1]=2&#x60;
 * &#x27;repeat&#x27;: appends the key for every value e.g. &#x60;&amp;ids=1&amp;ids=2&#x60;
 * &#x27;comma&#x27; (default): appends the key once with a comma separated list of values e.g. &#x60;&amp;ids=1,2&#x60;
 *
 * @method sortQueryParams
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param {URLSearchParams | object} params
 * @param {object} options
 * @return {URLSearchParams} A URLSearchParams with keys inserted in sorted order
 */
export function sortQueryParams(params: QueryParamsSource, options?: QueryParamsSerializationOptions): URLSearchParams {
  const opts = Object.assign({}, DEFAULT_QUERY_PARAMS_SERIALIZATION_OPTIONS, options);
  const paramsIsObject = !(params instanceof URLSearchParams);
  const urlParams = new URLSearchParams();
  const dictionaryParams: Record&lt;string, Serializable&gt; = paramsIsObject ? params : {};

  if (!paramsIsObject) {
    params.forEach((value, key) =&gt; {
      const hasExisting = key in dictionaryParams;
      if (!hasExisting) {
        dictionaryParams[key] = value;
      } else {
        const existingValue = dictionaryParams[key];
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          dictionaryParams[key] = [existingValue, value];
        }
      }
    });
  }

  if (&#x27;include&#x27; in dictionaryParams) {
    dictionaryParams.include = handleInclude(dictionaryParams.include as string | string[]);
  }

  const sortedKeys = Object.keys(dictionaryParams).sort();
  sortedKeys.forEach((key) =&gt; {
    const value = dictionaryParams[key];
    if (Array.isArray(value)) {
      value.sort();
      switch (opts.arrayFormat) {
        case &#x27;indices&#x27;:
          value.forEach((v, i) =&gt; {
            urlParams.append(&#x60;${key}[${i}]&#x60;, String(v));
          });
          return;
        case &#x27;bracket&#x27;:
          value.forEach((v) =&gt; {
            urlParams.append(&#x60;${key}[]&#x60;, String(v));
          });
          return;
        case &#x27;repeat&#x27;:
          value.forEach((v) =&gt; {
            urlParams.append(key, String(v));
          });
          return;
        case &#x27;comma&#x27;:
        default:
          urlParams.append(key, value.join(&#x27;,&#x27;));
          return;
      }
    } else {
      urlParams.append(key, String(value));
    }
  });

  return urlParams;
}

/**
 * Sorts query params by both key and value, returning a query params string
 *
 * Treats &#x60;included&#x60; specially, splicing it into an array if it is a string and sorting the array.
 *
 * Options:
 * - arrayFormat: &#x27;bracket&#x27; | &#x27;indices&#x27; | &#x27;repeat&#x27; | &#x27;comma&#x27;
 *
 * &#x27;bracket&#x27;: appends [] to the key for every value e.g. &#x60;ids[]=1&amp;ids[]=2&#x60;
 * &#x27;indices&#x27;: appends [i] to the key for every value e.g. &#x60;ids[0]=1&amp;ids[1]=2&#x60;
 * &#x27;repeat&#x27;: appends the key for every value e.g. &#x60;ids=1&amp;ids=2&#x60;
 * &#x27;comma&#x27; (default): appends the key once with a comma separated list of values e.g. &#x60;ids=1,2&#x60;
 *
 * @method buildQueryParams
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param {URLSearchParams | object} params
 * @param {object} [options]
 * @return {string} A sorted query params string without the leading &#x60;?&#x60;
 */
export function buildQueryParams(params: QueryParamsSource, options?: QueryParamsSerializationOptions): string {
  return sortQueryParams(params, options).toString();
}
export interface CacheControlValue {
  immutable?: boolean;
  &#x27;max-age&#x27;?: number;
  &#x27;must-revalidate&#x27;?: boolean;
  &#x27;must-understand&#x27;?: boolean;
  &#x27;no-cache&#x27;?: boolean;
  &#x27;no-store&#x27;?: boolean;
  &#x27;no-transform&#x27;?: boolean;
  &#x27;only-if-cached&#x27;?: boolean;
  private?: boolean;
  &#x27;proxy-revalidate&#x27;?: boolean;
  public?: boolean;
  &#x27;s-maxage&#x27;?: number;
  &#x27;stale-if-error&#x27;?: number;
  &#x27;stale-while-revalidate&#x27;?: number;
}

type CacheControlKey = keyof CacheControlValue;

const NUMERIC_KEYS = new Set([&#x27;max-age&#x27;, &#x27;s-maxage&#x27;, &#x27;stale-if-error&#x27;, &#x27;stale-while-revalidate&#x27;]);

/**
 *  Parses a string Cache-Control header value into an object with the following structure:
 *
 * &#x60;&#x60;&#x60;ts
 * interface CacheControlValue {
 *   immutable?: boolean;
 *   &#x27;max-age&#x27;?: number;
 *   &#x27;must-revalidate&#x27;?: boolean;
 *   &#x27;must-understand&#x27;?: boolean;
 *   &#x27;no-cache&#x27;?: boolean;
 *   &#x27;no-store&#x27;?: boolean;
 *   &#x27;no-transform&#x27;?: boolean;
 *   &#x27;only-if-cached&#x27;?: boolean;
 *   private?: boolean;
 *   &#x27;proxy-revalidate&#x27;?: boolean;
 *   public?: boolean;
 *   &#x27;s-maxage&#x27;?: number;
 *   &#x27;stale-if-error&#x27;?: number;
 *   &#x27;stale-while-revalidate&#x27;?: number;
 * }
 * &#x60;&#x60;&#x60;
 * @method parseCacheControl
 * @static
 * @public
 * @for @ember-data/request-utils
 * @param {string} header
 * @return {CacheControlValue}
 */
export function parseCacheControl(header: string): CacheControlValue {
  let key: CacheControlKey = &#x27;&#x27; as CacheControlKey;
  let value = &#x27;&#x27;;
  let isParsingKey = true;
  const cacheControlValue: CacheControlValue = {};

  function parseCacheControlValue(stringToParse: string): number {
    const parsedValue = Number.parseInt(stringToParse);
    assert(&#x60;Invalid Cache-Control value, expected a number but got - ${stringToParse}&#x60;, !Number.isNaN(parsedValue));
    return parsedValue;
  }

  for (let i = 0; i &lt; header.length; i++) {
    const char = header.charAt(i);
    if (char === &#x27;,&#x27;) {
      assert(&#x60;Invalid Cache-Control value, expected a value&#x60;, !isParsingKey || !NUMERIC_KEYS.has(key));
      assert(
        &#x60;Invalid Cache-Control value, expected a value after &quot;=&quot; but got &quot;,&quot;&#x60;,
        i === 0 || header.charAt(i - 1) !== &#x27;=&#x27;
      );
      isParsingKey = true;
      // @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined
      cacheControlValue[key] = NUMERIC_KEYS.has(key) ? parseCacheControlValue(value) : true;
      key = &#x27;&#x27; as CacheControlKey;
      value = &#x27;&#x27;;
      continue;
    } else if (char === &#x27;=&#x27;) {
      assert(&#x60;Invalid Cache-Control value, expected a value after &quot;=&quot;&#x60;, i + 1 !== header.length);
      isParsingKey = false;
    } else if (char === &#x27; &#x27; || char === &#x60;\t&#x60; || char === &#x60;\n&#x60;) {
      continue;
    } else if (isParsingKey) {
      key += char;
    } else {
      value += char;
    }

    if (i === header.length - 1) {
      // @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined
      cacheControlValue[key] = NUMERIC_KEYS.has(key) ? parseCacheControlValue(value) : true;
    }
  }

  return cacheControlValue;
}

function isStale(headers: Headers, expirationTime: number): boolean {
  // const age = headers.get(&#x27;age&#x27;);
  // const cacheControl = parseCacheControl(headers.get(&#x27;cache-control&#x27;) || &#x27;&#x27;);
  // const expires = headers.get(&#x27;expires&#x27;);
  // const lastModified = headers.get(&#x27;last-modified&#x27;);
  const date = headers.get(&#x27;date&#x27;);

  if (!date) {
    return true;
  }

  const time = new Date(date).getTime();
  const now = Date.now();
  const deadline = time + expirationTime;

  const result = now &gt; deadline;

  return result;
}

export type LifetimesConfig = { apiCacheSoftExpires: number; apiCacheHardExpires: number };

/**
 * A basic LifetimesService that can be added to the Store service.
 *
 * Determines staleness based on time since the request was last received from the API
 * using the &#x60;date&#x60; header.
 *
 * Invalidates any request for which &#x60;cacheOptions.types&#x60; was provided when a createRecord
 * request for that type is successful.
 *
 * This allows the Store&#x27;s CacheHandler to determine if a request is expired and
 * should be refetched upon next request.
 *
 * The &#x60;Fetch&#x60; handler provided by &#x60;@ember-data/request/fetch&#x60; will automatically
 * add the &#x60;date&#x60; header to responses if it is not present.
 *
 * Note: Date headers do not have millisecond precision, so expiration times should
 * generally be larger than 1000ms.
 *
 * Usage:
 *
 * &#x60;&#x60;&#x60;ts
 * import { LifetimesService } from &#x27;@ember-data/request-utils&#x27;;
 * import DataStore from &#x27;@ember-data/store&#x27;;
 *
 * // ...
 *
 * export class Store extends DataStore {
 *   constructor(args) {
 *     super(args);
 *     this.lifetimes = new LifetimesService({ apiCacheSoftExpires: 30_000, apiCacheHardExpires: 60_000 });
 *   }
 * }
 * &#x60;&#x60;&#x60;
 *
 * @class LifetimesService
 * @public
 * @module @ember-data/request-utils
 */
export class LifetimesService {
  declare config: LifetimesConfig;
  declare _stores: WeakMap&lt;Store, { invalidated: Set&lt;string&gt;; types: Map&lt;string, Set&lt;string&gt;&gt; }&gt;;

  _getStore(store: Store): { invalidated: Set&lt;string&gt;; types: Map&lt;string, Set&lt;string&gt;&gt; } {
    let set = this._stores.get(store);
    if (!set) {
      set = { invalidated: new Set(), types: new Map() };
      this._stores.set(store, set);
    }
    return set;
  }

  constructor(config: LifetimesConfig) {
    this._stores = new WeakMap();

    const _config = arguments.length === 1 ? config : (arguments[1] as unknown as LifetimesConfig);
    deprecate(
      &#x60;Passing a Store to the LifetimesService is deprecated, please pass only a config instead.&#x60;,
      arguments.length === 1,
      {
        id: &#x27;ember-data:request-utils:lifetimes-service-store-arg&#x27;,
        since: {
          enabled: &#x27;5.4&#x27;,
          available: &#x27;5.4&#x27;,
        },
        for: &#x27;@ember-data/request-utils&#x27;,
        until: &#x27;6.0&#x27;,
      }
    );
    assert(&#x60;You must pass a config to the LifetimesService&#x60;, _config);
    assert(
      &#x60;You must pass a apiCacheSoftExpires to the LifetimesService&#x60;,
      typeof _config.apiCacheSoftExpires === &#x27;number&#x27;
    );
    assert(
      &#x60;You must pass a apiCacheHardExpires to the LifetimesService&#x60;,
      typeof _config.apiCacheHardExpires === &#x27;number&#x27;
    );
    this.config = _config;
  }

  /**
   * Invalidate a request by its identifier for a given store instance.
   *
   * While the store argument may seem redundant, the lifetimes service
   * is designed to be shared across multiple stores / forks
   * of the store.
   *
   * &#x60;&#x60;&#x60;ts
   * store.lifetimes.invalidateRequest(store, identifier);
   * &#x60;&#x60;&#x60;
   *
   * @method invalidateRequest
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   */
  invalidateRequest(identifier: StableDocumentIdentifier, store: Store): void {
    this._getStore(store).invalidated.add(identifier.lid);
  }

  /**
   * Invalidate all requests associated to a specific type
   * for a given store instance.
   *
   * While the store argument may seem redundant, the lifetimes service
   * is designed to be shared across multiple stores / forks
   * of the store.
   *
   * This invalidation is done automatically when using this service
   * for both the CacheHandler and the LegacyNetworkHandler.
   *
   * &#x60;&#x60;&#x60;ts
   * store.lifetimes.invalidateRequestsForType(store, &#x27;person&#x27;);
   * &#x60;&#x60;&#x60;
   *
   * @method invalidateRequestsForType
   * @public
   * @param {string} type
   * @param {Store} store
   */
  invalidateRequestsForType(type: string, store: Store): void {
    const storeCache = this._getStore(store);
    const set = storeCache.types.get(type);
    if (set) {
      set.forEach((id) =&gt; {
        storeCache.invalidated.add(id);
      });
    }
  }

  /**
   * Invoked when a request has been fulfilled from the configured request handlers.
   * This is invoked by the CacheHandler for both foreground and background requests
   * once the cache has been updated.
   *
   * Note, this is invoked by the CacheHandler regardless of whether
   * the request has a cache-key.
   *
   * This method should not be invoked directly by consumers.
   *
   * @method didRequest
   * @public
   * @param {ImmutableRequestInfo} request
   * @param {ImmutableResponse} response
   * @param {Store} store
   * @param {StableDocumentIdentifier | null} identifier
   * @return {void}
   */
  didRequest(
    request: ImmutableRequestInfo,
    response: Response | ResponseInfo | null,
    identifier: StableDocumentIdentifier | null,
    store: Store
  ): void {
    // if this is a successful createRecord request, invalidate the cacheKey for the type
    if (request.op === &#x27;createRecord&#x27;) {
      const statusNumber = response?.status ?? 0;
      if (statusNumber &gt;= 200 &amp;&amp; statusNumber &lt; 400) {
        const types = new Set(request.records?.map((r) =&gt; r.type));
        types.forEach((type) =&gt; {
          this.invalidateRequestsForType(type, store);
        });
      }

      // add this document&#x27;s cacheKey to a map for all associated types
      // it is recommended to only use this for queries
    } else if (identifier &amp;&amp; request.cacheOptions?.types?.length) {
      const storeCache = this._getStore(store);
      request.cacheOptions?.types.forEach((type) =&gt; {
        const set = storeCache.types.get(type);
        if (set) {
          set.add(identifier.lid);
          storeCache.invalidated.delete(identifier.lid);
        } else {
          storeCache.types.set(type, new Set([identifier.lid]));
        }
      });
    }
  }

  /**
   * Invoked to determine if the request may be fulfilled from cache
   * if possible.
   *
   * Note, this is only invoked by the CacheHandler if the request has
   * a cache-key.
   *
   * If no cache entry is found or the entry is hard expired,
   * the request will be fulfilled from the configured request handlers
   * and the cache will be updated before returning the response.
   *
   * @method isHardExpired
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {boolean} true if the request is considered hard expired
   */
  isHardExpired(identifier: StableDocumentIdentifier, store: Store): boolean {
    // if we are explicitly invalidated, we are hard expired
    const storeCache = this._getStore(store);
    if (storeCache.invalidated.has(identifier.lid)) {
      return true;
    }
    const cache = store.cache;
    const cached = cache.peekRequest(identifier);
    return !cached || !cached.response || isStale(cached.response.headers, this.config.apiCacheHardExpires);
  }

  /**
   * Invoked if &#x60;isHardExpired&#x60; is false to determine if the request
   * should be update behind the scenes if cache data is already available.
   *
   * Note, this is only invoked by the CacheHandler if the request has
   * a cache-key.
   *
   * If true, the request will be fulfilled from cache while a backgrounded
   * request is made to update the cache via the configured request handlers.
   *
   * @method isSoftExpired
   * @public
   * @param {StableDocumentIdentifier} identifier
   * @param {Store} store
   * @return {boolean} true if the request is considered soft expired
   */
  isSoftExpired(identifier: StableDocumentIdentifier, store: Store): boolean {
    const cache = store.cache;
    const cached = cache.peekRequest(identifier);
    return !cached || !cached.response || isStale(cached.response.headers, this.config.apiCacheSoftExpires);
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
