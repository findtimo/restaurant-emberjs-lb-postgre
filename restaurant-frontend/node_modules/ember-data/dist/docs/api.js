YUI.add("yuidoc-meta", function(Y) {
   Y.YUIDoc = { meta: {
    "classes": [
        "<Interface> Adapter",
        "<Interface> Cache",
        "<Interface> Handler",
        "<Interface> LifetimesService",
        "<Interface> Serializer",
        "@ember-data/active-record/request",
        "@ember-data/adapter/rest",
        "@ember-data/json-api/request",
        "@ember-data/model",
        "@ember-data/request-utils",
        "@ember-data/rest/request",
        "@ember-data/store",
        "@ember-data/tracking",
        "AbortError",
        "Adapter",
        "AdapterError",
        "BelongsToReference",
        "BooleanTransform",
        "BuildURLMixin",
        "Cache",
        "CacheCapabilitiesManager",
        "CacheManager",
        "CanaryFeatureFlags",
        "ConflictError",
        "CurrentDeprecations",
        "DateTransform",
        "DebugLogging",
        "Document",
        "EmbeddedRecordsMixin",
        "Errors",
        "Fetch",
        "ForbiddenError",
        "Future",
        "HasManyReference",
        "IdentifierCache",
        "InspectorDataAdapter",
        "InvalidError",
        "JSONAPIAdapter",
        "JSONAPISerializer",
        "JSONSerializer",
        "LifetimesService",
        "ManyArray",
        "Model",
        "NotFoundError",
        "NotificationManager",
        "NumberTransform",
        "PromiseBelongsTo",
        "PromiseManyArray",
        "RESTAdapter",
        "RESTSerializer",
        "RecordArray",
        "RecordReference",
        "RequestManager",
        "RequestStateService",
        "SchemaService",
        "Serializer",
        "ServerError",
        "Snapshot",
        "SnapshotRecordArray",
        "StableRecordIdentifier",
        "Store",
        "StringTransform",
        "TimeoutError",
        "Transform",
        "UnauthorizedError"
    ],
    "modules": [
        "@ember-data_active-record_request",
        "@ember-data_adapter",
        "@ember-data_adapter_error",
        "@ember-data_adapter_json-api",
        "@ember-data_adapter_rest",
        "@ember-data_canary-features",
        "@ember-data_debug",
        "@ember-data_deprecations",
        "@ember-data_experimental-preview-types",
        "@ember-data_graph",
        "@ember-data_json-api",
        "@ember-data_json-api_request",
        "@ember-data_legacy-compat",
        "@ember-data_model",
        "@ember-data_request",
        "@ember-data_request-utils",
        "@ember-data_request_fetch",
        "@ember-data_rest_request",
        "@ember-data_serializer",
        "@ember-data_serializer_json",
        "@ember-data_serializer_json-api",
        "@ember-data_serializer_rest",
        "@ember-data_store",
        "@ember-data_tracking",
        "ember-data-overview"
    ],
    "allModules": [
        {
            "displayName": "@ember-data/active-record/request",
            "name": "@ember-data_active-record_request",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with [ActiveRecord](https://guides.rubyonrails.org/active_record_basics.html#convention-over-configuration-in-active-record) APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/active-record\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/active-record/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/\\*\n => {\n   url: 'https://api.example.com/v1/ember_developers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>, // 'Content-Type': 'application/json;charset=utf-8'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n\\/\n```\n\nRequest builder output may be used with either `requestManager.request` or `store.request`.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common ActiveRecord format (underscored pluralized resource types).\n\n### Available Builders\n\n- [createRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/createRecord)\n- [deleteRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/deleteRecord)\n- [findRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/findRecord)\n- [query](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/query)\n- [updateRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Factive-record/updateRecord)"
        },
        {
            "displayName": "@ember-data/adapter",
            "name": "@ember-data_adapter",
            "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nIn order to properly fetch and update data, EmberData\nneeds to understand how to connect to your API.\n\n`Adapters` accept various kinds of requests from the store\nand manage fulfillment of the request from your API.\n\n### Request Flow\n\nWhen the store decides it needs to issue a request it uses the\nfollowing flow to manage the request and process the data.\n\n- find the appropriate adapter\n- issue the request to the adapter\n- await the adapter's response\n  - if an error occurs reject with the error\n  - if no error\n    - if there is response data\n      - pass the response data to the appropriate serializer\n      - update the cache using the JSON:API formatted data from the serializer's response\n    - return the primary record(s) associated with the request\n\n### Request Errors\n\nWhen a request errors and your adapter does not have the ability to recover from the error,\nyou may either reject the promise returned by your adapter method with the error or simply\nthrow the error.\n\nIf the request was for a `createRecord` `updateRecord` or `deleteRecord` special rules\napply to how this error will affect the state of the store and additional properties on\nthe `Error` class may be used. See the documentation for these methods in\n[<Interface> Adapter](/ember-data/release/classes/%3CInterface%3E%20Adapter) for more information.\n\n### Implementing an Adapter\n\nThere are seven required adapter methods, one for each of\nthe primary request types that EmberData issues.\n\nThey are:\n\n- findRecord\n- findAll\n- queryRecord\n- query\n- createRecord\n- updateRecord\n- deleteRecord\n\nEach of these request types has a matching store method that triggers it\nand matching `requestType` that is passed to the serializer's\n`normalizeResponse` method.\n\nIf your app only reads data but never writes data, it is not necessary\nto implement the methods for create, update, and delete. This extends to\nall of the store's find methods with the exception of `findRecord` (`findAll`,\n`query`, `queryRecord`): if you do not use the store method in your app then\nyour Adapter does not need the method.\n\n```ts\nasync function fetchData(url, options = {}) {\n  let response = await fetch(url, options);\n  return response.toJSON();\n}\n\nexport default class ApplicationAdapter {\n  findRecord(_, { modelName }, id) {\n    return fetchData(`./${modelName}s/${id}`);\n  }\n\n  static create() {\n    return new this();\n  }\n}\n```\n\n### Adapter Resolution\n\n`store.adapterFor(name)` will lookup adapters defined in `app/adapters/` and\nreturn an instance.\n\n`adapterFor` first attempts to find an adapter with an exact match on `name`,\nthen falls back to checking for the presence of an adapter named `application`.\n\nIf no adapter is found, an error will be thrown.\n\n```ts\nstore.adapterFor('author');\n\n// lookup paths (in order) =>\n//   app/adapters/author.js\n//   app/adapters/application.js\n```\n\nMost requests in EmberData are made with respect to a particular `type` (or `modelName`)\n(e.g., \"get me the full collection of **books**\" or \"get me the **employee** whose id is 37\"). We\nrefer to this as the **primary** resource `type`.\n\n`adapterFor` is used by the store to find an adapter with a name matching that of the primary\nresource `type` for the request, which then falls back to the `application` adapter.\n\nIt is recommended that applications define only a single `application` adapter and serializer\nwhere possible, only implementing an adapter specific to the `type` when absolutely necessary.\n\nIf you need to support multiple API versions for the same type, the per-type strategy for\ndefining adapters might not be adequate.\n\nIf you have multiple APIs or multiple API versions and the single application adapter and per-type\nstrategy does not suite your needs, one strategy is to write an `application` adapter and serializer\nthat make use of `options` to specify the desired format when making a request, then forwards to the\nrequest to the desired adapter or serializer as needed.\n\n```app/adapters/application.js\nexport default class Adapter extends EmberObject {\n  findRecord(store, schema, id, snapshot) {\n    let { apiVersion } = snapshot.adapterOptions;\n    return this.adapterFor(`-api-${apiVersion}`).findRecord(store, schema, id, snapshot);\n  }\n}\n```\n\n### Overriding `Store.adapterFor`\n\n```js\nimport Store from '@ember-data/store';\nimport Adapter from '@ember-data/adapter/json-api';\n\nclass extends Store {\n  #adapter = new Adapter();\n\n  adapterFor() {\n    return this.#adapter;\n  }\n}\n```\n\n\nNote: If you are using Ember and would like to make use of `service` injections in your adapter, you will want to additionally `setOwner` for the Adapter.\n\n```js\nimport Store from '@ember-data/store';\nimport Adapter from '@ember-data/adapter/json-api';\nimport { getOwner, setOwner } from '@ember/owner';\n\nclass extends Store {\n  #adapter = null;\n\n  adapterFor() {\n    let adapter = this.#adapter;\n    if (!adapter) {\n      const owner = getOwner(this);\n      adapter = new Adapter();\n      setOwner(adapter, owner);\n      this.#adapter = adapter;\n    }\n\n    return adapter;\n  }\n}\n```\n\nBy default when using with Ember you only need to implement this hook if you want your adapter usage to be statically analyzeable. *Ember***Data** will attempt to resolve adapters using Ember's resolver. To provide a single Adapter for your application like the above you would provide it as the default export of the file `app/adapters/application.{js/ts}`\n\n### Using an Adapter\n\nAny adapter in `app/adapters/` can be looked up by `name` using `store.adapterFor(name)`.\n\n### Default Adapters\n\nApplications whose API's structure endpoint URLs *very close to* or *exactly* the **REST**\nor **JSON:API** convention, the `@ember-data/adapter` package contains implementations\nthese applications can extend.\n\nMany applications will find writing their own adapter to be allow greater flexibility,\ncustomization, and maintenance than attempting to override methods in these adapters."
        },
        {
            "displayName": "@ember-data/adapter/error",
            "name": "@ember-data_adapter_error",
            "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nAn `AdapterError` is used by an adapter to signal that an error occurred\nduring a request to an external API. It indicates a generic error, and\nsubclasses are used to indicate specific error states.\n\nTo create a custom error to signal a specific error state in communicating\nwith an external API, extend the `AdapterError`. For example, if the\nexternal API exclusively used HTTP `503 Service Unavailable` to indicate\nit was closed for maintenance:\n\n```app/adapters/maintenance-error.js\nimport AdapterError from '@ember-data/adapter/error';\n\nexport default AdapterError.extend({ message: \"Down for maintenance.\" });\n```\n\nThis error would then be returned by an adapter's `handleResponse` method:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\nimport MaintenanceError from './maintenance-error';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  handleResponse(status) {\n    if (503 === status) {\n      return new MaintenanceError();\n    }\n\n    return super.handleResponse(...arguments);\n  }\n}\n```\n\nAnd can then be detected in an application and used to send the user to an\n`under-maintenance` route:\n\n```app/routes/application.js\nimport Route from '@ember/routing/route';\nimport MaintenanceError from '../adapters/maintenance-error';\n\nexport default class ApplicationRoute extends Route {\n  actions: {\n    error(error, transition) {\n      if (error instanceof MaintenanceError) {\n        this.transitionTo('under-maintenance');\n        return;\n      }\n\n      // ...other error handling logic\n    }\n  }\n}\n```"
        },
        {
            "displayName": "@ember-data/adapter/json-api",
            "name": "@ember-data_adapter_json-api",
            "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new adapter, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nThe `JSONAPIAdapter` is an adapter whichtransforms the store's\nrequests into HTTP requests that follow the [JSON API format](http://jsonapi.org/format/).\n\n## JSON API Conventions\n\nThe JSONAPIAdapter uses JSON API conventions for building the URL\nfor a record and selecting the HTTP verb to use with a request. The\nactions you can take on a record map onto the following URLs in the\nJSON API adapter:\n\n<table>\n<tr>\n  <th>\n    Action\n  </th>\n  <th>\n    HTTP Verb\n  </th>\n  <th>\n    URL\n  </th>\n</tr>\n<tr>\n  <th>\n    `store.findRecord('post', 123)`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    `store.findAll('post')`\n  </th>\n  <td>\n    GET\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Update `postRecord.save()`\n  </th>\n  <td>\n    PATCH\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n<tr>\n  <th>\n    Create `store.createRecord('post').save()`\n  </th>\n  <td>\n    POST\n  </td>\n  <td>\n    /posts\n  </td>\n</tr>\n<tr>\n  <th>\n    Delete `postRecord.destroyRecord()`\n  </th>\n  <td>\n    DELETE\n  </td>\n  <td>\n    /posts/123\n  </td>\n</tr>\n</table>\n\n## Success and failure\n\nThe JSONAPIAdapter will consider a success any response with a\nstatus code of the 2xx family (\"Success\"), as well as 304 (\"Not\nModified\"). Any other status code will be considered a failure.\n\nOn success, the request promise will be resolved with the full\nresponse payload.\n\nFailed responses with status code 422 (\"Unprocessable Entity\") will\nbe considered \"invalid\". The response will be discarded, except for\nthe `errors` key. The request promise will be rejected with a\n`InvalidError`. This error object will encapsulate the saved\n`errors` value.\n\nAny other status codes will be treated as an adapter error. The\nrequest promise will be rejected, similarly to the invalid case,\nbut with an instance of `AdapterError` instead.\n\n### Endpoint path customization\n\nEndpoint paths can be prefixed with a `namespace` by setting the\nnamespace property on the adapter:\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  namespace = 'api/1';\n}\n```\nRequests for the `person` model would now target `/api/1/people/1`.\n\n### Host customization\n\nAn adapter can target other hosts by setting the `host` property.\n\n```app/adapters/application.js\nimport JSONAPIAdapter from '@ember-data/adapter/json-api';\n\nexport default class ApplicationAdapter extends JSONAPIAdapter {\n  host = 'https://api.example.com';\n}\n```\n\nRequests for the `person` model would now target\n`https://api.example.com/people/1`."
        },
        {
            "displayName": "@ember-data/adapter/rest",
            "name": "@ember-data_adapter_rest",
            "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n The REST adapter allows your store to communicate with an HTTP server by\n transmitting JSON via XHR.\n\n This adapter is designed around the idea that the JSON exchanged with\n the server should be conventional. It builds URLs in a manner that follows\n the structure of most common REST-style web services.\n\n ## Success and failure\n\n The REST adapter will consider a success any response with a status code\n of the 2xx family (\"Success\"), as well as 304 (\"Not Modified\"). Any other\n status code will be considered a failure.\n\n On success, the request promise will be resolved with the full response\n payload.\n\n Failed responses with status code 422 (\"Unprocessable Entity\") will be\n considered \"invalid\". The response will be discarded, except for the\n `errors` key. The request promise will be rejected with a `InvalidError`.\n This error object will encapsulate the saved `errors` value.\n\n Any other status codes will be treated as an \"adapter error\". The request\n promise will be rejected, similarly to the \"invalid\" case, but with\n an instance of `AdapterError` instead.\n\n ## JSON Structure\n\n The REST adapter expects the JSON returned from your server to follow\n these conventions.\n\n ### Object Root\n\n The JSON payload should be an object that contains the record inside a\n root property. For example, in response to a `GET` request for\n `/posts/1`, the JSON should look like this:\n\n ```js\n {\n   \"posts\": {\n     \"id\": 1,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\"\n   }\n }\n ```\n\n Similarly, in response to a `GET` request for `/posts`, the JSON should\n look like this:\n\n ```js\n {\n   \"posts\": [\n     {\n       \"id\": 1,\n       \"title\": \"I'm Running to Reform the W3C\",\n       \"author\": \"Yehuda Katz\"\n     },\n     {\n       \"id\": 2,\n       \"title\": \"Rails is omakase\",\n       \"author\": \"D2H\"\n     }\n   ]\n }\n ```\n\n Note that the object root can be pluralized for both a single-object response\n and an array response: the REST adapter is not strict on this. Further, if the\n HTTP server responds to a `GET` request to `/posts/1` (e.g. the response to a\n `findRecord` query) with more than one object in the array, Ember Data will\n only display the object with the matching ID.\n\n ### Conventional Names\n\n Attribute names in your JSON payload should be the camelCased versions of\n the attributes in your Ember.js models.\n\n For example, if you have a `Person` model:\n\n ```app/models/person.js\n import Model, { attr } from '@ember-data/model';\n\n export default Model.extend({\n   firstName: attr('string'),\n   lastName: attr('string'),\n   occupation: attr('string')\n });\n ```\n\n The JSON returned should look like this:\n\n ```js\n {\n   \"people\": {\n     \"id\": 5,\n     \"firstName\": \"Zaphod\",\n     \"lastName\": \"Beeblebrox\",\n     \"occupation\": \"President\"\n   }\n }\n ```\n\n #### Relationships\n\n Relationships are usually represented by ids to the record in the\n relationship. The related records can then be sideloaded in the\n response under a key for the type.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"comments\": [1, 2]\n   },\n   \"comments\": [{\n     \"id\": 1,\n     \"author\": \"User 1\",\n     \"message\": \"First!\",\n   }, {\n     \"id\": 2,\n     \"author\": \"User 2\",\n     \"message\": \"Good Luck!\",\n   }]\n }\n ```\n\n If the records in the relationship are not known when the response\n is serialized it's also possible to represent the relationship as a\n URL using the `links` key in the response. Ember Data will fetch\n this URL to resolve the relationship when it is accessed for the\n first time.\n\n ```js\n {\n   \"posts\": {\n     \"id\": 5,\n     \"title\": \"I'm Running to Reform the W3C\",\n     \"author\": \"Yehuda Katz\",\n     \"links\": {\n       \"comments\": \"/posts/5/comments\"\n     }\n   }\n }\n ```\n\n ### Errors\n\n If a response is considered a failure, the JSON payload is expected to include\n a top-level key `errors`, detailing any specific issues. For example:\n\n ```js\n {\n   \"errors\": {\n     \"msg\": \"Something went wrong\"\n   }\n }\n ```\n\n This adapter does not make any assumptions as to the format of the `errors`\n object. It will simply be passed along as is, wrapped in an instance\n of `InvalidError` or `AdapterError`. The serializer can interpret it\n afterwards.\n\n ## Customization\n\n ### Endpoint path customization\n\n Endpoint paths can be prefixed with a `namespace` by setting the namespace\n property on the adapter:\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   namespace = 'api/1';\n }\n ```\n Requests for the `Person` model would now target `/api/1/people/1`.\n\n ### Host customization\n\n An adapter can target other hosts by setting the `host` property.\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   host = 'https://api.example.com';\n }\n ```\n\n ### Headers customization\n\n Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary\n headers can be set as key/value pairs on the `RESTAdapter`'s `headers`\n object and Ember Data will send them along with each ajax request.\n\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n import { computed } from '@ember/object';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   headers: computed(function() {\n     return {\n       'API_KEY': 'secret key',\n       'ANOTHER_HEADER': 'Some header value'\n     };\n   }\n }\n ```\n\n `headers` can also be used as a computed property to support dynamic\n headers. In the example below, the `session` object has been\n injected into an adapter by Ember's container.\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n import { computed } from '@ember/object';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   headers: computed('session.authToken', function() {\n     return {\n       'API_KEY': this.session.authToken,\n       'ANOTHER_HEADER': 'Some header value'\n     };\n   })\n }\n ```\n\n In some cases, your dynamic headers may require data from some\n object outside of Ember's observer system (for example\n `document.cookie`). You can use the\n [volatile](/api/classes/Ember.ComputedProperty.html?anchor=volatile)\n function to set the property into a non-cached mode causing the headers to\n be recomputed with every request.\n\n ```app/adapters/application.js\n import RESTAdapter from '@ember-data/adapter/rest';\n import { computed } from '@ember/object';\n\n export default class ApplicationAdapter extends RESTAdapter {\n   headers: computed(function() {\n     return {\n       'API_KEY': document.cookie.match(/apiKey\\=([^;]*)/)['1'],\n       'ANOTHER_HEADER': 'Some header value'\n     };\n   }).volatile()\n }\n ```"
        },
        {
            "displayName": "@ember-data/canary-features",
            "name": "@ember-data_canary-features",
            "description": "## Canary Features\n\nEmberData allows users to test features that are implemented but not yet\navailable even in canary.\n\nTypically these features represent work that might introduce a new concept,\nnew API, change an API, or risk an unintended change in behavior to consuming\napplications.\n\nSuch features have their implementations guarded by a \"feature flag\", and the\nflag is only activated once the core-data team is prepared to ship the work\nin a canary release.\n\n### Installing Canary\n\nTo test a feature you MUST be using a canary build. Canary builds are published\nto `npm` and can be installed using a precise tag (such as `ember-data@3.16.0-alpha.1`)\nor by installing the latest dist-tag published to the `canary` channel using your javascript\npackage manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n ```cli\n pnpm add ember-data@canary\n ```\n\n### Activating a Canary Feature\n\nOnce you have installed canary, feature-flags can be activated at build-time\n\nby setting an environment variable:\n\n```cli\n# Activate a single flag\nEMBER_DATA_FEATURE_OVERRIDE=SOME_FLAG ember build\n\n# Activate multiple flags by separating with commas\nEMBER_DATA_FEATURE_OVERRIDE=SOME_FLAG,OTHER_FLAG ember build\n\n# Activate all flags\nEMBER_DATA_FEATURE_OVERRIDE=ENABLE_ALL_OPTIONAL ember build\n```\n\nor by setting the appropriate flag in your `ember-cli-build` file:\n\n```ts\nlet app = new EmberApp(defaults, {\n  emberData: {\n    features: {\n      SAMPLE_FEATURE_FLAG: false // utliize existing behavior, strip code for the new feature\n      OTHER_FEATURE_FLAG: true // utilize this new feature, strip code for the older behavior\n    }\n  }\n})\n```\n\n**The \"off\" branch of feature-flagged code is always stripped from production builds.**\n\nThe list of available feature-flags is located [here](https://github.com/emberjs/data/tree/main/packages/private-build-infra/virtual-packages/canary-features.js \"List of EmberData FeatureFlags\")\n\n\n### Preparing a Project to use a Canary Feature\n\nFor most projects, simple version detection should be enough.\nUsing the provided version compatibility helpers from [embroider-macros](https://github.com/embroider-build/embroider/tree/main/packages/macros#readme)\nthe following can be done:\n\n```js\nif (macroCondition(dependencySatisfies('@ember-data/store', '5.0'))) {\n  // do thing\n}\n```"
        },
        {
            "displayName": "@ember-data/debug",
            "name": "@ember-data_debug",
            "description": "# Overview\n\nThis package provides the `DataAdapter` which the [Ember Inspector](https://github.com/emberjs/ember-inspector)\nuses to subscribe and retrieve information for the `data` tab in the inspector.\n\nThis package adds roughly .6 KB when minified and compressed to your application in production; however,\nyou can opt out of shipping this addon in production via options in `ember-cli-build.js`\n\n```js\nlet app = new EmberApp(defaults, {\n  emberData: {\n    includeDataAdapterInProduction: false\n  }\n});\n```\n\nWhen using `ember-data` as a dependency of your app, the default is to ship the inspector support to production.\n\nWhen not using `ember-data` as a dependency but instead using EmberData via declaring specific `@ember-data/<package>`\ndependencies the default is to not ship to production."
        },
        {
            "displayName": "@ember-data/deprecations",
            "name": "@ember-data_deprecations",
            "description": "## Deprecations\n\nEmberData allows users to opt-in and remove code that exists to support deprecated\nbehaviors.\n\nIf your app has resolved all deprecations present in a given version,\nyou may specify that version as your \"compatibility\" version to remove\nthe code that supported the deprecated behavior from your app.\n\nFor instance, if a deprecation was introduced in 3.13, and the app specifies\n3.13 as its minimum version compatibility, any deprecations introduced before\nor during 3.13 would be stripped away.\n\nAn app can use a different version than what it specifies as it's compatibility\nversion. For instance, an App could be using `3.16` while specifying compatibility\nwith `3.12`. This would remove any deprecations that were present in or before `3.12`\nbut keep support for anything deprecated in or above `3.13`.\n\n### Configuring Compatibility\n\nTo configure your compatibility version, set the `compatWith` to the version you\nare compatible with on the `emberData` config in your `ember-cli-build.js` file.\n\n```js\nlet app = new EmberApp(defaults, {\n  emberData: {\n    compatWith: '3.12',\n  },\n});\n```\n\nAlternatively, individual deprecations can be resolved (and thus have its support stripped)\nvia one of the flag names listed below. For instance, given a flag named `DEPRECATE_FOO_BEHAVIOR`.\n\nThis capability is interopable with `compatWith`. You may set `compatWith` and then selectively resolve\nadditional deprecations, or set compatWith and selectively un-resolve specific deprecations.\n\nNote: EmberData does not test against permutations of deprecations being stripped, our tests run against\n\"all deprecated code included\" and \"all deprecated code removed\". Unspecified behavior may sometimes occur\nwhen removing code for only some deprecations associated to a version number.\n\n```js\nlet app = new EmberApp(defaults, {\n  emberData: {\n    deprecations: {\n      DEPRECATE_FOO_BEHAVIOR: false // set to false to strip this code\n      DEPRECATE_BAR_BEHAVIOR: true // force to true to not strip this code\n    }\n  }\n})\n```\n\nThe complete list of which versions specific deprecations will be removed in\ncan be found [here](https://github.com/emberjs/data/blob/main/packages/private-build-infra/virtual-packages/deprecations.js \"List of EmberData Deprecations\")"
        },
        {
            "displayName": "@ember-data/experimental-preview-types",
            "name": "@ember-data_experimental-preview-types",
            "description": "Many parts of EmberData are interface-driven,\nmeaning that no specific base-class is necessary\nto implement an interopable module of your own\nutilizing only public APIs.\n\nExamples of primitives in EmberData that are interface-driven\ninclude Adapters, Serializers, Request Handlers, and the Cache.\n\nThese **Not Yet Installable** Typescript Types\nDocument key interfaces that libraries and\napplications interfacing with EmberData would need\nto conform to."
        },
        {
            "displayName": "@ember-data/graph",
            "name": "@ember-data_graph",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\n<p align=\"center\">Provides a performance tuned normalized graph for intelligently managing relationships between resources based on identity</p>\n\nWhile this Graph is abstract, it currently is a private implementation required as a peer-dependency by the [JSON:API Cache Implementation](https://github.com/emberjs/data/tree/main/packages/json-api).\n\nWe intend to make this Graph public API after some additional iteration during the 5.x timeframe, until then all APIs should be considered experimental and unstable, not fit for direct application or 3rd party library usage.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/graph\n```"
        },
        {
            "displayName": "@ember-data/json-api",
            "name": "@ember-data_json-api",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\nThis package provides an in-memory [JSON:API](https://jsonapi.org/) document and resource [*Ember***Data** Cache](https://github.com/emberjs/data/blob/main/ember-data-types/cache/cache.ts) implementation.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## üöÄ Setup\n\n> **Note**\n> When using [ember-data](https://github.com/emberjs/data/blob/main/packages/-ember-data) the below\n> configuration is handled for you automatically.\n\n```ts\nimport Store from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\n\nexport default class extends Store {\n createCache(wrapper) {\n   return new Cache(wrapper);\n }\n}\n```\n\n\n## Usage\n\nUsually you will directly interact with the cache only if implementing a presentation class. Below we\ngive an example of a read-only record (mutations never written back to the cache). More typically cache\ninteractions are something that the `Store` coordinates as part of the `request/response` lifecycle.\n\n```ts\nimport Store, { recordIdentifierFor } from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\nimport { TrackedObject } from 'tracked-built-ins';\n\nclass extends Store {\n createCache(wrapper) {\n   return new Cache(wrapper);\n }\n\n instantiateRecord(identifier) {\n   const { cache, notifications } = this;\n   const { type, id } = identifier;\n\n   // create a TrackedObject with our attributes, id and type\n   const attrs = cache.peek(identifier).attributes;\n   const data = Object.assign({}, attrs, { type, id });\n   const record = new TrackedObject(data);\n\n   // update the TrackedObject whenever attributes change\n   const token = notifications.subscribe(identifier, (_, change) => {\n     if (change === 'attributes') {\n       Object.assign(record, cache.peek(identifier).attributes);\n     }\n   });\n\n   // setup the ability to teardown the subscription when the\n   // record is no longer needed\n   record.destroy = () => {\n     this.notifications.unsubscribe(token);\n   };\n\n   return record;\n }\n\n teardownRecord(record: FakeRecord) {\n   record.destroy();\n }\n}\n```\n\nFor the full list of APIs see the docs for [Cache Interface](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache)"
        },
        {
            "displayName": "@ember-data/json-api/request",
            "name": "@ember-data_json-api_request",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with [JSON:API](https://json-api.org) APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/json-api/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/\\*\n => {\n   url: 'https://api.example.com/v1/ember-developers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>,\n     // => 'Accept': 'application/vnd.api+json'\n     // => 'Content-Type': 'application/vnd.api+json'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n\\/\n```\n\nRequest builder output may be used with either `requestManager.request` or `store.request`.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common JSON:API format (dasherized pluralized resource types)."
        },
        {
            "displayName": "@ember-data/legacy-compat",
            "name": "@ember-data_legacy-compat",
            "description": "Utilities - often temporary - for maintaining backwards compatibility with\nolder parts of EmberData."
        },
        {
            "displayName": "@ember-data/model",
            "name": "@ember-data_model",
            "description": "This package provides a Presentation Model for resource data in an EmberData Cache.\n\nModels are defined as classes extending from `import Model from '@ember-data/model';` and the\nattributes and relationships on these classes are parsed at runtime to supply static \"schema\"\nto EmberData's SchemaService.\n\nResource data for individual resources fetched from your API is presented to the UI via instances\nof the `Model`s you define. An instantiated `Model` is referred to as a `record`.\n\n When we refer to the `ModelClass` as opposed to a `Model` or `Record` we are referring\n specifically to the class definition and the static schema methods present on it.\n\n When we refer to a `record` we refer to a specific class instance presenting\n the resource data for a given `type` and `id`.\n\n ### Defining a Model\n\n ```app/models/person.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default class PersonModel extends Model {\n   @attr name;\n\n   @belongsTo('pet', { inverse: 'owners', async: false }) dog;\n\n   @hasMany('person', { inverse: 'friends', async: true }) friends;\n }\n ```\n\n ### modelName convention\n\n By convention, the name of a given model (its `type`) matches the name\n of the file in the `app/models` folder and should be lowercase, singular\n and dasherized."
        },
        {
            "displayName": "@ember-data/request",
            "name": "@ember-data_request",
            "description": "<p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData RequestManager\"\n    width=\"240px\"\n    title=\"EmberData RequestManager\"\n    />\n</p>\n\n<p align=\"center\">‚ö°Ô∏è a simple abstraction over fetch to enable easy management of request/response flows</p>\n\nThis package provides [*Ember*‚Äç**Data**](https://github.com/emberjs/data/)'s `RequestManager`, a framework agnostic library that can be integrated with any Javascript application to make [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) happen.\n\n- [Installation](#installation)\n- [Basic Usage](#üöÄ-basic-usage)\n- [Architecture](#ü™ú-architecture)\n- [Usage](#usage)\n  - [Making Requests](#making-requests)\n    - [Using The Response](#using-the-response)\n  - [Request Handlers](#handling-requests)\n    - [Handling Errors](#handling-errors)\n    - [Handling Abort](#handling-abort)\n    - [Stream Currying](#stream-currying)\n    - [Automatic Currying](#automatic-currying-of-stream-and-response)\n  - [Using as a Service](#using-as-a-service)\n    - [Using with `@ember-data/store`](#using-with-ember-datastore)\n    - [Using with `ember-data`](#using-with-ember-data)\n\n---\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/request\n```\n\n---\n\n## üöÄ Basic Usage\n\nA `RequestManager` provides a request/response flow in which configured handlers are successively given the opportunity to handle, modify, or pass-along a request.\n\nThe RequestManager on its own does not know how to fulfill requests. For this we must register at least one handler. A basic `Fetch` handler is provided that will take the request options provided and execute `fetch`.\n\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { apiUrl } from './config';\n\n// ... create manager and add our Fetch handler\nconst manager = new RequestManager();\nmanager.use([Fetch]);\n\n// ... execute a request\nconst response = await manager.request({\n  url: `${apiUrl}/users`\n});\n```\n\n---\n\n## ü™ú Architecture\n\nA `RequestManager` receives a request and manages fulfillment via configured handlers. It may be used standalone from the rest of *Ember*‚Äç**Data** and is not specific to any library or framework.\n\nEach handler may choose to fulfill the request using some source of data or to pass the request along to other handlers.\n\nThe same or a separate instance of a `RequestManager` may also be used to fulfill requests issued by [*Ember*‚Äç**Data**{Store}](https://github.com/emberjs/data/tree/main/packages/store)\n\nWhen the same instance is used by both this allows for simple coordination throughout the application. Requests issued by the Store will use the in-memory cache\nand return hydrated responses, requests issued directly to the RequestManager\nwill skip the in-memory cache and return raw responses.\n\n---\n\n## Usage\n\n```ts\nconst userList = await manager.request({\n  url: `/api/v1/users.list`\n});\n\nconst users = userList.content;\n```\n\n---\n\n### Making Requests\n\n`RequestManager` has a single asyncronous method as it's API: `request`\n\n```ts\nclass RequestManager {\n  request<T>(req: RequestInfo): Future<T>;\n}\n```\n\n`manager.request(<RequestInfo>)` accepts an object containing the information\nnecessary for the request to be handled successfully.\n\nThese options extend the [options](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) provided to `fetch`, and can accept a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request). All properties accepted by Request options and fetch options are valid.\n\n```ts\ninterface RequestInfo extends FetchOptions {\n  op?: string;\n  store?: Store;\nurl: string;\n   // data that a handler should convert into\n   // the query (GET) or body (POST)\n  data?: Record<string, unknown>;\n// options specifically intended for handlers\n  // to utilize to process the request\n  options?: Record<string, unknown>;\n}\n```\n\n> **note**\n> providing a `signal` is unnecessary as an `AbortController` is automatically provided if none is present.\n\n---\n\n#### Using the Response\n\n`manager.request` returns a `Future`, which allows access to limited information about the request while it is still pending and fulfills with the final state when the request completes and the response has been read.\n\n```ts\nconst usersFuture = manager.request({\n  url: `/api/v1/users.list`\n});\n```\n\nA `Future` is cancellable via `abort`.\n\n```ts\nusersFuture.abort();\n```\n\nHandlers may *optionally* expose a ReadableStream to the `Future` for streaming data; however, when doing so the handler should not resolve until it has fully read the response stream itself.\n\n```ts\ninterface Future<T> extends Promise<StructuredDocument<T>> {\n  abort(): void;\nasync getStream(): ReadableStream | null;\n}\n```\n\nA Future resolves or rejects with a `StructuredDocument`.\n\n```ts\ninterface StructuredDocument<T> {\n  request: RequestInfo;\n  response: ResponseInfo | null;\n  content?: T;\n  error?: Error;\n}\n```\n\nThe `RequestInfo` specified by `document.request` is the same as originally provided to `manager.request`. If any handler fulfilled this request using different request info it is not represented here. This contract helps to ensure that `retry` and `caching` are possible since the original arguments are correctly preserved. This also allows handlers to \"fork\" the request or fulfill from multiple sources without the details of fulfillment muddying the original request.\n\nThe `ResponseInfo` is a serializable fulfilled subset of a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) if set via `setResponse`. If no response was ever set this will be `null`.\n\n```ts\ninterface ResponseInfo {\n  headers?: Record<string, string>;\n  ok?: boolean;\n  redirected?: boolean;\n  status?: HTTPStatusCode;\n  statusText?: string;\n  type?: 'basic' | 'cors';\n  url?: string;\n}\n```\n\n---\n\n### Request Handlers\n\nRequests are fulfilled by handlers. A handler receives the request context\nas well as a `next` function with which to pass along a request to the next\nhandler if it so chooses.\n\nA handler may be any object with a `request` method. This allows both stateful and non-stateful\nhandlers to be utilized.\n\nIf a handler calls `next`, it receives a `Future` which resolves to a `StructuredDocument`\nthat it can then compose how it sees fit with its own response.\n\n```ts\n\ntype NextFn<P> = (req: RequestInfo) => Future<P>;\n\ninterface Handler {\n  async request<T>(context: RequestContext, next: NextFn<P>): T;\n}\n```\n\n`RequestContext` contains a readonly version of the RequestInfo as well as a few methods for building up the `StructuredDocument` and `Future` that will be part of the response.\n\n```ts\ninterface RequestContext<T> {\n  readonly request: RequestInfo;\nsetStream(stream: ReadableStream | Promise<ReadableStream>): void;\n  setResponse(response: Response | ResponseInfo): void;\n}\n```\n\nA basic `fetch` handler with support for streaming content updates while\nthe download is still underway might look like the following, where we use\n[`response.clone()`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) to `tee` the `ReadableStream` into two streams.\n\nA more efficient handler might read from the response stream, building up the\nresponse content before passing along the chunk downstream.\n\n```ts\nconst FetchHandler = {\n  async request(context) {\n    const response = await fetch(context.request);\n    context.setResponse(reponse);\n    context.setStream(response.clone().body);\n  return response.json();\n  }\n}\n```\n\nRequest handlers are registered by configuring the manager via `use`\n\n```ts\nmanager.use([Handler1, Handler2])\n```\n\nHandlers will be invoked in the order they are registered (\"fifo\", first-in first-out), and may only be registered up until the first request is made. It is recommended but not required to register all handlers at one time in order to ensure explicitly visible handler ordering.\n\n---\n\n#### Handling Errors\n\nEach handler in the chain can catch errors from upstream and choose to\neither handle the error, re-throw the error, or throw a new error.\n\n```ts\nconst MAX_RETRIES = 5;\n\nconst Handler = {\n  async request(context, next) {\n    let attempts = 0;\n  while (attempts < MAX_RETRIES) {\n      attempts++;\n      try {\n        const response = await next(context.request);\n        return response;\n      } catch (e) {\n        if (isTimeoutError(e) && attempts < MAX_RETRIES) {\n          // retry request\n          continue;\n        }\n        // rethrow if it is not a timeout error\n        throw e;\n      }\n    }\n  }\n}\n```\n\n---\n\n#### Handling Abort\n\nAborting a request will reject the current handler in the chain. However,\nevery handler can potentially catch this error. If your handler needs to\nseparate AbortError from other Error types, it is recommended to check\n`context.request.signal.aborted` (or if a custom controller was supplied `controller.signal.aborted`).\n\nIn this manner it is possible for a request to recover from an abort and\nstill proceed; however, as a best practice this should be used for necessary\ncleanup only and the original AbortError rethrown if the abort signal comes\nfrom the root controller.\n\n*AbortControllers are Always Present and Always Entangled**\n\nIf the initial request does not supply an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController), one will be generated.\n\nThe [signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for this controller is automatically added to the request passed into the first handler.\n\nEach handler has the option to supply a new controller to the request when calling `next`. If a new controller is provided it will be automatically\nentangled with the root controller. If the root controller aborts, so will\nany entangled controllers.\n\nIf an entangled controller aborts, the root controller will not abort. This\nallows for advanced request-flow scenarios to abort subsections of the request tree without aborting the entire request.\n\n---\n\n#### Stream Currying\n\n`RequestManager.request` and `next` differ from `fetch` in one **crucial detail** in that the outer Promise resolves only once the response stream has been processed.\n\nFor context, it helps to understand a few of the use-cases that RequestManager\nis intended to allow.\n\n- to manage and return streaming content (such as video files)\n- to fulfill a request from multiple sources or by splitting one request into multiple requests\n  - for instance one API call for a user and another for the user's friends\n  - or e.g. fulfilling part of the request from one source (one API, in-memory, localStorage, IndexedDB\n   etc.) and the rest from another source (a different API, a WebWorker, etc.)\n- to coalesce multiple requests\n- to decorate a request with additional info\n  - e.g. an Auth handler that ensures the correct tokens or headers or cookies are attached.\n\n\n`await fetch(<req>)` resolves at the moment headers are received. This allows for the body of the request to be processed as a stream by application\ncode *while chunks are still being received by the browser*.\n\nWhen an app chooses to `await response.json()` what occurs is the browser reads the stream to completion and then returns the result. Additionally, this stream may only be read **once**.\n\nThe `RequestManager` preserves this ability to subscribe to and utilize the stream by either the application or the handler ‚Äì¬†thereby delivering the full power and flexibility of native APIs ‚Äì without restricting developers in ways that lead to complicated workarounds.\n\nEach handler may call `setStream` only once, but may do so *at any time* until the promise that the handler returns has resolved. The associated promise returned by calling `future.getStream` will resolve with the stream set by `setStream` if that method is called, or `null` if that method\nhas not been called by the time that the handler's request method has resolved.\n\nHandlers that do not create a stream of their own, but which call `next`, should defensively pipe the stream forward. While this is not required (see automatic currying below) it is better to do so in most cases as otherwise the stream may not become available to downstream handlers or the application until the upstream handler has fully read it.\n\n```ts\ncontext.setStream(future.getStream());\n```\n\nHandlers that either call `next` multiple times or otherwise have reason to create multiple  fetch requests should either choose to return no stream, meaningfully combine the streams, or select a single prioritized stream.\n\nOf course, any handler may choose to read and handle the stream, and return either no stream or a different stream in the process.\n\n---\n\n#### Automatic Currying of Stream and Response\n\nIn order to simplify the common case for handlers which decorate a request, if `next` is called only a single time and `setResponse` was never called by the handler, the response set by the next handler in the chain will be applied to that handler's outcome. For instance, this makes the following pattern possible `return (await next(<req>)).content;`.\n\nSimilarly, if `next` is called only a single time and neither `setStream` nor `getStream` was called, we automatically curry the stream from the future returned by `next` onto the future returned by the handler.\n\nFinally, if the return value of a handler is a `Future`, we curry `content` and `errors` as well, thus enabling the simplest form `return next(<req>)`.\n\nIn the case of the `Future` being returned, `Stream` proxying is automatic and immediate and does not wait for the `Future` to resolve.\n\n---\n\n### Using as a Service\n\nMost applications will desire to have a single `RequestManager` instance, which can be achieved using module-state patterns for singletons, or for [Ember](https://emberjs.com) applications by exporting the manager as a [service](https://guides.emberjs.com/release/services/).\n\nservices/request.ts*\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport Auth from 'ember-simple-auth/ember-data-handler';\n\nexport default class extends RequestManager {\n  constructor(createArgs) {\n    super(createArgs);\n    this.use([Auth, Fetch]);\n  }\n}\n```\n\n---\n\n#### Using with `@ember-data/store`\n\nTo have a request service unique to a Store:\n\n```ts\nimport Store, { CacheHandler } from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nclass extends Store {\n  requestManager = new RequestManager();\nconstructor(args) {\n    super(args);\n    this.requestManager.use([Fetch]);\n    this.requestManager.useCache(CacheHandler);\n  }\n}\n```\n\n---\n\n#### Using with `ember-data`\n\nIf using the package [ember-data](https://github.com/emberjs/data/tree/main/packages/-ember-data),\nthe following configuration will automatically be done in order to preserve the\nlegacy [Adapter](https://github.com/emberjs/data/tree/main/packages/adapter) and\n[Serializer](https://github.com/emberjs/data/tree/main/packages/serializer) behavior.\nAdditional handlers or a service injection like the above would need to be done by the\nconsuming application in order to make broader use of `RequestManager`.\n\n```ts\nimport Store, { CacheHandler } from 'ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { LegacyNetworkHandler } from '@ember-data/legacy-compat';\n\nexport default class extends Store {\n  requestManager = new RequestManager();\nconstructor(args) {\n    super(args);\n    this.requestManager.use([LegacyNetworkHandler, Fetch]);\n    this.requestManager.useCache(CacheHandler);\n  }\n}\n```\n\nTo provide a different configuration, import and extend `ember-data/store`. The\ndefault configuration will be ignored if the `requestManager` property is set,\nthough the store will still register the CacheHandler.\n\nFor usage of the store's `requestManager` via `store.request(<req>)` see the\n[Store](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fstore) documentation."
        },
        {
            "displayName": "@ember-data/request-utils",
            "name": "@ember-data_request-utils",
            "description": "Simple utility function to assist in url building,\nquery params, and other common request operations.\n\nThese primitives may be used directly or composed\nby request builders to provide a consistent interface\nfor building requests.\n\nFor instance:\n\n```ts\nimport { buildBaseURL, buildQueryParams } from '@ember-data/request-utils';\n\nconst baseURL = buildBaseURL({\n  host: 'https://api.example.com',\n  namespace: 'api/v1',\n  resourcePath: 'emberDevelopers',\n  op: 'query',\n  identifier: { type: 'ember-developer' }\n});\nconst url = `${baseURL}?${buildQueryParams({ name: 'Chris', include:['pets'] })}`;\n// => 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris'\n```\n\nThis is useful, but not as useful as the REST request builder for query which is sugar\nover this (and more!):\n\n```ts\nimport { query } from '@ember-data/rest/request';\n\nconst options = query('ember-developer', { name: 'Chris', include:['pets'] });\n// => { url: 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris' }\n// Note: options will also include other request options like headers, method, etc.\n```"
        },
        {
            "displayName": "@ember-data/request/fetch",
            "name": "@ember-data_request_fetch",
            "description": "A basic Fetch Handler which converts a request into a\n`fetch` call presuming the response to be `json`.\n\n```ts\nimport Fetch from '@ember-data/request/fetch';\n\nmanager.use([Fetch]);\n```"
        },
        {
            "displayName": "@ember-data/rest/request",
            "name": "@ember-data_rest_request",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n />\n</p>\n\nThis package provides utilities for working with **REST**ful APIs with [*Ember***Data**](https://github.com/emberjs/data/).\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/json-api\n```\n\n## Usage\n\nRequest builders are functions that produce [Fetch Options](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\nThey take a few contextual inputs about the request you want to make, abstracting away the gnarlier details.\n\nFor instance, to fetch a resource from your API\n\n```ts\nimport { findRecord } from '@ember-data/rest/request';\n\nconst options = findRecord('ember-developer', '1', { include: ['pets', 'friends'] });\n\n/*\n => {\n   url: 'https://api.example.com/v1/emberDevelopers/1?include=friends,pets',\n   method: 'GET',\n   headers: <Headers>, // 'Content-Type': 'application/json;charset=utf-8'\n   op: 'findRecord';\n   records: [{ type: 'ember-developer', id: '1' }]\n }\n/\n```\n\nRequest builder output is ready to go for use with [store.request](https://api.emberjs.com/ember-data/release/classes/Store/methods/request?anchor=request),\n[manager.request](https://api.emberjs.com/ember-data/release/classes/RequestManager/methods/request?anchor=request) and most conventional REST APIs.\n\nResource types are pluralized and camelized for the url.\n\nURLs are stable. The same query will produce the same URL every time, even if the order of keys in\nthe query or values in an array changes.\n\nURLs follow the most common REST format (camelCase pluralized resource types).\n\n### Available Builders\n\n- [createRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/createRecord)\n- [deleteRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/deleteRecord)\n- [findRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/findRecord)\n- [query](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/query)\n- [updateRecord](https://api.emberjs.com/ember-data/release/functions/@ember-data%2Frest/updateRecord)"
        },
        {
            "displayName": "@ember-data/serializer",
            "name": "@ember-data_serializer",
            "description": "## Overview\n\n<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n<p>\n  ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n  If starting a new app or thinking of implementing a new serializer, consider writing a\n  <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n</p>\n</blockquote>\n\nIn order to properly manage and present your data, EmberData\nneeds to understand the structure of data it receives.\n\n`Serializers` convert data between the server's API format and\nthe format EmberData understands.\n\nData received from an API response is **normalized** into\n[JSON:API](https://jsonapi.org/) (the format used internally\nby EmberData), while data sent to an API is **serialized**\ninto the format the API expects.\n\n### Implementing a Serializer\n\nThere are only two required serializer methods, one for\nnormalizing data from the server API format into JSON:API, and\nanother for serializing records via `Snapshots` into the expected\nserver API format.\n\nTo implement a serializer, export a class that conforms to the structure\ndescribed by [<Interface> Serializer](/ember-data/release/classes/%3CInterface%3E%20Serializer)\nfrom the `app/serializers/` directory. An example is below.\n\n```ts\nimport EmberObject from '@ember/object';\n\nexport default class ApplicationSerializer extends EmberObject {\n  normalizeResponse(store, schema, rawPayload) {\n    return rawPayload;\n  }\n\n  serialize(snapshot, options) {\n    const serializedResource = {\n      id: snapshot.id,\n      type: snapshot.modelName,\n      attributes: snapshot.attributes()\n    };\n\n    return serializedResource;\n  }\n}\n ```\n\n\n### Serializer Resolution\n\n`store.serializerFor(name)` will lookup serializers defined in\n`app/serializers/` and return an instance. If no serializer is found, an\nerror will be thrown.\n\n`serializerFor` first attempts to find a serializer with an exact match on `name`,\nthen falls back to checking for the presence of a serializer named `application`.\n\n```ts\nstore.serializerFor('author');\n\n// lookup paths (in order) =>\n//   app/serializers/author.js\n//   app/serializers/application.js\n```\n\nMost requests in EmberData are made with respect to a particular `type` (or `modelName`)\n(e.g., \"get me the full collection of **books**\" or \"get me the **employee** whose id is 37\"). We\nrefer to this as the **primary** resource `type`.\n\nTypically `serializerFor` will be used to find a serializer with a name matching that of the primary\nresource `type` for the request, falling back to the `application` serializer for those types that\ndo not have a defined serializer. This is often described as a `per-model` or `per-type` strategy\nfor defining serializers. However, because APIs rarely format payloads per-type but rather\nper-API-version, this may not be a desired strategy.\n\nIt is recommended that applications define only a single `application` adapter and serializer\nwhere possible.\n\nIf you have multiple API formats and the per-type strategy is not viable, one strategy is to\nwrite an `application` adapter and serializer that make use of `options` to specify the desired\nformat when making a request.\n\n### Using a Serializer\n\nAny serializer in `app/serializers/` can be looked up by `name` using `store.serializerFor(name)`.\n\n### Default Serializers\n\nFor applications whose APIs are *very close to* or *exactly* the **REST** format or **JSON:API**\nformat the `@ember-data/serializer` package contains implementations these applications can\nextend. It also contains a simple `JSONSerializer` for serializing to/from very basic JSON objects.\n\nMany applications will find writing their own serializer to be more performant and less\ncomplex than extending these classes even when their API format is very close to that expected\nby these serializers.\n\nIt is recommended that apps write their own serializer to best suit the needs of their API and\napplication."
        },
        {
            "displayName": "@ember-data/serializer/json",
            "name": "@ember-data_serializer_json",
            "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n By default, EmberData uses and recommends the `JSONAPISerializer`.\n\n `JSONSerializer` is useful for simpler or legacy backends that may\n not support the http://jsonapi.org/ spec.\n\n For example, given the following `User` model and JSON payload:\n\n ```app/models/user.js\n import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n\n export default class UserModel extends Model {\n   @hasMany('user') friends;\n   @belongsTo('location') house;\n\n   @attr('string') name;\n }\n ```\n\n ```js\n {\n   id: 1,\n   name: 'Sebastian',\n   friends: [3, 4],\n   links: {\n     house: '/houses/lefkada'\n   }\n }\n ```\n\n `JSONSerializer` will normalize the JSON payload to the JSON API format that the\n Ember Data store expects.\n\n You can customize how JSONSerializer processes its payload by passing options in\n the `attrs` hash or by subclassing the `JSONSerializer` and overriding hooks:\n\n   - To customize how a single record is normalized, use the `normalize` hook.\n   - To customize how `JSONSerializer` normalizes the whole server response, use the\n     `normalizeResponse` hook.\n   - To customize how `JSONSerializer` normalizes a specific response from the server,\n     use one of the many specific `normalizeResponse` hooks.\n   - To customize how `JSONSerializer` normalizes your id, attributes or relationships,\n     use the `extractId`, `extractAttributes` and `extractRelationships` hooks.\n\n The `JSONSerializer` normalization process follows these steps:\n\n   1. `normalizeResponse`\n       - entry method to the serializer.\n   2. `normalizeCreateRecordResponse`\n       - a `normalizeResponse` for a specific operation is called.\n   3. `normalizeSingleResponse`|`normalizeArrayResponse`\n       - for methods like `createRecord` we expect a single record back, while for methods like `findAll` we expect multiple records back.\n   4. `normalize`\n       - `normalizeArrayResponse` iterates and calls `normalize` for each of its records while `normalizeSingle`\n         calls it once. This is the method you most likely want to subclass.\n   5. `extractId` | `extractAttributes` | `extractRelationships`\n       - `normalize` delegates to these methods to\n         turn the record payload into the JSON API format."
        },
        {
            "displayName": "@ember-data/serializer/json-api",
            "name": "@ember-data_serializer_json-api",
            "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n In EmberData a Serializer is used to serialize and deserialize\n records when they are transferred in and out of an external source.\n This process involves normalizing property names, transforming\n attribute values and serializing relationships.\n\n `JSONAPISerializer` supports the http://jsonapi.org/ spec and is the\n serializer recommended by Ember Data.\n\n This serializer normalizes a JSON API payload that looks like:\n\n ```app/models/player.js\n import Model, { attr, belongsTo } from '@ember-data/model';\n\n export default class Player extends Model {\n   @attr('string') name;\n   @attr('string') skill;\n   @attr('number') gamesPlayed;\n   @belongsTo('club') club;\n }\n ```\n\n ```app/models/club.js\n import Model, { attr, hasMany } from '@ember-data/model';\n\n export default class Club extends Model {\n   @attr('string') name;\n   @attr('string') location;\n   @hasMany('player') players;\n }\n ```\n\n ```js\n   {\n     \"data\": [\n       {\n         \"attributes\": {\n           \"name\": \"Benfica\",\n           \"location\": \"Portugal\"\n         },\n         \"id\": \"1\",\n         \"relationships\": {\n           \"players\": {\n             \"data\": [\n               {\n                 \"id\": \"3\",\n                 \"type\": \"players\"\n               }\n             ]\n           }\n         },\n         \"type\": \"clubs\"\n       }\n     ],\n     \"included\": [\n       {\n         \"attributes\": {\n           \"name\": \"Eusebio Silva Ferreira\",\n           \"skill\": \"Rocket shot\",\n           \"games-played\": 431\n         },\n         \"id\": \"3\",\n         \"relationships\": {\n           \"club\": {\n             \"data\": {\n               \"id\": \"1\",\n               \"type\": \"clubs\"\n             }\n           }\n         },\n         \"type\": \"players\"\n       }\n     ]\n   }\n ```\n\n to the format that the Ember Data store expects.\n\n ### Customizing meta\n\n Since a JSON API Document can have meta defined in multiple locations you can\n use the specific serializer hooks if you need to customize the meta.\n\n One scenario would be to camelCase the meta keys of your payload. The example\n below shows how this could be done using `normalizeArrayResponse` and\n `extractRelationship`.\n\n ```app/serializers/application.js\n import JSONAPISerializer from '@ember-data/serializer/json-api';\n\n export default class ApplicationSerializer extends JSONAPISerializer {\n   normalizeArrayResponse(store, primaryModelClass, payload, id, requestType) {\n     let normalizedDocument = super.normalizeArrayResponse(...arguments);\n\n     // Customize document meta\n     normalizedDocument.meta = camelCaseKeys(normalizedDocument.meta);\n\n     return normalizedDocument;\n   }\n\n   extractRelationship(relationshipHash) {\n     let normalizedRelationship = super.extractRelationship(...arguments);\n\n     // Customize relationship meta\n     normalizedRelationship.meta = camelCaseKeys(normalizedRelationship.meta);\n\n     return normalizedRelationship;\n   }\n }\n ```"
        },
        {
            "displayName": "@ember-data/serializer/rest",
            "name": "@ember-data_serializer_rest",
            "description": "<blockquote style=\"margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;\">\n <p>\n   ‚ö†Ô∏è <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.\n   If starting a new app or thinking of implementing a new adapter, consider writing a\n   <a href=\"/ember-data/release/classes/%3CInterface%3E%20Handler\">Handler</a> instead to be used with the <a href=\"https://github.com/emberjs/data/tree/main/packages/request#readme\">RequestManager</a>\n </p>\n </blockquote>\n\n Normally, applications will use the `RESTSerializer` by implementing\n the `normalize` method.\n\n This allows you to do whatever kind of munging you need and is\n especially useful if your server is inconsistent and you need to\n do munging differently for many different kinds of responses.\n\n See the `normalize` documentation for more information.\n\n ## Across the Board Normalization\n\n There are also a number of hooks that you might find useful to define\n across-the-board rules for your payload. These rules will be useful\n if your server is consistent, or if you're building an adapter for\n an infrastructure service, like Firebase, and want to encode service\n conventions.\n\n For example, if all of your keys are underscored and all-caps, but\n otherwise consistent with the names you use in your models, you\n can implement across-the-board rules for how to convert an attribute\n name in your model to a key in your JSON.\n\n ```app/serializers/application.js\n import RESTSerializer from '@ember-data/serializer/rest';\n import { underscore } from '<app-name>/utils/string-utils';\n\n export default class ApplicationSerializer extends RESTSerializer {\n   keyForAttribute(attr, method) {\n     return underscore(attr).toUpperCase();\n   }\n }\n ```\n\n You can also implement `keyForRelationship`, which takes the name\n of the relationship as the first parameter, the kind of\n relationship (`hasMany` or `belongsTo`) as the second parameter, and\n the method (`serialize` or `deserialize`) as the third parameter."
        },
        {
            "displayName": "@ember-data/store",
            "name": "@ember-data_store",
            "description": "<p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData Store\"\n    width=\"240px\"\n    title=\"EmberData Store\"\n    />\n</p>\n\nThis package provides [*Ember***Data**](https://github.com/emberjs/data/)'s `Store` class.\n\nA [Store](https://api.emberjs.com/ember-data/release/classes/Store) coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\nand sources of data (such as your API or a local persistence layer) accessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n\nOptionally, a Store can be configured to hydrate the response data into rich presentation classes.\n\n## Installation\n\nIf you have installed `ember-data` then you already have this package installed.\nOtherwise you can install it using your javascript package manager of choice.\nFor instance with [pnpm](https://pnpm.io/)\n\n```\npnpm add @ember-data/store\n```\n\nAfter installing you will want to configure your first `Store`. Read more below\nfor how to create and configure stores for your application.\n\n\n## üî® Creating A Store\n\nTo use a `Store` we will need to do few things: add a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache)\nto store data **in-memory**, add a [Handler](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache) to fetch data from a source,\nand implement `instantiateRecord` to tell the store how to display the data for individual resources.\n\n> **Note**\n> If you are using the package `ember-data` then a JSON:API cache, RequestManager, LegacyNetworkHandler,\n> and `instantiateRecord` are configured for you by default.\n\n### Configuring A Cache\n\nTo start, let's install a [JSON:API](https://jsonapi.org/) cache. If your app uses `GraphQL` or `REST` other\ncaches may better fit your data. You can author your own cache by creating one that\nconforms to the [spec](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache).\n\nThe package `@ember-data/json-api` provides a [JSON:API](https://jsonapi.org/) cache we can use.\nAfter installing it, we can configure the store to use this cache.\n\n```js\nimport Store from '@ember-data/store';\nimport Cache from '@ember-data/json-api';\n\nclass extends Store {\n  createCache(storeWrapper) {\n    return new Cache(storeWrapper);\n  }\n}\n```\n\nNow that we have a `cache` let's setup something to handle fetching\nand saving data via our API.\n\n> **Note**\n> The `ember-data` package automatically includes and configures\n> the `@ember-data/json-api` cache for you.\n\n### Handling Requests\n\nWhen *Ember***Data** needs to fetch or save data it will pass that request to your application's `RequestManager` for fulfillment. How this fulfillment occurs (in-memory, device storage, via single or multiple API requests, etc.) is then up to the registered request handlers.\n\nTo start, let's install the `RequestManager` from `@ember-data/request` and the basic `Fetch` handler from ``@ember-data/request/fetch`.\n\n> **Note**\n> If your app uses `GraphQL`, `REST` or different conventions for `JSON:API` than your cache expects, other handlers may better fit your data. You can author your own handler by creating one that conforms to the [handler interface](https://github.com/emberjs/data/tree/main/packages/request#handling-requests).\n\n```ts\nimport Store from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nexport default class extends Store {\n  constructor() {\n    super(...arguments);\n    this.requestManager = new RequestManager();\n    this.requestManager.use([Fetch]);\n  }\n}\n```\n\n**Using RequestManager as a Service**\n\nAlternatively if you have configured the `RequestManager` to be a service you may re-use it.\n\n*app/services/request.js*\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nexport default class extends RequestManager {\n  constructor(createArgs) {\n    super(createArgs);\n    this.use([Fetch]);\n  }\n}\n```\n\n*app/services/store.js*\n```ts\nimport Store from '@ember-data/store';\nimport { service } from '@ember/service';\n\nexport default class extends Store {\n  @service('request') requestManager\n}\n```\n\n\n### Presenting Data from the Cache\n\nNow that we have a source and a cach for our data, we need to configure how\nthe Store delivers that data back to our application. We do this via the hook\n[instantiateRecord](https://api.emberjs.com/ember-data/release/classes/Store/methods/instantiateRecord%20(hook)?anchor=instantiateRecord%20(hook)),\nwhich allows us to transform the data for a resource before handing it to the application.\n\nA naive way to present the data would be to return it as JSON. Typically instead\nthis hook will be used to add reactivity and make each unique resource a singleton,\nensuring that if the cache updates our presented data will reflect the new state.\n\nBelow is an example of using the hooks `instantiateRecord` and a `teardownRecord`\nto provide minimal read-only reactive state for simple resources.\n\n```ts\nimport Store, { recordIdentifierFor } from '@ember-data/store';\nimport { TrackedObject } from 'tracked-built-ins';\n\nclass extends Store {\n  instantiateRecord(identifier) {\n    const { cache, notifications } = this;\n\n    // create a TrackedObject with our attributes, id and type\n    const record = new TrackedObject(Object.assign({}, cache.peek(identifier)));\n    record.type = identifier.type;\n    record.id = identifier.id;\n\n    notifications.subscribe(identifier, (_, change) => {\n      if (change === 'attributes') {\n        Object.assign(record, cache.peek(identifier));\n      }\n    });\n\n    return record;\n  }\n}\n```\n\nBecause `instantiateRecord` is opaque to the nature of the record, an implementation\ncan be anything from a fairly simple object to a robust proxy that intelligently links\ntogether associated records through relationships.\n\nThis also enables creating a record that separates `edit` flows from `create` flows\nentirely. A record class might choose to implement a `checkout`method that gives access\nto an editable instance while the primary record continues to be read-only and reflect\nonly persisted (non-mutated) state.\n\nTypically you will choose an existing record implementation such as `@ember-data/model`\nfor your application.\n\nBecause of the boundaries around instantiation and the cache, record implementations\nshould be capable of interop both with each other and with any `Cache`. Due to this,\nif needed an application can utilize multiple record implementations and multiple cache\nimplementations either to support enhanced features for only a subset of records or to\nbe able to incrementally migrate from one record/cache to another record or cache.\n\n> **Note**\n> The `ember-data` package automatically includes the `@ember-data/model`\n> package and configures it for you."
        },
        {
            "displayName": "@ember-data/tracking",
            "name": "@ember-data_tracking",
            "description": "This package provides primitives that allow powerful low-level\nadjustments to change tracking notification behaviors.\n\nTypically you want to use these primitives when you want to divorce\nproperty accesses on EmberData provided objects from the current\ntracking context. Typically this sort of thing occurs when serializing\ntracked data to send in a request: the data itself is often ancillary\nto the thing which triggered the request in the first place and you\nwould not want to re-trigger the request for any update to the data."
        },
        {
            "displayName": "ember-data-overview",
            "name": "ember-data-overview",
            "description": "<p align=\"center\">\n <img\n   class=\"project-logo\"\n   src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n   alt=\"EmberData\"\n   width=\"240px\"\n   title=\"EmberData\"\n   />\n</p>\n\n<p align=\"center\">The lightweight reactive data library for JavaScript applications</p>\n\n---\n\nWrangle your application's data management with scalable patterns for developer productivity.\n\n- ‚ö°Ô∏è  Committed to Best-In-Class Performance\n- üå≤ Focused on being as svelte as possible\n- üöÄ SSR Ready\n- üîú Typescript Support\n- üêπ Built with ‚ô•Ô∏è by [Ember](https://emberjs.com)\n- ‚öõÔ∏è Supports any API: `GraphQL` `JSON:API` `REST` `tRPC` ...bespoke or a mix\n\n### üìñ On This Page\n\n- [Overview](./#overview)\n - [Architecture](#ü™ú-architecture)\n - [Basic Installation](#basic-installation)\n - [Advanced Installation](#advanced-installation)\n- [Configuration](#configuration)\n - [Deprecation Stripping](#deprecation-stripping)\n - [randomUUID polyfill](#randomuuid-polyfill)\n - [Removing inspector support in production](#removing-inspector-support-in-production)\n - [Debugging](#debugging)\n\n\n# Overview\n\n*Ember*‚Äç**Data** is a lightweight reactive data library for JavaScript applications that provides composable primitives for ordering query/mutation/peek flows, managing network and cache, and reducing data for presentation.\n\n## ü™ú Architecture\n\nThe core of *Ember*‚Äç**Data** is the `Store`, which coordinates interaction between your application, the `Cache`, and sources of data (such as your `API` or a local persistence layer).\nOptionally, the Store can be configured to hydrate the response data into rich presentation classes.\n\n*Ember*‚Äç**Data** is both resource centric and document centric in it's approach to caching, requesting and presenting data. Your application's configuration and usage drives which is important and when.\n\nThe `Store` is a **coordinator**. When using a `Store` you configure what cache to use, how cache data should be presented to the UI, and where it should look for requested data when it is not available in the cache.\n\nThis coordination is handled opaquely to the nature of the requests issued and the format of the data being handled. This approach gives applications broad flexibility to configure *Ember*‚Äç**Data** to best suite their needs. This makes *Ember*‚Äç**Data** a powerful solution for applications regardless of their size and complexity.\n\n*Ember*‚Äç**Data** is designed to scale, with a religious focus on performance and asset-size to keep its footprint small but speedy while still being able to handle large complex APIs in huge data-driven applications with no additional code and no added application complexity. It's goal is to prevent applications from writing code to manage data that is difficult to maintain or reason about.\n\n*Ember*‚Äç**Data**'s power comes not from specific features, data formats, or adherence to specific API specs such as `JSON:API` `trpc` or `GraphQL`, but from solid conventions around requesting and mutating data developed over decades of experience scaling developer productivity.\n\n## Basic Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add ember-data\n```\n\n`ember-data` is installed by default for new applications generated with `ember-cli`. You can check what version is installed by looking in the `devDependencies` hash of your project's [package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json) file.\n\nIf you have generated a new `Ember` application using `ember-cli` but do\nnot wish to use `ember-data`, remove `ember-data` from your project's `package.json` file and run your package manager's install command to update your lockfile.\n\n## Advanced Installation\n\n*Ember*‚Äç**Data** is organized into primitives that compose together via public APIs.\n\n- [@ember-data/store](/ember-data/release/modules/@ember-data%2Fstore) is the core and handles coordination\n- [@ember-data/json-api](/ember-data/release/modules/@ember-data%2Fjson-api) provides a resource cache for JSON:API structured data. It integrates with the store via the hook `createCache`\n- [@ember-data/model](/ember-data/release/modules/@ember-data%2Fmodel) is a presentation layer, it integrates with the store via the hooks `instantiateRecord` and `teardownRecord`.\n- [@ember-data/adapter](/ember-data/release/modules/@ember-data%2Fadapter) provides various network API integrations for APIS built over specific REST or JSON:API conventions.\n- [@ember-data/serializer](/ember-data/release/modules/@ember-data%2Fserializer) pairs with `@ember-data/adapter` to normalize and serialize data to and from an API format into the `JSON:API` format understood by `@ember-data/json-api`.\n- [@ember-data/debug](/ember-data/release/modules/@ember-data%2Fdebug) provides debugging support for the `ember-inspector`.\n- **ember-data** is a \"meta\" package which bundles all of these together for convenience\n\nThe packages interop with each other through well defined public API boundaries. The core\nof the library is the store provided by `@ember-data/store`, while each of the other libraries plugs into the store when installed. Because these packages interop via fully\npublic APIs, other libraries or applications may provide their own implementations. For instance, [ember-m3](https://github.com/hjdivad/ember-m3) is a commonly used presentation and cache implementation suitable for complex resource objects and graphs.\n\n## Configuration\n\n### Deprecation Stripping\n\n*Ember*‚Äç**Data** allows users to opt-in and remove code that exists to support deprecated behaviors.\n\nIf your app has resolved all deprecations present in a given version, you may specify that version as your \"compatibility\" version to remove the code that supported the deprecated behavior from your app.\n\n```ts\nlet app = new EmberApp(defaults, {\n emberData: {\n   compatWith: '4.8',\n },\n});\n```\n\n- [Full Documentation](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fdeprecations)\n\n### randomUUID polyfill\n\n*Ember*‚Äç**Data** uses `UUID V4` by default to generate identifiers for new data created on the client. Identifier generation is configurable, but we also for convenience will polyfill\nthe necessary feature if your browser support or deployment environment demands it. To\nactivate this polyfill:\n\n```ts\nlet app = new EmberApp(defaults, {\n '@embroider/macros': {\n   setConfig: {\n     '@ember-data/store': {\n       polyfillUUID: true\n     },\n   },\n },\n});\n```\n\n### removing inspector support in production\n\nIf you do not with to ship inspector support in your production application, you can specify\nthat all support for it should be stripped from the build.\n\n```ts\nlet app = new EmberApp(defaults, {\n emberData: {\n   includeDataAdapterInProduction: false\n }\n});\n```\n\n- [Full Documentation](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fdebug)\n\n### Debugging\n\nMany portions of the internals are helpfully instrumented with logging that can be activated\nat build time. This instrumentation is always removed from production builds or any builds\nthat has not explicitly activated it. To activate it set the appropriate flag to `true`.\n\n```ts\n let app = new EmberApp(defaults, {\n   emberData: {\n     debug: {\n         LOG_PAYLOADS: false, // data store received to update cache with\n         LOG_OPERATIONS: false, // updates to cache remote state\n         LOG_MUTATIONS: false, // updates to cache local state\n         LOG_NOTIFICATIONS: false,\n         LOG_REQUESTS: false, // log Requests issued via the request manager\n         LOG_REQUEST_STATUS: false,\n         LOG_IDENTIFIERS: false,\n         LOG_GRAPH: false,\n         LOG_INSTANCE_CACHE: false,\n     }\n   }\n });\n ```"
        }
    ],
    "elements": []
} };
});