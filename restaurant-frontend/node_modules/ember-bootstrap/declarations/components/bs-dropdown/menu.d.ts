import Component from '@glimmer/component';
interface DropdownMenuSignature {
    Element: HTMLDivElement;
    Args: {
        align?: 'left' | 'right';
        isOpen?: boolean;
        registerChildElement: (element: HTMLDivElement, [type]: ['menu']) => void;
        renderInPlace?: boolean;
        toggleElement: HTMLAnchorElement;
        unregisterChildElement: (element: HTMLDivElement, [type]: ['menu']) => void;
        /**
         * @internal
         */
        direction?: 'up' | 'down' | 'left' | 'right';
        /**
         * @internal
         */
        inNav?: boolean;
    };
    Blocks: {
        default: [];
    };
}
/**
 Component for the dropdown menu.

 See [Components.Dropdown](Components.Dropdown.html) for examples.

 @class DropdownMenu
 @namespace Components
 @extends Component
 @public
 */
export default class DropdownMenu extends Component<DropdownMenuSignature> {
    /**
     * @property _element
     * @type null | HTMLElement
     * @private
     */
    menuElement: HTMLDivElement | null;
    /**
     * Alignment of the menu, either "left" or "right"
     *
     * @property align
     * @type string
     * @default left
     * @public
     */
    get align(): "left" | "right";
    /**
     * @property direction
     * @default 'down'
     * @type string
     * @private
     */
    get direction(): "left" | "right" | "up" | "down";
    /**
     * By default, the menu is rendered in the same place as the dropdown. If you experience clipping
     * issues, you can set this to false to render the menu in a wormhole at the top of the DOM.
     *
     * @property renderInPlace
     * @type boolean
     * @default true
     * @public
     */
    get renderInPlace(): boolean;
    /**
     * @property inNav
     * @type {boolean}
     * @private
     */
    get inNav(): boolean;
    /**
     * @property _renderInPlace
     * @type boolean
     * @private
     */
    get _renderInPlace(): boolean;
    /**
     * The wormhole destinationElement
     *
     * @property destinationElement
     * @type object
     * @readonly
     * @private
     */
    get destinationElement(): any;
    get alignClass(): string | undefined;
    isOpen: boolean | undefined;
    updateIsOpen(value: boolean): void;
    flip: boolean;
    get popperPlacement(): string;
    setFocus(): void;
    get popperOptions(): {
        placement: string;
        onFirstUpdate: () => void;
        modifiers: {
            name: string;
            enabled: boolean;
        }[];
    };
}
export {};
//# sourceMappingURL=menu.d.ts.map