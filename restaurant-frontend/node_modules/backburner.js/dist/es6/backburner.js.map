{"version":3,"file":"backburner.js","sources":["../lib/backburner/platform.ts","../lib/backburner/utils.ts","../lib/backburner/binary-search.ts","../lib/backburner/queue.ts","../lib/backburner/deferred-action-queues.ts","../lib/backburner/iterator-drain.ts","../lib/index.ts"],"sourcesContent":["export interface IPlatform {\n  setTimeout(fn: Function, ms: number): any;\n  clearTimeout(id: any): void;\n  next(): any;\n  clearNext(): void;\n  now(): number;\n}\n\nconst SET_TIMEOUT = setTimeout;\nconst NOOP = () => {};\n\nexport function buildNext(flush: () => void): () => void {\n  // Using \"promises first\" here to:\n  //\n  // 1) Ensure more consistent experience on browsers that\n  //    have differently queued microtasks (separate queues for\n  //    MutationObserver vs Promises).\n  // 2) Ensure better debugging experiences (it shows up in Chrome\n  //    call stack as \"Promise.then (async)\") which is more consistent\n  //    with user expectations\n  //\n  // When Promise is unavailable use MutationObserver (mostly so that we\n  // still get microtasks on IE11), and when neither MutationObserver and\n  // Promise are present use a plain old setTimeout.\n  if (typeof Promise === 'function') {\n    const autorunPromise = Promise.resolve();\n\n    return () => autorunPromise.then(flush);\n  } else if (typeof MutationObserver === 'function') {\n    let iterations = 0;\n    let observer = new MutationObserver(flush);\n    let node = document.createTextNode('');\n    observer.observe(node, { characterData: true });\n\n    return () => {\n      iterations = ++iterations % 2;\n      node.data = '' + iterations;\n      return iterations;\n    };\n  } else {\n    return () => SET_TIMEOUT(flush, 0);\n  }\n}\n\nexport function buildPlatform(flush: () => void): IPlatform {\n  let clearNext = NOOP;\n\n  return {\n    setTimeout(fn, ms) {\n      return setTimeout(fn, ms);\n    },\n\n    clearTimeout(timerId: number) {\n      return clearTimeout(timerId);\n    },\n\n    now() {\n      return Date.now();\n    },\n\n    next: buildNext(flush),\n    clearNext,\n  };\n}\n","import { IQueueItem } from './interfaces';\n\ntype MaybeError = Error | undefined;\n\nconst NUMBER = /\\d+/;\n\nconst enum QueueItemPosition {\n  target,\n  method,\n  args,\n  stack\n}\n\nexport const TIMERS_OFFSET = 6;\n\nexport function isCoercableNumber(suspect) {\n  let type = typeof suspect;\n  return type === 'number' && suspect === suspect || type === 'string' && NUMBER.test(suspect);\n}\n\nexport function getOnError(options) {\n  return options.onError || (options.onErrorTarget && options.onErrorTarget[options.onErrorMethod]);\n}\n\nexport function findItem(target, method, collection) {\n  let index = -1;\n\n  for (let i = 0, l = collection.length; i < l; i += 4) {\n    if (collection[i] === target && collection[i + 1] === method) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n\nexport function findTimerItem(target, method, collection) {\n  let index = -1;\n\n  for (let i = 2, l = collection.length; i < l; i += 6) {\n    if (collection[i] === target && collection[i + 1] === method) {\n      index = i - 2;\n      break;\n    }\n  }\n\n  return index;\n}\n\nexport function getQueueItems(items: any[], queueItemLength: number, queueItemPositionOffset: number = 0): IQueueItem[] {\n  let queueItems: IQueueItem[] = [];\n\n  for (let i = 0; i < items.length; i += queueItemLength) {\n    let maybeError: MaybeError = items[i + QueueItemPosition.stack + queueItemPositionOffset];\n    let queueItem = {\n      target: items[i + QueueItemPosition.target + queueItemPositionOffset],\n      method: items[i + QueueItemPosition.method + queueItemPositionOffset],\n      args: items[i + QueueItemPosition.args + queueItemPositionOffset],\n      stack: maybeError !== undefined && 'stack' in maybeError ? maybeError.stack : ''\n    };\n\n    queueItems.push(queueItem);\n  }\n\n  return queueItems;\n}\n","import { TIMERS_OFFSET } from './utils';\n\nexport default function binarySearch(time, timers) {\n  let start = 0;\n  let end = timers.length - TIMERS_OFFSET;\n  let middle;\n  let l;\n\n  while (start < end) {\n    // since timers is an array of pairs 'l' will always\n    // be an integer\n    l = (end - start) / TIMERS_OFFSET;\n\n    // compensate for the index in case even number\n    // of pairs inside timers\n    middle = start + l - (l % TIMERS_OFFSET);\n\n    if (time >= timers[middle]) {\n      start = middle + TIMERS_OFFSET;\n    } else {\n      end = middle;\n    }\n  }\n\n  return (time >= timers[start]) ? start + TIMERS_OFFSET : start;\n}\n","import { IQueueItem } from './interfaces';\nimport {\n  findItem,\n  getOnError,\n  getQueueItems\n} from './utils';\n\nexport const enum QUEUE_STATE {\n  Pause = 1\n}\n\nconst QUEUE_ITEM_LENGTH = 4;\n\nexport default class Queue {\n  private name: string;\n  private globalOptions: any;\n  private options: any;\n  private _queueBeingFlushed: any[] = [];\n  private targetQueues = new Map();\n  private index = 0;\n  private _queue: any[] = [];\n\n  constructor(name: string, options: any = {}, globalOptions: any = {}) {\n    this.name = name;\n    this.options = options;\n    this.globalOptions = globalOptions;\n  }\n\n  public stackFor(index) {\n    if (index < this._queue.length) {\n      let entry = this._queue[index * 3 + QUEUE_ITEM_LENGTH];\n      if (entry) {\n        return entry.stack;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  public flush(sync?: Boolean) {\n    let { before, after } = this.options;\n    let target;\n    let method;\n    let args;\n    let errorRecordedForStack;\n\n    this.targetQueues.clear();\n    if (this._queueBeingFlushed.length === 0) {\n      this._queueBeingFlushed = this._queue;\n      this._queue = [];\n    }\n\n    if (before !== undefined) {\n      before();\n    }\n\n    let invoke;\n    let queueItems = this._queueBeingFlushed;\n    if (queueItems.length > 0) {\n      let onError = getOnError(this.globalOptions);\n      invoke = onError ? this.invokeWithOnError : this.invoke;\n\n      for (let i = this.index; i < queueItems.length; i += QUEUE_ITEM_LENGTH) {\n        this.index += QUEUE_ITEM_LENGTH;\n\n        method                = queueItems[i + 1];\n        // method could have been nullified / canceled during flush\n        if (method !== null) {\n          //\n          //    ** Attention intrepid developer **\n          //\n          //    To find out the stack of this task when it was scheduled onto\n          //    the run loop, add the following to your app.js:\n          //\n          //    Ember.run.backburner.DEBUG = true; // NOTE: This slows your app, don't leave it on in production.\n          //\n          //    Once that is in place, when you are at a breakpoint and navigate\n          //    here in the stack explorer, you can look at `errorRecordedForStack.stack`,\n          //    which will be the captured stack when this job was scheduled.\n          //\n          //    One possible long-term solution is the following Chrome issue:\n          //       https://bugs.chromium.org/p/chromium/issues/detail?id=332624\n          //\n          target                = queueItems[i];\n          args                  = queueItems[i + 2];\n          errorRecordedForStack = queueItems[i + 3]; // Debugging assistance\n          invoke(target, method, args, onError, errorRecordedForStack);\n        }\n\n        if (this.index !== this._queueBeingFlushed.length &&\n          this.globalOptions.mustYield && this.globalOptions.mustYield()) {\n          return QUEUE_STATE.Pause;\n        }\n      }\n    }\n\n    if (after !== undefined) {\n      after();\n    }\n\n    this._queueBeingFlushed.length = 0;\n    this.index = 0;\n    if (sync !== false && this._queue.length > 0) {\n      // check if new items have been added\n      this.flush(true);\n    }\n  }\n\n  public hasWork() {\n    return this._queueBeingFlushed.length > 0 || this._queue.length > 0;\n  }\n\n  public cancel({ target, method }) {\n    let queue = this._queue;\n    let targetQueueMap = this.targetQueues.get(target);\n\n    if (targetQueueMap !== undefined) {\n      targetQueueMap.delete(method);\n    }\n\n    let index = findItem(target, method, queue);\n\n    if (index > -1) {\n      queue[index + 1] = null;\n      return true;\n    }\n\n    // if not found in current queue\n    // could be in the queue that is being flushed\n    queue = this._queueBeingFlushed;\n\n    index = findItem(target, method, queue);\n    if (index > -1) {\n      queue[index + 1] = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  public push(target, method, args, stack): { queue: Queue, target, method } {\n    this._queue.push(target, method, args, stack);\n\n    return {\n      queue: this,\n      target,\n      method\n    };\n  }\n\n  public pushUnique(target, method, args, stack): { queue: Queue, target, method } {\n    let localQueueMap = this.targetQueues.get(target);\n\n    if (localQueueMap === undefined) {\n      localQueueMap = new Map();\n      this.targetQueues.set(target, localQueueMap);\n    }\n\n    let index = localQueueMap.get(method);\n    if (index === undefined) {\n      let queueIndex = this._queue.push(target, method, args, stack) - QUEUE_ITEM_LENGTH;\n      localQueueMap.set(method, queueIndex);\n    } else {\n      let queue = this._queue;\n      queue[index + 2] = args;  // replace args\n      queue[index + 3] = stack; // replace stack\n    }\n\n    return {\n      queue: this,\n      target,\n      method\n    };\n  }\n\n  public _getDebugInfo(debugEnabled: boolean): IQueueItem[] | undefined {\n    if (debugEnabled) {\n      let debugInfo: IQueueItem[] = getQueueItems(this._queue, QUEUE_ITEM_LENGTH);\n\n      return debugInfo;\n    }\n\n    return undefined;\n  }\n\n  private invoke(target, method, args /*, onError, errorRecordedForStack */) {\n    if (args === undefined) {\n      method.call(target);\n    } else {\n      method.apply(target, args);\n    }\n  }\n\n  private invokeWithOnError(target, method, args, onError, errorRecordedForStack) {\n    try {\n      if (args === undefined) {\n        method.call(target);\n      } else {\n        method.apply(target, args);\n      }\n    } catch (error) {\n      onError(error, errorRecordedForStack);\n    }\n  }\n}\n","import { IQueueItem } from './interfaces';\nimport Queue, { QUEUE_STATE } from './queue';\n\nexport interface IDebugInfo {\n  [key: string]: IQueueItem[] | undefined;\n}\n\nexport default class DeferredActionQueues {\n  public queues: { [name: string]: Queue } = {};\n  public queueNameIndex = 0;\n\n  private queueNames: string[];\n\n  constructor(queueNames: string[] = [], options: any) {\n    this.queueNames = queueNames;\n\n    queueNames.reduce(function(queues, queueName) {\n      queues[queueName] = new Queue(queueName, options[queueName], options);\n      return queues;\n    }, this.queues);\n  }\n\n  /**\n   * @method schedule\n   * @param {String} queueName\n   * @param {Any} target\n   * @param {Any} method\n   * @param {Any} args\n   * @param {Boolean} onceFlag\n   * @param {Any} stack\n   * @return queue\n   */\n  public schedule(queueName: string, target: any, method: any, args: any, onceFlag: boolean, stack: any) {\n    let queues = this.queues;\n    let queue = queues[queueName];\n\n    if (queue === undefined) {\n      throw new Error(`You attempted to schedule an action in a queue (${queueName}) that doesn\\'t exist`);\n    }\n\n    if (method === undefined || method === null) {\n      throw new Error(`You attempted to schedule an action in a queue (${queueName}) for a method that doesn\\'t exist`);\n    }\n\n    this.queueNameIndex = 0;\n\n    if (onceFlag) {\n      return queue.pushUnique(target, method, args, stack);\n    } else {\n      return queue.push(target, method, args, stack);\n    }\n  }\n\n  /**\n   * DeferredActionQueues.flush() calls Queue.flush()\n   *\n   * @method flush\n   * @param {Boolean} fromAutorun\n   */\n  public flush(fromAutorun = false) {\n    let queue;\n    let queueName;\n    let numberOfQueues = this.queueNames.length;\n\n    while (this.queueNameIndex < numberOfQueues) {\n      queueName = this.queueNames[this.queueNameIndex];\n      queue = this.queues[queueName];\n\n      if (queue.hasWork() === false) {\n        this.queueNameIndex++;\n        if (fromAutorun && this.queueNameIndex < numberOfQueues) {\n          return QUEUE_STATE.Pause;\n        }\n      } else {\n        if (queue.flush(false /* async */) === QUEUE_STATE.Pause) {\n          return QUEUE_STATE.Pause;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns debug information for the current queues.\n   *\n   * @method _getDebugInfo\n   * @param {Boolean} debugEnabled\n   * @returns {IDebugInfo | undefined}\n   */\n  public _getDebugInfo(debugEnabled: boolean): IDebugInfo | undefined {\n    if (debugEnabled) {\n      let debugInfo: IDebugInfo = {};\n      let queue: Queue;\n      let queueName: string;\n      let numberOfQueues: number = this.queueNames.length;\n      let i: number = 0;\n\n      while (i < numberOfQueues) {\n        queueName = this.queueNames[i];\n        queue = this.queues[queueName];\n\n        debugInfo[queueName] = queue._getDebugInfo(debugEnabled);\n        i++;\n      }\n\n      return debugInfo;\n    }\n\n    return;\n  }\n}\n","// accepts a function that when invoked will return an iterator\n// iterator will drain until completion\nexport interface Iterable {\n  next: () => { done: boolean, value?: any };\n}\n\nexport default function(fn: () => Iterable) {\n  let iterator = fn();\n  let result = iterator.next();\n\n  while (result.done === false) {\n    result.value();\n    result = iterator.next();\n  }\n}\n","export {\n  buildPlatform,\n  IPlatform\n} from './backburner/platform';\n\nimport {\n  buildNext,\n  buildPlatform,\n  IPlatform,\n} from './backburner/platform';\nimport {\n  findTimerItem,\n  getOnError,\n  getQueueItems,\n  isCoercableNumber,\n  TIMERS_OFFSET\n} from './backburner/utils';\n\nimport searchTimer from './backburner/binary-search';\n\nimport DeferredActionQueues from './backburner/deferred-action-queues';\nexport type { DeferredActionQueues };\n\nimport iteratorDrain, { Iterable } from './backburner/iterator-drain';\n\n\nimport Queue, { QUEUE_STATE } from './backburner/queue';\n\nexport type Timer = string | number;\n\nconst noop = function() {};\n\nconst DISABLE_SCHEDULE = Object.freeze([]);\n\nfunction parseArgs(...args: any[]);\nfunction parseArgs() {\n  let length = arguments.length;\n\n  let args;\n  let method;\n  let target;\n\n  if (length === 0) {\n  } else if (length === 1) {\n    target = null;\n    method = arguments[0];\n  } else {\n    let argsIndex = 2;\n    let methodOrTarget = arguments[0];\n    let methodOrArgs = arguments[1];\n    let type = typeof methodOrArgs;\n    if (type === 'function') {\n      target = methodOrTarget;\n      method = methodOrArgs;\n    } else if (methodOrTarget !== null && type === 'string' && methodOrArgs in methodOrTarget) {\n      target = methodOrTarget;\n      method = target[methodOrArgs];\n    } else if (typeof methodOrTarget === 'function') {\n      argsIndex = 1;\n      target = null;\n      method = methodOrTarget;\n    }\n\n    if (length > argsIndex) {\n      let len = length - argsIndex;\n      args = new Array(len);\n      for (let i = 0; i < len; i++) {\n        args[i] = arguments[i + argsIndex];\n      }\n    }\n  }\n\n  return [target, method, args];\n}\n\nfunction parseTimerArgs(...args: any[]);\nfunction parseTimerArgs() {\n  let [target, method, args] = parseArgs(...arguments);\n  let wait = 0;\n  let length = args !== undefined ? args.length : 0;\n\n  if (length > 0) {\n    let last = args[length - 1];\n    if (isCoercableNumber(last)) {\n      wait = parseInt(args.pop(), 10);\n    }\n  }\n\n  return [target, method, args, wait];\n}\n\nfunction parseDebounceArgs(...args: any[]);\nfunction parseDebounceArgs() {\n  let target;\n  let method;\n  let isImmediate;\n  let args;\n  let wait;\n\n  if (arguments.length === 2) {\n    method = arguments[0];\n    wait = arguments[1];\n    target = null;\n  } else {\n    [target, method, args] = parseArgs(...arguments);\n\n    if (args === undefined) {\n      wait = 0;\n    } else {\n      wait = args.pop();\n\n      if (!isCoercableNumber(wait)) {\n        isImmediate = wait === true;\n        wait = args.pop();\n      }\n    }\n  }\n\n  wait = parseInt(wait, 10);\n\n  return [target, method, args, wait, isImmediate];\n}\n\nlet UUID = 0;\n\nlet beginCount = 0;\nlet endCount = 0;\nlet beginEventCount = 0;\nlet endEventCount = 0;\nlet runCount = 0;\nlet joinCount = 0;\nlet deferCount = 0;\nlet scheduleCount = 0;\nlet scheduleIterableCount = 0;\nlet deferOnceCount = 0;\nlet scheduleOnceCount = 0;\nlet setTimeoutCount = 0;\nlet laterCount = 0;\nlet throttleCount = 0;\nlet debounceCount = 0;\nlet cancelTimersCount = 0;\nlet cancelCount = 0;\nlet autorunsCreatedCount = 0;\nlet autorunsCompletedCount = 0;\nlet deferredActionQueuesCreatedCount = 0;\nlet nestedDeferredActionQueuesCreated = 0;\n\nexport interface IBackburnerOptions {\n  defaultQueue?: string;\n  onBegin?: (currentInstance: DeferredActionQueues, previousInstance: DeferredActionQueues) => void;\n  onEnd?: (currentInstance: DeferredActionQueues, nextInstance: DeferredActionQueues) => void;\n  onError?: (error: any, errorRecordedForStack?: any) => void;\n  onErrorTarget?: any;\n  onErrorMethod?: string;\n  mustYield?: () => boolean;\n  _buildPlatform?: (flush: () => void) => IPlatform;\n  flush?(queueName: string, flush: () => void): void;\n}\n\nexport default class Backburner {\n  public static Queue = Queue;\n  public static buildPlatform = buildPlatform;\n  public static buildNext = buildNext;\n\n  public DEBUG = false;\n\n  public currentInstance: DeferredActionQueues | null = null;\n\n  public options: IBackburnerOptions;\n\n  public get counters() {\n    return {\n      begin: beginCount,\n      end: endCount,\n      events: {\n        begin: beginEventCount,\n        end: endEventCount,\n      },\n      autoruns: {\n        created: autorunsCreatedCount,\n        completed: autorunsCompletedCount,\n      },\n      run: runCount,\n      join: joinCount,\n      defer: deferCount,\n      schedule: scheduleCount,\n      scheduleIterable: scheduleIterableCount,\n      deferOnce: deferOnceCount,\n      scheduleOnce: scheduleOnceCount,\n      setTimeout: setTimeoutCount,\n      later: laterCount,\n      throttle: throttleCount,\n      debounce: debounceCount,\n      cancelTimers: cancelTimersCount,\n      cancel: cancelCount,\n      loops: {\n        total: deferredActionQueuesCreatedCount,\n        nested: nestedDeferredActionQueuesCreated,\n      },\n    };\n  }\n\n  private _onBegin: (currentInstance: DeferredActionQueues, previousInstance: DeferredActionQueues | null) => void;\n  private _onEnd: (currentInstance: DeferredActionQueues, nextInstance: DeferredActionQueues | null) => void;\n  private queueNames: string[];\n  private instanceStack: DeferredActionQueues[] = [];\n  private _eventCallbacks: {\n    end: Function[];\n    begin: Function[];\n  } = {\n    end: [],\n    begin: []\n  };\n\n  private _timerTimeoutId: number | null = null;\n  private _timers: any[] = [];\n  private _platform: IPlatform;\n\n  private _boundRunExpiredTimers: () => void;\n\n  private _autorun = false;\n  private _autorunStack: Error | undefined | null = null;\n  private _boundAutorunEnd: () => void;\n  private _defaultQueue: string;\n\n  constructor(queueNames: string[], options?: IBackburnerOptions) {\n    this.queueNames = queueNames;\n    this.options = options || {};\n    if (typeof this.options.defaultQueue === 'string') {\n      this._defaultQueue = this.options.defaultQueue;\n    } else {\n      this._defaultQueue = this.queueNames[0];\n    }\n\n    this._onBegin = this.options.onBegin || noop;\n    this._onEnd = this.options.onEnd || noop;\n\n    this._boundRunExpiredTimers = this._runExpiredTimers.bind(this);\n\n    this._boundAutorunEnd = () => {\n      autorunsCompletedCount++;\n\n      // if the autorun was already flushed, do nothing\n      if (this._autorun === false) { return; }\n\n      this._autorun = false;\n      this._autorunStack = null;\n      this._end(true /* fromAutorun */);\n    };\n\n    let builder = this.options._buildPlatform || buildPlatform;\n    this._platform = builder(this._boundAutorunEnd);\n  }\n\n  public get defaultQueue() {\n    return this._defaultQueue;\n  }\n  /*\n    @method begin\n    @return instantiated class DeferredActionQueues\n  */\n  public begin(): DeferredActionQueues {\n    beginCount++;\n    let options = this.options;\n    let previousInstance = this.currentInstance;\n    let current;\n\n    if (this._autorun !== false) {\n      current = previousInstance;\n      this._cancelAutorun();\n    } else {\n      if (previousInstance !== null) {\n        nestedDeferredActionQueuesCreated++;\n        this.instanceStack.push(previousInstance);\n      }\n      deferredActionQueuesCreatedCount++;\n      current = this.currentInstance = new DeferredActionQueues(this.queueNames, options);\n      beginEventCount++;\n      this._trigger('begin', current, previousInstance);\n    }\n\n    this._onBegin(current, previousInstance);\n\n    return current;\n  }\n\n  public end() {\n    endCount++;\n    this._end(false);\n  }\n\n  public on(eventName, callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError(`Callback must be a function`);\n    }\n    let callbacks = this._eventCallbacks[eventName];\n    if (callbacks !== undefined) {\n      callbacks.push(callback);\n    } else {\n      throw new TypeError(`Cannot on() event ${eventName} because it does not exist`);\n    }\n  }\n\n  public off(eventName, callback) {\n    let callbacks = this._eventCallbacks[eventName];\n    if (!eventName || callbacks === undefined) {\n      throw new TypeError(`Cannot off() event ${eventName} because it does not exist`);\n    }\n    let callbackFound = false;\n    if (callback) {\n      for (let i = 0; i < callbacks.length; i++) {\n        if (callbacks[i] === callback) {\n          callbackFound = true;\n          callbacks.splice(i, 1);\n          i--;\n        }\n      }\n    }\n    if (!callbackFound) {\n      throw new TypeError(`Cannot off() callback that does not exist`);\n    }\n  }\n\n  public run(target: Function);\n  public run(target: Function | any | null, method?: Function | string, ...args);\n  public run(target: any | null | undefined, method?: Function, ...args: any[]);\n  public run() {\n    runCount++;\n    let [target, method, args] = parseArgs(...arguments);\n    return this._run(target, method, args);\n  }\n\n  /*\n    Join the passed method with an existing queue and execute immediately,\n    if there isn't one use `Backburner#run`.\n\n    The join method is like the run method except that it will schedule into\n    an existing queue if one already exists. In either case, the join method will\n    immediately execute the passed in function and return its result.\n\n    @method join\n    @param {Object} target\n    @param {Function} method The method to be executed\n    @param {any} args The method arguments\n    @return method result\n  */\n  public join(target: Function);\n  public join(target: Function | any | null, method?: Function | string, ...args);\n  public join(target: any | null | undefined, method?: Function, ...args: any[]);\n  public join() {\n    joinCount++;\n    let [target, method, args] = parseArgs(...arguments);\n    return this._join(target, method, args);\n  }\n\n  /**\n   * @deprecated please use schedule instead.\n   */\n  public defer(queueName, target, method, ...args) {\n    deferCount++;\n    return this.schedule(queueName, target, method, ...args);\n  }\n\n  /**\n   * Schedule the passed function to run inside the specified queue.\n   */\n  public schedule(queueName: string, method: Function);\n  public schedule<T, U extends keyof T>(queueName: string, target: T, method: U, ...args);\n  public schedule(queueName: string, target: any, method: any | Function, ...args);\n  public schedule(queueName, ..._args) {\n    scheduleCount++;\n    let [target, method, args] = parseArgs(..._args);\n    let stack = this.DEBUG ? new Error() : undefined;\n    return this._ensureInstance().schedule(queueName, target, method, args, false, stack);\n  }\n\n  /*\n    Defer the passed iterable of functions to run inside the specified queue.\n\n    @method scheduleIterable\n    @param {String} queueName\n    @param {Iterable} an iterable of functions to execute\n    @return method result\n  */\n  public scheduleIterable(queueName: string, iterable: () => Iterable) {\n    scheduleIterableCount++;\n    let stack = this.DEBUG ? new Error() : undefined;\n    return this._ensureInstance().schedule(queueName, null, iteratorDrain, [iterable], false, stack);\n  }\n\n  /**\n   * @deprecated please use scheduleOnce instead.\n   */\n  public deferOnce(queueName, target, method, ...args) {\n    deferOnceCount++;\n    return this.scheduleOnce(queueName, target, method, ...args);\n  }\n\n  /**\n   * Schedule the passed function to run once inside the specified queue.\n   */\n  public scheduleOnce(queueName: string, method: Function);\n  public scheduleOnce<T, U extends keyof T>(queueName: string, target: T, method: U, ...args);\n  public scheduleOnce(queueName: string, target: any | null, method: any | Function, ...args);\n  public scheduleOnce(queueName, ..._args) {\n    scheduleOnceCount++;\n    let [target, method, args] = parseArgs(..._args);\n    let stack = this.DEBUG ? new Error() : undefined;\n    return this._ensureInstance().schedule(queueName, target, method, args, true, stack);\n  }\n\n  /**\n   * @deprecated use later instead.\n   */\n  public setTimeout(...args);\n  public setTimeout() {\n    setTimeoutCount++;\n    return this.later(...arguments);\n  }\n\n  public later<T>(...args: any[]): Timer; // fixes `this.later(...arguments)` usage in `setTimeout`\n  public later<T>(target: T, methodName: keyof T, wait?: number | string): Timer;\n  public later<T>(target: T, methodName: keyof T, arg1: any, wait?: number | string): Timer;\n  public later<T>(target: T, methodName: keyof T, arg1: any, arg2: any, wait?: number | string): Timer;\n  public later<T>(target: T, methodName: keyof T, arg1: any, arg2: any, arg3: any, wait?: number | string): Timer;\n\n  // with target, with optional immediate\n  public later(thisArg: any | null, method: () => void, wait?: number | string): Timer;\n  public later<A>(thisArg: any | null, method: (arg1: A) => void, arg1: A, wait?: number | string): Timer;\n  public later<A, B>(thisArg: any | null, method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait?: number | string): Timer;\n  public later<A, B, C>(thisArg: any | null, method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait?: number | string): Timer;\n\n  // without target, with optional immediate\n  public later(method: () => void, wait?: number | string): Timer;\n  public later<A>(method: (arg1: A) => void, arg1: A, wait?: number | string): Timer;\n  public later<A, B>(method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait?: number | string): Timer;\n  public later<A, B, C>(method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait?: number | string): Timer;\n  public later() {\n    laterCount++;\n    let [target, method, args, wait] = parseTimerArgs(...arguments);\n    return this._later(target, method, args, wait);\n  }\n\n  public throttle<T>(target: T, methodName: keyof T, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<T>(target: T, methodName: keyof T, arg1: any, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<T>(target: T, methodName: keyof T, arg1: any, arg2: any, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<T>(target: T, methodName: keyof T, arg1: any, arg2: any, arg3: any, wait?: number | string, immediate?: boolean): Timer;\n\n  // with target, with immediate\n  public throttle(thisArg: any | null, method: () => void, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A>(thisArg: any | null, method: (arg1: A) => void, arg1: A, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A, B>(thisArg: any | null, method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A, B, C>(thisArg: any | null, method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait?: number | string, immediate?: boolean): Timer;\n\n  // without target, with immediate\n  public throttle(method: () => void, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A>(method: (arg1: A) => void, arg1: A, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A, B>(method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait?: number | string, immediate?: boolean): Timer;\n  public throttle<A, B, C>(method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait?: number | string, immediate?: boolean): Timer;\n  public throttle(): Timer {\n    throttleCount++;\n    let [target, method, args, wait, isImmediate = true] = parseDebounceArgs(...arguments);\n\n    let index = findTimerItem(target, method, this._timers);\n    let timerId;\n    if (index === -1) {\n      timerId = this._later(target, method, isImmediate ? DISABLE_SCHEDULE : args, wait);\n\n      if (isImmediate) {\n        this._join(target, method, args);\n      }\n    } else {\n      timerId = this._timers[index + 1];\n      let argIndex = index + 4;\n      if (this._timers[argIndex] !== DISABLE_SCHEDULE) {\n        this._timers[argIndex] = args;\n      }\n    }\n\n    return timerId;\n  }\n\n  // with target, with method name, with optional immediate\n  public debounce<T>(target: T, methodName: keyof T, wait: number | string, immediate?: boolean): Timer;\n  public debounce<T>(target: T, methodName: keyof T, arg1: any, wait: number | string, immediate?: boolean): Timer;\n  public debounce<T>(target: T, methodName: keyof T, arg1: any, arg2: any, wait: number | string, immediate?: boolean): Timer;\n  public debounce<T>(target: T, methodName: keyof T, arg1: any, arg2: any, arg3: any, wait: number | string, immediate?: boolean): Timer;\n\n  // with target, with optional immediate\n  public debounce(thisArg: any | null, method: () => void, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A>(thisArg: any | null, method: (arg1: A) => void, arg1: A, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A, B>(thisArg: any | null, method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A, B, C>(thisArg: any | null, method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait: number | string, immediate?: boolean): Timer;\n\n  // without target, with optional immediate\n  public debounce(method: () => void, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A>(method: (arg1: A) => void, arg1: A, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A, B>(method: (arg1: A, arg2: B) => void, arg1: A, arg2: B, wait: number | string, immediate?: boolean): Timer;\n  public debounce<A, B, C>(method: (arg1: A, arg2: B, arg3: C) => void, arg1: A, arg2: B, arg3: C, wait: number | string, immediate?: boolean): Timer;\n  public debounce(): Timer {\n    debounceCount++;\n    let [target, method, args, wait, isImmediate = false] = parseDebounceArgs(...arguments);\n    let _timers = this._timers;\n    let index = findTimerItem(target, method, _timers);\n\n    let timerId;\n    if (index === -1) {\n      timerId = this._later(target, method, isImmediate ? DISABLE_SCHEDULE : args, wait);\n      if (isImmediate) {\n        this._join(target, method, args);\n      }\n    } else {\n      let executeAt = this._platform.now() + wait;\n\n      let argIndex = index + 4;\n      if (_timers[argIndex] === DISABLE_SCHEDULE) {\n        args = DISABLE_SCHEDULE;\n      }\n\n      timerId = _timers[index + 1];\n      let i = searchTimer(executeAt, _timers);\n\n      if ((index + TIMERS_OFFSET) === i) {\n        _timers[index] = executeAt;\n        _timers[argIndex] = args;\n      } else {\n        let stack = this._timers[index + 5];\n        this._timers.splice(i, 0, executeAt, timerId, target, method, args, stack);\n        this._timers.splice(index, TIMERS_OFFSET);\n      }\n\n      if (index === 0) {\n        this._reinstallTimerTimeout();\n      }\n    }\n\n    return timerId;\n  }\n\n  public cancelTimers() {\n    cancelTimersCount++;\n    this._clearTimerTimeout();\n    this._timers = [];\n    this._cancelAutorun();\n  }\n\n  public hasTimers() {\n    return this._timers.length > 0 || this._autorun;\n  }\n\n  public cancel(timer?) {\n    cancelCount++;\n    if (timer === null || timer === undefined) { return false; }\n    let timerType = typeof timer;\n\n    if (timerType === 'number') { // we're cancelling a setTimeout or throttle or debounce\n      return this._cancelLaterTimer(timer);\n    } else if (timerType === 'object' && timer.queue && timer.method) { // we're cancelling a deferOnce\n      return timer.queue.cancel(timer);\n    }\n\n    return false;\n  }\n\n  public ensureInstance() {\n    this._ensureInstance();\n  }\n\n  /**\n   * Returns debug information related to the current instance of Backburner\n   *\n   * @method getDebugInfo\n   * @returns {Object | undefined} Will return and Object containing debug information if\n   * the DEBUG flag is set to true on the current instance of Backburner, else undefined.\n   */\n  public getDebugInfo() {\n    if (this.DEBUG) {\n      return {\n        autorun: this._autorunStack,\n        counters: this.counters,\n        timers: getQueueItems(this._timers, TIMERS_OFFSET, 2),\n        instanceStack: [this.currentInstance, ...this.instanceStack]\n          .map((deferredActionQueue) => deferredActionQueue && deferredActionQueue._getDebugInfo(this.DEBUG))\n      };\n    }\n\n    return undefined;\n  }\n\n  private _end(fromAutorun: boolean) {\n    let currentInstance = this.currentInstance;\n    let nextInstance: DeferredActionQueues | null  = null;\n\n    if (currentInstance === null) {\n      throw new Error(`end called without begin`);\n    }\n\n    // Prevent double-finally bug in Safari 6.0.2 and iOS 6\n    // This bug appears to be resolved in Safari 6.0.5 and iOS 7\n    let finallyAlreadyCalled = false;\n    let result;\n    try {\n      result = currentInstance.flush(fromAutorun);\n    } finally {\n      if (!finallyAlreadyCalled) {\n        finallyAlreadyCalled = true;\n\n        if (result === QUEUE_STATE.Pause) {\n          const plannedNextQueue = this.queueNames[currentInstance.queueNameIndex];\n          this._scheduleAutorun(plannedNextQueue);\n        } else {\n          this.currentInstance = null;\n\n          if (this.instanceStack.length > 0) {\n            nextInstance = this.instanceStack.pop() as DeferredActionQueues;\n            this.currentInstance = nextInstance;\n          }\n          this._trigger('end', currentInstance, nextInstance);\n          this._onEnd(currentInstance, nextInstance);\n        }\n      }\n    }\n  }\n\n  private _join(target, method, args) {\n    if (this.currentInstance === null) {\n      return this._run(target, method, args);\n    }\n\n    if (target === undefined && args === undefined) {\n      return method();\n    } else {\n      return method.apply(target, args);\n    }\n  }\n\n  private _run(target, method, args) {\n    let onError = getOnError(this.options);\n\n    this.begin();\n\n    if (onError) {\n      try {\n        return method.apply(target, args);\n      } catch (error) {\n        onError(error);\n      } finally {\n        this.end();\n      }\n    } else {\n      try {\n        return method.apply(target, args);\n      } finally {\n        this.end();\n      }\n    }\n  }\n\n  private _cancelAutorun() {\n    if (this._autorun) {\n      this._platform.clearNext();\n      this._autorun = false;\n      this._autorunStack = null;\n    }\n  }\n\n  private _later(target, method, args, wait) {\n    let stack = this.DEBUG ? new Error() : undefined;\n    let executeAt = this._platform.now() + wait;\n    let id = UUID++;\n\n    if (this._timers.length === 0) {\n      this._timers.push(executeAt, id, target, method, args, stack);\n      this._installTimerTimeout();\n    } else {\n      // find position to insert\n      let i = searchTimer(executeAt, this._timers);\n      this._timers.splice(i, 0, executeAt, id, target, method, args, stack);\n\n      // always reinstall since it could be out of sync\n      this._reinstallTimerTimeout();\n    }\n    return id;\n  }\n\n  private _cancelLaterTimer(timer) {\n    for (let i = 1; i < this._timers.length; i += TIMERS_OFFSET) {\n      if (this._timers[i] === timer) {\n        this._timers.splice(i - 1, TIMERS_OFFSET);\n        if (i === 1) {\n          this._reinstallTimerTimeout();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   Trigger an event. Supports up to two arguments. Designed around\n   triggering transition events from one run loop instance to the\n   next, which requires an argument for the  instance and then\n   an argument for the next instance.\n\n   @private\n   @method _trigger\n   @param {String} eventName\n   @param {any} arg1\n   @param {any} arg2\n   */\n  private _trigger<T, U>(eventName: string, arg1: T, arg2: U) {\n    let callbacks = this._eventCallbacks[eventName];\n    if (callbacks !== undefined) {\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](arg1, arg2);\n      }\n    }\n  }\n\n  private _runExpiredTimers() {\n    this._timerTimeoutId = null;\n    if (this._timers.length > 0) {\n      this.begin();\n      this._scheduleExpiredTimers();\n      this.end();\n    }\n  }\n\n  private _scheduleExpiredTimers() {\n    let timers = this._timers;\n    let i = 0;\n    let l = timers.length;\n    let defaultQueue = this._defaultQueue;\n    let n = this._platform.now();\n\n    for (; i < l; i += TIMERS_OFFSET) {\n      let executeAt = timers[i];\n      if (executeAt > n) { break; }\n      let args = timers[i + 4];\n      if (args !== DISABLE_SCHEDULE) {\n        let target = timers[i + 2];\n        let method = timers[i + 3];\n        let stack = timers[i + 5];\n        this.currentInstance!.schedule(defaultQueue, target, method, args, false, stack);\n      }\n    }\n\n    timers.splice(0, i);\n    this._installTimerTimeout();\n  }\n\n  private _reinstallTimerTimeout() {\n    this._clearTimerTimeout();\n    this._installTimerTimeout();\n  }\n\n  private _clearTimerTimeout() {\n    if (this._timerTimeoutId === null) { return; }\n    this._platform.clearTimeout(this._timerTimeoutId);\n    this._timerTimeoutId = null;\n  }\n\n  private _installTimerTimeout() {\n    if (this._timers.length === 0) { return; }\n    let minExpiresAt = this._timers[0];\n    let n = this._platform.now();\n    let wait = Math.max(0, minExpiresAt - n);\n    this._timerTimeoutId = this._platform.setTimeout(this._boundRunExpiredTimers, wait);\n  }\n\n  private _ensureInstance(): DeferredActionQueues {\n    let currentInstance = this.currentInstance;\n    if (currentInstance === null) {\n      this._autorunStack = this.DEBUG ? new Error() : undefined;\n      currentInstance = this.begin();\n      this._scheduleAutorun(this.queueNames[0]);\n    }\n    return currentInstance;\n  }\n\n  private _scheduleAutorun(plannedNextQueue: string) {\n    autorunsCreatedCount++;\n\n    const next = this._platform.next;\n    const flush = this.options.flush;\n\n    if (flush) {\n      flush(plannedNextQueue, next);\n    } else {\n      next();\n    }\n\n    this._autorun = true;\n  }\n}\n"],"names":["searchTimer"],"mappings":"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"}