"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionParser = void 0;
const scope_locals_1 = require("./scope-locals");
class ExpressionParser {
    constructor(babel) {
        this.babel = babel;
    }
    parseExpression(invokedName, path) {
        switch (path.node.type) {
            case 'ObjectExpression':
                return this.parseObjectExpression(invokedName, path);
            case 'ArrayExpression': {
                return this.parseArrayExpression(invokedName, path);
            }
            case 'StringLiteral':
            case 'BooleanLiteral':
            case 'NumericLiteral':
                return path.node.value;
            default:
                throw path.buildCodeFrameError(`${invokedName} can only accept static options but you passed ${JSON.stringify(path.node)}`);
        }
    }
    parseArrayExpression(invokedName, path) {
        return path.get('elements').map((element) => {
            if (element.isSpreadElement()) {
                throw element.buildCodeFrameError(`spread element is not allowed here`);
            }
            else if (element.isExpression()) {
                return this.parseExpression(invokedName, element);
            }
        });
    }
    parseScope(invokedName, path) {
        let body = undefined;
        if (path.node.type === 'ObjectMethod') {
            body = path.node.body;
        }
        else {
            let { value } = path.node;
            if (this.t.isObjectExpression(value)) {
                throw path.buildCodeFrameError(`Passing an object as the \`scope\` property to inline templates is no longer supported. Please pass a function that returns an object expression instead.`);
            }
            if (this.t.isFunctionExpression(value) || this.t.isArrowFunctionExpression(value)) {
                body = value.body;
            }
        }
        let objExpression = undefined;
        if ((body === null || body === void 0 ? void 0 : body.type) === 'ObjectExpression') {
            objExpression = body;
        }
        else if ((body === null || body === void 0 ? void 0 : body.type) === 'BlockStatement') {
            // SAFETY: We know that the body is a ReturnStatement because we're checking inside
            let returnStatements = body.body.filter((statement) => statement.type === 'ReturnStatement');
            if (returnStatements.length !== 1) {
                throw new Error('Scope functions must have a single return statement which returns an object expression containing references to in-scope values');
            }
            objExpression = returnStatements[0].argument;
        }
        if ((objExpression === null || objExpression === void 0 ? void 0 : objExpression.type) !== 'ObjectExpression') {
            throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` must be an object expression containing only references to in-scope values, or a function that returns an object expression containing only references to in-scope values`);
        }
        return objExpression.properties.reduce((res, prop) => {
            if (this.t.isSpreadElement(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain spread elements`);
            }
            if (this.t.isObjectMethod(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain methods`);
            }
            let { key, value } = prop;
            if (!this.t.isStringLiteral(key) && !this.t.isIdentifier(key)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain static property names`);
            }
            let propName = name(key);
            if (value.type !== 'Identifier') {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain direct references to in-scope values, e.g. { ${propName} } or { ${propName}: ${propName} }`);
            }
            res.add(propName, value.name);
            return res;
        }, new scope_locals_1.ScopeLocals());
    }
    parseEval(invokedName, path) {
        let body;
        if (path.isObjectMethod()) {
            body = path.get('body');
        }
        else if (path.isObjectProperty()) {
            let value = path.get('value');
            if (value.isFunctionExpression()) {
                body = value.get('body');
            }
            else {
                throw path.buildCodeFrameError(`unsupported syntax for \`eval\` parameter to \`${invokedName}\`. It must be an object method or a function.`);
            }
        }
        else {
            throw path.buildCodeFrameError(`unsupported syntax for \`eval\` parameter to \`${invokedName}\`. It must be an object method or a function.`);
        }
        let returnStatements = body
            .get('body')
            .filter((statement) => statement.isReturnStatement());
        if (returnStatements.length !== 1) {
            throw body.buildCodeFrameError('eval function must have a single return statement');
        }
        let returnExpression = returnStatements[0].get('argument');
        if (!returnExpression.isCallExpression()) {
            throw returnStatements[0].buildCodeFrameError('eval function must return `eval(arguments[0])`. Found non-CallExpression.');
        }
        let callee = returnExpression.get('callee');
        if (!callee.isIdentifier() || callee.node.name !== 'eval') {
            throw returnExpression.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found callee is not eval.');
        }
        let args = returnExpression.get('arguments');
        if (args.length !== 1) {
            throw returnExpression.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found incorrect number of arguments.');
        }
        let arg = args[0];
        if (!arg.isMemberExpression()) {
            throw arg.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found argument is non-MemberExpression.');
        }
        let obj = arg.get('object');
        if (!obj.isIdentifier() || obj.node.name !== 'arguments') {
            throw obj.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found wrong argument to eval.');
        }
        let prop = arg.get('property');
        if (!prop.isNumericLiteral() || prop.node.value !== 0) {
            throw prop.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found wrong property.');
        }
        return { isEval: true };
    }
    parseObjectExpression(invokedName, path, shouldParseScope = false, shouldSupportRFC931 = false) {
        let result = {};
        path.get('properties').forEach((property) => {
            let { node } = property;
            if (this.t.isSpreadElement(node)) {
                throw property.buildCodeFrameError(`${invokedName} does not allow spread element`);
            }
            if (node.computed) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let { key } = node;
            if (!this.t.isIdentifier(key) && !this.t.isStringLiteral(key)) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let propertyName = name(key);
            if (shouldParseScope && propertyName === 'scope') {
                result.scope = this.parseScope(invokedName, property);
            }
            else if (shouldSupportRFC931 && propertyName === 'eval') {
                result.eval = this.parseEval(invokedName, property);
            }
            else if (shouldSupportRFC931 && propertyName === 'component') {
                result.component = property.get('value');
            }
            else {
                if (this.t.isObjectMethod(node)) {
                    throw property.buildCodeFrameError(`${invokedName} does not accept a method for ${propertyName}`);
                }
                let valuePath = property.get('value');
                if (!valuePath.isExpression()) {
                    throw valuePath.buildCodeFrameError(`must be an expression`);
                }
                result[propertyName] = this.parseExpression(invokedName, valuePath);
            }
        });
        return result;
    }
    get t() {
        return this.babel.types;
    }
}
exports.ExpressionParser = ExpressionParser;
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHByZXNzaW9uLXBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxpREFBNkM7QUFFN0MsTUFBYSxnQkFBZ0I7SUFDM0IsWUFBb0IsS0FBbUI7UUFBbkIsVUFBSyxHQUFMLEtBQUssQ0FBYztJQUFHLENBQUM7SUFFM0MsZUFBZSxDQUFDLFdBQW1CLEVBQUUsSUFBNEI7UUFDL0QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN0QixLQUFLLGtCQUFrQjtnQkFDckIsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxFQUFFLElBQW9DLENBQUMsQ0FBQztZQUN2RixLQUFLLGlCQUFpQixDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxJQUFtQyxDQUFDLENBQUM7YUFDcEY7WUFDRCxLQUFLLGVBQWUsQ0FBQztZQUNyQixLQUFLLGdCQUFnQixDQUFDO1lBQ3RCLEtBQUssZ0JBQWdCO2dCQUNuQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3pCO2dCQUNFLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUM1QixHQUFHLFdBQVcsa0RBQWtELElBQUksQ0FBQyxTQUFTLENBQzVFLElBQUksQ0FBQyxJQUFJLENBQ1YsRUFBRSxDQUNKLENBQUM7U0FDTDtJQUNILENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxXQUFtQixFQUFFLElBQWlDO1FBQ3pFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMxQyxJQUFJLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRTtnQkFDN0IsTUFBTSxPQUFPLENBQUMsbUJBQW1CLENBQUMsb0NBQW9DLENBQUMsQ0FBQzthQUN6RTtpQkFBTSxJQUFJLE9BQU8s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QUM7UUFFSCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsSUFBWSxDQUFDO1FBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUMxQixDQUFDO0NBQ0Y7QUF2T0QsNENBdU9DO0FBRUQsU0FBUyxJQUFJLENBQUMsSUFBb0M7SUFDaEQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBRTtRQUNqQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWJlbDogdHlwZW9mIEJhYmVsKSB7fVxuXG4gIHBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZTogc3RyaW5nLCBwYXRoOiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+KTogdW5rbm93biB7XG4gICAgc3dpdGNoIChwYXRoLm5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0RXhwcmVzc2lvbihpbnZva2VkTmFtZSwgcGF0aCBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+KTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUV4cHJlc3Npb24oaW52b2tlZE5hbWUsIHBhdGggYXMgTm9kZVBhdGg8dC5BcnJheUV4cHJlc3Npb24+KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtZXJpY0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gcGF0aC5ub2RlLnZhbHVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGAke2ludm9rZWROYW1lfSBjYW4gb25seSBhY2NlcHQgc3RhdGljIG9wdGlvbnMgYnV0IHlvdSBwYXNzZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHBhdGgubm9kZVxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQXJyYXlFeHByZXNzaW9uKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuQXJyYXlFeHByZXNzaW9uPikge1xuICAgIHJldHVybiBwYXRoLmdldCgnZWxlbWVudHMnKS5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmlzU3ByZWFkRWxlbWVudCgpKSB7XG4gICAgICAgIHRocm93IGVsZW1lbnQuYnVpbGRDb2RlRnJhbWVFcnJvcihgc3ByZWFkIGVsZW1lbnQgaXMgbm90IGFsbG93ZWQgaGVyZWApO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVNjb3BlKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHkgfCB0Lk9iamVjdE1ldGhvZD4pOiBTY29wZUxvY2FscyB7XG4gICAgbGV0IGJvZHk6IHQuQmxvY2tTdGF0ZW1lbnQgfCB0LkV4cHJlc3Npb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocGF0aC5ub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHZhbHVlIH0gPSBwYXRoLm5vZGU7XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGBQYXNzaW5nIGFuIG9iamVjdCBhcyB0aGUgXFxgc2NvcGVcXGAgcHJvcGVydHkgdG8gaW5saW5lIHRlbXBsYXRlcyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnQuaXNGdW5jdGlvbkV4cHJlc3Npb24odmFsdWUpIHx8IHRoaXMudC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICBib2R5ID0gdmFsdWUuYm9keTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb2JqRXhwcmVzc2lvbjogdC5FeHByZXNzaW9uIHwgdW5kZWZpbmVkIHwgbnVsbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChib2R5Py50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgIG9iakV4cHJlc3Npb24gPSBib2R5O1xuICAgIH0gZWxzZSBpZiAoYm9keT8udHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgLy8gU0FGRVRZOiBXZSBrbm93IHRoYXQgdGhlIGJvZHkgaXMgYSBSZXR1cm5TdGF0ZW1lbnQgYmVjYXVzZSB3ZSdyZSBjaGVja2luZyBpbnNpZGVcbiAgICAgIGxldCByZXR1cm5TdGF0ZW1lbnRzID0gYm9keS5ib2R5LmZpbHRlcihcbiAgICAgICAgKHN0YXRlbWVudCkgPT4gc3RhdGVtZW50LnR5cGUgPT09ICdSZXR1cm5TdGF0ZW1lbnQnXG4gICAgICApIGFzIEJhYmVsLnR5cGVzLlJldHVyblN0YXRlbWVudFtdO1xuXG4gICAgICBpZiAocmV0dXJuU3RhdGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTY29wZSBmdW5jdGlvbnMgbXVzdCBoYXZlIGEgc2luZ2xlIHJldHVybiBzdGF0ZW1lbnQgd2hpY2ggcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBjb250YWluaW5nIHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvYmpFeHByZXNzaW9uID0gcmV0dXJuU3RhdGVtZW50c1swXS5hcmd1bWVudDtcbiAgICB9XG5cbiAgICBpZiAob2JqRXhwcmVzc2lvbj8udHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgIGBTY29wZSBvYmplY3RzIGZvciBcXGAke2ludm9rZWROYW1lfVxcYCBtdXN0IGJlIGFuIG9iamVjdCBleHByZXNzaW9uIGNvbnRhaW5pbmcgb25seSByZWZlcmVuY2VzIHRvIGluLXNjb3BlIHZhbHVlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IGV4cHJlc3Npb24gY29udGFpbmluZyBvbmx5IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLnJlZHVjZSgocmVzLCBwcm9wKSA9PiB7XG4gICAgICBpZiAodGhpcy50LmlzU3ByZWFkRWxlbWVudChwcm9wKSkge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBub3QgY29udGFpbiBzcHJlYWQgZWxlbWVudHNgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0TWV0aG9kKHByb3ApKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG5vdCBjb250YWluIG1ldGhvZHNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHByb3A7XG4gICAgICBpZiAoIXRoaXMudC5pc1N0cmluZ0xpdGVyYWwoa2V5KSAmJiAhdGhpcy50LmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG9ubHkgY29udGFpbiBzdGF0aWMgcHJvcGVydHkgbmFtZXNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcm9wTmFtZSA9IG5hbWUoa2V5KTtcblxuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBvbmx5IGNvbnRhaW4gZGlyZWN0IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzLCBlLmcuIHsgJHtwcm9wTmFtZX0gfSBvciB7ICR7cHJvcE5hbWV9OiAke3Byb3BOYW1lfSB9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXMuYWRkKHByb3BOYW1lLCB2YWx1ZS5uYW1lKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbmV3IFNjb3BlTG9jYWxzKCkpO1xuICB9XG5cbiAgcGFyc2VFdmFsKFxuICAgIGludm9rZWROYW1lOiBzdHJpbmcsXG4gICAgcGF0aDogTm9kZVBhdGg8dC5PYmplY3RQcm9wZXJ0eSB8IHQuT2JqZWN0TWV0aG9kPlxuICApOiB7IGlzRXZhbDogdHJ1ZSB9IHtcbiAgICBsZXQgYm9keTogTm9kZVBhdGg8dC5CbG9ja1N0YXRlbWVudD47XG5cbiAgICBpZiAocGF0aC5pc09iamVjdE1ldGhvZCgpKSB7XG4gICAgICBib2R5ID0gcGF0aC5nZXQoJ2JvZHknKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNPYmplY3RQcm9wZXJ0eSgpKSB7XG4gICAgICBsZXQgdmFsdWUgPSBwYXRoLmdldCgndmFsdWUnKTtcbiAgICAgIGlmICh2YWx1ZS5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIGJvZHkgPSB2YWx1ZS5nZXQoJ2JvZHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgdW5zdXBwb3J0ZWQgc3ludGF4IGZvciBcXGBldmFsXFxgIHBhcmFtZXRlciB0byBcXGAke2ludm9rZWROYW1lfVxcYC4gSXQgbXVzdCBiZSBhbiBvYmplY3QgbWV0aG9kIG9yIGEgZnVuY3Rpb24uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgIGB1bnN1cHBvcnRlZCBzeW50YXggZm9yIFxcYGV2YWxcXGAgcGFyYW1ldGVyIHRvIFxcYCR7aW52b2tlZE5hbWV9XFxgLiBJdCBtdXN0IGJlIGFuIG9iamVjdCBtZXRob2Qgb3IgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCByZXR1cm5TdGF0ZW1lbnRzID0gYm9keVxuICAgICAgLmdldCgnYm9keScpXG4gICAgICAuZmlsdGVyKChzdGF0ZW1lbnQpID0+IHN0YXRlbWVudC5pc1JldHVyblN0YXRlbWVudCgpKSBhcyBOb2RlUGF0aDx0LlJldHVyblN0YXRlbWVudD5bXTtcblxuICAgIGlmIChyZXR1cm5TdGF0ZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgYm9keS5idWlsZENvZGVGcmFtZUVycm9yKCdldmFsIGZ1bmN0aW9uIG11c3QgaGF2ZSBhIHNpbmdsZSByZXR1cm4gc3RhdGVtZW50Jyk7XG4gICAgfVxuXG4gICAgbGV0IHJldHVybkV4cHJlc3Npb24gPSByZXR1cm5TdGF0ZW1lbnRzWzBdLmdldCgnYXJndW1lbnQnKTtcblxuICAgIGlmICghcmV0dXJuRXhwcmVzc2lvbi5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IHJldHVyblN0YXRlbWVudHNbMF0uYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgJ2V2YWwgZnVuY3Rpb24gbXVzdCByZXR1cm4gYGV2YWwoYXJndW1lbnRzWzBdKWAuIEZvdW5kIG5vbi1DYWxsRXhwcmVzc2lvbi4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWUgPSByZXR1cm5FeHByZXNzaW9uLmdldCgnY2FsbGVlJyk7XG4gICAgaWYgKCFjYWxsZWUuaXNJZGVudGlmaWVyKCkgfHwgY2FsbGVlLm5vZGUubmFtZSAhPT0gJ2V2YWwnKSB7XG4gICAgICB0aHJvdyByZXR1cm5FeHByZXNzaW9uLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICdldmFsIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBldmFsKGFyZ3VtZW50c1swXSlgLiBGb3VuZCBjYWxsZWUgaXMgbm90IGV2YWwuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgYXJncyA9IHJldHVybkV4cHJlc3Npb24uZ2V0KCdhcmd1bWVudHMnKTtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IHJldHVybkV4cHJlc3Npb24uYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgJ2V2YWwgZnVuY3Rpb24gbXVzdCByZXR1cm4gYGV2YWwoYXJndW1lbnRzWzBdKWAuIEZvdW5kIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzLidcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBhcmcgPSBhcmdzWzBdO1xuICAgIGlmICghYXJnLmlzTWVtYmVyRXhwcmVzc2lvbigpKSB7XG4gICAgICB0aHJvdyBhcmcuYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgJ2V2YWwgZnVuY3Rpb24gbXVzdCByZXR1cm4gYGV2YWwoYXJndW1lbnRzWzBdKWAuIEZvdW5kIGFyZ3VtZW50IGlzIG5vbi1NZW1iZXJFeHByZXNzaW9uLidcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBvYmogPSBhcmcuZ2V0KCdvYmplY3QnKTtcbiAgICBpZiAoIW9iai5pc0lkZW50aWZpZXIoKSB8fCBvYmoubm9kZS5uYW1lICE9PSAnYXJndW1lbnRzJykge1xuICAgICAgdGhyb3cgb2JqLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICdldmFsIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBldmFsKGFyZ3VtZW50c1swXSlgLiBGb3VuZCB3cm9uZyBhcmd1bWVudCB0byBldmFsLidcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBwcm9wID0gYXJnLmdldCgncHJvcGVydHknKTtcbiAgICBpZiAoIXByb3AuaXNOdW1lcmljTGl0ZXJhbCgpIHx8IHByb3Aubm9kZS52YWx1ZSAhPT0gMCkge1xuICAgICAgdGhyb3cgcHJvcC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAnZXZhbCBmdW5jdGlvbiBtdXN0IHJldHVybiBgZXZhbChhcmd1bWVudHNbMF0pYC4gRm91bmQgd3JvbmcgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNFdmFsOiB0cnVlIH07XG4gIH1cblxuICBwYXJzZU9iamVjdEV4cHJlc3Npb24oXG4gICAgaW52b2tlZE5hbWU6IHN0cmluZyxcbiAgICBwYXRoOiBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+LFxuICAgIHNob3VsZFBhcnNlU2NvcGUgPSBmYWxzZSxcbiAgICBzaG91bGRTdXBwb3J0UkZDOTMxID0gZmFsc2VcbiAgKSB7XG4gICAgbGV0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcblxuICAgIHBhdGguZ2V0KCdwcm9wZXJ0aWVzJykuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgIGxldCB7IG5vZGUgfSA9IHByb3BlcnR5O1xuICAgICAgaWYgKHRoaXMudC5pc1NwcmVhZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgcHJvcGVydHkuYnVpbGRDb2RlRnJhbWVFcnJvcihgJHtpbnZva2VkTmFtZX0gZG9lcyBub3QgYWxsb3cgc3ByZWFkIGVsZW1lbnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgdGhyb3cgcHJvcGVydHkuYnVpbGRDb2RlRnJhbWVFcnJvcihgJHtpbnZva2VkTmFtZX0gY2FuIG9ubHkgYWNjZXB0IHN0YXRpYyBwcm9wZXJ0eSBuYW1lc2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgeyBrZXkgfSA9IG5vZGU7XG4gICAgICBpZiAoIXRoaXMudC5pc0lkZW50aWZpZXIoa2V5KSAmJiAhdGhpcy50LmlzU3RyaW5nTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgIHRocm93IHByb3BlcnR5LmJ1aWxkQ29kZUZyYW1lRXJyb3IoYCR7aW52b2tlZE5hbWV9IGNhbiBvbmx5IGFjY2VwdCBzdGF0aWMgcHJvcGVydHkgbmFtZXNgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHByb3BlcnR5TmFtZSA9IG5hbWUoa2V5KTtcblxuICAgICAgaWYgKHNob3VsZFBhcnNlU2NvcGUgJiYgcHJvcGVydHlOYW1lID09PSAnc2NvcGUnKSB7XG4gICAgICAgIHJlc3VsdC5zY29wZSA9IHRoaXMucGFyc2VTY29wZShpbnZva2VkTmFtZSwgcHJvcGVydHkgYXMgTm9kZVBhdGg8dHlwZW9mIG5vZGU+KTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU3VwcG9ydFJGQzkzMSAmJiBwcm9wZXJ0eU5hbWUgPT09ICdldmFsJykge1xuICAgICAgICByZXN1bHQuZXZhbCA9IHRoaXMucGFyc2VFdmFsKGludm9rZWROYW1lLCBwcm9wZXJ0eSBhcyBOb2RlUGF0aDx0eXBlb2Ygbm9kZT4pO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRTdXBwb3J0UkZDOTMxICYmIHByb3BlcnR5TmFtZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgcmVzdWx0LmNvbXBvbmVudCA9IChwcm9wZXJ0eSBhcyBOb2RlUGF0aDx0eXBlb2Ygbm9kZT4pLmdldCgndmFsdWUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnQuaXNPYmplY3RNZXRob2Qobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBwcm9wZXJ0eS5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgYCR7aW52b2tlZE5hbWV9IGRvZXMgbm90IGFjY2VwdCBhIG1ldGhvZCBmb3IgJHtwcm9wZXJ0eU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlUGF0aCA9IChwcm9wZXJ0eSBhcyBOb2RlUGF0aDx0eXBlb2Ygbm9kZT4pLmdldCgndmFsdWUnKTtcbiAgICAgICAgaWYgKCF2YWx1ZVBhdGguaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICB0aHJvdyB2YWx1ZVBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihgbXVzdCBiZSBhbiBleHByZXNzaW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZSwgdmFsdWVQYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGdldCB0KCkge1xuICAgIHJldHVybiB0aGlzLmJhYmVsLnR5cGVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5hbWUobm9kZTogdC5TdHJpbmdMaXRlcmFsIHwgdC5JZGVudGlmaWVyKTogc3RyaW5nIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxufVxuIl19