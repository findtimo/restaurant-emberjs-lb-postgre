"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JSUtils_instances, _JSUtils_babel, _JSUtils_state, _JSUtils_template, _JSUtils_scopeLocals, _JSUtils_importer, _JSUtils_emitStatement, _JSUtils_parseExpression, _ExpressionContext_importer, _ExpressionContext_target;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSUtils = void 0;
// This exists to give AST plugins a controlled interface for influencing the
// surrounding Javascript scope
class JSUtils {
    constructor(babel, state, template, 
    // mapping of handlebars identifiers to javascript identifiers, as appears
    // in the `scope` argument to precompileTemplate. This is both read and
    // write -- we might put more stuff into it.
    scopeLocals, importer) {
        _JSUtils_instances.add(this);
        _JSUtils_babel.set(this, void 0);
        _JSUtils_state.set(this, void 0);
        _JSUtils_template.set(this, void 0);
        _JSUtils_scopeLocals.set(this, void 0);
        _JSUtils_importer.set(this, void 0);
        __classPrivateFieldSet(this, _JSUtils_babel, babel, "f");
        __classPrivateFieldSet(this, _JSUtils_state, state, "f");
        __classPrivateFieldSet(this, _JSUtils_template, template, "f");
        __classPrivateFieldSet(this, _JSUtils_scopeLocals, scopeLocals, "f");
        __classPrivateFieldSet(this, _JSUtils_importer, importer, "f");
        if (!__classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath) {
            let target;
            for (let statement of __classPrivateFieldGet(this, _JSUtils_state, "f").program.get('body')) {
                if (!statement.isImportDeclaration()) {
                    break;
                }
                target = statement;
            }
            if (target) {
                __classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath = target;
            }
        }
    }
    /**
     * Create a new binding that you can use in your template, initialized with
     * the given Javascript expression.
     *
     * @param { Expression } expression A javascript expression whose value will
     * initialize your new binding. See docs on the Expression type for details.
     * @param target The location within your template where the binding will be
     * used. This matters so we can avoid naming collisions.
     * @param opts.nameHint Optionally, provide a descriptive name for your new
     * binding. We will mangle this name as needed to avoid collisions, but
     * picking a good name here can aid in debugging.
     *
     * @return The name you can use in your template to access the binding.
     */
    bindExpression(expression, target, opts) {
        var _a;
        let name = unusedNameLike((_a = opts === null || opts === void 0 ? void 0 : opts.nameHint) !== null && _a !== void 0 ? _a : 'a', (candidate) => __classPrivateFieldGet(this, _JSUtils_template, "f").scope.hasBinding(candidate) ||
            __classPrivateFieldGet(this, _JSUtils_scopeLocals, "f").has(candidate) ||
            astNodeHasBinding(target, candidate));
        let t = __classPrivateFieldGet(this, _JSUtils_babel, "f").types;
        let declaration = __classPrivateFieldGet(this, _JSUtils_instances, "m", _JSUtils_emitStatement).call(this, t.variableDeclaration('let', [
            t.variableDeclarator(t.identifier(name), __classPrivateFieldGet(this, _JSUtils_instances, "m", _JSUtils_parseExpression).call(this, __classPrivateFieldGet(this, _JSUtils_state, "f").program, expression)),
        ]));
        declaration.scope.registerBinding('module', declaration.get('declarations.0'));
        __classPrivateFieldGet(this, _JSUtils_scopeLocals, "f").add(name);
        return name;
    }
    /**
     * Gain access to an imported value within your template.
     *
     * @param moduleSpecifier The path to import from.
     * @param exportedName The named export you wish to access, or "default" for
     * the default export, or "*" for the namespace export.
     * @param target The location within your template where the binding will be
     * used. This matters so we can avoid naming collisions.
     * @param opts.nameHint Optionally, provide a descriptive name for your new
     * binding. We will mangle this name as needed to avoid collisions, but
     * picking a good name here can aid in debugging.
     *
     * @return The name you can use in your template to access the imported value.
     */
    bindImport(moduleSpecifier, exportedName, target, opts) {
        // This will discover or create the local name for accessing the given import.
        let importedIdentifier = __classPrivateFieldGet(this, _JSUtils_importer, "f").import(__classPrivateFieldGet(this, _JSUtils_template, "f"), moduleSpecifier, exportedName, opts === null || opts === void 0 ? void 0 : opts.nameHint);
        // If we're already referencing the imported name from the outer scope and
        // it's not shadowed at our target location in the template, we can reuse
        // the existing import.
        if (__classPrivateFieldGet(this, _JSUtils_scopeLocals, "f").has(importedIdentifier.name) &&
            !astNodeHasBinding(target, importedIdentifier.name)) {
            return importedIdentifier.name;
        }
        let identifier = unusedNameLike(importedIdentifier.name, (candidate) => __classPrivateFieldGet(this, _JSUtils_scopeLocals, "f").has(candidate) || astNodeHasBinding(target, candidate));
        if (identifier !== importedIdentifier.name) {
            // The importedIdentifier that we have in Javascript is not usable within
            // our HBS because it's shadowed by a block param. So we will introduce a
            // second name via a variable declaration.
            //
            // The reason we don't force the import itself to have this name is that
            // we might be re-using an existing import, and we don't want to go
            // rewriting all of its callsites that are unrelated to us.
            let t = __classPrivateFieldGet(this, _JSUtils_babel, "f").types;
            __classPrivateFieldGet(this, _JSUtils_instances, "m", _JSUtils_emitStatement).call(this, t.variableDeclaration('let', [
                t.variableDeclarator(t.identifier(identifier), importedIdentifier),
            ]));
        }
        __classPrivateFieldGet(this, _JSUtils_scopeLocals, "f").add(identifier);
        return identifier;
    }
    /**
     * Add an import statement purely for side effect.
     *
     * @param moduleSpecifier the module to import
     */
    importForSideEffect(moduleSpecifier) {
        __classPrivateFieldGet(this, _JSUtils_importer, "f").importForSideEffect(moduleSpecifier);
    }
    /**
     * Emit a javascript expresison for side-effect. This only accepts
     * expressions, not statements, because you should not introduce new bindings.
     * To introduce a binding see bindExpression or bindImport instead.
     *
     * @param { Expression } expression A javascript expression whose value will
     * initialize your new binding. See docs on the Expression type below for
     * details.
     */
    emitExpression(expression) {
        let t = __classPrivateFieldGet(this, _JSUtils_babel, "f").types;
        __classPrivateFieldGet(this, _JSUtils_instances, "m", _JSUtils_emitStatement).call(this, t.expressionStatement(__classPrivateFieldGet(this, _JSUtils_instances, "m", _JSUtils_parseExpression).call(this, __classPrivateFieldGet(this, _JSUtils_state, "f").program, expression)));
    }
}
exports.JSUtils = JSUtils;
_JSUtils_babel = new WeakMap(), _JSUtils_state = new WeakMap(), _JSUtils_template = new WeakMap(), _JSUtils_scopeLocals = new WeakMap(), _JSUtils_importer = new WeakMap(), _JSUtils_instances = new WeakSet(), _JSUtils_emitStatement = function _JSUtils_emitStatement(statement) {
    if (__classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath) {
        __classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath = __classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath.insertAfter(statement)[0];
    }
    else {
        __classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath = __classPrivateFieldGet(this, _JSUtils_state, "f").program.unshiftContainer('body', statement)[0];
    }
    return __classPrivateFieldGet(this, _JSUtils_state, "f").lastInsertedPath;
}, _JSUtils_parseExpression = function _JSUtils_parseExpression(target, expression) {
    let expressionString;
    if (typeof expression === 'string') {
        expressionString = expression;
    }
    else {
        expressionString = expression(new ExpressionContext(__classPrivateFieldGet(this, _JSUtils_importer, "f"), target));
    }
    let parsed = __classPrivateFieldGet(this, _JSUtils_babel, "f").parse(expressionString);
    if (!parsed) {
        throw new Error(`JSUtils.bindExpression could not understand the expression: ${expressionString}`);
    }
    let statements = body(parsed);
    if (statements.length !== 1) {
        throw new Error(`JSUtils.bindExpression expected to find exactly one expression but found ${statements.length} in: ${expressionString}`);
    }
    let statement = statements[0];
    if (statement.type !== 'ExpressionStatement') {
        throw new Error(`JSUtils.bindExpression expected to find an expression but found ${statement.type} in: ${expressionString}`);
    }
    return statement.expression;
};
function unusedNameLike(desiredName, isUsed) {
    let candidate = desiredName;
    let counter = 0;
    while (isUsed(candidate)) {
        candidate = `${desiredName}${counter++}`;
    }
    return candidate;
}
function astNodeHasBinding(target, name) {
    var _a;
    let cursor = target;
    while (cursor) {
        let parentNode = (_a = cursor.parent) === null || _a === void 0 ? void 0 : _a.node;
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === 'ElementNode' &&
            parentNode.blockParams.includes(name) &&
            // an ElementNode's block params are valid only within its children
            parentNode.children.includes(cursor.node)) {
            return true;
        }
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === 'Block' &&
            parentNode.blockParams.includes(name) &&
            // a Block's blockParams are valid only within its body
            parentNode.body.includes(cursor.node)) {
            return true;
        }
        cursor = cursor.parent;
    }
    return false;
}
function body(node) {
    if (node.type === 'File') {
        return node.program.body;
    }
    else {
        return node.body;
    }
}
/**
 * Allows you to construct an expression that relies on imported values.
 */
class ExpressionContext {
    constructor(importer, target) {
        _ExpressionContext_importer.set(this, void 0);
        _ExpressionContext_target.set(this, void 0);
        __classPrivateFieldSet(this, _ExpressionContext_importer, importer, "f");
        __classPrivateFieldSet(this, _ExpressionContext_target, target, "f");
    }
    /**
     * Find or create a local binding for the given import.
     *
     * @param moduleSpecifier The path to import from.
     * @param exportedName The named export you wish to access, or "default" for
     * the default export, or "*" for the namespace export.
     * @param nameHint Optionally, provide a descriptive name for your new
     * binding. We will mangle this name as needed to avoid collisions, but
     * picking a good name here can aid in debugging.
  
     * @return the local identifier for the imported value
     */
    import(moduleSpecifier, exportedName, nameHint) {
        return __classPrivateFieldGet(this, _ExpressionContext_importer, "f").import(__classPrivateFieldGet(this, _ExpressionContext_target, "f"), moduleSpecifier, exportedName, nameHint).name;
    }
}
_ExpressionContext_importer = new WeakMap(), _ExpressionContext_target = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJqcy11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFZQSw2RUFBNkU7QUFDN0UsK0JBQStCO0FBQy9CLE1BQWEsT0FBTztJQU9sQixZQUNFLEtBQW1CLEVBQ25CLEtBQVksRUFDWixRQUFnQztJQUNoQywwRUFBMEU7SUFDMUUsdUVBQXVFO0lBQ3ZFLDRDQUE0QztJQUM1QyxXQUF3QixFQUN4QixRQUFvQjs7UUFkdEIsaUNBQXFCO1FBQ3JCLGlDQUFjO1FBQ2Qsb0NBQWtDO1FBQ2xDLHVDQUEwQjtRQUMxQixvQ0FBc0I7UUFZcEIsdUJBQUEsSUFBSSxrQkFBVSxLQUFLLE1BQUEsQ0FBQztRQUNwQix1QkFBQSxJQUFJLGtCQUFVLEtBQUssTUFBQSxDQUFDO1FBQ3BCLHVCQUFBLElBQUkscUJBQWEsUUFBUSxNQUFBLENBQUM7UUFDMUIsdUJBQUEsSUFBSSx3QkFBZ0IsV0FBVyxNQUFBLENBQUM7UUFDaEMsdUJBQUEsSUFBSSxxQkFBYSxRQUFRLE1BQUEsQ0FBQztRQUUxQixJQUFJLENBQUMsdUJBQUEsSUFBSSxzQkFBTyxDQUFDLGdCQUFnQixFQUFFO1lBQ2pDLElBQUksTUFBeUMsQ0FBQztZQUM5QyxLQUFLLElBQUksU0FBUyxJQUFJLHVCQUFBLElBQUksc0JBQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNyRCxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixFQUFFLEVBQUU7b0JBQ3BDLE1BQU07aUJBQ1A7Z0JBQ0QsTUFBTSxHQUFHLFNBQVMsQ0FBQzthQUNwQjtZQUNELElBQUksTUFBTSxFQUFFO2dCQUNWLHVCQUFBLElBQUksc0JBQU8sQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7YUFDdkM7U0FDRjtJQUNILENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsY0FBYyxDQUNaLFVBQXNCLEVBQ3RC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Ozs7Ozs7OztPQVdHO0lBQ0gsTUFBTSxDQUFDLGVBQXVCLEVBQUUsWUFBb0IsRUFBRSxRQUFpQjtRQUNyRSxPQUFPLHVCQUFBLElBQUksbUNBQVUsQ0FBQyxNQUFNLENBQUMsdUJBQUEsSUFBSSxpQ0FBUSxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzNGLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgdHlwZXMgYXMgdCB9IGZyb20gJ0BiYWJlbC9jb3JlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC90cmF2ZXJzZSc7XG5pbXBvcnQgdHlwZSB7IEFTVFBsdWdpbkJ1aWxkZXIsIEFTVFBsdWdpbkVudmlyb25tZW50LCBBU1R2MSwgV2Fsa2VyUGF0aCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgdHlwZSB7IEltcG9ydFV0aWwgfSBmcm9tICdiYWJlbC1pbXBvcnQtdXRpbCc7XG5pbXBvcnQgeyBTY29wZUxvY2FscyB9IGZyb20gJy4vc2NvcGUtbG9jYWxzJztcblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgcHJvZ3JhbTogTm9kZVBhdGg8QmFiZWwudHlwZXMuUHJvZ3JhbT47XG4gIGxhc3RJbnNlcnRlZFBhdGg6IE5vZGVQYXRoPEJhYmVsLnR5cGVzLlN0YXRlbWVudD4gfCB1bmRlZmluZWQ7XG59XG5cbi8vIFRoaXMgZXhpc3RzIHRvIGdpdmUgQVNUIHBsdWdpbnMgYSBjb250cm9sbGVkIGludGVyZmFjZSBmb3IgaW5mbHVlbmNpbmcgdGhlXG4vLyBzdXJyb3VuZGluZyBKYXZhc2NyaXB0IHNjb3BlXG5leHBvcnQgY2xhc3MgSlNVdGlscyB7XG4gICNiYWJlbDogdHlwZW9mIEJhYmVsO1xuICAjc3RhdGU6IFN0YXRlO1xuICAjdGVtcGxhdGU6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj47XG4gICNzY29wZUxvY2FsczogU2NvcGVMb2NhbHM7XG4gICNpbXBvcnRlcjogSW1wb3J0VXRpbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICAgIHN0YXRlOiBTdGF0ZSxcbiAgICB0ZW1wbGF0ZTogTm9kZVBhdGg8dC5FeHByZXNzaW9uPixcbiAgICAvLyBtYXBwaW5nIG9mIGhhbmRsZWJhcnMgaWRlbnRpZmllcnMgdG8gamF2YXNjcmlwdCBpZGVudGlmaWVycywgYXMgYXBwZWFyc1xuICAgIC8vIGluIHRoZSBgc2NvcGVgIGFyZ3VtZW50IHRvIHByZWNvbXBpbGVUZW1wbGF0ZS4gVGhpcyBpcyBib3RoIHJlYWQgYW5kXG4gICAgLy8gd3JpdGUgLS0gd2UgbWlnaHQgcHV0IG1vcmUgc3R1ZmYgaW50byBpdC5cbiAgICBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMsXG4gICAgaW1wb3J0ZXI6IEltcG9ydFV0aWxcbiAgKSB7XG4gICAgdGhpcy4jYmFiZWwgPSBiYWJlbDtcbiAgICB0aGlzLiNzdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuI3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy4jc2NvcGVMb2NhbHMgPSBzY29wZUxvY2FscztcbiAgICB0aGlzLiNpbXBvcnRlciA9IGltcG9ydGVyO1xuXG4gICAgaWYgKCF0aGlzLiNzdGF0ZS5sYXN0SW5zZXJ0ZWRQYXRoKSB7XG4gICAgICBsZXQgdGFyZ2V0OiBOb2RlUGF0aDx0LlN0YXRlbWVudD4gfCB1bmRlZmluZWQ7XG4gICAgICBmb3IgKGxldCBzdGF0ZW1lbnQgb2YgdGhpcy4jc3RhdGUucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgICBpZiAoIXN0YXRlbWVudC5pc0ltcG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSBzdGF0ZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuI3N0YXRlLmxhc3RJbnNlcnRlZFBhdGggPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBiaW5kaW5nIHRoYXQgeW91IGNhbiB1c2UgaW4geW91ciB0ZW1wbGF0ZSwgaW5pdGlhbGl6ZWQgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyBFeHByZXNzaW9uIH0gZXhwcmVzc2lvbiBBIGphdmFzY3JpcHQgZXhwcmVzc2lvbiB3aG9zZSB2YWx1ZSB3aWxsXG4gICAqIGluaXRpYWxpemUgeW91ciBuZXcgYmluZGluZy4gU2VlIGRvY3Mgb24gdGhlIEV4cHJlc3Npb24gdHlwZSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHRhcmdldCBUaGUgbG9jYXRpb24gd2l0aGluIHlvdXIgdGVtcGxhdGUgd2hlcmUgdGhlIGJpbmRpbmcgd2lsbCBiZVxuICAgKiB1c2VkLiBUaGlzIG1hdHRlcnMgc28gd2UgY2FuIGF2b2lkIG5hbWluZyBjb2xsaXNpb25zLlxuICAgKiBAcGFyYW0gb3B0cy5uYW1lSGludCBPcHRpb25hbGx5LCBwcm92aWRlIGEgZGVzY3JpcHRpdmUgbmFtZSBmb3IgeW91ciBuZXdcbiAgICogYmluZGluZy4gV2Ugd2lsbCBtYW5nbGUgdGhpcyBuYW1lIGFzIG5lZWRlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBidXRcbiAgICogcGlja2luZyBhIGdvb2QgbmFtZSBoZXJlIGNhbiBhaWQgaW4gZGVidWdnaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIFRoZSBuYW1lIHlvdSBjYW4gdXNlIGluIHlvdXIgdGVtcGxhdGUgdG8gYWNjZXNzIHRoZSBiaW5kaW5nLlxuICAgKi9cbiAgYmluZEV4cHJlc3Npb24oXG4gICAgZXhwcmVzc2lvbjogRXhwcmVzc2lvbixcbiAgICB0YXJnZXQ6IFdhbGtlclBhdGg8QVNUdjEuTm9kZT4sXG4gICAgb3B0cz86IHsgbmFtZUhpbnQ/OiBzdHJpbmcgfVxuICApOiBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gdW51c2VkTmFtZUxpa2UoXG4gICAgICBvcHRzPy5uYW1lSGludCA/PyAnYScsXG4gICAgICAoY2FuZGlkYXRlKSA9PlxuICAgICAgICB0aGlzLiN0ZW1wbGF0ZS5zY29wZS5oYXNCaW5kaW5nKGNhbmRpZGF0ZSkgfHxcbiAgICAgICAgdGhpcy4jc2NvcGVMb2NhbHMuaGFzKGNhbmRpZGF0ZSkgfHxcbiAgICAgICAgYXN0Tm9kZUhhc0JpbmRpbmcodGFyZ2V0LCBjYW5kaWRhdGUpXG4gICAgKTtcbiAgICBsZXQgdCA9IHRoaXMuI2JhYmVsLnR5cGVzO1xuICAgIGxldCBkZWNsYXJhdGlvbjogTm9kZVBhdGg8dC5WYXJpYWJsZURlY2xhcmF0aW9uPiA9IHRoaXMuI2VtaXRTdGF0ZW1lbnQoXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRpb24oJ2xldCcsIFtcbiAgICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoXG4gICAgICAgICAgdC5pZGVudGlmaWVyKG5hbWUpLFxuICAgICAgICAgIHRoaXMuI3BhcnNlRXhwcmVzc2lvbih0aGlzLiNzdGF0ZS5wcm9ncmFtLCBleHByZXNzaW9uKVxuICAgICAgICApLFxuICAgICAgXSlcbiAgICApO1xuICAgIGRlY2xhcmF0aW9uLnNjb3BlLnJlZ2lzdGVyQmluZGluZygnbW9kdWxlJywgZGVjbGFyYXRpb24uZ2V0KCdkZWNsYXJhdGlvbnMuMCcpIGFzIE5vZGVQYXRoKTtcbiAgICB0aGlzLiNzY29wZUxvY2Fscy5hZGQobmFtZSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICAjZW1pdFN0YXRlbWVudDxUIGV4dGVuZHMgdC5TdGF0ZW1lbnQ+KHN0YXRlbWVudDogVCk6IE5vZGVQYXRoPFQ+IHtcbiAgICBpZiAodGhpcy4jc3RhdGUubGFzdEluc2VydGVkUGF0aCkge1xuICAgICAgdGhpcy4jc3RhdGUubGFzdEluc2VydGVkUGF0aCA9IHRoaXMuI3N0YXRlLmxhc3RJbnNlcnRlZFBhdGguaW5zZXJ0QWZ0ZXIoc3RhdGVtZW50KVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jc3RhdGUubGFzdEluc2VydGVkUGF0aCA9IHRoaXMuI3N0YXRlLnByb2dyYW0udW5zaGlmdENvbnRhaW5lcignYm9keScsIHN0YXRlbWVudClbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5sYXN0SW5zZXJ0ZWRQYXRoIGFzIE5vZGVQYXRoPFQ+O1xuICB9XG5cbiAgLyoqXG4gICAqIEdhaW4gYWNjZXNzIHRvIGFuIGltcG9ydGVkIHZhbHVlIHdpdGhpbiB5b3VyIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlU3BlY2lmaWVyIFRoZSBwYXRoIHRvIGltcG9ydCBmcm9tLlxuICAgKiBAcGFyYW0gZXhwb3J0ZWROYW1lIFRoZSBuYW1lZCBleHBvcnQgeW91IHdpc2ggdG8gYWNjZXNzLCBvciBcImRlZmF1bHRcIiBmb3JcbiAgICogdGhlIGRlZmF1bHQgZXhwb3J0LCBvciBcIipcIiBmb3IgdGhlIG5hbWVzcGFjZSBleHBvcnQuXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIGxvY2F0aW9uIHdpdGhpbiB5b3VyIHRlbXBsYXRlIHdoZXJlIHRoZSBiaW5kaW5nIHdpbGwgYmVcbiAgICogdXNlZC4gVGhpcyBtYXR0ZXJzIHNvIHdlIGNhbiBhdm9pZCBuYW1pbmcgY29sbGlzaW9ucy5cbiAgICogQHBhcmFtIG9wdHMubmFtZUhpbnQgT3B0aW9uYWxseSwgcHJvdmlkZSBhIGRlc2NyaXB0aXZlIG5hbWUgZm9yIHlvdXIgbmV3XG4gICAqIGJpbmRpbmcuIFdlIHdpbGwgbWFuZ2xlIHRoaXMgbmFtZSBhcyBuZWVkZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgYnV0XG4gICAqIHBpY2tpbmcgYSBnb29kIG5hbWUgaGVyZSBjYW4gYWlkIGluIGRlYnVnZ2luZy5cbiAgICpcbiAgICogQHJldHVybiBUaGUgbmFtZSB5b3UgY2FuIHVzZSBpbiB5b3VyIHRlbXBsYXRlIHRvIGFjY2VzcyB0aGUgaW1wb3J0ZWQgdmFsdWUuXG4gICAqL1xuICBiaW5kSW1wb3J0KFxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuICAgIGV4cG9ydGVkTmFtZTogc3RyaW5nLFxuICAgIHRhcmdldDogV2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPixcbiAgICBvcHRzPzogeyBuYW1lSGludD86IHN0cmluZyB9XG4gICk6IHN0cmluZyB7XG4gICAgLy8gVGhpcyB3aWxsIGRpc2NvdmVyIG9yIGNyZWF0ZSB0aGUgbG9jYWwgbmFtZSBmb3IgYWNjZXNzaW5nIHRoZSBnaXZlbiBpbXBvcnQuXG4gICAgbGV0IGltcG9ydGVkSWRlbnRpZmllciA9IHRoaXMuI2ltcG9ydGVyLmltcG9ydChcbiAgICAgIHRoaXMuI3RlbXBsYXRlLFxuICAgICAgbW9kdWxlU3BlY2lmaWVyLFxuICAgICAgZXhwb3J0ZWROYW1lLFxuICAgICAgb3B0cz8ubmFtZUhpbnRcbiAgICApO1xuXG4gICAgLy8gSWYgd2UncmUgYWxyZWFkeSByZWZlcmVuY2luZyB0aGUgaW1wb3J0ZWQgbmFtZSBmcm9tIHRoZSBvdXRlciBzY29wZSBhbmRcbiAgICAvLyBpdCdzIG5vdCBzaGFkb3dlZCBhdCBvdXIgdGFyZ2V0IGxvY2F0aW9uIGluIHRoZSB0ZW1wbGF0ZSwgd2UgY2FuIHJldXNlXG4gICAgLy8gdGhlIGV4aXN0aW5nIGltcG9ydC5cbiAgICBpZiAoXG4gICAgICB0aGlzLiNzY29wZUxvY2Fscy5oYXMoaW1wb3J0ZWRJZGVudGlmaWVyLm5hbWUpICYmXG4gICAgICAhYXN0Tm9kZUhhc0JpbmRpbmcodGFyZ2V0LCBpbXBvcnRlZElkZW50aWZpZXIubmFtZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBpbXBvcnRlZElkZW50aWZpZXIubmFtZTtcbiAgICB9XG5cbiAgICBsZXQgaWRlbnRpZmllciA9IHVudXNlZE5hbWVMaWtlKFxuICAgICAgaW1wb3J0ZWRJZGVudGlmaWVyLm5hbWUsXG4gICAgICAoY2FuZGlkYXRlKSA9PiB0aGlzLiNzY29wZUxvY2Fscy5oYXMoY2FuZGlkYXRlKSB8fCBhc3ROb2RlSGFzQmluZGluZyh0YXJnZXQsIGNhbmRpZGF0ZSlcbiAgICApO1xuICAgIGlmIChpZGVudGlmaWVyICE9PSBpbXBvcnRlZElkZW50aWZpZXIubmFtZSkge1xuICAgICAgLy8gVGhlIGltcG9ydGVkSWRlbnRpZmllciB0aGF0IHdlIGhhdmUgaW4gSmF2YXNjcmlwdCBpcyBub3QgdXNhYmxlIHdpdGhpblxuICAgICAgLy8gb3VyIEhCUyBiZWNhdXNlIGl0J3Mgc2hhZG93ZWQgYnkgYSBibG9jayBwYXJhbS4gU28gd2Ugd2lsbCBpbnRyb2R1Y2UgYVxuICAgICAgLy8gc2Vjb25kIG5hbWUgdmlhIGEgdmFyaWFibGUgZGVjbGFyYXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHJlYXNvbiB3ZSBkb24ndCBmb3JjZSB0aGUgaW1wb3J0IGl0c2VsZiB0byBoYXZlIHRoaXMgbmFtZSBpcyB0aGF0XG4gICAgICAvLyB3ZSBtaWdodCBiZSByZS11c2luZyBhbiBleGlzdGluZyBpbXBvcnQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGdvXG4gICAgICAvLyByZXdyaXRpbmcgYWxsIG9mIGl0cyBjYWxsc2l0ZXMgdGhhdCBhcmUgdW5yZWxhdGVkIHRvIHVzLlxuICAgICAgbGV0IHQgPSB0aGlzLiNiYWJlbC50eXBlcztcbiAgICAgIHRoaXMuI2VtaXRTdGF0ZW1lbnQoXG4gICAgICAgIHQudmFyaWFibGVEZWNsYXJhdGlvbignbGV0JywgW1xuICAgICAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKHQuaWRlbnRpZmllcihpZGVudGlmaWVyKSwgaW1wb3J0ZWRJZGVudGlmaWVyKSxcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuI3Njb3BlTG9jYWxzLmFkZChpZGVudGlmaWVyKTtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW1wb3J0IHN0YXRlbWVudCBwdXJlbHkgZm9yIHNpZGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlU3BlY2lmaWVyIHRoZSBtb2R1bGUgdG8gaW1wb3J0XG4gICAqL1xuICBpbXBvcnRGb3JTaWRlRWZmZWN0KG1vZHVsZVNwZWNpZmllcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy4jaW1wb3J0ZXIuaW1wb3J0Rm9yU2lkZUVmZmVjdChtb2R1bGVTcGVjaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBqYXZhc2NyaXB0IGV4cHJlc2lzb24gZm9yIHNpZGUtZWZmZWN0LiBUaGlzIG9ubHkgYWNjZXB0c1xuICAgKiBleHByZXNzaW9ucywgbm90IHN0YXRlbWVudHMsIGJlY2F1c2UgeW91IHNob3VsZCBub3QgaW50cm9kdWNlIG5ldyBiaW5kaW5ncy5cbiAgICogVG8gaW50cm9kdWNlIGEgYmluZGluZyBzZWUgYmluZEV4cHJlc3Npb24gb3IgYmluZEltcG9ydCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0geyBFeHByZXNzaW9uIH0gZXhwcmVzc2lvbiBBIGphdmFzY3JpcHQgZXhwcmVzc2lvbiB3aG9zZSB2YWx1ZSB3aWxsXG4gICAqIGluaXRpYWxpemUgeW91ciBuZXcgYmluZGluZy4gU2VlIGRvY3Mgb24gdGhlIEV4cHJlc3Npb24gdHlwZSBiZWxvdyBmb3JcbiAgICogZGV0YWlscy5cbiAgICovXG4gIGVtaXRFeHByZXNzaW9uKGV4cHJlc3Npb246IEV4cHJlc3Npb24pOiB2b2lkIHtcbiAgICBsZXQgdCA9IHRoaXMuI2JhYmVsLnR5cGVzO1xuICAgIHRoaXMuI2VtaXRTdGF0ZW1lbnQoXG4gICAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcy4jcGFyc2VFeHByZXNzaW9uKHRoaXMuI3N0YXRlLnByb2dyYW0sIGV4cHJlc3Npb24pKVxuICAgICk7XG4gIH1cblxuICAjcGFyc2VFeHByZXNzaW9uKHRhcmdldDogTm9kZVBhdGg8dC5Ob2RlPiwgZXhwcmVzc2lvbjogRXhwcmVzc2lvbik6IHQuRXhwcmVzc2lvbiB7XG4gICAgbGV0IGV4cHJlc3Npb25TdHJpbmc6IHN0cmluZztcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwcmVzc2lvblN0cmluZyA9IGV4cHJlc3Npb24obmV3IEV4cHJlc3Npb25Db250ZXh0KHRoaXMuI2ltcG9ydGVyLCB0YXJnZXQpKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gdGhpcy4jYmFiZWwucGFyc2UoZXhwcmVzc2lvblN0cmluZyk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEpTVXRpbHMuYmluZEV4cHJlc3Npb24gY291bGQgbm90IHVuZGVyc3RhbmQgdGhlIGV4cHJlc3Npb246ICR7ZXhwcmVzc2lvblN0cmluZ31gXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgc3RhdGVtZW50cyA9IGJvZHkocGFyc2VkKTtcbiAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEpTVXRpbHMuYmluZEV4cHJlc3Npb24gZXhwZWN0ZWQgdG8gZmluZCBleGFjdGx5IG9uZSBleHByZXNzaW9uIGJ1dCBmb3VuZCAke3N0YXRlbWVudHMubGVuZ3RofSBpbjogJHtleHByZXNzaW9uU3RyaW5nfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzWzBdO1xuICAgIGlmIChzdGF0ZW1lbnQudHlwZSAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBKU1V0aWxzLmJpbmRFeHByZXNzaW9uIGV4cGVjdGVkIHRvIGZpbmQgYW4gZXhwcmVzc2lvbiBidXQgZm91bmQgJHtzdGF0ZW1lbnQudHlwZX0gaW46ICR7ZXhwcmVzc2lvblN0cmluZ31gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50LmV4cHJlc3Npb247XG4gIH1cbn1cblxuZnVuY3Rpb24gdW51c2VkTmFtZUxpa2UoZGVzaXJlZE5hbWU6IHN0cmluZywgaXNVc2VkOiAobmFtZTogc3RyaW5nKSA9PiBib29sZWFuKTogc3RyaW5nIHtcbiAgbGV0IGNhbmRpZGF0ZSA9IGRlc2lyZWROYW1lO1xuICBsZXQgY291bnRlciA9IDA7XG4gIHdoaWxlIChpc1VzZWQoY2FuZGlkYXRlKSkge1xuICAgIGNhbmRpZGF0ZSA9IGAke2Rlc2lyZWROYW1lfSR7Y291bnRlcisrfWA7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXN0Tm9kZUhhc0JpbmRpbmcodGFyZ2V0OiBXYWxrZXJQYXRoPEFTVHYxLk5vZGU+LCBuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgbGV0IGN1cnNvcjogV2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPiB8IG51bGwgPSB0YXJnZXQ7XG4gIHdoaWxlIChjdXJzb3IpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IGN1cnNvci5wYXJlbnQ/Lm5vZGU7XG4gICAgaWYgKFxuICAgICAgcGFyZW50Tm9kZT8udHlwZSA9PT0gJ0VsZW1lbnROb2RlJyAmJlxuICAgICAgcGFyZW50Tm9kZS5ibG9ja1BhcmFtcy5pbmNsdWRlcyhuYW1lKSAmJlxuICAgICAgLy8gYW4gRWxlbWVudE5vZGUncyBibG9jayBwYXJhbXMgYXJlIHZhbGlkIG9ubHkgd2l0aGluIGl0cyBjaGlsZHJlblxuICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhjdXJzb3Iubm9kZSBhcyBBU1R2MS5TdGF0ZW1lbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwYXJlbnROb2RlPy50eXBlID09PSAnQmxvY2snICYmXG4gICAgICBwYXJlbnROb2RlLmJsb2NrUGFyYW1zLmluY2x1ZGVzKG5hbWUpICYmXG4gICAgICAvLyBhIEJsb2NrJ3MgYmxvY2tQYXJhbXMgYXJlIHZhbGlkIG9ubHkgd2l0aGluIGl0cyBib2R5XG4gICAgICBwYXJlbnROb2RlLmJvZHkuaW5jbHVkZXMoY3Vyc29yLm5vZGUgYXMgQVNUdjEuU3RhdGVtZW50KVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhpcyBleHRlbmRzIEdsaW1tZXIncyBBU1RQbHVnaW5FbnZpcm9ubWVudCB0eXBlIHRvIHB1dCBvdXIganN1dGlscyBpbnRvIG1ldGFcbiAqL1xuZXhwb3J0IHR5cGUgV2l0aEpTVXRpbHM8VCBleHRlbmRzIHsgbWV0YT86IG9iamVjdCB9PiA9IHtcbiAgbWV0YTogVFsnbWV0YSddICYgeyBqc3V0aWxzOiBKU1V0aWxzIH07XG59ICYgVDtcblxuZXhwb3J0IHR5cGUgRXh0ZW5kZWRQbHVnaW5CdWlsZGVyID0gQVNUUGx1Z2luQnVpbGRlcjxXaXRoSlNVdGlsczxBU1RQbHVnaW5FbnZpcm9ubWVudD4+O1xuXG5mdW5jdGlvbiBib2R5KG5vZGU6IHQuUHJvZ3JhbSB8IHQuRmlsZSkge1xuICBpZiAobm9kZS50eXBlID09PSAnRmlsZScpIHtcbiAgICByZXR1cm4gbm9kZS5wcm9ncmFtLmJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgfVxufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gY29uc3RydWN0IGFuIGV4cHJlc3Npb24gdGhhdCByZWxpZXMgb24gaW1wb3J0ZWQgdmFsdWVzLlxuICovXG5jbGFzcyBFeHByZXNzaW9uQ29udGV4dCB7XG4gICNpbXBvcnRlcjogSW1wb3J0VXRpbDtcbiAgI3RhcmdldDogTm9kZVBhdGg8dC5Ob2RlPjtcblxuICBjb25zdHJ1Y3RvcihpbXBvcnRlcjogSW1wb3J0VXRpbCwgdGFyZ2V0OiBOb2RlUGF0aDx0Lk5vZGU+KSB7XG4gICAgdGhpcy4jaW1wb3J0ZXIgPSBpbXBvcnRlcjtcbiAgICB0aGlzLiN0YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBvciBjcmVhdGUgYSBsb2NhbCBiaW5kaW5nIGZvciB0aGUgZ2l2ZW4gaW1wb3J0LlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlU3BlY2lmaWVyIFRoZSBwYXRoIHRvIGltcG9ydCBmcm9tLlxuICAgKiBAcGFyYW0gZXhwb3J0ZWROYW1lIFRoZSBuYW1lZCBleHBvcnQgeW91IHdpc2ggdG8gYWNjZXNzLCBvciBcImRlZmF1bHRcIiBmb3JcbiAgICogdGhlIGRlZmF1bHQgZXhwb3J0LCBvciBcIipcIiBmb3IgdGhlIG5hbWVzcGFjZSBleHBvcnQuXG4gICAqIEBwYXJhbSBuYW1lSGludCBPcHRpb25hbGx5LCBwcm92aWRlIGEgZGVzY3JpcHRpdmUgbmFtZSBmb3IgeW91ciBuZXdcbiAgICogYmluZGluZy4gV2Ugd2lsbCBtYW5nbGUgdGhpcyBuYW1lIGFzIG5lZWRlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBidXRcbiAgICogcGlja2luZyBhIGdvb2QgbmFtZSBoZXJlIGNhbiBhaWQgaW4gZGVidWdnaW5nLlxuXG4gICAqIEByZXR1cm4gdGhlIGxvY2FsIGlkZW50aWZpZXIgZm9yIHRoZSBpbXBvcnRlZCB2YWx1ZVxuICAgKi9cbiAgaW1wb3J0KG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLCBleHBvcnRlZE5hbWU6IHN0cmluZywgbmFtZUhpbnQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLiNpbXBvcnRlci5pbXBvcnQodGhpcy4jdGFyZ2V0LCBtb2R1bGVTcGVjaWZpZXIsIGV4cG9ydGVkTmFtZSwgbmFtZUhpbnQpLm5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBZb3UgY2FuIHBhc3MgYSBKYXZhc2NyaXB0IGV4cHJlc3Npb24gYXMgYSBzdHJpbmcgbGlrZTpcbiAqXG4gKiAgIFwibmV3IERhdGUoKVwiXG4gKlxuICogT3IgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmc6XG4gKlxuICogICAoKSA9PiBcIm5ldyBEYXRlKClcIlxuICpcbiAqIFdoZW4geW91IHVzZSBhIGZ1bmN0aW9uLCBpdCBjYW4gdXNlIGltcG9ydGVkIHZhbHVlczpcbiAqXG4gKiAgIChjb250ZXh0KSA9PiBgbmV3ICR7Y29udGV4dC5pbXBvcnQoXCJsdXhvblwiLCBcIkRhdGVUaW1lXCIpfSgpYFxuICpcbiAqL1xuZXhwb3J0IHR5cGUgRXhwcmVzc2lvbiA9IHN0cmluZyB8ICgoY29udGV4dDogRXhwcmVzc2lvbkNvbnRleHQpID0+IHN0cmluZyk7XG4iXX0=