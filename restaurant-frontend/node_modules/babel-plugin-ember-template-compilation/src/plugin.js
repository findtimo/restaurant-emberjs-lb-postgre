"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        return {
            pre(file) {
                // Remember the available set of imported names very early here in <pre>
                // so that when other plugins (particularly
                // @babel/plugin-transform-typescript) drop "unused" imports in their
                // own Program.enter we still know about them. If we want to use them
                // from inside a template, they weren't really unused and we can ensure
                // they continue to exist.
                this.originalImportedNames = new Map();
                for (let statement of file.ast.program.body) {
                    if (statement.type === 'ImportDeclaration') {
                        for (let specifier of statement.specifiers) {
                            this.originalImportedNames.set(specifier.local.name, [
                                statement.source.value,
                                importedName(specifier),
                            ]);
                        }
                    }
                }
            },
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(t, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, templateContent) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return discoverLocals(templateContent);
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals();
    }
}
function discoverLocals(templateContent) {
    // this is wrong, but the right thing is unreleased in
    // https://github.com/glimmerjs/glimmer-vm/pull/1421, so for the moment I'm
    // sticking with the exact behavior that ember-templates-imports has.
    //
    // (the reason it's wrong is that the correct answer depends on not just the
    // template, but the ambient javascript scope. Anything in locals needs to win
    // over ember keywords. Otherwise we can never introduce new keywords.)
    let scopeLocals = new scope_locals_1.ScopeLocals();
    for (let local of (0, syntax_1.getTemplateLocals)(templateContent)) {
        if (local.match(/^[$A-Z_][0-9A-Z_$]*$/i)) {
            scopeLocals.add(local);
        }
    }
    return scopeLocals;
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope, state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: state.normalizedOpts.transforms,
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
// if scope has different keys and values, this function will remap the keys to the values
// you can see an example of this in the test "correctly handles scope if it contains keys and values"
function remapIdentifiers(ast, babel, scopeLocals) {
    if (!scopeLocals.needsRemapping()) {
        // do nothing if all keys are the same as their values
        return;
    }
    babel.traverse(ast, {
        Identifier(path) {
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // replace the path only if the key is different from the value
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
        },
    });
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    var _a;
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, template);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString}; `, {
        babelrc: false,
        configFile: false,
    });
    ensureImportedNames(target, scopeLocals, state.util, state.originalImportedNames);
    remapIdentifiers(precompileResultAST, babel, scopeLocals);
    let templateExpression = precompileResultAST.program.body[0]
        .declarations[0].init;
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    let templateFactoryIdentifier = state.util.import(target, state.templateFactory.moduleName, state.templateFactory.exportName);
    let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
    if (config.rfc931Support) {
        expression = t.callExpression(state.util.import(target, '@ember/component', 'setComponentTemplate'), [
            expression,
            (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(state.util.import(target, '@ember/component/template-only', 'default', 'templateOnly'), []),
        ]);
    }
    target.replaceWith(expression);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    var _a;
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, template);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        target.get('arguments.0').replaceWith(t.stringLiteral(transformed));
        if (!scopeLocals.isEmpty()) {
            if (!formatOptions.enableScope) {
                maybePruneImport(state.util, target.get('callee'));
                target.set('callee', precompileTemplate(state.util, target));
            }
            ensureImportedNames(target, scopeLocals, state.util, state.originalImportedNames);
            updateScope(babel, target, scopeLocals);
        }
        if (formatOptions.rfc931Support === 'polyfilled') {
            maybePruneImport(state.util, target.get('callee'));
            target.set('callee', precompileTemplate(state.util, target));
            convertStrictMode(babel, target);
            removeEvalAndScope(target);
            target.node.arguments = target.node.arguments.slice(0, 2);
            state.recursionGuard.add(target.node);
            target.replaceWith(t.callExpression(state.util.import(target, '@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(state.util.import(target, '@ember/component/template-only', 'default', 'templateOnly'), []),
            ]));
        }
    }
    else {
        if (!scopeLocals.isEmpty()) {
            // need to add scope, so need to replace the backticks form with a call
            // expression to precompileTemplate
            maybePruneImport(state.util, target.get('tag'));
            let newCall = target.replaceWith(t.callExpression(precompileTemplate(state.util, target), [t.stringLiteral(transformed)]))[0];
            ensureImportedNames(newCall, scopeLocals, state.util, state.originalImportedNames);
            updateScope(babel, newCall, scopeLocals);
        }
        else {
            target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        }
    }
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            scope.set('value', buildScope(babel, locals));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    // this checks if the identifier (that we're about to remove) is used in
    // exactly one place.
    if ((binding === null || binding === void 0 ? void 0 : binding.referencePaths.reduce((count, path) => (path.removed ? count : count + 1), 0)) === 1) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
    identifier.removed = true;
}
function precompileTemplate(util, target) {
    return util.import(target, '@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
function ensureImportedNames(target, scopeLocals, util, originalImportedNames) {
    for (let [nameInTemplate, identifier] of scopeLocals.entries()) {
        if (!target.scope.getBinding(identifier)) {
            let available = originalImportedNames.get(identifier);
            if (available) {
                let newIdent = util.import(target, available[0], available[1], identifier);
                scopeLocals.add(nameInTemplate, newIdent.name);
            }
        }
    }
}
function importedName(node) {
    if (node.type === 'ImportDefaultSpecifier') {
        return 'default';
    }
    else if (node.type === 'ImportNamespaceSpecifier') {
        return '*';
    }
    else {
        return name(node.imported);
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EseURBQStDO0FBQy9DLDJEQUF1RDtBQUN2RCx5Q0FBNEQ7QUFHNUQsaURBQTZDO0FBQzdDLDRDQUF5RjtBQUV6RixpREFBK0I7QUFZL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDBCQUEwQjtRQUN0QyxNQUFNLEVBQUUsVUFBVTtRQUNsQixXQUFXLEVBQUUsSUFBSTtRQUNqQixhQUFhLEVBQUUsWUFBWTtLQUM1QjtDQUNGLENBQUM7QUErREYsU0FBUyxhQUFhLENBQUMsT0FBZ0I7O0lBQ3JDLElBQUksQ0FBQyxNQUFBLE9BQU8sQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUMvQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFDRCxxQ0FDRSxxQkFBcUIsRUFBRSxFQUFFLEVBQ3pCLG1CQUFtQixFQUFFLEVBQUUsRUFDdkIsVUFBVSxF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SSxDQUFDLElBQUksS0FBSyx3QkFBd0IsRUFBRTtRQUMxQyxPQUFPLFNBQVMsQ0FBQztLQUNsQjtTQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSywwQkFBMEIsRUFBRTtRQUNuRCxPQUFPLEdBQUcsQ0FBQztLQUNaO1NBQU07UUFDTCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDNUI7QUFDSCxDQUFDO0FBRUQsa0JBQWUsVUFBVSxDQUFVLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgKiBhcyBCYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgdHlwZSB7IHR5cGVzIGFzIHQgfSBmcm9tICdAYmFiZWwvY29yZSc7XG5pbXBvcnQgeyBJbXBvcnRVdGlsIH0gZnJvbSAnYmFiZWwtaW1wb3J0LXV0aWwnO1xuaW1wb3J0IHsgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gJy4vZXhwcmVzc2lvbi1wYXJzZXInO1xuaW1wb3J0IHsgSlNVdGlscywgRXh0ZW5kZWRQbHVnaW5CdWlsZGVyIH0gZnJvbSAnLi9qcy11dGlscyc7XG5pbXBvcnQgdHlwZSB7IEVtYmVyVGVtcGxhdGVDb21waWxlciwgUHJlcHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL2VtYmVyLXRlbXBsYXRlLWNvbXBpbGVyJztcbmltcG9ydCB7IExlZ2FjeU1vZHVsZU5hbWUgfSBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5pbXBvcnQgeyBTY29wZUxvY2FscyB9IGZyb20gJy4vc2NvcGUtbG9jYWxzJztcbmltcG9ydCB7IEFTVFBsdWdpbkJ1aWxkZXIsIGdldFRlbXBsYXRlTG9jYWxzLCBwcmVwcm9jZXNzLCBwcmludCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vcHVibGljLXR5cGVzJztcblxudHlwZSBNb2R1bGVOYW1lID0gTGVnYWN5TW9kdWxlTmFtZSB8ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nIHwgJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcic7XG5cbmludGVyZmFjZSBNb2R1bGVDb25maWcge1xuICBtb2R1bGVOYW1lOiBNb2R1bGVOYW1lO1xuICBleHBvcnQ6IHN0cmluZztcbiAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw/OiB0cnVlO1xuICBlbmFibGVTY29wZT86IHRydWU7XG4gIHJmYzkzMVN1cHBvcnQ/OiAncG9seWZpbGxlZCc7XG59XG5cbmNvbnN0IElOTElORV9QUkVDT01QSUxFX01PRFVMRVM6IE1vZHVsZUNvbmZpZ1tdID0gW1xuICB7XG4gICAgbW9kdWxlTmFtZTogJ2VtYmVyLWNsaS1odG1sYmFycycsXG4gICAgZXhwb3J0OiAnaGJzJyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdlbWJlci1jbGktaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ2h0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJyxcbiAgICBleHBvcnQ6ICdkZWZhdWx0JyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nLFxuICAgIGV4cG9ydDogJ3ByZWNvbXBpbGVUZW1wbGF0ZScsXG4gICAgZW5hYmxlU2NvcGU6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJyxcbiAgICBleHBvcnQ6ICd0ZW1wbGF0ZScsXG4gICAgZW5hYmxlU2NvcGU6IHRydWUsXG4gICAgcmZjOTMxU3VwcG9ydDogJ3BvbHlmaWxsZWQnLFxuICB9LFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgLy8gVGhlIGVtYmVyLXRlbXBsYXRlLWNvbXBpbGVyLmpzIG1vZHVsZSB0aGF0IHNoaXBzIHdpdGhpbiB5b3VyIGVtYmVyLXNvdXJjZVxuICAvLyB2ZXJzaW9uLiBNYW5kYXRvcnkgd2hlbiB1c2luZyB0YXJnZXRGb3JtYXQ6ICd3aXJlJy5cbiAgY29tcGlsZXI/OiBFbWJlclRlbXBsYXRlQ29tcGlsZXI7XG5cbiAgLy8gQWxsb3dzIHlvdSB0byByZW1hcCB3aGF0IGltcG9ydHMgd2lsbCBiZSBlbWl0dGVkIGluIG91ciBjb21waWxlZCBvdXRwdXQuIEJ5XG4gIC8vIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7XG4gIC8vICAgICAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknOiB7XG4gIC8vICAgICAgIGNyZWF0ZVRlbXBsYXRlRmFjdG9yeTogWydjcmVhdGVUZW1wbGF0ZUZhY3RvcnknLCAnQGdsaW1tZXIvY29yZSddLFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gTm9ybWFsIEVtYmVyIGFwcHMgc2hvdWxkbid0IG5lZWQgdGhpcywgaXQgZXhpc3RzIHRvIHN1cHBvcnQgb3RoZXJcbiAgLy8gZW52aXJvbm1lbnRzIGxpa2Ugc3RhbmRhbG9uZSBHbGltbWVySlNcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIHRoaXMgcGx1Z2luIGltcGxlbWVudHMgb25seSBFbWJlcidzIHN0YWJsZSBwdWJsaWMgQVBJIGZvclxuICAvLyB0ZW1wbGF0ZSBjb21waWxhdGlvbiwgd2hpY2ggaXM6XG4gIC8vXG4gIC8vICAgIGltcG9ydCB7IHByZWNvbXBpbGVUZW1wbGF0ZSB9IGZyb20gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbic7XG4gIC8vXG4gIC8vIEJ1dCBoaXN0b3JpY2FsbHkgdGhlcmUgYXJlIHNldmVyYWwgb3RoZXIgaW1wb3J0YWJsZSBzeW50YXhlcyBpbiB3aWRlc3ByZWFkXG4gIC8vIHVzZSwgYW5kIHdlIGNhbiBlbmFibGUgdGhvc2UgdG9vIGJ5IGluY2x1ZGluZyB0aGVpciBtb2R1bGUgbmFtZXMgaW4gdGhpc1xuICAvLyBsaXN0LlxuICBlbmFibGVMZWdhY3lNb2R1bGVzPzogTGVnYWN5TW9kdWxlTmFtZVtdO1xuXG4gIC8vIENvbnRyb2xzIHRoZSBvdXRwdXQgZm9ybWF0LlxuICAvL1xuICAvLyAgXCJ3aXJlXCI6IFRoZSBkZWZhdWx0LiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyBhcmUgcmVhZHkgdG8gZXhlY3V0ZSBpblxuICAvLyAgdGhlIG1vc3QgcGVyZm9ybWFudCB3YXkuXG4gIC8vXG4gIC8vICBcImhic1wiOiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyB3aWxsIHN0aWxsIGJlIGluIEhCUyBmb3JtYXQuXG4gIC8vICBHZW5lcmFsbHkgdGhpcyBtZWFucyB0aGV5IHdpbGwgc3RpbGwgbmVlZCBmdXJ0aGVyIHByb2Nlc3NpbmcgYmVmb3JlXG4gIC8vICB0aGV5J3JlIHJlYWR5IHRvIGV4ZWN1dGUuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbW9kZSBpcyB0byBzdXBwb3J0IHRoaW5nc1xuICAvLyAgbGlrZSBjb2RlbW9kcyBhbmQgcHJlLXB1YmxpY2F0aW9uIHRyYW5zZm9ybWF0aW9ucyBpbiBsaWJyYXJpZXMuXG4gIHRhcmdldEZvcm1hdD86ICd3aXJlJyB8ICdoYnMnO1xuXG4gIC8vIE9wdGlvbmFsIGxpc3Qgb2YgY3VzdG9tIHRyYW5zZm9ybXMgdG8gYXBwbHkgdG8gdGhlIGhhbmRsZWJhcnMgQVNUIGJlZm9yZVxuICAvLyBjb21waWxhdGlvbi5cbiAgdHJhbnNmb3Jtcz86IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG5pbnRlcmZhY2UgV2lyZU9wdHMge1xuICB0YXJnZXRGb3JtYXQ6ICd3aXJlJztcbiAgY29tcGlsZXI6IEVtYmVyVGVtcGxhdGVDb21waWxlcjtcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IExlZ2FjeU1vZHVsZU5hbWVbXTtcbiAgdHJhbnNmb3JtczogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbmludGVyZmFjZSBIYnNPcHRzIHtcbiAgdGFyZ2V0Rm9ybWF0OiAnaGJzJztcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IExlZ2FjeU1vZHVsZU5hbWVbXTtcbiAgdHJhbnNmb3JtczogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbnR5cGUgTm9ybWFsaXplZE9wdHMgPSBXaXJlT3B0cyB8IEhic09wdHM7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdHMob3B0aW9uczogT3B0aW9ucyk6IE5vcm1hbGl6ZWRPcHRzIHtcbiAgaWYgKChvcHRpb25zLnRhcmdldEZvcm1hdCA/PyAnd2lyZScpID09PSAnd2lyZScpIHtcbiAgICBsZXQgeyBjb21waWxlciB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB3aGVuIHRhcmdldEZvcm1hdD09PVwid2lyZVwiIHlvdSBtdXN0IHNldCB0aGUgY29tcGlsZXIgb3IgY29tcGlsZXJQYXRoIG9wdGlvbmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHt9LFxuICAgICAgZW5hYmxlTGVnYWN5TW9kdWxlczogW10sXG4gICAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXJnZXRGb3JtYXQ6ICd3aXJlJyxcbiAgICAgIGNvbXBpbGVyLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge30sXG4gICAgICBlbmFibGVMZWdhY3lNb2R1bGVzOiBbXSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhcmdldEZvcm1hdDogJ2hicycsXG4gICAgfTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPiB7XG4gIG9wdHM6IEVudlNwZWNpZmljT3B0aW9ucztcbiAgbm9ybWFsaXplZE9wdHM6IE5vcm1hbGl6ZWRPcHRzO1xuICB1dGlsOiBJbXBvcnRVdGlsO1xuICB0ZW1wbGF0ZUZhY3Rvcnk6IHsgbW9kdWxlTmFtZTogc3RyaW5nOyBleHBvcnROYW1lOiBzdHJpbmcgfTtcbiAgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPjtcbiAgbGFzdEluc2VydGVkUGF0aDogTm9kZVBhdGg8dC5TdGF0ZW1lbnQ+IHwgdW5kZWZpbmVkO1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICByZWN1cnNpb25HdWFyZDogU2V0PHVua25vd24+O1xuICBvcmlnaW5hbEltcG9ydGVkTmFtZXM6IE1hcDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBsdWdpbjxFbnZTcGVjaWZpY09wdGlvbnM+KGxvYWRPcHRpb25zOiAob3B0czogRW52U3BlY2lmaWNPcHRpb25zKSA9PiBPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBodG1sYmFyc0lubGluZVByZWNvbXBpbGUoXG4gICAgYmFiZWw6IHR5cGVvZiBCYWJlbFxuICApOiBCYWJlbC5QbHVnaW5PYmo8U3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPj4ge1xuICAgIGxldCB0ID0gYmFiZWwudHlwZXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJlKHRoaXM6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sIGZpbGUpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGF2YWlsYWJsZSBzZXQgb2YgaW1wb3J0ZWQgbmFtZXMgdmVyeSBlYXJseSBoZXJlIGluIDxwcmU+XG4gICAgICAgIC8vIHNvIHRoYXQgd2hlbiBvdGhlciBwbHVnaW5zIChwYXJ0aWN1bGFybHlcbiAgICAgICAgLy8gQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tdHlwZXNjcmlwdCkgZHJvcCBcInVudXNlZFwiIGltcG9ydHMgaW4gdGhlaXJcbiAgICAgICAgLy8gb3duIFByb2dyYW0uZW50ZXIgd2Ugc3RpbGwga25vdyBhYm91dCB0aGVtLiBJZiB3ZSB3YW50IHRvIHVzZSB0aGVtXG4gICAgICAgIC8vIGZyb20gaW5zaWRlIGEgdGVtcGxhdGUsIHRoZXkgd2VyZW4ndCByZWFsbHkgdW51c2VkIGFuZCB3ZSBjYW4gZW5zdXJlXG4gICAgICAgIC8vIHRoZXkgY29udGludWUgdG8gZXhpc3QuXG4gICAgICAgIHRoaXMub3JpZ2luYWxJbXBvcnRlZE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBzdGF0ZW1lbnQgb2YgZmlsZS5hc3QucHJvZ3JhbS5ib2R5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlbWVudC50eXBlID09PSAnSW1wb3J0RGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjaWZpZXIgb2Ygc3RhdGVtZW50LnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEltcG9ydGVkTmFtZXMuc2V0KHNwZWNpZmllci5sb2NhbC5uYW1lLCBbXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50LnNvdXJjZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbXBvcnRlZE5hbWUoc3BlY2lmaWVyKSxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRvcjoge1xuICAgICAgICBQcm9ncmFtOiB7XG4gICAgICAgICAgZW50ZXIocGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzID0gbm9ybWFsaXplT3B0cyhsb2FkT3B0aW9ucyhzdGF0ZS5vcHRzKSk7XG4gICAgICAgICAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnlDb25maWcoc3RhdGUubm9ybWFsaXplZE9wdHMpO1xuICAgICAgICAgICAgc3RhdGUudXRpbCA9IG5ldyBJbXBvcnRVdGlsKHQsIHBhdGgpO1xuICAgICAgICAgICAgc3RhdGUucHJvZ3JhbSA9IHBhdGg7XG4gICAgICAgICAgICBzdGF0ZS5yZWN1cnNpb25HdWFyZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4aXQoX3BhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeyBtb2R1bGVOYW1lLCBleHBvcnQ6IGV4cG9ydE5hbWUgfSBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGlsLnJlbW92ZUltcG9ydChtb2R1bGVOYW1lLCBleHBvcnROYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKFxuICAgICAgICAgIHBhdGg6IE5vZGVQYXRoPHQuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uPixcbiAgICAgICAgICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgdGFnUGF0aCA9IHBhdGguZ2V0KCd0YWcnKTtcblxuICAgICAgICAgIGlmICghdGFnUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKHRhZ1BhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29uZmlnLmFsbG93VGVtcGxhdGVMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIFxcYCR7dGFnUGF0aC5ub2RlLm5hbWV9XFxgIGFzIGEgdGVtcGxhdGUgdGFnLCBidXQgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBwYXNzZWQgdG8gaXQ6ICR7dGFnUGF0aC5ub2RlLm5hbWV9KCdjb250ZW50IGhlcmUnKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGgubm9kZS5xdWFzaS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0YWdnZWQgdGVtcGxhdGUgc3RyaW5nIGFyZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBwYXRoLm5vZGUucXVhc2kucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlKGJhYmVsLCBzdGF0ZSwgdGVtcGxhdGUsIHBhdGgsIHt9LCBjb25maWcsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxFeHByZXNzaW9uKHBhdGg6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgIGxldCBjYWxsZWVQYXRoID0gcGF0aC5nZXQoJ2NhbGxlZScpO1xuXG4gICAgICAgICAgaWYgKCFjYWxsZWVQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjb25maWcgPSByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXIoY2FsbGVlUGF0aCwgc3RhdGUpO1xuICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlY3Vyc2lvbkd1YXJkLmhhcyhwYXRoLm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGguZ2V0KCdhcmd1bWVudHMnKS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcgYW5kIGFueSBzdGF0aWMgb3B0aW9uc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IHBhdGguZ2V0KCdhcmd1bWVudHMnKTtcblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmlyc3RBcmc/Lm5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUZW1wbGF0ZUxpdGVyYWwnOlxuICAgICAgICAgICAgICBpZiAoZmlyc3RBcmcubm9kZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRlbXBsYXRlIHN0cmluZyBhcmUgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZ3MgaW5zaWRlICR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGFyZSBub3Qgc3VwcG9ydGVkYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBzaG91bGQgYmUgaW52b2tlZCB3aXRoIGF0IGxlYXN0IGEgc2luZ2xlIGFyZ3VtZW50ICh0aGUgdGVtcGxhdGUgc3RyaW5nKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgICAgbGV0IGJhY2tpbmdDbGFzczogdW5kZWZpbmVkIHwgTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT47XG5cbiAgICAgICAgICBpZiAoIXNlY29uZEFyZykge1xuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlY29uZEFyZy5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGNhbiBvbmx5IGJlIGludm9rZWQgd2l0aCAyIGFyZ3VtZW50czogdGhlIHRlbXBsYXRlIHN0cmluZywgYW5kIGFueSBzdGF0aWMgb3B0aW9uc2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IG5ldyBFeHByZXNzaW9uUGFyc2VyKGJhYmVsKS5wYXJzZU9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIGNhbGxlZVBhdGgubm9kZS5uYW1lLFxuICAgICAgICAgICAgICBzZWNvbmRBcmcsXG4gICAgICAgICAgICAgIGNvbmZpZy5lbmFibGVTY29wZSxcbiAgICAgICAgICAgICAgQm9vbGVhbihjb25maWcucmZjOTMxU3VwcG9ydClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQgJiYgdXNlclR5cGVkT3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzID0gdXNlclR5cGVkT3B0aW9ucy5jb21wb25lbnQgYXMgTm9kZVBhdGg8XG4gICAgICAgICAgICAgICAgUGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXVxuICAgICAgICAgICAgICA+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH0gYXMgKGJhYmVsOiB0eXBlb2YgQmFiZWwpID0+IEJhYmVsLlBsdWdpbk9iajx1bmtub3duPjtcbn1cblxuZnVuY3Rpb24qIGNvbmZpZ3VyZWRNb2R1bGVzPEVudlNwZWNpZmljT3B0aW9ucz4oc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIElOTElORV9QUkVDT01QSUxFX01PRFVMRVMpIHtcbiAgICBpZiAoXG4gICAgICBtb2R1bGVDb25maWcubW9kdWxlTmFtZSAhPT0gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicgJiZcbiAgICAgIG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lICE9PSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJyAmJlxuICAgICAgIXN0YXRlLm5vcm1hbGl6ZWRPcHRzLmVuYWJsZUxlZ2FjeU1vZHVsZXMuaW5jbHVkZXMobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgbW9kdWxlQ29uZmlnO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcjxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+LFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuKTogTW9kdWxlQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgbW9kdWxlQ29uZmlnIG9mIGNvbmZpZ3VyZWRNb2R1bGVzKHN0YXRlKSkge1xuICAgIGlmIChwYXRoLnJlZmVyZW5jZXNJbXBvcnQobW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUsIG1vZHVsZUNvbmZpZy5leHBvcnQpKSB7XG4gICAgICByZXR1cm4gbW9kdWxlQ29uZmlnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBydW50aW1lRXJyb3JJSUZFKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHJlcGxhY2VtZW50czogeyBFUlJPUl9NRVNTQUdFOiBzdHJpbmcgfSkge1xuICBsZXQgc3RhdGVtZW50ID0gYmFiZWwudGVtcGxhdGUoYChmdW5jdGlvbigpIHtcXG4gIHRocm93IG5ldyBFcnJvcignRVJST1JfTUVTU0FHRScpO1xcbn0pKCk7YCkoXG4gICAgcmVwbGFjZW1lbnRzXG4gICkgYXMgdC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICByZXR1cm4gc3RhdGVtZW50LmV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NvcGVMb2NhbHMoXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIHRlbXBsYXRlQ29udGVudDogc3RyaW5nXG4pOiBTY29wZUxvY2FscyB7XG4gIGlmIChmb3JtYXRPcHRpb25zLnJmYzkzMVN1cHBvcnQgJiYgdXNlclR5cGVkT3B0aW9ucy5ldmFsKSB7XG4gICAgcmV0dXJuIGRpc2NvdmVyTG9jYWxzKHRlbXBsYXRlQ29udGVudCk7XG4gIH0gZWxzZSBpZiAodXNlclR5cGVkT3B0aW9ucy5zY29wZSkge1xuICAgIHJldHVybiB1c2VyVHlwZWRPcHRpb25zLnNjb3BlIGFzIFNjb3BlTG9jYWxzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgU2NvcGVMb2NhbHMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNjb3ZlckxvY2Fscyh0ZW1wbGF0ZUNvbnRlbnQ6IHN0cmluZyk6IFNjb3BlTG9jYWxzIHtcbiAgLy8gdGhpcyBpcyB3cm9uZywgYnV0IHRoZSByaWdodCB0aGluZyBpcyB1bnJlbGVhc2VkIGluXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9wdWxsLzE0MjEsIHNvIGZvciB0aGUgbW9tZW50IEknbVxuICAvLyBzdGlja2luZyB3aXRoIHRoZSBleGFjdCBiZWhhdmlvciB0aGF0IGVtYmVyLXRlbXBsYXRlcy1pbXBvcnRzIGhhcy5cbiAgLy9cbiAgLy8gKHRoZSByZWFzb24gaXQncyB3cm9uZyBpcyB0aGF0IHRoZSBjb3JyZWN0IGFuc3dlciBkZXBlbmRzIG9uIG5vdCBqdXN0IHRoZVxuICAvLyB0ZW1wbGF0ZSwgYnV0IHRoZSBhbWJpZW50IGphdmFzY3JpcHQgc2NvcGUuIEFueXRoaW5nIGluIGxvY2FscyBuZWVkcyB0byB3aW5cbiAgLy8gb3ZlciBlbWJlciBrZXl3b3Jkcy4gT3RoZXJ3aXNlIHdlIGNhbiBuZXZlciBpbnRyb2R1Y2UgbmV3IGtleXdvcmRzLilcbiAgbGV0IHNjb3BlTG9jYWxzID0gbmV3IFNjb3BlTG9jYWxzKCk7XG4gIGZvciAobGV0IGxvY2FsIG9mIGdldFRlbXBsYXRlTG9jYWxzKHRlbXBsYXRlQ29udGVudCkpIHtcbiAgICBpZiAobG9jYWwubWF0Y2goL15bJEEtWl9dWzAtOUEtWl8kXSokL2kpKSB7XG4gICAgICBzY29wZUxvY2Fscy5hZGQobG9jYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NvcGVMb2NhbHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJlY29tcGlsZU9wdGlvbnM8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+LFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgdGVtcGxhdGU6IHN0cmluZyxcbiAgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGNvbmZpZzogTW9kdWxlQ29uZmlnLFxuICBzY29wZTogU2NvcGVMb2NhbHNcbik6IFByZXByb2Nlc3NPcHRpb25zICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBsZXQganN1dGlscyA9IG5ldyBKU1V0aWxzKGJhYmVsLCBzdGF0ZSwgdGFyZ2V0LCBzY29wZSwgc3RhdGUudXRpbCk7XG4gIGxldCBtZXRhID0gT2JqZWN0LmFzc2lnbih7IGpzdXRpbHMgfSwgdXNlclR5cGVkT3B0aW9ucz8ubWV0YSk7XG5cbiAgbGV0IG91dHB1dDogUHJlcHJvY2Vzc09wdGlvbnMgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHtcbiAgICBjb250ZW50czogdGVtcGxhdGUsXG5cbiAgICAvLyB3ZSd2ZSBleHRlbmRlZCBtZXRhIHRvIGFkZCBqc3V0aWxzLCBidXQgdGhlIHR5cGVzIGluIEBnbGltbWVyL3N5bnRheFxuICAgIC8vIGRvbid0IGFjY291bnQgZm9yIGV4dGVuc2lvblxuICAgIG1ldGE6IG1ldGEgYXMgUHJlcHJvY2Vzc09wdGlvbnNbJ21ldGEnXSxcblxuICAgIC8vIFRPRE86IGVtYnJvaWRlcidzIHRlbXBsYXRlLWNvbXBpbGVyIGFsbG93cyB0aGlzIHRvIGJlIG92ZXJyaWRlbiB0byBnZXRcbiAgICAvLyBiYWNrd2FyZC1jb21wYXRpYmxlIG1vZHVsZSBuYW1lcyB0aGF0IGRvbid0IG1hdGNoIHRoZSByZWFsIG5hbWUgb2YgdGhlXG4gICAgLy8gb24tZGlzayBmaWxlLiBXaGF0J3Mgb3VyIHBsYW4gZm9yIG1pZ3JhdGluZyBwZW9wbGUgYXdheSBmcm9tIHRoYXQ/XG4gICAgbW9kdWxlTmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICAvLyBUaGlzIGlzIGhlcmUgc28gaXQncyAqYWx3YXlzKiB0aGUgcmVhbCBmaWxlbmFtZS4gSGlzdG9yaWNhbGx5LCB0aGVyZSBpc1xuICAgIC8vIGFsc28gYG1vZHVsZU5hbWVgIGJ1dCB0aGF0IGRpZCBub3QgbWF0Y2ggdGhlIHJlYWwgb24tZGlzayBmaWxlbmFtZSwgaXRcbiAgICAvLyB3YXMgdGhlIG5vdGlvbmFsIHJ1bnRpbWUgbW9kdWxlIG5hbWUgZnJvbSBjbGFzc2ljIGVtYmVyIGJ1aWxkcy5cbiAgICBmaWxlbmFtZTogc3RhdGUuZmlsZW5hbWUsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICAvLyB0aGUgY2FzdCBpcyBuZWVkZWQgaGVyZSBvbmx5IGJlY2F1c2Ugb3VyIG1ldGEgaXMgZXh0ZW5kZWQuIFRoYXQgaXMsXG4gICAgICAvLyB0aGVzZSBwbHVnaW5zIGNhbiBhY2Nlc3MgbWV0YS5qc3V0aWxzLlxuICAgICAgYXN0OiBzdGF0ZS5ub3JtYWxpemVkT3B0cy50cmFuc2Zvcm1zIGFzIEFTVFBsdWdpbkJ1aWxkZXJbXSxcbiAgICB9LFxuICB9O1xuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh1c2VyVHlwZWRPcHRpb25zKSkge1xuICAgIGlmIChrZXkgIT09ICdzY29wZScpIHtcbiAgICAgIC8vIGBzY29wZWAgaW4gdGhlIHVzZXItZmFjaW5nIEFQSSBiZWNvbWVzIGBsb2NhbHNgIGluIHRoZSBsb3ctbGV2ZWxcbiAgICAgIC8vIGVtYmVyLXRlbXBsYXRlLWNvbXBpbGVyIEFQSVxuICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBvdXRwdXQubG9jYWxzID0gc2NvcGUubG9jYWxzO1xuXG4gIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgIG91dHB1dC5zdHJpY3RNb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIGlmIHNjb3BlIGhhcyBkaWZmZXJlbnQga2V5cyBhbmQgdmFsdWVzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVtYXAgdGhlIGtleXMgdG8gdGhlIHZhbHVlc1xuLy8geW91IGNhbiBzZWUgYW4gZXhhbXBsZSBvZiB0aGlzIGluIHRoZSB0ZXN0IFwiY29ycmVjdGx5IGhhbmRsZXMgc2NvcGUgaWYgaXQgY29udGFpbnMga2V5cyBhbmQgdmFsdWVzXCJcbmZ1bmN0aW9uIHJlbWFwSWRlbnRpZmllcnMoYXN0OiBCYWJlbC50eXBlcy5GaWxlLCBiYWJlbDogdHlwZW9mIEJhYmVsLCBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgaWYgKCFzY29wZUxvY2Fscy5uZWVkc1JlbWFwcGluZygpKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBhbGwga2V5cyBhcmUgdGhlIHNhbWUgYXMgdGhlaXIgdmFsdWVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYmFiZWwudHJhdmVyc2UoYXN0LCB7XG4gICAgSWRlbnRpZmllcihwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+KSB7XG4gICAgICBpZiAoc2NvcGVMb2NhbHMuaGFzKHBhdGgubm9kZS5uYW1lKSAmJiBwYXRoLm5vZGUubmFtZSAhPT0gc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkge1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBwYXRoIG9ubHkgaWYgdGhlIGtleSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgdmFsdWVcbiAgICAgICAgcGF0aC5yZXBsYWNlV2l0aChiYWJlbC50eXBlcy5pZGVudGlmaWVyKHNjb3BlTG9jYWxzLmdldChwYXRoLm5vZGUubmFtZSkpKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBiYWJlbDogdHlwZW9mIEJhYmVsLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgb3B0czogV2lyZU9wdHMsXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5FeHByZXNzaW9uPixcbiAgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGNvbmZpZzogTW9kdWxlQ29uZmlnLFxuICBiYWNraW5nQ2xhc3M6IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+IHwgdW5kZWZpbmVkXG4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNjb3BlTG9jYWxzID0gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zLCBjb25maWcsIHRlbXBsYXRlKTtcbiAgbGV0IG9wdGlvbnMgPSBidWlsZFByZWNvbXBpbGVPcHRpb25zKFxuICAgIGJhYmVsLFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZSxcbiAgICB0ZW1wbGF0ZSxcbiAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgIGNvbmZpZyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuXG4gIGxldCBwcmVjb21waWxlUmVzdWx0U3RyaW5nOiBzdHJpbmc7XG5cbiAgLy8gaW5zZXJ0UnVudGltZUVycm9ycyBpcyBsZWdhY3kgYW5kIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIG5ld2VyIHJmYzkzMSBmb3JtXG4gIGlmIChvcHRpb25zLmluc2VydFJ1bnRpbWVFcnJvcnMgJiYgIWNvbmZpZy5yZmM5MzFTdXBwb3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBvcHRzLmNvbXBpbGVyLnByZWNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgocnVudGltZUVycm9ySUlGRShiYWJlbCwgeyBFUlJPUl9NRVNTQUdFOiAoZXJyb3IgYXMgYW55KS5tZXNzYWdlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJlY29tcGlsZVJlc3VsdFN0cmluZyA9IG9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBsZXQgcHJlY29tcGlsZVJlc3VsdEFTVCA9IGJhYmVsLnBhcnNlKGB2YXIgcHJlY29tcGlsZVJlc3VsdCA9ICR7cHJlY29tcGlsZVJlc3VsdFN0cmluZ307IGAsIHtcbiAgICBiYWJlbHJjOiBmYWxzZSxcbiAgICBjb25maWdGaWxlOiBmYWxzZSxcbiAgfSkgYXMgdC5GaWxlO1xuXG4gIGVuc3VyZUltcG9ydGVkTmFtZXModGFyZ2V0LCBzY29wZUxvY2Fscywgc3RhdGUudXRpbCwgc3RhdGUub3JpZ2luYWxJbXBvcnRlZE5hbWVzKTtcbiAgcmVtYXBJZGVudGlmaWVycyhwcmVjb21waWxlUmVzdWx0QVNULCBiYWJlbCwgc2NvcGVMb2NhbHMpO1xuXG4gIGxldCB0ZW1wbGF0ZUV4cHJlc3Npb24gPSAocHJlY29tcGlsZVJlc3VsdEFTVC5wcm9ncmFtLmJvZHlbMF0gYXMgdC5WYXJpYWJsZURlY2xhcmF0aW9uKVxuICAgIC5kZWNsYXJhdGlvbnNbMF0uaW5pdCBhcyB0LkV4cHJlc3Npb247XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIHRlbXBsYXRlRXhwcmVzc2lvbixcbiAgICAnbGVhZGluZycsXG4gICAgYFxcbiAgJHt0ZW1wbGF0ZS5yZXBsYWNlKC9cXCpcXC8vZywgJypcXFxcLycpfVxcbmAsXG4gICAgLyogbGluZSBjb21tZW50PyAqLyBmYWxzZVxuICApO1xuXG4gIGxldCB0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyID0gc3RhdGUudXRpbC5pbXBvcnQoXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5tb2R1bGVOYW1lLFxuICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5leHBvcnROYW1lXG4gICk7XG5cbiAgbGV0IGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIsIFt0ZW1wbGF0ZUV4cHJlc3Npb25dKTtcblxuICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICBleHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIHN0YXRlLnV0aWwuaW1wb3J0KHRhcmdldCwgJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSxcbiAgICAgIFtcbiAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHN0YXRlLnV0aWwuaW1wb3J0KHRhcmdldCwgJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsICdkZWZhdWx0JywgJ3RlbXBsYXRlT25seScpLFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApLFxuICAgICAgXVxuICAgICk7XG4gIH1cbiAgdGFyZ2V0LnJlcGxhY2VXaXRoKGV4cHJlc3Npb24pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+IHwgTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnLFxuICBiYWNraW5nQ2xhc3M6IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+IHwgdW5kZWZpbmVkXG4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNjb3BlTG9jYWxzID0gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zLCBmb3JtYXRPcHRpb25zLCB0ZW1wbGF0ZSk7XG4gIGxldCBvcHRpb25zID0gYnVpbGRQcmVjb21waWxlT3B0aW9ucyhcbiAgICBiYWJlbCxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUsXG4gICAgdGVtcGxhdGUsXG4gICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICBmb3JtYXRPcHRpb25zLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG4gIGxldCBhc3QgPSBwcmVwcm9jZXNzKHRlbXBsYXRlLCB7IC4uLm9wdGlvbnMsIG1vZGU6ICdjb2RlbW9kJyB9KTtcbiAgbGV0IHRyYW5zZm9ybWVkID0gcHJpbnQoYXN0LCB7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KTtcbiAgaWYgKHRhcmdldC5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICAodGFyZ2V0LmdldCgnYXJndW1lbnRzLjAnKSBhcyBOb2RlUGF0aDx0Lk5vZGU+KS5yZXBsYWNlV2l0aCh0LnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpKTtcbiAgICBpZiAoIXNjb3BlTG9jYWxzLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLmVuYWJsZVNjb3BlKSB7XG4gICAgICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgICAgICB0YXJnZXQuc2V0KCdjYWxsZWUnLCBwcmVjb21waWxlVGVtcGxhdGUoc3RhdGUudXRpbCwgdGFyZ2V0KSk7XG4gICAgICB9XG4gICAgICBlbnN1cmVJbXBvcnRlZE5hbWVzKHRhcmdldCwgc2NvcGVMb2NhbHMsIHN0YXRlLnV0aWwsIHN0YXRlLm9yaWdpbmFsSW1wb3J0ZWROYW1lcyk7XG4gICAgICB1cGRhdGVTY29wZShiYWJlbCwgdGFyZ2V0LCBzY29wZUxvY2Fscyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdE9wdGlvbnMucmZjOTMxU3VwcG9ydCA9PT0gJ3BvbHlmaWxsZWQnKSB7XG4gICAgICBtYXliZVBydW5lSW1wb3J0KHN0YXRlLnV0aWwsIHRhcmdldC5nZXQoJ2NhbGxlZScpKTtcbiAgICAgIHRhcmdldC5zZXQoJ2NhbGxlZScsIHByZWNvbXBpbGVUZW1wbGF0ZShzdGF0ZS51dGlsLCB0YXJnZXQpKTtcbiAgICAgIGNvbnZlcnRTdHJpY3RNb2RlKGJhYmVsLCB0YXJnZXQpO1xuICAgICAgcmVtb3ZlRXZhbEFuZFNjb3BlKHRhcmdldCk7XG4gICAgICB0YXJnZXQubm9kZS5hcmd1bWVudHMgPSB0YXJnZXQubm9kZS5hcmd1bWVudHMuc2xpY2UoMCwgMik7XG4gICAgICBzdGF0ZS5yZWN1cnNpb25HdWFyZC5hZGQodGFyZ2V0Lm5vZGUpO1xuICAgICAgdGFyZ2V0LnJlcGxhY2VXaXRoKFxuICAgICAgICB0LmNhbGxFeHByZXNzaW9uKHN0YXRlLnV0aWwuaW1wb3J0KHRhcmdldCwgJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSwgW1xuICAgICAgICAgIHRhcmdldC5ub2RlLFxuICAgICAgICAgIGJhY2tpbmdDbGFzcz8ubm9kZSA/P1xuICAgICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgc3RhdGUudXRpbC5pbXBvcnQoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICdAZW1iZXIvY29tcG9uZW50L3RlbXBsYXRlLW9ubHknLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAndGVtcGxhdGVPbmx5J1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc2NvcGVMb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICAvLyBuZWVkIHRvIGFkZCBzY29wZSwgc28gbmVlZCB0byByZXBsYWNlIHRoZSBiYWNrdGlja3MgZm9ybSB3aXRoIGEgY2FsbFxuICAgICAgLy8gZXhwcmVzc2lvbiB0byBwcmVjb21waWxlVGVtcGxhdGVcbiAgICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgndGFnJykpO1xuICAgICAgbGV0IG5ld0NhbGwgPSB0YXJnZXQucmVwbGFjZVdpdGgoXG4gICAgICAgIHQuY2FsbEV4cHJlc3Npb24ocHJlY29tcGlsZVRlbXBsYXRlKHN0YXRlLnV0aWwsIHRhcmdldCksIFt0LnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpXSlcbiAgICAgIClbMF07XG4gICAgICBlbnN1cmVJbXBvcnRlZE5hbWVzKG5ld0NhbGwsIHNjb3BlTG9jYWxzLCBzdGF0ZS51dGlsLCBzdGF0ZS5vcmlnaW5hbEltcG9ydGVkTmFtZXMpO1xuICAgICAgdXBkYXRlU2NvcGUoYmFiZWwsIG5ld0NhbGwsIHNjb3BlTG9jYWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHRhcmdldC5nZXQoJ3F1YXNpJykuZ2V0KCdxdWFzaXMuMCcpIGFzIE5vZGVQYXRoPHQuVGVtcGxhdGVFbGVtZW50PikucmVwbGFjZVdpdGgoXG4gICAgICAgIHQudGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0cmFuc2Zvcm1lZCB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVGYWN0b3J5Q29uZmlnKG9wdHM6IE5vcm1hbGl6ZWRPcHRzKSB7XG4gIGxldCBtb2R1bGVOYW1lID0gJ0BlbWJlci90ZW1wbGF0ZS1mYWN0b3J5JztcbiAgbGV0IGV4cG9ydE5hbWUgPSAnY3JlYXRlVGVtcGxhdGVGYWN0b3J5JztcbiAgbGV0IG92ZXJyaWRlcyA9IG9wdHMub3V0cHV0TW9kdWxlT3ZlcnJpZGVzW21vZHVsZU5hbWVdPy5bZXhwb3J0TmFtZV07XG4gIHJldHVybiBvdmVycmlkZXNcbiAgICA/IHsgZXhwb3J0TmFtZTogb3ZlcnJpZGVzWzBdLCBtb2R1bGVOYW1lOiBvdmVycmlkZXNbMV0gfVxuICAgIDogeyBleHBvcnROYW1lLCBtb2R1bGVOYW1lIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICByZXR1cm4gdC5hcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihcbiAgICBbXSxcbiAgICB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICBsb2NhbHNcbiAgICAgICAgLmVudHJpZXMoKVxuICAgICAgICAubWFwKChbbmFtZSwgaWRlbnRpZmllcl0pID0+XG4gICAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIobmFtZSksIHQuaWRlbnRpZmllcihpZGVudGlmaWVyKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIClcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVTY29wZShiYWJlbDogdHlwZW9mIEJhYmVsLCB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBsb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgc2NvcGUgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnc2NvcGUnO1xuICAgIH0pO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2NvcGUuc2V0KCd2YWx1ZScsIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRBcmcucHVzaENvbnRhaW5lcihcbiAgICAgICAgJ3Byb3BlcnRpZXMnLFxuICAgICAgICB0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc2NvcGUnKSwgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSlcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wdXNoQ29udGFpbmVyKFxuICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW3Qub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzY29wZScpLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKV0pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmFsQW5kU2NvcGUodGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPikge1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IGV2YWxQcm9wID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ2V2YWwnO1xuICAgIH0pO1xuICAgIGlmIChldmFsUHJvcCkge1xuICAgICAgZXZhbFByb3AucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbXBvbmVudFByb3AgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnY29tcG9uZW50JztcbiAgICB9KTtcbiAgICBpZiAoY29tcG9uZW50UHJvcCkge1xuICAgICAgY29tcG9uZW50UHJvcC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gR2l2ZW4gYSBjYWxsIHRvIHRlbXBsYXRlKCksIGNvbnZlcnQgaXRzIFwic3RyaWN0XCIgYXJndW1lbnQgaW50b1xuLy8gcHJlY29tcGlsZVRlbXBsYXRlJ3MgXCJzdHJpY3RNb2RlXCIgYXJndW1lbnQuIFRoZXkgZGlmZmVyIGluIG5hbWUgYW5kIGRlZmF1bHRcbi8vIHZhbHVlLlxuZnVuY3Rpb24gY29udmVydFN0cmljdE1vZGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHN0cmljdCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdzdHJpY3QnO1xuICAgIH0pIGFzIE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHk+O1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIHN0cmljdC5zZXQoJ2tleScsIHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSwgdC5ib29sZWFuTGl0ZXJhbCh0cnVlKSlcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wdXNoQ29udGFpbmVyKFxuICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW3Qub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJyksIHQuYm9vbGVhbkxpdGVyYWwodHJ1ZSkpXSlcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUHJ1bmVJbXBvcnQoXG4gIHV0aWw6IEltcG9ydFV0aWwsXG4gIGlkZW50aWZpZXI6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbiB8IHQuVjhJbnRyaW5zaWNJZGVudGlmaWVyPlxuKSB7XG4gIGlmICghaWRlbnRpZmllci5pc0lkZW50aWZpZXIoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYmluZGluZyA9IGlkZW50aWZpZXIuc2NvcGUuZ2V0QmluZGluZyhpZGVudGlmaWVyLm5vZGUubmFtZSk7XG4gIC8vIHRoaXMgY2hlY2tzIGlmIHRoZSBpZGVudGlmaWVyICh0aGF0IHdlJ3JlIGFib3V0IHRvIHJlbW92ZSkgaXMgdXNlZCBpblxuICAvLyBleGFjdGx5IG9uZSBwbGFjZS5cbiAgaWYgKFxuICAgIGJpbmRpbmc/LnJlZmVyZW5jZVBhdGhzLnJlZHVjZSgoY291bnQsIHBhdGgpID0+IChwYXRoLnJlbW92ZWQgPyBjb3VudCA6IGNvdW50ICsgMSksIDApID09PSAxXG4gICkge1xuICAgIGxldCBzcGVjaWZpZXIgPSBiaW5kaW5nLnBhdGg7XG4gICAgaWYgKHNwZWNpZmllci5pc0ltcG9ydFNwZWNpZmllcigpKSB7XG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSBzcGVjaWZpZXIucGFyZW50UGF0aCBhcyBOb2RlUGF0aDx0LkltcG9ydERlY2xhcmF0aW9uPjtcbiAgICAgIHV0aWwucmVtb3ZlSW1wb3J0KGRlY2xhcmF0aW9uLm5vZGUuc291cmNlLnZhbHVlLCBuYW1lKHNwZWNpZmllci5ub2RlLmltcG9ydGVkKSk7XG4gICAgfVxuICB9XG4gIGlkZW50aWZpZXIucmVtb3ZlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGVUZW1wbGF0ZSh1dGlsOiBJbXBvcnRVdGlsLCB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4pIHtcbiAgcmV0dXJuIHV0aWwuaW1wb3J0KHRhcmdldCwgJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicsICdwcmVjb21waWxlVGVtcGxhdGUnKTtcbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVJbXBvcnRlZE5hbWVzKFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG4gIHNjb3BlTG9jYWxzOiBTY29wZUxvY2FscyxcbiAgdXRpbDogSW1wb3J0VXRpbCxcbiAgb3JpZ2luYWxJbXBvcnRlZE5hbWVzOiBNYXA8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPlxuKSB7XG4gIGZvciAobGV0IFtuYW1lSW5UZW1wbGF0ZSwgaWRlbnRpZmllcl0gb2Ygc2NvcGVMb2NhbHMuZW50cmllcygpKSB7XG4gICAgaWYgKCF0YXJnZXQuc2NvcGUuZ2V0QmluZGluZyhpZGVudGlmaWVyKSkge1xuICAgICAgbGV0IGF2YWlsYWJsZSA9IG9yaWdpbmFsSW1wb3J0ZWROYW1lcy5nZXQoaWRlbnRpZmllcik7XG4gICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgIGxldCBuZXdJZGVudCA9IHV0aWwuaW1wb3J0KHRhcmdldCwgYXZhaWxhYmxlWzBdLCBhdmFpbGFibGVbMV0sIGlkZW50aWZpZXIpO1xuICAgICAgICBzY29wZUxvY2Fscy5hZGQobmFtZUluVGVtcGxhdGUsIG5ld0lkZW50Lm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbXBvcnRlZE5hbWUobm9kZTogdC5JbXBvcnREZWNsYXJhdGlvblsnc3BlY2lmaWVycyddW251bWJlcl0pOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicpIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicpIHtcbiAgICByZXR1cm4gJyonO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lKG5vZGUuaW1wb3J0ZWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VQbHVnaW48T3B0aW9ucz4oKG9wdGlvbnMpID0+IG9wdGlvbnMpO1xuIl19