<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/models/host-info-cache.js - ember-cli</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/yui/3.18.0/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  <img src="https://ember-cli.com/assets/images/ember-cli-logo-small-dark.png">
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/ember-cli.html">ember-cli</a>
                            </li>
                            <li><a href="../modules/is-lazy-engine.html">is-lazy-engine</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/Addon.html">Addon</a></li>
                            <li><a href="../classes/AmdTransformAddon.html">AmdTransformAddon</a></li>
                            <li><a href="../classes/Blueprint.html">Blueprint</a></li>
                            <li><a href="../classes/Builder.html">Builder</a></li>
                            <li><a href="../classes/CLI.html">CLI</a></li>
                            <li><a href="../classes/Command.html">Command</a></li>
                            <li><a href="../classes/DefaultPackager.html">DefaultPackager</a></li>
                            <li><a href="../classes/EmberAddon.html">EmberAddon</a></li>
                            <li><a href="../classes/EmberApp.html">EmberApp</a></li>
                            <li><a href="../classes/HardwareInfo.html">HardwareInfo</a></li>
                            <li><a href="../classes/HistorySupportAddon.html">HistorySupportAddon</a></li>
                            <li><a href="../classes/Instrumentation.html">Instrumentation</a></li>
                            <li><a href="../classes/NodeModulesList.html">NodeModulesList</a></li>
                            <li><a href="../classes/NpmTask.html">NpmTask</a></li>
                            <li><a href="../classes/PackageInfo.html">PackageInfo</a></li>
                            <li><a href="../classes/PackageInfoCache.html">PackageInfoCache</a></li>
                            <li><a href="../classes/PerBundleAddonCache {.html">PerBundleAddonCache {</a></li>
                            <li><a href="../classes/Project.html">Project</a></li>
                            <li><a href="../classes/ServeFilesAddon.html">ServeFilesAddon</a></li>
                            <li><a href="../classes/TestsServerAddon.html">TestsServerAddon</a></li>
                            <li><a href="../classes/WatcherAddon.html">WatcherAddon</a></li>
                            <li><a href="../classes/WindowsSymlinkChecker.html">WindowsSymlinkChecker</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 3.28.6-lts-3-28-23a0d98b59
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">lib/models/host-info-cache.js</h1>
</div>

<pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

function allPkgInfosEqualAtIndex(paths, index) {
  const itemToCheck = paths[0][index];
  return paths.every((pathToLazyEngine) =&gt; pathToLazyEngine[index] === itemToCheck);
}

class HostInfoCache {
  constructor(project) {
    this.project = project;
    this._bundledPackageInfoCache = new Map();
    this._hostAddonInfoCache = new Map();
    this._lcaHostCache = new Map();
  }

  /**
   * Given a path (calculated as part of &#x60;getHostAddonInfo&#x60;), return the correct
   * &quot;bundle host&quot;. A bundle host is considered the project or lazy engine.
   *
   * For example, given the following package structure:
   *
   *      --Project--
   *       /      \
   *      /        \
   * Lazy Engine A  \
   *              Addon A
   *                |
   *                |
   *           Lazy Engine B
   *            /          \
   *           /            \
   *      Lazy Engine A   Lazy Engine C
   *
   * The provided paths for lazy engine A would look like:
   *
   * - [Project]
   * - [Project, Addon A, Lazy Engine B]
   *
   * For this project structure, this function would return [Project, [Project]]
   *
   * Similarly, given the following project structure:
   *
   *            --Project--
   *             /      \
   *            /        \
   *     Lazy Engine A    \
   *          /        Lazy Engine B
   *         /               |
   *        /                |
   *  Lazy Engine C     Lazy Engine C
   *
   * The provided paths for lazy engine C would look like:
   *
   * - [Project, Lazy Engine A]
   * - [Project, Lazy Engine B]
   *
   * In this case, the host is the project and would also return [Project, [Project]]
   *
   * @method _findNearestBundleHost
   * @param {Array&lt;PackageInfo[]&gt;} paths The found paths to a given bundle host
   * @return {[PackageInfo, PackageInfo[]]}
   * @private
   */
  _findNearestBundleHost(paths, pkgInfoForLazyEngine) {
    // building an engine in isolation (it&#x27;s considered the project, but it&#x27;s
    // also added as a dependency to the project by &#x60;ember-cli&#x60;)
    if (this.project._packageInfo === pkgInfoForLazyEngine) {
      return [this.project._packageInfo, [this.project._packageInfo]];
    }

    const shortestPath = paths.reduce(
      (acc, pathToLazyEngine) =&gt; Math.min(acc, pathToLazyEngine.length),
      Number.POSITIVE_INFINITY
    );

    const pathsEqualToShortest = paths.filter((pathToLazyEngine) =&gt; pathToLazyEngine.length === shortestPath);
    const [firstPath] = pathsEqualToShortest;

    for (let i = firstPath.length - 1; i &gt;= 0; i--) {
      const pkgInfo = firstPath[i];

      if (pkgInfo.isForBundleHost() &amp;&amp; allPkgInfosEqualAtIndex(pathsEqualToShortest, i)) {
        return [pkgInfo, firstPath.slice(0, i + 1)];
      }
    }

    // this should _never_ be triggered
    throw new Error(
      &#x60;[ember-cli] Could not find a common host for: \&#x60;${pkgInfoForLazyEngine.name}\&#x60; (located at \&#x60;${pkgInfoForLazyEngine.realPath}\&#x60;)&#x60;
    );
  }

  /**
   * Returns a &#x60;Set&#x60; of package-info objects that a given bundle host is
   * _directly_ responsible for bundling (i.e., it excludes other bundle
   * hosts/lazy engines when it encounters these)
   *
   * @method _getBundledPackageInfos
   * @param {PackageInfo} pkgInfoToStartAt
   * @return {Set&lt;PackageInfo&gt;}
   * @private
   */
  _getBundledPackageInfos(pkgInfoToStartAt) {
    let pkgInfos = this._bundledPackageInfoCache.get(pkgInfoToStartAt);

    if (pkgInfos) {
      return pkgInfos;
    }

    if (!pkgInfoToStartAt.isForBundleHost()) {
      throw new Error(
        &#x60;[ember-cli] \&#x60;${pkgInfoToStartAt.name}\&#x60; is not a bundle host; \&#x60;getBundledPackageInfos\&#x60; should only be used to find bundled package infos for a project or lazy engine&#x60;
      );
    }

    pkgInfos = new Set();
    this._bundledPackageInfoCache.set(pkgInfoToStartAt, pkgInfos);

    let findAddons = (currentPkgInfo) =&gt; {
      if (!currentPkgInfo.valid || !currentPkgInfo.addonMainPath) {
        return;
      }

      if (pkgInfos.has(currentPkgInfo)) {
        return;
      }

      if (currentPkgInfo.isForBundleHost()) {
        return;
      }

      pkgInfos.add(currentPkgInfo);

      let addonPackageList = currentPkgInfo.discoverAddonAddons();
      addonPackageList.forEach((pkgInfo) =&gt; findAddons(pkgInfo));
    };

    let addonPackageList = pkgInfoToStartAt.project
      ? pkgInfoToStartAt.discoverProjectAddons()
      : pkgInfoToStartAt.discoverAddonAddons();

    addonPackageList.forEach((pkgInfo) =&gt; findAddons(pkgInfo));

    return pkgInfos;
  }

  /**
   * This function intends to return a common host for a bundle host (lazy engine). The root
   * package info should be the starting point (i.e., the project&#x27;s package info). We do this
   * by performing a breadth-first traversal until we find the intended lazy engine (represented
   * as a package-info &amp; the 1st argument passed to this function). As part of the traversal, we keep
   * track of all paths to said engine; then, once we find the intended engine we use this to determine
   * the nearest common host amongst all shortest paths.
   *
   * Some context:
   *
   * For a given engine/bundle host, this finds the lowest common ancestor that is considered a
   * host amongst _all_ engines by the same name in the project.
   *
   * For example, given the following package structure:
   *
   *      --Project--
   *       /      \
   *      /        \
   * Lazy Engine A  \
   *              Addon A
   *                |
   *                |
   *           Lazy Engine B
   *            /          \
   *           /            \
   *      Lazy Engine A   Lazy Engine C
   *
   * - The LCA host for Lazy Engine A is the project
   * - The LCA host for Lazy Engine B is the project
   * - The LCA host for Lazy Engine C is Lazy Engine B
   *
   * This also returns &#x60;hostAndAncestorBundledPackageInfos&#x60;, which are all bundled addons above a given host:
   *
   * - &#x60;hostAndAncestorBundledPackageInfos&#x60; for lazy engine A includes all non-lazy dependencies of its LCA host &amp; above (in this case, just the project)
   * - &#x60;hostAndAncestorBundledPackageInfos&#x60; for lazy engine B includes all non-lazy dependencies of its LCA host &amp; above (in this case, just the project)
   * - &#x60;hostAndAncestorBundledPackageInfos&#x60; for lazy engine C includes non-lazy deps of lazy engine B &amp; non-lazy deps of the project (LCA host &amp; above)
   *
   * This is intended to mimic the behavior of &#x60;ancestorHostAddons&#x60; in &#x60;ember-engines&#x60;:
   * https://github.com/ember-engines/ember-engines/blob/master/packages/ember-engines/lib/engine-addon.js#L333
   *
   * Unfortunately, we can&#x27;t easily repurpose the logic in &#x60;ember-engines&#x60; since the algorithm has to be different;
   * in &#x60;ember-engines&#x60; we need access to the actual addon instance, however, this is intended to be used _during_
   * addon instantiation, so we only have access to package-info objects. In having said this, we _can_ repurpose
   * the &#x60;hostPackageInfo&#x60; to determine the LCA host; see below &#x60;findLCAHost&#x60;.
   *
   * @method getHostAddonInfo
   * @param {PackageInfo} packageInfoForLazyEngine
   * @return {{ hostPackageInfo: PackageInfo, hostAndAncestorBundledPackageInfos: Set&lt;PackageInfo&gt; }}
   */
  getHostAddonInfo(packageInfoForLazyEngine) {
    const cacheKey = &#x60;${this.project._packageInfo.realPath}-${packageInfoForLazyEngine.realPath}&#x60;;

    let hostInfoCacheEntry = this._hostAddonInfoCache.get(cacheKey);

    if (hostInfoCacheEntry) {
      return hostInfoCacheEntry;
    }

    if (!packageInfoForLazyEngine.isForEngine()) {
      throw new Error(
        &#x60;[ember-cli] \&#x60;${packageInfoForLazyEngine.name}\&#x60; is not an engine; \&#x60;getHostAddonInfo\&#x60; should only be used to find host information about engines&#x60;
      );
    }

    const queue = [{ pkgInfo: this.project._packageInfo, path: [] }];
    const visited = new Set();
    const foundPaths = [];

    while (queue.length) {
      const { pkgInfo: currentPackageInfo, path } = queue.shift();

      const {
        addonMainPath,
        inRepoAddons = [],
        dependencyPackages = {},
        devDependencyPackages = {},
      } = currentPackageInfo;

      const isCurrentPackageInfoProject = this.project._packageInfo === currentPackageInfo;

      // don&#x27;t process non-ember addons
      if (!isCurrentPackageInfoProject &amp;&amp; typeof addonMainPath !== &#x27;string&#x27;) {
        continue;
      }

      // store found paths
      if (currentPackageInfo === packageInfoForLazyEngine) {
        foundPaths.push([...path]);
      }

      // don&#x27;t process a given &#x60;PackageInfo&#x60; object more than once
      if (!visited.has(currentPackageInfo)) {
        visited.add(currentPackageInfo);

        // add current package info to current path
        path.push(currentPackageInfo);

        queue.push(
          ...[
            ...inRepoAddons,
            ...Object.values(dependencyPackages),
            ...Object.values(devDependencyPackages),
          ].map((pkgInfo) =&gt; ({ pkgInfo, path: [...path] }))
        );
      }
    }

    const [hostPackageInfo, foundPath] = this._findNearestBundleHost(foundPaths, packageInfoForLazyEngine);

    const hostAndAncestorBundledPackageInfos = foundPath
      .filter((pkgInfo) =&gt; pkgInfo.isForBundleHost())
      .reduce((acc, curr) =&gt; {
        acc.push(...this._getBundledPackageInfos(curr));
        return acc;
      }, []);

    hostInfoCacheEntry = {
      hostPackageInfo,
      hostAndAncestorBundledPackageInfos: new Set(hostAndAncestorBundledPackageInfos),
    };

    this._hostAddonInfoCache.set(cacheKey, hostInfoCacheEntry);
    return hostInfoCacheEntry;
  }

  /**
   * This returns the LCA host for a given engine; we use the associated package info
   * to compute this (see &#x60;getHostAddonInfo&#x60; above); this finds the lowest common ancestor
   * that is considered a host amongst _all_ engines by the same name in the project. This
   * function is intended to replace the original behavior in &#x60;ember-engines&#x60;.
   *
   * For more info, see the original implementation here:
   *
   * https://github.com/ember-engines/ember-engines/blob/master/packages/ember-engines/lib/utils/find-lca-host.js
   *
   * @method findLCAHost
   * @param {EngineAddon} engineInstance
   * @return {EngineAddon|EmberApp}
   */
  findLCAHost(engineInstance) {
    // only compute once for a given engine
    // we&#x27;re using the engine name as the cache key here because regardless of its
    // version, lazy engines will always get output to: &#x60;engines-dist/${engineName}&#x60;
    let lcaHost = this._lcaHostCache.get(engineInstance.name);

    if (lcaHost) {
      return lcaHost;
    }

    if (!engineInstance._packageInfo.isForEngine()) {
      throw new Error(
        &#x60;[ember-cli] \&#x60;findLCAHost\&#x60; should only be used for engines; \&#x60;${engineInstance.name}\&#x60; is not an engine&#x60;
      );
    }

    const { hostPackageInfo } = this.getHostAddonInfo(engineInstance._packageInfo);

    let curr = engineInstance;

    while (curr &amp;&amp; curr.parent) {
      if (curr.app) {
        lcaHost = curr.app;
        break;
      }

      if (curr._packageInfo === hostPackageInfo) {
        lcaHost = curr;
        break;
      }

      curr = curr.parent;
    }

    if (lcaHost) {
      this._lcaHostCache.set(engineInstance.name, lcaHost);
      return lcaHost;
    }

    // this should _never_ be triggered
    throw new Error(
      &#x60;[ember-cli] Could not find an LCA host for: \&#x60;${engineInstance.name}\&#x60; (located at \&#x60;${
        engineInstance.packageRoot || engineInstance.root
      }\&#x60;)&#x60;
    );
  }
}

module.exports = HostInfoCache;

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
