<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/models/per-bundle-addon-cache/addon-proxy.js - ember-cli</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/yui/3.18.0/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  <img src="https://ember-cli.com/assets/images/ember-cli-logo-small-dark.png">
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/ember-cli.html">ember-cli</a>
                            </li>
                            <li><a href="../modules/is-lazy-engine.html">is-lazy-engine</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/Addon.html">Addon</a></li>
                            <li><a href="../classes/AmdTransformAddon.html">AmdTransformAddon</a></li>
                            <li><a href="../classes/Blueprint.html">Blueprint</a></li>
                            <li><a href="../classes/Builder.html">Builder</a></li>
                            <li><a href="../classes/CLI.html">CLI</a></li>
                            <li><a href="../classes/Command.html">Command</a></li>
                            <li><a href="../classes/DefaultPackager.html">DefaultPackager</a></li>
                            <li><a href="../classes/EmberAddon.html">EmberAddon</a></li>
                            <li><a href="../classes/EmberApp.html">EmberApp</a></li>
                            <li><a href="../classes/HardwareInfo.html">HardwareInfo</a></li>
                            <li><a href="../classes/HistorySupportAddon.html">HistorySupportAddon</a></li>
                            <li><a href="../classes/Instrumentation.html">Instrumentation</a></li>
                            <li><a href="../classes/NodeModulesList.html">NodeModulesList</a></li>
                            <li><a href="../classes/NpmTask.html">NpmTask</a></li>
                            <li><a href="../classes/PackageInfo.html">PackageInfo</a></li>
                            <li><a href="../classes/PackageInfoCache.html">PackageInfoCache</a></li>
                            <li><a href="../classes/PerBundleAddonCache {.html">PerBundleAddonCache {</a></li>
                            <li><a href="../classes/Project.html">Project</a></li>
                            <li><a href="../classes/ServeFilesAddon.html">ServeFilesAddon</a></li>
                            <li><a href="../classes/TestsServerAddon.html">TestsServerAddon</a></li>
                            <li><a href="../classes/WatcherAddon.html">WatcherAddon</a></li>
                            <li><a href="../classes/WindowsSymlinkChecker.html">WindowsSymlinkChecker</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 3.28.6-lts-3-28-23a0d98b59
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">lib/models/per-bundle-addon-cache/addon-proxy.js</h1>
</div>

<pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

const { TARGET_INSTANCE } = require(&#x27;./target-instance&#x27;);

const CACHE_KEY_FOR_TREE_TRACKER = Symbol(&#x27;CACHE_KEY_FOR_TREE_TRACKER&#x27;);

/**
 * Validates that a new cache key for a given tree type matches the previous
 * cache key for the same tree type. To opt-in to bundle addon caching for
 * a given addon it&#x27;s assumed that it returns stable cache keys; specifically
 * this is because the interplay between bundle addon caching and &#x60;ember-engines&#x60;
 * when transitive deduplication is enabled assumes stable cache keys, so we validate
 * for this case here.
 *
 * @method validateCacheKey
 * @param {Addon} realAddonInstance The real addon instance
 * @param {string} treeType
 * @param {string} newCacheKey
 * @throws {Error} If the new cache key doesn&#x27;t match the previous cache key
 */
function validateCacheKey(realAddonInstance, treeType, newCacheKey) {
  let cacheKeyTracker = realAddonInstance[CACHE_KEY_FOR_TREE_TRACKER];

  if (!cacheKeyTracker) {
    cacheKeyTracker = {};
    realAddonInstance[CACHE_KEY_FOR_TREE_TRACKER] = cacheKeyTracker;
  }

  cacheKeyTracker[treeType] = treeType in cacheKeyTracker ? cacheKeyTracker[treeType] : newCacheKey;

  if (cacheKeyTracker[treeType] !== newCacheKey) {
    throw new Error(
      &#x60;[ember-cli] addon bundle caching can only be used on addons that have stable cache keys (previously \&#x60;${
        cacheKeyTracker[treeType]
      }\&#x60;, now \&#x60;${newCacheKey}\&#x60;; for addon \&#x60;${realAddonInstance.name}\&#x60; located at \&#x60;${
        realAddonInstance.packageRoot || realAddonInstance.root
      }\&#x60;)&#x60;
    );
  }
}

/**
 * Returns a proxy to a target with specific handling for the
 * &#x60;parent&#x60; property, as well has to handle the &#x60;app&#x60; property;
 * that is, the proxy should maintain correct local state in
 * closure scope for the &#x60;app&#x60; property if it happens to be set
 * by &#x60;ember-cli&#x60;. Other than &#x60;parent&#x60; &amp; &#x60;app&#x60;, this function also
 * proxies _almost_ everything to &#x60;target[TARGET_INSTANCE] with a few
 * exceptions: we trap &amp; return &#x60;[]&#x60; for &#x60;addons&#x60;, and we don&#x27;t return
 * the original &#x60;included&#x60; (it&#x27;s already called on the &quot;real&quot; addon
 * by &#x60;ember-cli&#x60;).
 *
 * Note: the target is NOT the per-bundle cacheable instance of the addon. Rather,
 * it is a cache entry POJO from PerBundleAddonCache.
 *
 * @method getAddonProxy
 * @param targetCacheEntry the PerBundleAddonCache cache entry we are to proxy. It
 * has one interesting property, the real addon instance the proxy is forwarding
 * calls to (that property is not globally exposed).
 * @param parent the parent object of the proxy being created (the same as
 * the &#x27;parent&#x27; property of a normal addon instance)
 * @return Proxy
 */
function getAddonProxy(targetCacheEntry, parent) {
  let _app;

  // handle &#x60;preprocessJs&#x60; separately for Embroider
  //
  // some context here:
  //
  // Embroider patches &#x60;preprocessJs&#x60;, so we want to maintain local state within the
  // proxy rather than allowing a patched &#x60;preprocessJs&#x60; set on the original addon
  // instance itself
  //
  // for more info as to where this happens, see:
  // https://github.com/embroider-build/embroider/blob/master/packages/compat/src/v1-addon.ts#L634
  let _preprocessJs;

  return new Proxy(targetCacheEntry, {
    get(targetCacheEntry, property) {
      if (property === &#x27;parent&#x27;) {
        return parent;
      }

      if (property === &#x27;app&#x27;) {
        return _app;
      }

      // only return &#x60;_preprocessJs&#x60; here if it was previously set to a patched version
      if (property === &#x27;preprocessJs&#x27; &amp;&amp; _preprocessJs) {
        return _preprocessJs;
      }

      // keep proxies from even trying to set or initialize addons
      if (property === &#x27;initializeAddons&#x27;) {
        return undefined;
      }

      // See the {@link index.js} file for a discussion of why the proxy &#x27;addons&#x27;
      // property returns an empty array.
      if (property === &#x27;addons&#x27;) {
        return [];
      }

      // allow access to the property pointing to the real instance.
      if (property === TARGET_INSTANCE) {
        return targetCacheEntry[TARGET_INSTANCE];
      }

      // &#x60;included&#x60; will be called on the &quot;real&quot; addon, so there&#x27;s no need for it to be
      // called again; instead we return a no-op implementation here
      if (property === &#x27;included&#x27;) {
        return () =&gt; undefined;
      }

      if (targetCacheEntry[TARGET_INSTANCE]) {
        if (property !== &#x27;constructor&#x27; &amp;&amp; typeof targetCacheEntry[TARGET_INSTANCE][property] === &#x27;function&#x27;) {
          // If we fall through to the Reflect.get just below, the &#x27;this&#x27; context of the function when
          // invoked is the proxy, not the original instance (so its local state is incorrect).
          // Wrap the original methods to maintain the correct &#x27;this&#x27; context.
          return function _originalAddonPropMethodWrapper() {
            let originalReturnValue = targetCacheEntry[TARGET_INSTANCE][property](...arguments);

            if (property === &#x27;cacheKeyForTree&#x27;) {
              const treeType = arguments[0];
              validateCacheKey(targetCacheEntry[TARGET_INSTANCE], treeType, originalReturnValue);
            }

            return originalReturnValue;
          };
        }

        return Reflect.get(targetCacheEntry[TARGET_INSTANCE], property);
      }

      return Reflect.get(targetCacheEntry, property);
    },
    set(targetCacheEntry, property, value) {
      if (property === &#x27;app&#x27;) {
        _app = value;
        return true;
      }

      if (property === &#x27;preprocessJs&#x27;) {
        _preprocessJs = value;
        return true;
      }

      if (targetCacheEntry[TARGET_INSTANCE]) {
        return Reflect.set(targetCacheEntry[TARGET_INSTANCE], property, value);
      }

      return Reflect.set(targetCacheEntry, property, value);
    },
  });
}

module.exports = { getAddonProxy };

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
