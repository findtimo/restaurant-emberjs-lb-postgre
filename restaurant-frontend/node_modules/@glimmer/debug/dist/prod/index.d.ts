import { Dict, Maybe, RuntimeOp, TemplateCompilationContext, Nullable, PresentArray, VmMachineOp, VmOp, BlockSymbolTable, ProgramSymbolTable, SimpleDocumentFragment, SimpleElement, SimpleNode } from "@glimmer/interfaces";
interface DebugConstants {
    getValue<T>(handle: number): T;
    getArray<T>(value: number): T[];
}
declare function debugSlice(context: TemplateCompilationContext, start: number, end: number): void;
declare function logOpcode(type: string, params: Maybe<Dict>): string | void;
declare function debug(c: DebugConstants, op: RuntimeOp, isMachine: 0 | 1): [
    string,
    Dict
] | undefined;
// TODO: How do these map onto constant and machine types?
declare const OPERAND_TYPES: string[];
type OperandType = (typeof OPERAND_TYPES)[number];
interface Operand {
    type: OperandType;
    name: string;
}
type OperandList = ([
] | [
    Operand
] | [
    Operand,
    Operand
] | [
    Operand,
    Operand,
    Operand
]) & Operand[];
interface NormalizedMetadata {
    name: string;
    mnemonic: string;
    before: null;
    stackChange: Nullable<number>;
    ops: OperandList;
    operands: number;
    check: boolean;
}
type Stack = [
    string[],
    string[]
];
interface RawOperandMetadata {
    kind: "machine" | "syscall";
    format: RawOperandFormat;
    skip?: true;
    operation: string;
    "operand-stack"?: [
        string[],
        string[]
    ];
    notes?: string;
}
type OperandName = `${string}:${string}`;
type RawOperandFormat = OperandName | PresentArray<OperandName>;
declare function normalize(key: string, input: RawOperandMetadata): NormalizedMetadata;
interface NormalizedOpcodes {
    readonly machine: Dict<NormalizedMetadata>;
    readonly syscall: Dict<NormalizedMetadata>;
}
declare function normalizeAll(parsed: {
    machine: Dict<RawOperandMetadata>;
    syscall: Dict<RawOperandMetadata>;
}): NormalizedOpcodes;
declare function normalizeParsed(parsed: Dict<RawOperandMetadata>): Dict<NormalizedMetadata>;
declare function buildEnum(name: string, parsed: Dict<NormalizedMetadata>, offset: number, max?: number): {
    enumString: string;
    predicate: string;
};
declare function strip(strings: TemplateStringsArray, ...args: unknown[]): string;
declare const META_KIND: string[];
type META_KIND = (typeof META_KIND)[number];
declare function buildSingleMeta<D extends Dict<NormalizedMetadata>>(kind: META_KIND, all: D, key: keyof D): string;
declare function buildMetas(kind: META_KIND, all: Dict<NormalizedMetadata>): string;
declare function opcodeMetadata(op: VmMachineOp | VmOp, isMachine: 0 | 1): Nullable<NormalizedMetadata>;
interface Checker<T> {
    type: T;
    validate(value: unknown): value is T;
    expected(): string;
}
declare function wrap<T>(checker: () => Checker<T>): Checker<T>;
interface Constructor<T> extends Function {
    prototype: T;
}
type Primitive = undefined | null | boolean | number | string;
interface SafeString {
    toHTML(): string;
}
declare function CheckInstanceof<T>(Class: Constructor<T>): Checker<T>;
declare function CheckOption<T>(checker: Checker<T>): Checker<Nullable<T>>;
declare function CheckMaybe<T>(checker: Checker<T>): Checker<Maybe<T>>;
declare function CheckInterface<I extends {
    [P in keyof O]: O[P]["type"];
}, O extends Dict<Checker<unknown>>>(obj: O): Checker<I>;
declare function CheckArray<T>(obj: Checker<T>): Checker<T[]>;
declare function CheckDict<T>(obj: Checker<T>): Checker<Dict<T>>;
declare function check<T>(value: unknown, checker: Checker<T>, message?: (value: unknown, expected: string) => string): T;
declare function check<T, U extends T>(value: T, checker: (value: T) => asserts value is U): U;
declare function recordStackSize(sp: number): void;
declare function expectStackChange(stack: {
    sp: number;
}, expected: number, name: string): void;
declare const CheckPrimitive: Checker<Primitive>;
declare const CheckFunction: Checker<Function>;
declare const CheckNumber: Checker<number>;
declare const CheckBoolean: Checker<boolean>;
declare const CheckHandle: Checker<number>;
declare const CheckString: Checker<string>;
declare const CheckNull: Checker<null>;
declare const CheckUnknown: Checker<unknown>;
declare const CheckSafeString: Checker<SafeString>;
declare const CheckObject: Checker<object>;
declare function CheckOr<T, U>(left: Checker<T>, right: Checker<U>): Checker<T | U>;
declare function CheckValue<T>(value: T, desc?: string): Checker<T>;
declare const CheckBlockSymbolTable: Checker<BlockSymbolTable>;
declare const CheckProgramSymbolTable: Checker<ProgramSymbolTable>;
declare const CheckElement: Checker<SimpleElement>;
declare const CheckDocumentFragment: Checker<SimpleDocumentFragment>;
declare const CheckNode: Checker<SimpleNode>;
export { debug, debugSlice, logOpcode, OPERAND_TYPES, OperandType, Operand, OperandList, NormalizedMetadata, Stack, RawOperandMetadata, OperandName, RawOperandFormat, normalize, NormalizedOpcodes, normalizeAll, normalizeParsed, buildEnum, strip, META_KIND, buildSingleMeta, buildMetas, opcodeMetadata, Checker, wrap, Constructor, Primitive, SafeString, CheckInstanceof, CheckOption, CheckMaybe, CheckInterface, CheckArray, CheckDict, check, recordStackSize, expectStackChange, CheckPrimitive, CheckFunction, CheckNumber, CheckBoolean, CheckHandle, CheckString, CheckNull, CheckUnknown, CheckSafeString, CheckObject, CheckOr, CheckValue, CheckBlockSymbolTable, CheckProgramSymbolTable, CheckElement, CheckDocumentFragment, CheckNode };
//# sourceMappingURL=index.d.ts.map