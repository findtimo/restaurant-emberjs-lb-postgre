import{extractHandle as e,assert as t,expect as o,unwrap as n,debugToString as l,isSmallInt as a,Stack as r,isPresentArray as i,encodeHandle as s,EMPTY_STRING_ARRAY as u,dict as p,assign as c,enumerate as m,encodeImmediate as d,EMPTY_ARRAY as h,reverse as f}from"@glimmer/util";import{debugSlice as b}from"@glimmer/debug";import{Op as y,MachineOp as v,TYPE_SIZE as w,isMachineOp as g,MACHINE_MASK as S,ARG_SHIFT as k,$v0 as A,$fp as L,$sp as C,InternalComponentCapabilities as P,$s0 as F,$s1 as E,ContentType as D}from"@glimmer/vm";import{InstructionEncoderImpl as H}from"@glimmer/encoder";import{SexpOpcodes as B}from"@glimmer/wire-format";import{hasCapability as G}from"@glimmer/manager";import{assert as N,deprecate as T}from"@glimmer/global-context";const I=!("undefined"==typeof window||!window.location||!/[&?]enable_local_should_log/u.test(window.location.search));let O;function x(e){return t=>{if(!function(e){return Array.isArray(e)&&2===e.length}(t))return!1;let o=t[0];return o===B.GetStrictKeyword||o===B.GetLexicalSymbol||o===e}}I&&(O=(t,o)=>{let n=e(o),{heap:l}=t.program,a=l.getaddr(n),r=a+l.sizeof(n);b(t,a,r)});const M=x(B.GetFreeAsComponentHead),V=x(B.GetFreeAsModifierHead),R=x(B.GetFreeAsHelperHead),$=x(B.GetFreeAsComponentOrHelperHead),U=x(B.GetFreeAsHelperHeadOrThisFallback);const J=x(B.GetFreeAsComponentOrHelperHeadOrThisFallback);function Y(e){if(!e.upvars)throw new Error("Attempted to resolve a component, helper, or modifier, but no free vars were found");if(!e.owner)throw new Error("Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from");return e}function K(e,o,l,[,a,{ifHelper:r}]){var i;t(U(a)||(i=a,Array.isArray(i)&&i[0]===B.GetFreeAsDeprecatedHelperHeadOrThisFallback),"Attempted to resolve a helper with incorrect opcode");let{upvars:s,owner:u}=Y(l),p=n(s[a[1]]),c=e.lookupHelper(p,u);c&&r(o.helper(c,p),p,l.moduleName)}function W(e,t,o,l,a){let{upvars:r}=Y(o),i=n(r[e[1]]),s=t.lookupBuiltInHelper(i);if(null===s)throw new Error(`Attempted to resolve a ${a} in a strict mode template, but that value was not in scope: ${o.upvars[e[1]]??"{unknown variable}"}`);return l.helper(s,i)}const _={Modifier:1003,Component:1004,Helper:1005,OptionalHelper:1006,ComponentOrHelper:1007,OptionalComponentOrHelper:1008,Free:1009,Local:1010,TemplateLocal:1011},j={Label:1e3,StartLabels:1001,StopLabels:1002,Start:1e3,End:1002},z={Label:1,IsStrictMode:2,DebugSymbols:3,Block:4,StdLib:5,NonSmallInt:6,SymbolTable:7,Layout:8};function q(e){return{type:z.Label,value:e}}function Q(){return{type:z.IsStrictMode,value:void 0}}function X(e){return{type:z.StdLib,value:e}}function Z(e){return{type:z.SymbolTable,value:e}}function ee(e){return{type:z.Layout,value:e}}class te{labels=p();targets=[];label(e,t){this.labels[e]=t}target(e,t){this.targets.push({at:e,target:t})}patch(e){let{targets:o,labels:n}=this;for(const{at:l,target:a}of o){let o=n[a]-l;t(-1===e.getbyaddr(l),"Expected heap to contain a placeholder, but it did not"),e.setbyaddr(l,o)}}}function oe(e,a,r,i,s){if(function(e){return e<j.Start}(s[0])){let[t,...o]=s;e.push(a,t,...o)}else switch(s[0]){case j.Label:return e.label(s[1]);case j.StartLabels:return e.startLabels();case j.StopLabels:return e.stopLabels();case _.Component:return function(e,l,a,[,r,i]){t(M(r),"Attempted to resolve a component with incorrect opcode");let s=r[0];if(r[0]===B.GetStrictKeyword)throw new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${a.upvars[r[1]]??"{unknown variable}"}`);if(s===B.GetLexicalSymbol){let{scopeValues:e,owner:t}=a,n=o(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.component(n,o(t,"BUG: expected owner when resolving component definition")))}else{let{upvars:t,owner:o}=Y(a),s=n(t[r[1]]),u=e.lookupComponent(s,o);if("object"!=typeof u||null===u)throw new Error(`Attempted to resolve \`${s}\`, which was expected to be a component, but nothing was found.`);i(l.resolvedComponent(u,s))}}(r,a,i,s);case _.Modifier:return function(e,l,a,[,r,i]){t(V(r),"Attempted to resolve a modifier with incorrect opcode");let s=r[0];if(s===B.GetLexicalSymbol){let{scopeValues:e}=a,t=o(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.modifier(t))}else if(s===B.GetStrictKeyword){let{upvars:t}=Y(a),o=n(t[r[1]]),s=e.lookupBuiltInModifier(o);if(null===s)throw new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${o}`);i(l.modifier(s,o))}else{let{upvars:t,owner:o}=Y(a),s=n(t[r[1]]),u=e.lookupModifier(s,o);if(null===u)throw new Error(`Attempted to resolve \`${s}\`, which was expected to be a modifier, but nothing was found.`);i(l.modifier(u,s))}}(r,a,i,s);case _.Helper:return function(e,l,a,[,r,i]){t(R(r),"Attempted to resolve a helper with incorrect opcode");let s=r[0];if(s===B.GetLexicalSymbol){let{scopeValues:e}=a,t=o(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.helper(t))}else if(s===B.GetStrictKeyword)i(W(r,e,a,l,"helper"));else{let{upvars:t,owner:o}=Y(a),s=n(t[r[1]]),u=e.lookupHelper(s,o);if(null===u)throw new Error(`Attempted to resolve \`${s}\`, which was expected to be a helper, but nothing was found.`);i(l.helper(u,s))}}(r,a,i,s);case _.ComponentOrHelper:return function(e,a,r,[,i,{ifComponent:s,ifHelper:u}]){t($(i),"Attempted to resolve a component or helper with incorrect opcode");let p=i[0];if(p===B.GetLexicalSymbol){let{scopeValues:e,owner:t}=r,n=o(e,"BUG: scopeValues must exist if template symbol is used")[i[1]],p=a.component(n,o(t,"BUG: expected owner when resolving component definition"),!0);if(null!==p)return void s(p);let c=a.helper(n,null,!0);if(null===c)throw new Error(`Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${l(n)}`);u(o(c,"BUG: helper must exist"))}else if(p===B.GetStrictKeyword)u(W(i,e,r,a,"component or helper"));else{let{upvars:t,owner:o}=Y(r),l=n(t[i[1]]),p=e.lookupComponent(l,o);if(null!==p)s(a.resolvedComponent(p,l));else{let t=e.lookupHelper(l,o);if(null===t)throw new Error(`Attempted to resolve \`${l}\`, which was expected to be a component or helper, but nothing was found.`);u(a.helper(t,l))}}}(r,a,i,s);case _.OptionalHelper:return K(r,a,i,s);case _.OptionalComponentOrHelper:return function(e,l,a,[,r,{ifComponent:i,ifHelper:s,ifValue:u}]){t(J(r),"Attempted to resolve an optional component or helper with incorrect opcode");let p=r[0];if(p===B.GetLexicalSymbol){let{scopeValues:e,owner:t}=a,n=o(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];if("function"!=typeof n&&("object"!=typeof n||null===n))return void u(l.value(n));let p=l.component(n,o(t,"BUG: expected owner when resolving component definition"),!0);if(null!==p)return void i(p);let c=l.helper(n,null,!0);if(null!==c)return void s(c);u(l.value(n))}else if(p===B.GetStrictKeyword)s(W(r,e,a,l,"value"));else{let{upvars:t,owner:o}=Y(a),u=n(t[r[1]]),p=e.lookupComponent(u,o);if(null!==p)return void i(l.resolvedComponent(p,u));let c=e.lookupHelper(u,o);null!==c&&s(l.helper(c,u))}}(r,a,i,s);case _.Local:{let e=s[1],t=o(i.upvars,"BUG: attempted to resolve value but no upvars found")[e];(0,s[2])(t,i.moduleName);break}case _.TemplateLocal:{let[,e,t]=s,n=o(i.scopeValues,"BUG: Attempted to gect a template local, but template does not have any")[e];t(a.value(n));break}case _.Free:{let[,e]=s,t=o(i.upvars,"BUG: attempted to resolve value but no upvars found")[e];throw new Error(`Attempted to resolve a value in a strict mode template, but that value was not in scope: ${t}`)}default:throw new Error(`Unexpected high level opcode ${s[0]}`)}}class ne{labelsStack=new r;encoder=new H([]);errors=[];handle;constructor(e,t,o){this.heap=e,this.meta=t,this.stdlib=o,this.handle=e.malloc()}error(e){this.encoder.encode(y.Primitive,0),this.errors.push(e)}commit(e){let t=this.handle;return this.heap.pushMachine(v.Return),this.heap.finishMalloc(t,e),i(this.errors)?{errors:this.errors,handle:t}:t}push(e,t,...o){let{heap:n}=this;if(t>w)throw new Error(`Opcode type over 8-bits. Got ${t}.`);let l=t|(g(t)?S:0)|o.length<<k;n.pushRaw(l);for(let t=0;t<o.length;t++){let l=o[t];n.pushRaw(this.operand(e,l))}}operand(e,t){if("number"==typeof t)return t;if("object"==typeof t&&null!==t){if(Array.isArray(t))return s(e.array(t));switch(t.type){case z.Label:return this.currentLabels.target(this.heap.offset,t.value),-1;case z.IsStrictMode:return s(e.value(this.meta.isStrictMode));case z.DebugSymbols:return s(e.array(this.meta.evalSymbols||u));case z.Block:return s(e.value((n=t.value,l=this.meta,new je(n[0],l,{parameters:n[1]||h}))));case z.StdLib:return o(this.stdlib,"attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?")[t.value];case z.NonSmallInt:case z.SymbolTable:case z.Layout:return e.value(t.value)}}var n,l;return s(e.value(t))}get currentLabels(){return o(this.labelsStack.current,"bug: not in a label stack")}label(e){this.currentLabels.label(e,this.heap.offset+1)}startLabels(){this.labelsStack.push(new te)}stopLabels(){o(this.labelsStack.pop(),"unbalanced push and pop labels").patch(this.heap)}}class le{constructor(e,t,o,n,l){this.main=e,this.trustingGuardedAppend=t,this.cautiousGuardedAppend=o,this.trustingNonDynamicAppend=n,this.cautiousNonDynamicAppend=l}get"trusting-append"(){return this.trustingGuardedAppend}get"cautious-append"(){return this.cautiousGuardedAppend}get"trusting-non-dynamic-append"(){return this.trustingNonDynamicAppend}get"cautious-non-dynamic-append"(){return this.cautiousNonDynamicAppend}getAppend(e){return e?this.trustingGuardedAppend:this.cautiousGuardedAppend}}class ae{names;constructor(e){this.blocks=e,this.names=e?Object.keys(e):[]}get(e){return this.blocks&&this.blocks[e]||null}has(e){let{blocks:t}=this;return null!==t&&e in t}with(e,t){let{blocks:o}=this;return new ae(o?c({},o,{[e]:t}):{[e]:t})}get hasAny(){return null!==this.blocks}}const re=new ae(null);function ie(e){if(null===e)return re;let t=p(),[o,l]=e;for(const[e,a]of m(o))t[a]=n(l[e]);return new ae(t)}function se(e,t){ue(e,t),e(y.PrimitiveReference)}function ue(e,o){let n=o;var l;"number"==typeof n&&(n=a(n)?d(n):(t(!a(l=n),"Attempted to make a operand for an int that was not a small int, you should encode this as an immediate"),{type:z.NonSmallInt,value:l})),e(y.Primitive,n)}function pe(e,t,o,n){e(v.PushFrame),ye(e,o,n,!1),e(y.Helper,t),e(v.PopFrame),e(y.Fetch,A)}function ce(e,t,o,n){e(v.PushFrame),ye(e,t,o,!1),e(y.Dup,L,1),e(y.DynamicHelper),n?(e(y.Fetch,A),n(),e(v.PopFrame),e(y.Pop,1)):(e(v.PopFrame),e(y.Pop,1),e(y.Fetch,A))}function me(e,t,o,n,l){e(v.PushFrame),ye(e,n,l,!1),e(y.CaptureArgs),be(e,o),e(y.Curry,t,Q()),e(v.PopFrame),e(y.Fetch,A)}class de{names={};funcs=[];add(e,t){this.names[e]=this.funcs.push(t)-1}compile(e,o){let l=o[0],a=n(this.names[l]),r=this.funcs[a];t(!!r,`expected an implementation for ${o[0]}`),r(e,o)}}const he=new de;function fe(e,t){if(void 0!==t&&0!==t.length)for(let o=0;o<t.length;o++)e(y.GetProperty,t[o])}function be(e,t){Array.isArray(t)?he.compile(e,t):(ue(e,t),e(y.PrimitiveReference))}function ye(e,t,o,n){if(null===t&&null===o)return void e(y.PushEmptyArgs);let l=ve(e,t)<<4;n&&(l|=8);let a=u;if(o){a=o[0];let t=o[1];for(let o=0;o<t.length;o++)be(e,t[o])}e(y.PushArgs,a,u,l)}function ve(e,t){if(null===t)return 0;for(let o=0;o<t.length;o++)be(e,t[o]);return t.length}function we(e){let[,t,,o]=e.block;return{evalSymbols:ge(e),upvars:o,scopeValues:e.scope?.()??null,isStrictMode:e.isStrictMode,moduleName:e.moduleName,owner:e.owner,size:t.length}}function ge(e){let{block:t}=e,[,o,n]=t;return n?o:null}function Se(e,t,o){ye(e,o,null,!0),e(y.GetBlock,t),e(y.SpreadBlock),e(y.CompileBlock),e(y.InvokeYield),e(y.PopScope),e(v.PopFrame)}function ke(e,t){!function(e,t){null!==t?e(y.PushSymbolTable,Z({parameters:t})):ue(e,null)}(e,t&&t[1]),e(y.PushBlockScope),Ce(e,t)}function Ae(e,t){e(v.PushFrame),Ce(e,t),e(y.CompileBlock),e(v.InvokeVirtual),e(v.PopFrame)}function Le(e,t,o){let n=t[1],l=n.length,a=Math.min(o,l);if(0!==a){if(e(v.PushFrame),a){e(y.ChildScope);for(let t=0;t<a;t++)e(y.Dup,L,o-t),e(y.SetVariable,n[t])}Ce(e,t),e(y.CompileBlock),e(v.InvokeVirtual),a&&e(y.PopScope),e(v.PopFrame)}else Ae(e,t)}function Ce(e,t){var o;null===t?ue(e,null):e(y.Constant,(o=t,{type:z.Block,value:o}))}function Pe(e,t,o){let l=[],a=0;o((function(e,t){l.push({match:e,callback:t,label:"CLAUSE"+a++})})),e(y.Enter,1),t(),e(j.StartLabels);for(let t of l.slice(0,-1))e(y.JumpEq,q(t.label),t.match);for(let t=l.length-1;t>=0;t--){let o=n(l[t]);e(j.Label,o.label),e(y.Pop,1),o.callback(),0!==t&&e(v.Jump,q("END"))}e(j.Label,"END"),e(j.StopLabels),e(y.Exit)}function Fe(e,t,o){e(j.StartLabels),e(v.PushFrame),e(v.ReturnTo,q("ENDINITIAL"));let n=t();e(y.Enter,n),o(),e(j.Label,"FINALLY"),e(y.Exit),e(v.Return),e(j.Label,"ENDINITIAL"),e(v.PopFrame),e(j.StopLabels)}function Ee(e,t,o,n){return Fe(e,t,(()=>{e(y.JumpUnless,q("ELSE")),o(),e(v.Jump,q("FINALLY")),e(j.Label,"ELSE"),void 0!==n&&n()}))}he.add(B.Concat,((e,[,t])=>{for(let o of t)be(e,o);e(y.Concat,t.length)})),he.add(B.Call,((e,[,t,o,n])=>{R(t)?e(_.Helper,t,(t=>{pe(e,t,o,n)})):(be(e,t),ce(e,o,n))})),he.add(B.Curry,((e,[,t,o,n,l])=>{me(e,o,t,n,l)})),he.add(B.GetSymbol,((e,[,t,o])=>{e(y.GetVariable,t),fe(e,o)})),he.add(B.GetLexicalSymbol,((e,[,t,o])=>{e(_.TemplateLocal,t,(t=>{e(y.ConstantReference,t),fe(e,o)}))})),he.add(B.GetStrictKeyword,((e,[,t,o])=>{e(_.Free,t,(e=>{}))})),he.add(B.GetFreeAsComponentOrHelperHeadOrThisFallback,(()=>{throw new Error("unimplemented opcode")})),he.add(B.GetFreeAsHelperHeadOrThisFallback,((e,t)=>{e(_.Local,t[1],(o=>{e(_.OptionalHelper,t,{ifHelper:t=>{pe(e,t,null,null)}})}))})),he.add(B.GetFreeAsDeprecatedHelperHeadOrThisFallback,((e,t)=>{e(_.Local,t[1],(o=>{e(_.OptionalHelper,t,{ifHelper:(o,n,l)=>{N(t[2]&&1===t[2].length,"[BUG] Missing argument name");let a=t[2][0];T(`The \`${n}\` helper was used in the \`${l}\` template as \`${a}={{${n}}}\`. This is ambigious between wanting the \`${a}\` argument to be the \`${n}\` helper itself, or the result of invoking the \`${n}\` helper (current behavior). This implicit invocation behavior has been deprecated.\n\nInstead, please explicitly invoke the helper with parenthesis, i.e. \`${a}={{(${n})}}\`.\n\nNote: the parenthesis are only required in this exact scenario where an ambiguity is present – where \`${n}\` referes to a global helper (as opposed to a local variable), AND the \`${n}\` helper invocation does not take any arguments, AND this occurs in a named argument position of a component invocation.\n\nWe expect this combination to be quite rare, as most helpers require at least one argument. There is no need to refactor helper invocations in cases where this deprecation was not triggered.`,!1,{id:"argument-less-helper-paren-less-invocation"}),pe(e,o,null,null)}})}))})),he.add(B.Undefined,(e=>se(e,void 0))),he.add(B.HasBlock,((e,[,t])=>{be(e,t),e(y.HasBlock)})),he.add(B.HasBlockParams,((e,[,t])=>{be(e,t),e(y.SpreadBlock),e(y.CompileBlock),e(y.HasBlockParams)})),he.add(B.IfInline,((e,[,t,o,n])=>{be(e,n),be(e,o),be(e,t),e(y.IfInline)})),he.add(B.Not,((e,[,t])=>{be(e,t),e(y.Not)})),he.add(B.GetDynamicVar,((e,[,t])=>{be(e,t),e(y.GetDynamicVar)})),he.add(B.Log,((e,[,t])=>{e(v.PushFrame),ye(e,t,null,!1),e(y.Log),e(v.PopFrame),e(y.Fetch,A)}));const De="&attrs";function He(e,t,o,l,a,r){let{compilable:i,capabilities:s,handle:p}=t,c=o?[o,[]]:null,m=Array.isArray(r)||null===r?ie(r):r;i?(e(y.PushComponentDefinition,p),function(e,{capabilities:t,layout:o,elementBlock:l,positional:a,named:r,blocks:i}){let{symbolTable:s}=o,p=s.hasEval||G(t,P.prepareArgs);if(p)return void Ge(e,{capabilities:t,elementBlock:l,positional:a,named:r,atNames:!0,blocks:i,layout:o});e(y.Fetch,F),e(y.Dup,C,1),e(y.Load,F),e(v.PushFrame);let{symbols:c}=s,m=[],d=[],h=[],b=i.names;if(null!==l){let t=c.indexOf(De);-1!==t&&(ke(e,l),m.push(t))}for(const t of b){let o=c.indexOf(`&${t}`);-1!==o&&(ke(e,i.get(t)),m.push(o))}if(G(t,P.createArgs)){let t=ve(e,a)<<4;t|=8;let o=u;if(null!==r){o=r[0];let t=r[1];for(let l=0;l<t.length;l++){let a=c.indexOf(n(o[l]));be(e,t[l]),d.push(a)}}e(y.PushArgs,o,u,t),d.push(-1)}else if(null!==r){let t=r[0],o=r[1];for(let l=0;l<o.length;l++){let a=n(t[l]),r=c.indexOf(a);-1!==r&&(be(e,o[l]),d.push(r),h.push(a))}}e(y.BeginComponentTransaction,F),G(t,P.dynamicScope)&&e(y.PushDynamicScope);G(t,P.createInstance)&&e(y.CreateComponent,0|i.has("default"),F);e(y.RegisterComponentDestructor,F),G(t,P.createArgs)?e(y.GetComponentSelf,F):e(y.GetComponentSelf,F,h);e(y.RootScope,c.length+1,Object.keys(i).length>0?1:0),e(y.SetVariable,0);for(const t of f(d))-1===t?e(y.Pop,1):e(y.SetVariable,t+1);null!==a&&e(y.Pop,a.length);for(const t of f(m))e(y.SetBlock,t+1);e(y.Constant,ee(o)),e(y.CompileBlock),e(v.InvokeVirtual),e(y.DidRenderLayout,F),e(v.PopFrame),e(y.PopScope),G(t,P.dynamicScope)&&e(y.PopDynamicScope);e(y.CommitComponentTransaction),e(y.Load,F)}(e,{capabilities:s,layout:i,elementBlock:c,positional:l,named:a,blocks:m})):(e(y.PushComponentDefinition,p),Ge(e,{capabilities:s,elementBlock:c,positional:l,named:a,atNames:!0,blocks:m}))}function Be(e,t,o,n,l,a,r,i){let s=o?[o,[]]:null,u=Array.isArray(a)||null===a?ie(a):a;Fe(e,(()=>(be(e,t),e(y.Dup,C,0),2)),(()=>{e(y.JumpUnless,q("ELSE")),i?e(y.ResolveCurriedComponent):e(y.ResolveDynamicComponent,Q()),e(y.PushDynamicComponentInstance),Ge(e,{capabilities:!0,elementBlock:s,positional:n,named:l,atNames:r,blocks:u}),e(j.Label,"ELSE")}))}function Ge(e,{capabilities:t,elementBlock:o,positional:n,named:l,atNames:a,blocks:r,layout:i}){let s=!!r,u=!0===t||G(t,P.prepareArgs)||!(!l||0===l[0].length),p=r.with("attrs",o);e(y.Fetch,F),e(y.Dup,C,1),e(y.Load,F),e(v.PushFrame),function(e,t,o,n,l){let a=n.names;for(const t of a)ke(e,n.get(t));let r=ve(e,t)<<4;l&&(r|=8),n&&(r|=7);let i=h;if(o){i=o[0];let t=o[1];for(let o=0;o<t.length;o++)be(e,t[o])}e(y.PushArgs,i,a,r)}(e,n,l,p,a),e(y.PrepareArgs,F),Te(e,p.has("default"),s,u,(()=>{i?(e(y.PushSymbolTable,Z(i.symbolTable)),e(y.Constant,ee(i)),e(y.CompileBlock)):e(y.GetComponentLayout,F),e(y.PopulateLayout,F)})),e(y.Load,F)}function Ne(e,t,o){e(j.StartLabels),function(e,t,o){e(y.Fetch,t),o(),e(y.Load,t)}(e,E,(()=>{e(y.GetComponentTagName,F),e(y.PrimitiveReference),e(y.Dup,C,0)})),e(y.JumpUnless,q("BODY")),e(y.Fetch,E),e(y.PutComponentOperations),e(y.OpenDynamicElement),e(y.DidCreateElement,F),Se(e,o,null),e(y.FlushElement),e(j.Label,"BODY"),Ae(e,[t.block[0],[]]),e(y.Fetch,E),e(y.JumpUnless,q("END")),e(y.CloseElement),e(j.Label,"END"),e(y.Load,E),e(j.StopLabels)}function Te(e,t,o,n,l=null){e(y.BeginComponentTransaction,F),e(y.PushDynamicScope),e(y.CreateComponent,0|t,F),l&&l(),e(y.RegisterComponentDestructor,F),e(y.GetComponentSelf,F),e(y.VirtualRootScope,F),e(y.SetVariable,0),e(y.SetupForEval,F),n&&e(y.SetNamedVariables,F),o&&e(y.SetBlocks,F),e(y.Pop,1),e(y.InvokeComponentLayout,F),e(y.DidRenderLayout,F),e(v.PopFrame),e(y.PopScope),e(y.PopDynamicScope),e(y.CommitComponentTransaction)}function Ie(e,t,o){Pe(e,(()=>e(y.ContentType)),(n=>{n(D.String,(()=>{t?(e(y.AssertSame),e(y.AppendHTML)):e(y.AppendText)})),"number"==typeof o?(n(D.Component,(()=>{e(y.ResolveCurriedComponent),e(y.PushDynamicComponentInstance),function(e){e(y.Fetch,F),e(y.Dup,C,1),e(y.Load,F),e(v.PushFrame),e(y.PushEmptyArgs),e(y.PrepareArgs,F),Te(e,!1,!1,!0,(()=>{e(y.GetComponentLayout,F),e(y.PopulateLayout,F)})),e(y.Load,F)}(e)})),n(D.Helper,(()=>{ce(e,null,null,(()=>{e(v.InvokeStatic,o)}))}))):(n(D.Component,(()=>{e(y.AppendText)})),n(D.Helper,(()=>{e(y.AppendText)}))),n(D.SafeString,(()=>{e(y.AssertSame),e(y.AppendSafeHTML)})),n(D.Fragment,(()=>{e(y.AssertSame),e(y.AppendDocumentFragment)})),n(D.Node,(()=>{e(y.AssertSame),e(y.AppendNode)}))}))}function Oe(e){let t=Me(e,(e=>function(e){e(y.Main,F),Te(e,!1,!1,!0)}(e))),o=Me(e,(e=>Ie(e,!0,null))),n=Me(e,(e=>Ie(e,!1,null))),l=Me(e,(e=>Ie(e,!0,o))),a=Me(e,(e=>Ie(e,!1,n)));return new le(t,l,a,o,n)}const xe={evalSymbols:null,upvars:null,moduleName:"stdlib",scopeValues:null,isStrictMode:!0,owner:null,size:0};function Me(e,t){let{constants:o,heap:n,resolver:l}=e,a=new ne(n,xe);t((function(...e){oe(a,o,l,xe,e)}));let r=a.commit(0);if("number"!=typeof r)throw new Error("Unexpected errors compiling std");return r}class Ve{constants;heap;stdlib;constructor({constants:e,heap:t},o,n){this.resolver=o,this.createOp=n,this.constants=e,this.heap=t,this.stdlib=Oe(this)}}function Re(e,t,o){return new Ve(e,t,o)}function $e(e,t){return{program:e,encoder:new ne(e.heap,t,e.stdlib),meta:t}}const Ue=new de,Je=["class","id","value","name","type","style","href"],Ye=["div","span","p","a"];function Ke(e){return"string"==typeof e?e:Ye[e]}function We(e){return"string"==typeof e?e:Je[e]}function _e(e){if(null===e)return null;return[e[0].map((e=>`@${e}`)),e[1]]}Ue.add(B.Comment,((e,t)=>e(y.Comment,t[1]))),Ue.add(B.CloseElement,(e=>e(y.CloseElement))),Ue.add(B.FlushElement,(e=>e(y.FlushElement))),Ue.add(B.Modifier,((e,[,t,o,n])=>{V(t)?e(_.Modifier,t,(t=>{e(v.PushFrame),ye(e,o,n,!1),e(y.Modifier,t),e(v.PopFrame)})):(be(e,t),e(v.PushFrame),ye(e,o,n,!1),e(y.Dup,L,1),e(y.DynamicModifier),e(v.PopFrame))})),Ue.add(B.StaticAttr,((e,[,t,o,n])=>{e(y.StaticAttr,We(t),o,n??null)})),Ue.add(B.StaticComponentAttr,((e,[,t,o,n])=>{e(y.StaticComponentAttr,We(t),o,n??null)})),Ue.add(B.DynamicAttr,((e,[,t,o,n])=>{be(e,o),e(y.DynamicAttr,We(t),!1,n??null)})),Ue.add(B.TrustingDynamicAttr,((e,[,t,o,n])=>{be(e,o),e(y.DynamicAttr,We(t),!0,n??null)})),Ue.add(B.ComponentAttr,((e,[,t,o,n])=>{be(e,o),e(y.ComponentAttr,We(t),!1,n??null)})),Ue.add(B.TrustingComponentAttr,((e,[,t,o,n])=>{be(e,o),e(y.ComponentAttr,We(t),!0,n??null)})),Ue.add(B.OpenElement,((e,[,t])=>{e(y.OpenElement,Ke(t))})),Ue.add(B.OpenElementWithSplat,((e,[,t])=>{e(y.PutComponentOperations),e(y.OpenElement,Ke(t))})),Ue.add(B.Component,((e,[,t,o,n,l])=>{M(t)?e(_.Component,t,(t=>{He(e,t,o,null,n,l)})):Be(e,t,o,null,n,l,!0,!0)})),Ue.add(B.Yield,((e,[,t,o])=>Se(e,t,o))),Ue.add(B.AttrSplat,((e,[,t])=>Se(e,t,null))),Ue.add(B.Debugger,((e,[,t])=>e(y.Debugger,{type:z.DebugSymbols,value:void 0},t))),Ue.add(B.Append,((e,[,t])=>{if(Array.isArray(t))if(J(t))e(_.OptionalComponentOrHelper,t,{ifComponent(t){He(e,t,null,null,null,null)},ifHelper(t){e(v.PushFrame),pe(e,t,null,null),e(v.InvokeStatic,X("cautious-non-dynamic-append")),e(v.PopFrame)},ifValue(t){e(v.PushFrame),e(y.ConstantReference,t),e(v.InvokeStatic,X("cautious-non-dynamic-append")),e(v.PopFrame)}});else if(t[0]===B.Call){let[,o,n,l]=t;$(o)?e(_.ComponentOrHelper,o,{ifComponent(t){He(e,t,null,n,_e(l),null)},ifHelper(t){e(v.PushFrame),pe(e,t,n,l),e(v.InvokeStatic,X("cautious-non-dynamic-append")),e(v.PopFrame)}}):Pe(e,(()=>{be(e,o),e(y.DynamicContentType)}),(t=>{t(D.Component,(()=>{e(y.ResolveCurriedComponent),e(y.PushDynamicComponentInstance),Ge(e,{capabilities:!0,elementBlock:null,positional:n,named:l,atNames:!1,blocks:ie(null)})})),t(D.Helper,(()=>{ce(e,n,l,(()=>{e(v.InvokeStatic,X("cautious-non-dynamic-append"))}))}))}))}else e(v.PushFrame),be(e,t),e(v.InvokeStatic,X("cautious-append")),e(v.PopFrame);else e(y.Text,null==t?"":String(t))})),Ue.add(B.TrustingAppend,((e,[,t])=>{Array.isArray(t)?(e(v.PushFrame),be(e,t),e(v.InvokeStatic,X("trusting-append")),e(v.PopFrame)):e(y.Text,null==t?"":String(t))})),Ue.add(B.Block,((e,[,t,o,n,l])=>{M(t)?e(_.Component,t,(t=>{He(e,t,null,o,_e(n),l)})):Be(e,t,null,o,n,l,!1,!1)})),Ue.add(B.InElement,((e,[,t,o,n,l])=>{Ee(e,(()=>(be(e,o),void 0===l?se(e,void 0):be(e,l),be(e,n),e(y.Dup,C,0),4)),(()=>{e(y.PushRemoteElement),Ae(e,t),e(y.PopRemoteElement)}))})),Ue.add(B.If,((e,[,t,o,n])=>Ee(e,(()=>(be(e,t),e(y.ToBoolean),1)),(()=>{Ae(e,o)}),n?()=>{Ae(e,n)}:void 0))),Ue.add(B.Each,((e,[,t,o,n,l])=>Fe(e,(()=>(o?be(e,o):se(e,null),be(e,t),2)),(()=>{e(y.EnterList,q("BODY"),q("ELSE")),e(v.PushFrame),e(y.Dup,L,1),e(v.ReturnTo,q("ITER")),e(j.Label,"ITER"),e(y.Iterate,q("BREAK")),e(j.Label,"BODY"),Le(e,n,2),e(y.Pop,2),e(v.Jump,q("FINALLY")),e(j.Label,"BREAK"),e(v.PopFrame),e(y.ExitList),e(v.Jump,q("FINALLY")),e(j.Label,"ELSE"),l&&Ae(e,l)})))),Ue.add(B.With,((e,[,t,o,n])=>{Ee(e,(()=>(be(e,t),e(y.Dup,C,0),e(y.ToBoolean),2)),(()=>{Le(e,o,1)}),(()=>{n&&Ae(e,n)}))})),Ue.add(B.Let,((e,[,t,o])=>{Le(e,o,ve(e,t))})),Ue.add(B.WithDynamicVars,((e,[,t,o])=>{if(t){let[n,l]=t;ve(e,l),function(e,t,o){e(y.PushDynamicScope),e(y.BindDynamicScope,t),o(),e(y.PopDynamicScope)}(e,n,(()=>{Ae(e,o)}))}else Ae(e,o)})),Ue.add(B.InvokeComponent,((e,[,t,o,n,l])=>{M(t)?e(_.Component,t,(t=>{He(e,t,null,o,_e(n),l)})):Be(e,t,null,o,n,l,!1,!1)}));class je{compiled=null;constructor(e,t,o,n="plain block"){this.statements=e,this.meta=t,this.symbolTable=o,this.moduleName=n}compile(e){return function(e,t){if(null!==e.compiled)return e.compiled;e.compiled=-1;let{statements:o,meta:n}=e,l=qe(o,n,t);return e.compiled=l,l}(this,e)}}function ze(e,t){let[o,n,l]=e.block;return new je(o,we(e),{symbols:n,hasEval:l},t)}function qe(e,t,o){let n=Ue,l=$e(o,t),{encoder:a,program:{constants:r,resolver:i}}=l;function s(...e){oe(a,r,i,t,e)}for(const t of e)n.compile(s,t);let u=l.encoder.commit(t.size);return I&&O(l,u),u}const Qe={dynamicLayout:!0,dynamicTag:!0,prepareArgs:!0,createArgs:!0,attributeHook:!1,elementHook:!1,dynamicScope:!0,createCaller:!1,updateHook:!0,createInstance:!0,wrapped:!1,willDestroy:!1,hasSubOwner:!1},Xe={dynamicLayout:!1,dynamicTag:!1,prepareArgs:!1,createArgs:!1,attributeHook:!1,elementHook:!1,dynamicScope:!1,createCaller:!1,updateHook:!1,createInstance:!1,wrapped:!1,willDestroy:!1,hasSubOwner:!1};class Ze{symbolTable;compiled=null;attrsBlockNumber;constructor(e,t){this.layout=e,this.moduleName=t;let{block:o}=e,[,n,l]=o;n=n.slice();let a=n.indexOf(De);this.attrsBlockNumber=-1===a?n.push(De):a+1,this.symbolTable={hasEval:l,symbols:n}}compile(e){if(null!==this.compiled)return this.compiled;let t=we(this.layout),o=$e(e,t),{encoder:n,program:{constants:l,resolver:a}}=o;Ne((function(...e){oe(n,l,a,t,e)}),this.layout,this.attrsBlockNumber);let r=o.encoder.commit(t.size);return"number"!=typeof r||(this.compiled=r,I&&O(o,r)),r}}let et=0,tt={cacheHit:0,cacheMiss:0};function ot({id:e,moduleName:t,block:o,scope:n,isStrictMode:l}){let a,r=e||"client-"+et++,i=null,s=new WeakMap,u=e=>{if(void 0===a&&(a=JSON.parse(o)),void 0===e)return null===i?(tt.cacheMiss++,i=new nt({id:r,block:a,moduleName:t,owner:null,scope:n,isStrictMode:l})):tt.cacheHit++,i;let u=s.get(e);return void 0===u?(tt.cacheMiss++,u=new nt({id:r,block:a,moduleName:t,owner:e,scope:n,isStrictMode:l}),s.set(e,u)):tt.cacheHit++,u};return u.__id=r,u.__meta={moduleName:t},u}class nt{result="ok";layout=null;wrappedLayout=null;constructor(e){this.parsedLayout=e}get moduleName(){return this.parsedLayout.moduleName}get id(){return this.parsedLayout.id}get referrer(){return{moduleName:this.parsedLayout.moduleName,owner:this.parsedLayout.owner}}asLayout(){return this.layout?this.layout:this.layout=ze(c({},this.parsedLayout),this.moduleName)}asWrappedLayout(){return this.wrappedLayout?this.wrappedLayout:this.wrappedLayout=new Ze(c({},this.parsedLayout),this.moduleName)}}export{Ve as CompileTimeCompilationContextImpl,Qe as DEFAULT_CAPABILITIES,re as EMPTY_BLOCKS,Xe as MINIMAL_CAPABILITIES,le as StdLib,Ze as WrappedBuilder,ze as compilable,qe as compileStatements,Oe as compileStd,O as debugCompiler,Ae as invokeStaticBlock,Le as invokeStaticBlockWithStack,we as meta,Re as programCompilationContext,tt as templateCacheCounters,$e as templateCompilationContext,ot as templateFactory};
//# sourceMappingURL=index.js.map
