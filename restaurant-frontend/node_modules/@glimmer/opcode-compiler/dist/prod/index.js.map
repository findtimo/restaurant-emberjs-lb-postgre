{"version":3,"file":"index.js","sources":["../../../local-debug-flags/index.ts","../../lib/compiler.ts","../../lib/opcode-builder/helpers/resolution.ts","../../lib/opcode-builder/opcodes.ts","../../lib/opcode-builder/operands.ts","../../lib/opcode-builder/encoder.ts","../../lib/compilable-template.ts","../../lib/opcode-builder/stdlib.ts","../../lib/utils.ts","../../lib/opcode-builder/helpers/vm.ts","../../lib/syntax/compilers.ts","../../lib/syntax/expressions.ts","../../lib/opcode-builder/helpers/expr.ts","../../lib/opcode-builder/helpers/shared.ts","../../lib/opcode-builder/helpers/blocks.ts","../../lib/opcode-builder/helpers/conditional.ts","../../lib/opcode-builder/helpers/components.ts","../../lib/opcode-builder/helpers/stdlib.ts","../../lib/program-context.ts","../../lib/opcode-builder/context.ts","../../lib/syntax/statements.ts","../../lib/opcode-builder/delegate.ts","../../lib/wrapped-component.ts","../../lib/template.ts"],"sourcesContent":["export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { HandleResult, TemplateCompilationContext } from '@glimmer/interfaces';\nimport { debugSlice } from '@glimmer/debug';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { extractHandle } from '@glimmer/util';\n\nexport let debugCompiler: (context: TemplateCompilationContext, handle: HandleResult) => void;\n\nif (LOCAL_SHOULD_LOG) {\n  debugCompiler = (context: TemplateCompilationContext, result: HandleResult) => {\n    let handle = extractHandle(result);\n    let { heap } = context.program;\n    let start = heap.getaddr(handle);\n    let end = start + heap.sizeof(handle);\n\n    debugSlice(context, start, end);\n  };\n}\n","import type {\n  CompileTimeConstants,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Expressions,\n  Owner,\n  ResolutionTimeConstants,\n  ResolveComponentOp,\n  ResolveComponentOrHelperOp,\n  ResolveHelperOp,\n  ResolveModifierOp,\n  ResolveOptionalComponentOrHelperOp,\n  ResolveOptionalHelperOp,\n  SexpOpcode,\n} from '@glimmer/interfaces';\nimport { assert, debugToString, expect, unwrap } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nfunction isGetLikeTuple(opcode: Expressions.Expression): opcode is Expressions.TupleExpression {\n  return Array.isArray(opcode) && opcode.length === 2;\n}\n\nfunction makeResolutionTypeVerifier(typeToVerify: SexpOpcode) {\n  return (\n    opcode: Expressions.Expression\n  ): opcode is Expressions.GetFree | Expressions.GetLexicalSymbol => {\n    if (!isGetLikeTuple(opcode)) return false;\n\n    let type = opcode[0];\n\n    return (\n      type === SexpOpcodes.GetStrictKeyword ||\n      type === SexpOpcodes.GetLexicalSymbol ||\n      type === typeToVerify\n    );\n  };\n}\n\nexport const isGetFreeComponent = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);\n\nexport const isGetFreeModifier = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);\n\nexport const isGetFreeHelper = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);\n\nexport const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHead\n);\n\nexport const isGetFreeOptionalHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsHelperHeadOrThisFallback\n);\n\nexport function isGetFreeDeprecatedHelper(\n  opcode: Expressions.Expression\n): opcode is Expressions.GetPathFreeAsDeprecatedHelperHeadOrThisFallback {\n  return (\n    Array.isArray(opcode) && opcode[0] === SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback\n  );\n}\n\nexport const isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback\n);\n\ninterface ResolvedContainingMetadata extends ContainingMetadata {\n  owner: Owner;\n  upvars: string[];\n}\n\nfunction assertResolverInvariants(meta: ContainingMetadata): ResolvedContainingMetadata {\n  if (import.meta.env.DEV) {\n    if (!meta.upvars) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no free vars were found'\n      );\n    }\n\n    if (!meta.owner) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from'\n      );\n    }\n  }\n\n  return meta as unknown as ResolvedContainingMetadata;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nexport function resolveComponent(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveComponentOp\n): void {\n  assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');\n\n  let type = expr[0];\n\n  if (import.meta.env.DEV && expr[0] === SexpOpcodes.GetStrictKeyword) {\n    throw new Error(\n      `Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(\n      constants.component(\n        definition as object,\n        expect(owner, 'BUG: expected owner when resolving component definition')\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner)!;\n\n    if (import.meta.env.DEV && (typeof definition !== 'object' || definition === null)) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n      );\n    }\n\n    then(constants.resolvedComponent(definition, name));\n  }\n}\n\n/**\n * (helper)\n * (helper arg)\n */\nexport function resolveHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveHelperOp\n): void {\n  assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.helper(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    then(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'helper')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let helper = resolver.lookupHelper(name, owner)!;\n\n    if (import.meta.env.DEV && helper === null) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`\n      );\n    }\n\n    then(constants.helper(helper, name));\n  }\n}\n\n/**\n * <div {{modifier}}/>\n * <div {{modifier arg}}/>\n * <Foo {{modifier}}/>\n */\nexport function resolveModifier(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveModifierOp\n): void {\n  assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.modifier(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    let { upvars } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupBuiltInModifier(name);\n\n    if (import.meta.env.DEV && modifier === null) {\n      throw new Error(\n        `Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`\n      );\n    }\n\n    then(constants.modifier(modifier!, name));\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupModifier(name, owner)!;\n\n    if (import.meta.env.DEV && modifier === null) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`\n      );\n    }\n\n    then(constants.modifier(modifier, name));\n  }\n}\n\n/**\n * {{component-or-helper arg}}\n */\nexport function resolveComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper }]: ResolveComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve a component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    let component = constants.component(\n      definition as object,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition as object, null, true);\n\n    if (import.meta.env.DEV && helper === null) {\n      throw new Error(\n        `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    ifHelper(expect(helper, 'BUG: helper must exist'));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(\n        expr as Expressions.GetStrictFree,\n        resolver,\n        meta,\n        constants,\n        'component or helper'\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n    } else {\n      let helper = resolver.lookupHelper(name, owner);\n\n      if (import.meta.env.DEV && helper === null) {\n        throw new Error(\n          `Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`\n        );\n      }\n\n      ifHelper(constants.helper(helper!, name));\n    }\n  }\n}\n\n/**\n * <Foo @arg={{helper}}>\n */\nexport function resolveOptionalHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifHelper }]: ResolveOptionalHelperOp\n): void {\n  assert(\n    isGetFreeOptionalHelper(expr) || isGetFreeDeprecatedHelper(expr),\n    'Attempted to resolve a helper with incorrect opcode'\n  );\n  let { upvars, owner } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupHelper(name, owner);\n\n  if (helper) {\n    ifHelper(constants.helper(helper, name), name, meta.moduleName);\n  }\n}\n\n/**\n * {{maybeHelperOrComponent}}\n */\nexport function resolveOptionalComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper, ifValue }]: ResolveOptionalComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeOptionalComponentOrHelper(expr),\n    'Attempted to resolve an optional component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    if (\n      typeof definition !== 'function' &&\n      (typeof definition !== 'object' || definition === null)\n    ) {\n      // The value is not an object, so it can't be a component or helper.\n      ifValue(constants.value(definition));\n      return;\n    }\n\n    let component = constants.component(\n      definition,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition, null, true);\n\n    if (helper !== null) {\n      ifHelper(helper);\n      return;\n    }\n\n    ifValue(constants.value(definition));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'value')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n      return;\n    }\n\n    let helper = resolver.lookupHelper(name, owner);\n\n    if (helper !== null) {\n      ifHelper(constants.helper(helper, name));\n    }\n  }\n}\n\nfunction lookupBuiltInHelper(\n  expr: Expressions.GetStrictFree,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  constants: ResolutionTimeConstants,\n  type: string\n): number {\n  let { upvars } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupBuiltInHelper(name);\n\n  if (import.meta.env.DEV && helper === null) {\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw new Error(\n      `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  return constants.helper(helper!, name);\n}\n","import type {\n  HighLevelEnd,\n  HighLevelLabel,\n  HighLevelResolveComponent,\n  HighLevelResolveComponentOrHelper,\n  HighLevelResolveFree,\n  HighLevelResolveHelper,\n  HighLevelResolveLocal,\n  HighLevelResolveModifier,\n  HighLevelResolveOptionalComponentOrHelper,\n  HighLevelResolveOptionalHelper,\n  HighLevelResolveTemplateLocal,\n  HighLevelStart,\n  HighLevelStartLabels,\n  HighLevelStopLabels,\n} from '@glimmer/interfaces';\n\nexport const HighLevelResolutionOpcodes = {\n  Modifier: 1003 satisfies HighLevelResolveModifier,\n  Component: 1004 satisfies HighLevelResolveComponent,\n  Helper: 1005 satisfies HighLevelResolveHelper,\n  OptionalHelper: 1006 satisfies HighLevelResolveOptionalHelper,\n  ComponentOrHelper: 1007 satisfies HighLevelResolveComponentOrHelper,\n  OptionalComponentOrHelper: 1008 satisfies HighLevelResolveOptionalComponentOrHelper,\n  Free: 1009 satisfies HighLevelResolveFree,\n  Local: 1010 satisfies HighLevelResolveLocal,\n  TemplateLocal: 1011 satisfies HighLevelResolveTemplateLocal,\n} as const;\n\nexport const HighLevelBuilderOpcodes = {\n  Label: 1000 satisfies HighLevelLabel,\n  StartLabels: 1001 satisfies HighLevelStartLabels,\n  StopLabels: 1002 satisfies HighLevelStopLabels,\n  Start: 1000 satisfies HighLevelStart,\n  End: 1002 satisfies HighLevelEnd,\n} as const;\n","import type {\n  BlockOperand,\n  BlockOperandType,\n  CompilableTemplate,\n  DebugSymbolsOperand,\n  DebugSymbolsOperandType,\n  IsStrictModeOperand,\n  IsStrictModeOperandType,\n  LabelOperand,\n  LabelOperandType,\n  LayoutOperand,\n  LayoutOperandType,\n  NonSmallIntOperand,\n  NonSmallIntOperandType,\n  SerializedBlock,\n  SerializedInlineBlock,\n  StdLibOperand,\n  StdLibOperandType,\n  SymbolTable,\n  SymbolTableOperand,\n  SymbolTableOperandType,\n} from '@glimmer/interfaces';\nimport { assert, isSmallInt } from '@glimmer/util';\n\nexport const HighLevelOperands = {\n  Label: 1 satisfies LabelOperandType,\n  IsStrictMode: 2 satisfies IsStrictModeOperandType,\n  DebugSymbols: 3 satisfies DebugSymbolsOperandType,\n  Block: 4 satisfies BlockOperandType,\n  StdLib: 5 satisfies StdLibOperandType,\n  NonSmallInt: 6 satisfies NonSmallIntOperandType,\n  SymbolTable: 7 satisfies SymbolTableOperandType,\n  Layout: 8 satisfies LayoutOperandType,\n} as const;\n\nexport function labelOperand(value: string): LabelOperand {\n  return { type: HighLevelOperands.Label, value };\n}\n\nexport function debugSymbolsOperand(): DebugSymbolsOperand {\n  return { type: HighLevelOperands.DebugSymbols, value: undefined };\n}\n\nexport function isStrictMode(): IsStrictModeOperand {\n  return { type: HighLevelOperands.IsStrictMode, value: undefined };\n}\n\nexport function blockOperand(value: SerializedInlineBlock | SerializedBlock): BlockOperand {\n  return { type: HighLevelOperands.Block, value };\n}\n\nexport function stdlibOperand(\n  value:\n    | 'main'\n    | 'trusting-append'\n    | 'cautious-append'\n    | 'trusting-non-dynamic-append'\n    | 'cautious-non-dynamic-append'\n): StdLibOperand {\n  return { type: HighLevelOperands.StdLib, value };\n}\n\nexport function nonSmallIntOperand(value: number): NonSmallIntOperand {\n  assert(\n    !isSmallInt(value),\n    'Attempted to make a operand for an int that was not a small int, you should encode this as an immediate'\n  );\n  return { type: HighLevelOperands.NonSmallInt, value };\n}\n\nexport function symbolTableOperand(value: SymbolTable): SymbolTableOperand {\n  return { type: HighLevelOperands.SymbolTable, value };\n}\n\nexport function layoutOperand(value: CompilableTemplate): LayoutOperand {\n  return { type: HighLevelOperands.Layout, value };\n}\n","import type {\n  BuilderOp,\n  BuilderOpcode,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Dict,\n  Encoder,\n  EncoderError,\n  HandleResult,\n  HighLevelOp,\n  InstructionEncoder,\n  Operand,\n  ResolutionTimeConstants,\n  SingleBuilderOperand,\n  STDLib,\n} from '@glimmer/interfaces';\nimport { InstructionEncoderImpl } from '@glimmer/encoder';\nimport {\n  assert,\n  dict,\n  EMPTY_STRING_ARRAY,\n  encodeHandle,\n  expect,\n  isPresentArray,\n  Stack,\n} from '@glimmer/util';\nimport { ARG_SHIFT, isMachineOp, MACHINE_MASK, MachineOp, Op, TYPE_SIZE } from '@glimmer/vm';\n\nimport { compilableBlock } from '../compilable-template';\nimport {\n  resolveComponent,\n  resolveComponentOrHelper,\n  resolveHelper,\n  resolveModifier,\n  resolveOptionalComponentOrHelper,\n  resolveOptionalHelper,\n} from './helpers/resolution';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from './opcodes';\nimport { HighLevelOperands } from './operands';\n\nexport class Labels {\n  labels: Dict<number> = dict();\n  targets: Array<{ at: number; target: string }> = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, target: string) {\n    this.targets.push({ at, target });\n  }\n\n  patch(heap: CompileTimeHeap): void {\n    let { targets, labels } = this;\n\n    for (const { at, target } of targets) {\n      let address = labels[target]! - at;\n\n      assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not');\n\n      heap.setbyaddr(at, address);\n    }\n  }\n}\n\nexport function encodeOp(\n  encoder: Encoder,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  op: BuilderOp | HighLevelOp\n): void {\n  if (isBuilderOpcode(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...(operands as SingleBuilderOperand[]));\n  } else {\n    switch (op[0]) {\n      case HighLevelBuilderOpcodes.Label:\n        return encoder.label(op[1]);\n      case HighLevelBuilderOpcodes.StartLabels:\n        return encoder.startLabels();\n      case HighLevelBuilderOpcodes.StopLabels:\n        return encoder.stopLabels();\n\n      case HighLevelResolutionOpcodes.Component:\n        return resolveComponent(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Modifier:\n        return resolveModifier(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Helper:\n        return resolveHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.ComponentOrHelper:\n        return resolveComponentOrHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalHelper:\n        return resolveOptionalHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalComponentOrHelper:\n        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);\n\n      case HighLevelResolutionOpcodes.Local: {\n        let freeVar = op[1];\n        let name = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n          freeVar\n        ]!;\n\n        let andThen = op[2];\n        andThen(name, meta.moduleName);\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.TemplateLocal: {\n        let [, valueIndex, then] = op;\n        let value = expect(\n          meta.scopeValues,\n          'BUG: Attempted to gect a template local, but template does not have any'\n        )[valueIndex];\n\n        then(constants.value(value));\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.Free:\n        if (import.meta.env.DEV) {\n          let [, upvarIndex] = op;\n          let freeName = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n            upvarIndex\n          ];\n\n          throw new Error(\n            `Attempted to resolve a value in a strict mode template, but that value was not in scope: ${freeName}`\n          );\n        }\n        break;\n\n      default:\n        throw new Error(`Unexpected high level opcode ${op[0]}`);\n    }\n  }\n}\n\nexport class EncoderImpl implements Encoder {\n  private labelsStack = new Stack<Labels>();\n  private encoder: InstructionEncoder = new InstructionEncoderImpl([]);\n  private errors: EncoderError[] = [];\n  private handle: number;\n\n  constructor(\n    private heap: CompileTimeHeap,\n    private meta: ContainingMetadata,\n    private stdlib?: STDLib\n  ) {\n    this.handle = heap.malloc();\n  }\n\n  error(error: EncoderError): void {\n    this.encoder.encode(Op.Primitive, 0);\n    this.errors.push(error);\n  }\n\n  commit(size: number): HandleResult {\n    let handle = this.handle;\n\n    this.heap.pushMachine(MachineOp.Return);\n    this.heap.finishMalloc(handle, size);\n\n    if (isPresentArray(this.errors)) {\n      return { errors: this.errors, handle };\n    } else {\n      return handle;\n    }\n  }\n\n  push(\n    constants: CompileTimeConstants,\n    type: BuilderOpcode,\n    ...args: SingleBuilderOperand[]\n  ): void {\n    let { heap } = this;\n\n    if (import.meta.env.DEV && (type as number) > TYPE_SIZE) {\n      throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    }\n\n    let machine = isMachineOp(type) ? MACHINE_MASK : 0;\n    let first = type | machine | (args.length << ARG_SHIFT);\n\n    heap.pushRaw(first);\n\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n\n  private operand(constants: CompileTimeConstants, operand: SingleBuilderOperand): Operand {\n    if (typeof operand === 'number') {\n      return operand;\n    }\n\n    if (typeof operand === 'object' && operand !== null) {\n      if (Array.isArray(operand)) {\n        return encodeHandle(constants.array(operand));\n      } else {\n        switch (operand.type) {\n          case HighLevelOperands.Label:\n            this.currentLabels.target(this.heap.offset, operand.value);\n            return -1;\n\n          case HighLevelOperands.IsStrictMode:\n            return encodeHandle(constants.value(this.meta.isStrictMode));\n\n          case HighLevelOperands.DebugSymbols:\n            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));\n\n          case HighLevelOperands.Block:\n            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));\n\n          case HighLevelOperands.StdLib:\n            return expect(\n              this.stdlib,\n              'attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?'\n            )[operand.value];\n\n          case HighLevelOperands.NonSmallInt:\n          case HighLevelOperands.SymbolTable:\n          case HighLevelOperands.Layout:\n            return constants.value(operand.value);\n        }\n      }\n    }\n\n    return encodeHandle(constants.value(operand));\n  }\n\n  private get currentLabels(): Labels {\n    return expect(this.labelsStack.current, 'bug: not in a label stack');\n  }\n\n  label(name: string) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = expect(this.labelsStack.pop(), 'unbalanced push and pop labels');\n    label.patch(this.heap);\n  }\n}\n\nfunction isBuilderOpcode(op: number): op is BuilderOpcode {\n  return op < HighLevelBuilderOpcodes.Start;\n}\n","import type {\n  BlockSymbolTable,\n  BuilderOp,\n  CompilableBlock,\n  CompilableProgram,\n  CompilableTemplate,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  SerializedBlock,\n  SerializedInlineBlock,\n  Statement,\n  SymbolTable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { EMPTY_ARRAY } from '@glimmer/util';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { meta } from './opcode-builder/helpers/shared';\nimport { STATEMENTS } from './syntax/statements';\n\nexport const PLACEHOLDER_HANDLE = -1;\n\nclass CompilableTemplateImpl<S extends SymbolTable> implements CompilableTemplate<S> {\n  compiled: Nullable<HandleResult> = null;\n\n  constructor(\n    readonly statements: WireFormat.Statement[],\n    readonly meta: ContainingMetadata,\n    // Part of CompilableTemplate\n    readonly symbolTable: S,\n    // Used for debugging\n    readonly moduleName = 'plain block'\n  ) {}\n\n  // Part of CompilableTemplate\n  compile(context: CompileTimeCompilationContext): HandleResult {\n    return maybeCompile(this, context);\n  }\n}\n\nexport function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram {\n  let [statements, symbols, hasEval] = layout.block;\n  return new CompilableTemplateImpl(\n    statements,\n    meta(layout),\n    {\n      symbols,\n      hasEval,\n    },\n    moduleName\n  );\n}\n\nfunction maybeCompile(\n  compilable: CompilableTemplateImpl<SymbolTable>,\n  context: CompileTimeCompilationContext\n): HandleResult {\n  if (compilable.compiled !== null) return compilable.compiled;\n\n  compilable.compiled = PLACEHOLDER_HANDLE;\n\n  let { statements, meta } = compilable;\n\n  let result = compileStatements(statements, meta, context);\n  compilable.compiled = result;\n\n  return result;\n}\n\nexport function compileStatements(\n  statements: Statement[],\n  meta: ContainingMetadata,\n  syntaxContext: CompileTimeCompilationContext\n): HandleResult {\n  let sCompiler = STATEMENTS;\n  let context = templateCompilationContext(syntaxContext, meta);\n\n  let {\n    encoder,\n    program: { constants, resolver },\n  } = context;\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, meta, op as BuilderOp | HighLevelOp);\n  }\n\n  for (const statement of statements) {\n    sCompiler.compile(pushOp, statement);\n  }\n\n  let handle = context.encoder.commit(meta.size);\n\n  if (LOCAL_SHOULD_LOG) {\n    debugCompiler(context, handle);\n  }\n\n  return handle;\n}\n\nexport function compilableBlock(\n  block: SerializedInlineBlock | SerializedBlock,\n  containing: ContainingMetadata\n): CompilableBlock {\n  return new CompilableTemplateImpl<BlockSymbolTable>(block[0], containing, {\n    parameters: block[1] || (EMPTY_ARRAY as number[]),\n  });\n}\n","export class StdLib {\n  constructor(\n    public main: number,\n    private trustingGuardedAppend: number,\n    private cautiousGuardedAppend: number,\n    private trustingNonDynamicAppend: number,\n    private cautiousNonDynamicAppend: number\n  ) {}\n\n  get 'trusting-append'() {\n    return this.trustingGuardedAppend;\n  }\n\n  get 'cautious-append'() {\n    return this.cautiousGuardedAppend;\n  }\n\n  get 'trusting-non-dynamic-append'() {\n    return this.trustingNonDynamicAppend;\n  }\n\n  get 'cautious-non-dynamic-append'() {\n    return this.cautiousNonDynamicAppend;\n  }\n\n  getAppend(trusting: boolean) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n","import type { NamedBlocks, Nullable, SerializedInlineBlock, WireFormat } from '@glimmer/interfaces';\nimport { assign, dict, enumerate, unwrap } from '@glimmer/util';\n\ninterface NamedBlocksDict {\n  [key: string]: Nullable<WireFormat.SerializedInlineBlock>;\n}\n\nexport class NamedBlocksImpl implements NamedBlocks {\n  public names: string[];\n\n  constructor(private blocks: Nullable<NamedBlocksDict>) {\n    this.names = blocks ? Object.keys(blocks) : [];\n  }\n\n  get(name: string): Nullable<SerializedInlineBlock> {\n    if (!this.blocks) return null;\n\n    return this.blocks[name] || null;\n  }\n\n  has(name: string): boolean {\n    let { blocks } = this;\n    return blocks !== null && name in blocks;\n  }\n\n  with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks {\n    let { blocks } = this;\n\n    if (blocks) {\n      return new NamedBlocksImpl(assign({}, blocks, { [name]: block }));\n    } else {\n      return new NamedBlocksImpl({ [name]: block });\n    }\n  }\n\n  get hasAny(): boolean {\n    return this.blocks !== null;\n  }\n}\n\nexport const EMPTY_BLOCKS = new NamedBlocksImpl(null);\n\nexport function namedBlocks(blocks: WireFormat.Core.Blocks): NamedBlocks {\n  if (blocks === null) {\n    return EMPTY_BLOCKS;\n  }\n\n  let out: NamedBlocksDict = dict();\n\n  let [keys, values] = blocks;\n\n  for (const [i, key] of enumerate(keys)) {\n    out[key] = unwrap(values[i]);\n  }\n\n  return new NamedBlocksImpl(out);\n}\n","import type { CurriedType, NonSmallIntOperand, Nullable, WireFormat } from '@glimmer/interfaces';\nimport { encodeImmediate, isSmallInt } from '@glimmer/util';\nimport { $fp, $v0, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { isStrictMode, nonSmallIntOperand } from '../operands';\nimport { expr } from './expr';\nimport { SimpleArgs } from './shared';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport interface CompileHelper {\n  handle: number;\n  positional: Nullable<WireFormat.Core.Params>;\n  named: WireFormat.Core.Hash;\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void {\n  PushPrimitive(op, value);\n  op(Op.PrimitiveReference);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void {\n  let p: Primitive | NonSmallIntOperand = primitive;\n\n  if (typeof p === 'number') {\n    p = isSmallInt(p) ? encodeImmediate(p) : nonSmallIntOperand(p);\n  }\n\n  op(Op.Primitive, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function Call(\n  op: PushExpressionOp,\n  handle: number,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Helper, handle);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function CallDynamic(\n  op: PushExpressionOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  append?: () => void\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Dup, $fp, 1);\n  op(Op.DynamicHelper);\n  if (append) {\n    op(Op.Fetch, $v0);\n    append();\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n  } else {\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n    op(Op.Fetch, $v0);\n  }\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nexport function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void {\n  op(Op.PushDynamicScope);\n  op(Op.BindDynamicScope, names);\n  block();\n  op(Op.PopDynamicScope);\n}\n\nexport function Curry(\n  op: PushExpressionOp,\n  type: CurriedType,\n  definition: WireFormat.Expression,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.CaptureArgs);\n  expr(op, definition);\n  op(Op.Curry, type, isStrictMode());\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n","import type { BuilderOp, HighLevelOp, SexpOpcode, SexpOpcodeMap } from '@glimmer/interfaces';\nimport { assert, unwrap } from '@glimmer/util';\n\nexport type PushExpressionOp = (...op: BuilderOp | HighLevelOp) => void;\n\ndeclare const STATEMENT: unique symbol;\n\nexport type HighLevelStatementOp = [{ [STATEMENT]: undefined }];\n\nexport type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;\n\nexport type CompilerFunction<PushOp extends PushExpressionOp, TSexp> = (\n  op: PushOp,\n  sexp: TSexp\n) => void;\n\nexport class Compilers<PushOp extends PushExpressionOp, TSexpOpcodes extends SexpOpcode> {\n  private names: {\n    [name: number]: number;\n  } = {};\n\n  private funcs: CompilerFunction<PushOp, any>[] = [];\n\n  add<TSexpOpcode extends TSexpOpcodes>(\n    name: TSexpOpcode,\n    func: CompilerFunction<PushOp, SexpOpcodeMap[TSexpOpcode]>\n  ): void {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n\n  compile(op: PushOp, sexp: SexpOpcodeMap[TSexpOpcodes]): void {\n    let name = sexp[0];\n    let index = unwrap(this.names[name]);\n    let func = this.funcs[index];\n    assert(!!func, `expected an implementation for ${sexp[0]}`);\n\n    func(op, sexp);\n  }\n}\n","import type { ExpressionSexpOpcode } from '@glimmer/interfaces';\nimport { assert, deprecate } from '@glimmer/global-context';\nimport { $v0, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushExpressionOp } from './compilers';\n\nimport { expr } from '../opcode-builder/helpers/expr';\nimport { isGetFreeHelper } from '../opcode-builder/helpers/resolution';\nimport { SimpleArgs } from '../opcode-builder/helpers/shared';\nimport { Call, CallDynamic, Curry, PushPrimitiveReference } from '../opcode-builder/helpers/vm';\nimport { HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { Compilers } from './compilers';\n\nexport const EXPRESSIONS = new Compilers<PushExpressionOp, ExpressionSexpOpcode>();\n\nEXPRESSIONS.add(SexpOpcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) {\n    expr(op, part);\n  }\n\n  op(Op.Concat, parts.length);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Call, (op, [, expression, positional, named]) => {\n  if (isGetFreeHelper(expression)) {\n    op(HighLevelResolutionOpcodes.Helper, expression, (handle: number) => {\n      Call(op, handle, positional, named);\n    });\n  } else {\n    expr(op, expression);\n    CallDynamic(op, positional, named);\n  }\n});\n\nEXPRESSIONS.add(SexpOpcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetSymbol, (op, [, sym, path]) => {\n  op(Op.GetVariable, sym);\n  withPath(op, path);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(HighLevelResolutionOpcodes.TemplateLocal, sym, (handle: number) => {\n    op(Op.ConstantReference, handle);\n    withPath(op, path);\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetStrictKeyword, (op, [, sym, _path]) => {\n  op(HighLevelResolutionOpcodes.Free, sym, (_handle: unknown) => {\n    // TODO: Implement in strict mode\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback, () => {\n  // TODO: The logic for this opcode currently exists in STATEMENTS.Append, since\n  // we want different wrapping logic depending on if we are invoking a component,\n  // helper, or {{this}} fallback. Eventually we fix the opcodes so that we can\n  // traverse the subexpression tree like normal in this location.\n  throw new Error('unimplemented opcode');\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHeadOrThisFallback, (op, expr) => {\n  // <div id={{baz}}>\n\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.OptionalHelper, expr, {\n      ifHelper: (handle: number) => {\n        Call(op, handle, null, null);\n      },\n    });\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback, (op, expr) => {\n  // <Foo @bar={{baz}}>\n\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.OptionalHelper, expr, {\n      ifHelper: (handle: number, name: string, moduleName: string) => {\n        assert(expr[2] && expr[2].length === 1, '[BUG] Missing argument name');\n\n        let arg = expr[2][0];\n\n        deprecate(\n          `The \\`${name}\\` helper was used in the \\`${moduleName}\\` template as \\`${arg}={{${name}}}\\`. ` +\n            `This is ambigious between wanting the \\`${arg}\\` argument to be the \\`${name}\\` helper itself, ` +\n            `or the result of invoking the \\`${name}\\` helper (current behavior). ` +\n            `This implicit invocation behavior has been deprecated.\\n\\n` +\n            `Instead, please explicitly invoke the helper with parenthesis, i.e. \\`${arg}={{(${name})}}\\`.\\n\\n` +\n            `Note: the parenthesis are only required in this exact scenario where an ambiguity is present â€“ where ` +\n            `\\`${name}\\` referes to a global helper (as opposed to a local variable), AND ` +\n            `the \\`${name}\\` helper invocation does not take any arguments, AND ` +\n            `this occurs in a named argument position of a component invocation.\\n\\n` +\n            `We expect this combination to be quite rare, as most helpers require at least one argument. ` +\n            `There is no need to refactor helper invocations in cases where this deprecation was not triggered.`,\n          false,\n          {\n            id: 'argument-less-helper-paren-less-invocation',\n          }\n        );\n\n        Call(op, handle, null, null);\n      },\n    });\n  });\n});\n\nfunction withPath(op: PushExpressionOp, path?: string[]) {\n  if (path === undefined || path.length === 0) return;\n\n  for (let i = 0; i < path.length; i++) {\n    op(Op.GetProperty, path[i]);\n  }\n}\n\nEXPRESSIONS.add(SexpOpcodes.Undefined, (op) => PushPrimitiveReference(op, undefined));\nEXPRESSIONS.add(SexpOpcodes.HasBlock, (op, [, block]) => {\n  expr(op, block);\n  op(Op.HasBlock);\n});\n\nEXPRESSIONS.add(SexpOpcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.HasBlockParams);\n});\n\nEXPRESSIONS.add(SexpOpcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy);\n  expr(op, truthy);\n  expr(op, condition);\n  op(Op.IfInline);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Not, (op, [, value]) => {\n  expr(op, value);\n  op(Op.Not);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression);\n  op(Op.GetDynamicVar);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Log, (op, [, positional]) => {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, null, false);\n  op(Op.Log);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n});\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp } from '../../syntax/compilers';\n\nimport { EXPRESSIONS } from '../../syntax/expressions';\nimport { PushPrimitive } from './vm';\n\nexport function expr(op: PushExpressionOp, expression: WireFormat.Expression): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(op, expression);\n  } else {\n    PushPrimitive(op, expression);\n    op(Op.PrimitiveReference);\n  }\n}\n","import type {\n  ContainingMetadata,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { EMPTY_ARRAY, EMPTY_STRING_ARRAY } from '@glimmer/util';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { PushYieldableBlock } from './blocks';\nimport { expr } from './expr';\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nexport function CompileArgs(\n  op: PushStatementOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  blocks: NamedBlocks,\n  atNames: boolean\n): void {\n  let blockNames: string[] = blocks.names;\n  for (const name of blockNames) {\n    PushYieldableBlock(op, blocks.get(name));\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  if (blocks) {\n    flags |= 0b111;\n  }\n\n  let names = EMPTY_ARRAY as readonly string[];\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names as string[], blockNames, flags);\n}\n\nexport function SimpleArgs(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>,\n  named: Nullable<WireFormat.Core.Hash>,\n  atNames: boolean\n): void {\n  if (positional === null && named === null) {\n    op(Op.PushEmptyArgs);\n    return;\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  let names = EMPTY_STRING_ARRAY;\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nexport function CompilePositional(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>\n): number {\n  if (positional === null) return 0;\n\n  for (let i = 0; i < positional.length; i++) {\n    expr(op, positional[i]);\n  }\n\n  return positional.length;\n}\n\nexport function meta(layout: LayoutWithContext): ContainingMetadata {\n  let [, symbols, , upvars] = layout.block;\n\n  return {\n    evalSymbols: evalSymbols(layout),\n    upvars: upvars,\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: symbols.length,\n  };\n}\n\nexport function evalSymbols(layout: LayoutWithContext): Nullable<string[]> {\n  let { block } = layout;\n  let [, symbols, hasEval] = block;\n\n  return hasEval ? symbols : null;\n}\n","import type { Nullable, WireFormat } from '@glimmer/interfaces';\nimport { $fp, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { blockOperand, symbolTableOperand } from '../operands';\nimport { SimpleArgs } from './shared';\nimport { PushPrimitive } from './vm';\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nexport function YieldBlock(\n  op: PushStatementOp,\n  to: number,\n  positional: Nullable<WireFormat.Core.Params>\n): void {\n  SimpleArgs(op, positional, null, true);\n  op(Op.GetBlock, to);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.InvokeYield);\n  op(Op.PopScope);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nexport function PushYieldableBlock(\n  op: PushStatementOp,\n  block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  PushSymbolTable(op, block && block[1]);\n  op(Op.PushBlockScope);\n  PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nexport function InvokeStaticBlock(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock\n): void {\n  op(MachineOp.PushFrame);\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nexport function InvokeStaticBlockWithStack(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock,\n  callerCount: number\n): void {\n  let parameters = block[1];\n  let calleeCount = parameters.length;\n  let count = Math.min(callerCount, calleeCount);\n\n  if (count === 0) {\n    InvokeStaticBlock(op, block);\n    return;\n  }\n\n  op(MachineOp.PushFrame);\n\n  if (count) {\n    op(Op.ChildScope);\n\n    for (let i = 0; i < count; i++) {\n      op(Op.Dup, $fp, callerCount - i);\n      op(Op.SetVariable, parameters[i]);\n    }\n  }\n\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n\n  if (count) {\n    op(Op.PopScope);\n  }\n\n  op(MachineOp.PopFrame);\n}\n\nexport function PushSymbolTable(op: PushExpressionOp, parameters: number[] | null): void {\n  if (parameters !== null) {\n    op(Op.PushSymbolTable, symbolTableOperand({ parameters }));\n  } else {\n    PushPrimitive(op, null);\n  }\n}\n\nexport function PushCompilable(\n  op: PushExpressionOp,\n  _block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  if (_block === null) {\n    PushPrimitive(op, null);\n  } else {\n    op(Op.Constant, blockOperand(_block));\n  }\n}\n","import { unwrap } from '@glimmer/util';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushStatementOp } from '../../syntax/compilers';\n\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { labelOperand } from '../operands';\n\nexport type When = (match: number, callback: () => void) => void;\n\nexport function SwitchCases(\n  op: PushStatementOp,\n  bootstrap: () => void,\n  matcher: (when: When) => void\n): void {\n  // Setup the switch DSL\n  let clauses: Array<{ match: number; label: string; callback: () => void }> = [];\n\n  let count = 0;\n\n  function when(match: number, callback: () => void): void {\n    clauses.push({ match, callback, label: `CLAUSE${count++}` });\n  }\n\n  // Call the callback\n  matcher(when);\n\n  // Emit the opcodes for the switch\n  op(Op.Enter, 1);\n  bootstrap();\n  op(HighLevelBuilderOpcodes.StartLabels);\n\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) {\n    op(Op.JumpEq, labelOperand(clause.label), clause.match);\n  }\n\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = unwrap(clauses[i]);\n\n    op(HighLevelBuilderOpcodes.Label, clause.label);\n    op(Op.Pop, 1);\n    clause.callback();\n\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    if (i !== 0) {\n      op(MachineOp.Jump, labelOperand('END'));\n    }\n  }\n\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(HighLevelBuilderOpcodes.StopLabels);\n  op(Op.Exit);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nexport function Replayable(op: PushStatementOp, args: () => number, body: () => void): void {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n\n  op(HighLevelBuilderOpcodes.StartLabels);\n  op(MachineOp.PushFrame);\n\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(MachineOp.ReturnTo, labelOperand('ENDINITIAL'));\n\n  // Push the arguments onto the stack. The args() function\n  // tells us how many stack elements to retain for re-execution\n  // when updating.\n  let count = args();\n\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  //\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(Op.Enter, count);\n\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body();\n\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(HighLevelBuilderOpcodes.Label, 'FINALLY');\n\n  // Finalize the DOM.\n  op(Op.Exit);\n\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(MachineOp.Return);\n\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(HighLevelBuilderOpcodes.Label, 'ENDINITIAL');\n  op(MachineOp.PopFrame);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nexport function ReplayableIf(\n  op: PushStatementOp,\n  args: () => number,\n  ifTrue: () => void,\n  ifFalse?: () => void\n): void {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(Op.JumpUnless, labelOperand('ELSE'));\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue();\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(MachineOp.Jump, labelOperand('FINALLY'));\n    op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    if (ifFalse !== undefined) {\n      ifFalse();\n    }\n  });\n}\n","import type {\n  CapabilityMask,\n  CompilableProgram,\n  CompileTimeComponent,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport type { SavedRegister } from '@glimmer/vm';\nimport { hasCapability } from '@glimmer/manager';\nimport { EMPTY_STRING_ARRAY, reverse, unwrap } from '@glimmer/util';\nimport { $s0, $s1, $sp, InternalComponentCapabilities, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { namedBlocks } from '../../utils';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { isStrictMode, labelOperand, layoutOperand, symbolTableOperand } from '../operands';\nimport { InvokeStaticBlock, PushYieldableBlock, YieldBlock } from './blocks';\nimport { Replayable } from './conditional';\nimport { expr } from './expr';\nimport { CompileArgs, CompilePositional } from './shared';\n\nexport const ATTRS_BLOCK = '&attrs';\n\ninterface AnyComponent {\n  elementBlock: Nullable<WireFormat.SerializedInlineBlock>;\n  positional: WireFormat.Core.Params;\n  named: WireFormat.Core.Hash;\n  blocks: NamedBlocks;\n}\n\n// {{component}}\nexport interface DynamicComponent extends AnyComponent {\n  definition: WireFormat.Expression;\n  atNames: boolean;\n  curried: boolean;\n}\n\n// <Component>\nexport interface StaticComponent extends AnyComponent {\n  capabilities: CapabilityMask;\n  layout: CompilableProgram;\n}\n\n// chokepoint\nexport interface Component extends AnyComponent {\n  // either we know the capabilities statically or we need to be conservative and assume\n  // that the component requires all capabilities\n  capabilities: CapabilityMask | true;\n\n  // are the arguments supplied as atNames?\n  atNames: boolean;\n\n  // do we have the layout statically or will we need to look it up at runtime?\n  layout?: CompilableProgram;\n}\n\nexport function InvokeComponent(\n  op: PushStatementOp,\n  component: CompileTimeComponent,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks\n): void {\n  let { compilable, capabilities, handle } = component;\n\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  if (compilable) {\n    op(Op.PushComponentDefinition, handle);\n    InvokeStaticComponent(op, {\n      capabilities: capabilities,\n      layout: compilable,\n      elementBlock,\n      positional,\n      named,\n      blocks,\n    });\n  } else {\n    op(Op.PushComponentDefinition, handle);\n    InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n    });\n  }\n}\n\nexport function InvokeDynamicComponent(\n  op: PushStatementOp,\n  definition: WireFormat.Core.Expression,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks,\n  atNames: boolean,\n  curried: boolean\n): void {\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  Replayable(\n    op,\n\n    () => {\n      expr(op, definition);\n      op(Op.Dup, $sp, 0);\n      return 2;\n    },\n\n    () => {\n      op(Op.JumpUnless, labelOperand('ELSE'));\n\n      if (curried) {\n        op(Op.ResolveCurriedComponent);\n      } else {\n        op(Op.ResolveDynamicComponent, isStrictMode());\n      }\n\n      op(Op.PushDynamicComponentInstance);\n      InvokeNonStaticComponent(op, {\n        capabilities: true,\n        elementBlock,\n        positional,\n        named,\n        atNames,\n        blocks,\n      });\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n    }\n  );\n}\n\nfunction InvokeStaticComponent(\n  op: PushStatementOp,\n  { capabilities, layout, elementBlock, positional, named, blocks }: StaticComponent\n): void {\n  let { symbolTable } = layout;\n\n  let bailOut =\n    symbolTable.hasEval || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs);\n\n  if (bailOut) {\n    InvokeNonStaticComponent(op, {\n      capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n      layout,\n    });\n\n    return;\n  }\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n  op(MachineOp.PushFrame);\n\n  // Setup arguments\n  let { symbols } = symbolTable;\n\n  // As we push values onto the stack, we store the symbols associated  with them\n  // so that we can set them on the scope later on with SetVariable and SetBlock\n  let blockSymbols: number[] = [];\n  let argSymbols: number[] = [];\n  let argNames: string[] = [];\n\n  // First we push the blocks onto the stack\n  let blockNames = blocks.names;\n\n  // Starting with the attrs block, if it exists and is referenced in the component\n  if (elementBlock !== null) {\n    let symbol = symbols.indexOf(ATTRS_BLOCK);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, elementBlock);\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Followed by the other blocks, if they exist and are referenced in the component.\n  // Also store the index of the associated symbol.\n  for (const name of blockNames) {\n    let symbol = symbols.indexOf(`&${name}`);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, blocks.get(name));\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Next up we have arguments. If the component has the `createArgs` capability,\n  // then it wants access to the arguments in JavaScript. We can't know whether\n  // or not an argument is used, so we have to give access to all of them.\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    // First we push positional arguments\n    let count = CompilePositional(op, positional);\n\n    // setup the flags with the count of positionals, and to indicate that atNames\n    // are used\n    let flags = count << 4;\n    flags |= 0b1000;\n\n    let names: string[] = EMPTY_STRING_ARRAY;\n\n    // Next, if named args exist, push them all. If they have an associated symbol\n    // in the invoked component (e.g. they are used within its template), we push\n    // that symbol. If not, we still push the expression as it may be used, and\n    // we store the symbol as -1 (this is used later).\n    if (named !== null) {\n      names = named[0];\n      let val = named[1];\n\n      for (let i = 0; i < val.length; i++) {\n        let symbol = symbols.indexOf(unwrap(names[i]));\n\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n      }\n    }\n\n    // Finally, push the VM arguments themselves. These args won't need access\n    // to blocks (they aren't accessible from userland anyways), so we push an\n    // empty array instead of the actual block names.\n    op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n\n    // And push an extra pop operation to remove the args before we begin setting\n    // variables on the local context\n    argSymbols.push(-1);\n  } else if (named !== null) {\n    // If the component does not have the `createArgs` capability, then the only\n    // expressions we need to push onto the stack are those that are actually\n    // referenced in the template of the invoked component (e.g. have symbols).\n    let names = named[0];\n    let val = named[1];\n\n    for (let i = 0; i < val.length; i++) {\n      let name = unwrap(names[i]);\n      let symbol = symbols.indexOf(name);\n\n      if (symbol !== -1) {\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n        argNames.push(name);\n      }\n    }\n  }\n\n  op(Op.BeginComponentTransaction, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PushDynamicScope);\n  }\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createInstance)) {\n    op(Op.CreateComponent, (blocks.has('default') as any) | 0, $s0);\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    op(Op.GetComponentSelf, $s0);\n  } else {\n    op(Op.GetComponentSelf, $s0, argNames);\n  }\n\n  // Setup the new root scope for the component\n  op(Op.RootScope, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0);\n\n  // Pop the self reference off the stack and set it to the symbol for `this`\n  // in the new scope. This is why all subsequent symbols are increased by one.\n  op(Op.SetVariable, 0);\n\n  // Going in reverse, now we pop the args/blocks off the stack, starting with\n  // arguments, and assign them to their symbols in the new scope.\n  for (const symbol of reverse(argSymbols)) {\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n\n    if (symbol === -1) {\n      // The expression was not bound to a local symbol, it was only pushed to be\n      // used with VM args in the javascript side\n      op(Op.Pop, 1);\n    } else {\n      op(Op.SetVariable, symbol + 1);\n    }\n  }\n\n  // if any positional params exist, pop them off the stack as well\n  if (positional !== null) {\n    op(Op.Pop, positional.length);\n  }\n\n  // Finish up by popping off and assigning blocks\n  for (const symbol of reverse(blockSymbols)) {\n    op(Op.SetBlock, symbol + 1);\n  }\n\n  op(Op.Constant, layoutOperand(layout));\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(Op.DidRenderLayout, $s0);\n\n  op(MachineOp.PopFrame);\n  op(Op.PopScope);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PopDynamicScope);\n  }\n\n  op(Op.CommitComponentTransaction);\n  op(Op.Load, $s0);\n}\n\nexport function InvokeNonStaticComponent(\n  op: PushStatementOp,\n  { capabilities, elementBlock, positional, named, atNames, blocks: namedBlocks, layout }: Component\n): void {\n  let bindableBlocks = !!namedBlocks;\n  let bindableAtNames =\n    capabilities === true ||\n    hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) ||\n    !!(named && named[0].length !== 0);\n\n  let blocks = namedBlocks.with('attrs', elementBlock);\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  CompileArgs(op, positional, named, blocks, atNames);\n  op(Op.PrepareArgs, $s0);\n\n  invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, () => {\n    if (layout) {\n      op(Op.PushSymbolTable, symbolTableOperand(layout.symbolTable));\n      op(Op.Constant, layoutOperand(layout));\n      op(Op.CompileBlock);\n    } else {\n      op(Op.GetComponentLayout, $s0);\n    }\n\n    op(Op.PopulateLayout, $s0);\n  });\n\n  op(Op.Load, $s0);\n}\n\nexport function WrappedComponent(\n  op: PushStatementOp,\n  layout: LayoutWithContext,\n  attrsBlockNumber: number\n): void {\n  op(HighLevelBuilderOpcodes.StartLabels);\n  WithSavedRegister(op, $s1, () => {\n    op(Op.GetComponentTagName, $s0);\n    op(Op.PrimitiveReference);\n    op(Op.Dup, $sp, 0);\n  });\n  op(Op.JumpUnless, labelOperand('BODY'));\n  op(Op.Fetch, $s1);\n  op(Op.PutComponentOperations);\n  op(Op.OpenDynamicElement);\n  op(Op.DidCreateElement, $s0);\n  YieldBlock(op, attrsBlockNumber, null);\n  op(Op.FlushElement);\n  op(HighLevelBuilderOpcodes.Label, 'BODY');\n  InvokeStaticBlock(op, [layout.block[0], []]);\n  op(Op.Fetch, $s1);\n  op(Op.JumpUnless, labelOperand('END'));\n  op(Op.CloseElement);\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(Op.Load, $s1);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\nexport function invokePreparedComponent(\n  op: PushStatementOp,\n  hasBlock: boolean,\n  bindableBlocks: boolean,\n  bindableAtNames: boolean,\n  populateLayout: Nullable<() => void> = null\n): void {\n  op(Op.BeginComponentTransaction, $s0);\n  op(Op.PushDynamicScope);\n\n  op(Op.CreateComponent, (hasBlock as any) | 0, $s0);\n\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  if (populateLayout) {\n    populateLayout();\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n  op(Op.GetComponentSelf, $s0);\n\n  op(Op.VirtualRootScope, $s0);\n  op(Op.SetVariable, 0);\n  op(Op.SetupForEval, $s0);\n\n  if (bindableAtNames) op(Op.SetNamedVariables, $s0);\n  if (bindableBlocks) op(Op.SetBlocks, $s0);\n\n  op(Op.Pop, 1);\n  op(Op.InvokeComponentLayout, $s0);\n  op(Op.DidRenderLayout, $s0);\n  op(MachineOp.PopFrame);\n\n  op(Op.PopScope);\n  op(Op.PopDynamicScope);\n  op(Op.CommitComponentTransaction);\n}\n\nexport function InvokeBareComponent(op: PushStatementOp): void {\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  op(Op.PushEmptyArgs);\n  op(Op.PrepareArgs, $s0);\n  invokePreparedComponent(op, false, false, true, () => {\n    op(Op.GetComponentLayout, $s0);\n    op(Op.PopulateLayout, $s0);\n  });\n  op(Op.Load, $s0);\n}\n\nexport function WithSavedRegister(\n  op: PushExpressionOp,\n  register: SavedRegister,\n  block: () => void\n): void {\n  op(Op.Fetch, register);\n  block();\n  op(Op.Load, register);\n}\n","import type {\n  BuilderOp,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HighLevelOp,\n} from '@glimmer/interfaces';\nimport { $s0, ContentType, MachineOp, Op } from '@glimmer/vm';\n\nimport type { HighLevelStatementOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { encodeOp, EncoderImpl } from '../encoder';\nimport { StdLib } from '../stdlib';\nimport { InvokeBareComponent, invokePreparedComponent } from './components';\nimport { SwitchCases } from './conditional';\nimport { CallDynamic } from './vm';\n\nexport function main(op: PushStatementOp): void {\n  op(Op.Main, $s0);\n  invokePreparedComponent(op, false, false, true);\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nexport function StdAppend(\n  op: PushStatementOp,\n  trusting: boolean,\n  nonDynamicAppend: number | null\n): void {\n  SwitchCases(\n    op,\n    () => op(Op.ContentType),\n    (when) => {\n      when(ContentType.String, () => {\n        if (trusting) {\n          op(Op.AssertSame);\n          op(Op.AppendHTML);\n        } else {\n          op(Op.AppendText);\n        }\n      });\n\n      if (typeof nonDynamicAppend === 'number') {\n        when(ContentType.Component, () => {\n          op(Op.ResolveCurriedComponent);\n          op(Op.PushDynamicComponentInstance);\n          InvokeBareComponent(op);\n        });\n\n        when(ContentType.Helper, () => {\n          CallDynamic(op, null, null, () => {\n            op(MachineOp.InvokeStatic, nonDynamicAppend);\n          });\n        });\n      } else {\n        // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n        when(ContentType.Component, () => {\n          op(Op.AppendText);\n        });\n\n        when(ContentType.Helper, () => {\n          op(Op.AppendText);\n        });\n      }\n\n      when(ContentType.SafeString, () => {\n        op(Op.AssertSame);\n        op(Op.AppendSafeHTML);\n      });\n\n      when(ContentType.Fragment, () => {\n        op(Op.AssertSame);\n        op(Op.AppendDocumentFragment);\n      });\n\n      when(ContentType.Node, () => {\n        op(Op.AssertSame);\n        op(Op.AppendNode);\n      });\n    }\n  );\n}\n\nexport function compileStd(context: CompileTimeCompilationContext): StdLib {\n  let mainHandle = build(context, (op) => main(op));\n  let trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null));\n  let cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null));\n\n  let trustingGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, true, trustingGuardedNonDynamicAppend)\n  );\n  let cautiousGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, false, cautiousGuardedNonDynamicAppend)\n  );\n\n  return new StdLib(\n    mainHandle,\n    trustingGuardedDynamicAppend,\n    cautiousGuardedDynamicAppend,\n    trustingGuardedNonDynamicAppend,\n    cautiousGuardedNonDynamicAppend\n  );\n}\n\nexport const STDLIB_META: ContainingMetadata = {\n  evalSymbols: null,\n  upvars: null,\n  moduleName: 'stdlib',\n\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0,\n};\n\nfunction build(\n  program: CompileTimeCompilationContext,\n  builder: (op: PushStatementOp) => void\n): number {\n  let { constants, heap, resolver } = program;\n  let encoder = new EncoderImpl(heap, STDLIB_META);\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, STDLIB_META, op as BuilderOp | HighLevelOp);\n  }\n\n  builder(pushOp);\n\n  let result = encoder.commit(0);\n\n  if (typeof result !== 'number') {\n    // This shouldn't be possible\n    throw new Error(`Unexpected errors compiling std`);\n  } else {\n    return result;\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  CreateRuntimeOp,\n  ResolutionTimeConstants,\n  STDLib,\n} from '@glimmer/interfaces';\n\nimport { compileStd } from './opcode-builder/helpers/stdlib';\n\nexport class CompileTimeCompilationContextImpl implements CompileTimeCompilationContext {\n  readonly constants: CompileTimeConstants & ResolutionTimeConstants;\n  readonly heap: CompileTimeHeap;\n  readonly stdlib: STDLib;\n\n  constructor(\n    { constants, heap }: CompileTimeArtifacts,\n    readonly resolver: CompileTimeResolver,\n    readonly createOp: CreateRuntimeOp\n  ) {\n    this.constants = constants;\n    this.heap = heap;\n    this.stdlib = compileStd(this);\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeResolver,\n  ContainingMetadata,\n  CreateRuntimeOp,\n  TemplateCompilationContext,\n} from '@glimmer/interfaces';\n\nimport { CompileTimeCompilationContextImpl } from '../program-context';\nimport { EncoderImpl } from './encoder';\n\nexport function programCompilationContext(\n  artifacts: CompileTimeArtifacts,\n  resolver: CompileTimeResolver,\n  createOp: CreateRuntimeOp\n): CompileTimeCompilationContext {\n  return new CompileTimeCompilationContextImpl(artifacts, resolver, createOp);\n}\n\nexport function templateCompilationContext(\n  program: CompileTimeCompilationContext,\n  meta: ContainingMetadata\n): TemplateCompilationContext {\n  let encoder = new EncoderImpl(program.heap, meta, program.stdlib);\n\n  return {\n    program,\n    encoder,\n    meta,\n  };\n}\n","import type {\n  CompileTimeComponent,\n  StatementSexpOpcode,\n  WellKnownAttrName,\n  WellKnownTagName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { $fp, $sp, ContentType, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushStatementOp } from './compilers';\n\nimport {\n  InvokeStaticBlock,\n  InvokeStaticBlockWithStack,\n  YieldBlock,\n} from '../opcode-builder/helpers/blocks';\nimport {\n  InvokeComponent,\n  InvokeDynamicComponent,\n  InvokeNonStaticComponent,\n} from '../opcode-builder/helpers/components';\nimport { Replayable, ReplayableIf, SwitchCases } from '../opcode-builder/helpers/conditional';\nimport { expr } from '../opcode-builder/helpers/expr';\nimport {\n  isGetFreeComponent,\n  isGetFreeComponentOrHelper,\n  isGetFreeModifier,\n  isGetFreeOptionalComponentOrHelper,\n} from '../opcode-builder/helpers/resolution';\nimport { CompilePositional, SimpleArgs } from '../opcode-builder/helpers/shared';\nimport {\n  Call,\n  CallDynamic,\n  DynamicScope,\n  PushPrimitiveReference,\n} from '../opcode-builder/helpers/vm';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { debugSymbolsOperand, labelOperand, stdlibOperand } from '../opcode-builder/operands';\nimport { namedBlocks } from '../utils';\nimport { Compilers } from './compilers';\n\nexport const STATEMENTS = new Compilers<PushStatementOp, StatementSexpOpcode>();\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n\nSTATEMENTS.add(SexpOpcodes.Comment, (op, sexp) => op(Op.Comment, sexp[1]));\nSTATEMENTS.add(SexpOpcodes.CloseElement, (op) => op(Op.CloseElement));\nSTATEMENTS.add(SexpOpcodes.FlushElement, (op) => op(Op.FlushElement));\n\nSTATEMENTS.add(SexpOpcodes.Modifier, (op, [, expression, positional, named]) => {\n  if (isGetFreeModifier(expression)) {\n    op(HighLevelResolutionOpcodes.Modifier, expression, (handle: number) => {\n      op(MachineOp.PushFrame);\n      SimpleArgs(op, positional, named, false);\n      op(Op.Modifier, handle);\n      op(MachineOp.PopFrame);\n    });\n  } else {\n    expr(op, expression);\n    op(MachineOp.PushFrame);\n    SimpleArgs(op, positional, named, false);\n    op(Op.Dup, $fp, 1);\n    op(Op.DynamicModifier);\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticComponentAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElement, (op, [, tag]) => {\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(Op.PutComponentOperations);\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, elementBlock, null, named, blocks);\n    });\n  } else {\n    // otherwise, the component name was an expression, so resolve the expression\n    // and invoke it as a dynamic component\n    InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params));\n\nSTATEMENTS.add(SexpOpcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null));\n\nSTATEMENTS.add(SexpOpcodes.Debugger, (op, [, debugInfo]) =>\n  op(Op.Debugger, debugSymbolsOperand(), debugInfo)\n);\n\nSTATEMENTS.add(SexpOpcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else if (isGetFreeOptionalComponentOrHelper(value)) {\n    op(HighLevelResolutionOpcodes.OptionalComponentOrHelper, value, {\n      ifComponent(component: CompileTimeComponent) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n\n      ifHelper(handle: number) {\n        op(MachineOp.PushFrame);\n        Call(op, handle, null, null);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n\n      ifValue(handle: number) {\n        op(MachineOp.PushFrame);\n        op(Op.ConstantReference, handle);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n    });\n  } else if (value[0] === SexpOpcodes.Call) {\n    let [, expression, positional, named] = value;\n\n    if (isGetFreeComponentOrHelper(expression)) {\n      op(HighLevelResolutionOpcodes.ComponentOrHelper, expression, {\n        ifComponent(component: CompileTimeComponent) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle: number) {\n          op(MachineOp.PushFrame);\n          Call(op, handle, positional, named);\n          op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n          op(MachineOp.PopFrame);\n        },\n      });\n    } else {\n      SwitchCases(\n        op,\n        () => {\n          expr(op, expression);\n          op(Op.DynamicContentType);\n        },\n        (when) => {\n          when(ContentType.Component, () => {\n            op(Op.ResolveCurriedComponent);\n            op(Op.PushDynamicComponentInstance);\n            InvokeNonStaticComponent(op, {\n              capabilities: true,\n              elementBlock: null,\n              positional,\n              named,\n              atNames: false,\n              blocks: namedBlocks(null),\n            });\n          });\n\n          when(ContentType.Helper, () => {\n            CallDynamic(op, positional, named, () => {\n              op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n            });\n          });\n        }\n      );\n    }\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('cautious-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingAppend, (op, [, value]) => {\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('trusting-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, guid);\n\n      if (insertBefore === undefined) {\n        PushPrimitiveReference(op, undefined);\n      } else {\n        expr(op, insertBefore);\n      }\n\n      expr(op, destination);\n      op(Op.Dup, $sp, 0);\n\n      return 4;\n    },\n\n    () => {\n      op(Op.PushRemoteElement);\n      InvokeStaticBlock(op, block);\n      op(Op.PopRemoteElement);\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.If, (op, [, condition, block, inverse]) =>\n  ReplayableIf(\n    op,\n    () => {\n      expr(op, condition);\n      op(Op.ToBoolean);\n\n      return 1;\n    },\n\n    () => {\n      InvokeStaticBlock(op, block);\n    },\n\n    inverse\n      ? () => {\n          InvokeStaticBlock(op, inverse);\n        }\n      : undefined\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Each, (op, [, value, key, block, inverse]) =>\n  Replayable(\n    op,\n\n    () => {\n      if (key) {\n        expr(op, key);\n      } else {\n        PushPrimitiveReference(op, null);\n      }\n\n      expr(op, value);\n\n      return 2;\n    },\n\n    () => {\n      op(Op.EnterList, labelOperand('BODY'), labelOperand('ELSE'));\n      op(MachineOp.PushFrame);\n      op(Op.Dup, $fp, 1);\n      op(MachineOp.ReturnTo, labelOperand('ITER'));\n      op(HighLevelBuilderOpcodes.Label, 'ITER');\n      op(Op.Iterate, labelOperand('BREAK'));\n      op(HighLevelBuilderOpcodes.Label, 'BODY');\n      InvokeStaticBlockWithStack(op, block, 2);\n      op(Op.Pop, 2);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'BREAK');\n      op(MachineOp.PopFrame);\n      op(Op.ExitList);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.With, (op, [, value, block, inverse]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, value);\n      op(Op.Dup, $sp, 0);\n      op(Op.ToBoolean);\n\n      return 2;\n    },\n\n    () => {\n      InvokeStaticBlockWithStack(op, block, 1);\n    },\n\n    () => {\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.Let, (op, [, positional, block]) => {\n  let count = CompilePositional(op, positional);\n  InvokeStaticBlockWithStack(op, block, count);\n});\n\nSTATEMENTS.add(SexpOpcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n\n    CompilePositional(op, expressions);\n    DynamicScope(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else {\n    InvokeStaticBlock(op, block);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nfunction hashToArgs(hash: WireFormat.Core.Hash | null): WireFormat.Core.Hash | null {\n  if (hash === null) return null;\n  let names = hash[0].map((key) => `@${key}`);\n  return [names as [string, ...string[]], hash[1]];\n}\n","import type {\n  CompileTimeComponent,\n  InternalComponentCapabilities,\n  Nullable,\n} from '@glimmer/interfaces';\n\nexport const DEFAULT_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: true,\n  dynamicTag: true,\n  prepareArgs: true,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: true,\n  createCaller: false,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport const MINIMAL_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: false,\n  createCaller: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport interface ResolverDelegate<R = unknown> {\n  lookupHelper?(name: string, referrer: R): Nullable<number> | void;\n  lookupModifier?(name: string, referrer: R): Nullable<number> | void;\n  lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;\n\n  // For debugging\n  resolve?(handle: number): R;\n}\n","import type {\n  BuilderOp,\n  CompilableProgram,\n  CompileTimeCompilationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  ProgramSymbolTable,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';\nimport { meta } from './opcode-builder/helpers/shared';\n\nexport class WrappedBuilder implements CompilableProgram {\n  public symbolTable: ProgramSymbolTable;\n  private compiled: Nullable<number> = null;\n  private attrsBlockNumber: number;\n\n  constructor(\n    private layout: LayoutWithContext,\n    public moduleName: string\n  ) {\n    let { block } = layout;\n    let [, symbols, hasEval] = block;\n\n    symbols = symbols.slice();\n\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);\n    if (attrsBlockIndex === -1) {\n      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);\n    } else {\n      this.attrsBlockNumber = attrsBlockIndex + 1;\n    }\n\n    this.symbolTable = {\n      hasEval,\n      symbols,\n    };\n  }\n\n  compile(syntax: CompileTimeCompilationContext): HandleResult {\n    if (this.compiled !== null) return this.compiled;\n\n    let m = meta(this.layout);\n    let context = templateCompilationContext(syntax, m);\n\n    let {\n      encoder,\n      program: { constants, resolver },\n    } = context;\n\n    function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n      encodeOp(encoder, constants, resolver, m, op as BuilderOp | HighLevelOp);\n    }\n\n    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);\n\n    let handle = context.encoder.commit(m.size);\n\n    if (typeof handle !== 'number') {\n      return handle;\n    }\n\n    this.compiled = handle;\n\n    if (LOCAL_SHOULD_LOG) {\n      debugCompiler(context, handle);\n    }\n\n    return handle;\n  }\n}\n","import type {\n  CompilableProgram,\n  LayoutWithContext,\n  Nullable,\n  Owner,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  Template,\n  TemplateFactory,\n  TemplateOk,\n} from '@glimmer/interfaces';\nimport { assign } from '@glimmer/util';\n\nimport { compilable } from './compilable-template';\nimport { WrappedBuilder } from './wrapped-component';\n\nlet clientId = 0;\n\nexport let templateCacheCounters = {\n  cacheHit: 0,\n  cacheMiss: 0,\n};\n\n// These interfaces are for backwards compatibility, some addons use these intimate APIs\nexport interface TemplateFactoryWithIdAndMeta extends TemplateFactory {\n  __id?: string;\n  __meta?: { moduleName: string };\n}\n\nexport interface TemplateWithIdAndReferrer extends TemplateOk {\n  id: string;\n  referrer: {\n    moduleName: string;\n    owner: Owner | null;\n  };\n}\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nexport default function templateFactory({\n  id: templateId,\n  moduleName,\n  block,\n  scope,\n  isStrictMode,\n}: SerializedTemplateWithLazyBlock): TemplateFactory {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let id = templateId || `client-${clientId++}`;\n\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  let parsedBlock: SerializedTemplateBlock;\n\n  let ownerlessTemplate: Template | null = null;\n  let templateCache = new WeakMap<object, Template>();\n\n  let factory: TemplateFactoryWithIdAndMeta = (owner?: Owner) => {\n    if (parsedBlock === undefined) {\n      parsedBlock = JSON.parse(block);\n    }\n\n    if (owner === undefined) {\n      if (ownerlessTemplate === null) {\n        templateCacheCounters.cacheMiss++;\n        ownerlessTemplate = new TemplateImpl({\n          id,\n          block: parsedBlock,\n          moduleName,\n          owner: null,\n          scope,\n          isStrictMode,\n        });\n      } else {\n        templateCacheCounters.cacheHit++;\n      }\n\n      return ownerlessTemplate;\n    }\n\n    let result = templateCache.get(owner) as Template;\n\n    if (result === undefined) {\n      templateCacheCounters.cacheMiss++;\n      result = new TemplateImpl({ id, block: parsedBlock, moduleName, owner, scope, isStrictMode });\n      templateCache.set(owner, result);\n    } else {\n      templateCacheCounters.cacheHit++;\n    }\n\n    return result;\n  };\n\n  factory.__id = id;\n  factory.__meta = { moduleName };\n\n  return factory;\n}\n\nclass TemplateImpl implements TemplateWithIdAndReferrer {\n  readonly result = 'ok';\n\n  private layout: Nullable<CompilableProgram> = null;\n  private wrappedLayout: Nullable<CompilableProgram> = null;\n\n  constructor(private parsedLayout: LayoutWithContext) {}\n\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n\n  get id() {\n    return this.parsedLayout.id;\n  }\n\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner,\n    };\n  }\n\n  asLayout(): CompilableProgram {\n    if (this.layout) return this.layout;\n    return (this.layout = compilable(assign({}, this.parsedLayout), this.moduleName));\n  }\n\n  asWrappedLayout(): CompilableProgram {\n    if (this.wrappedLayout) return this.wrappedLayout;\n    return (this.wrappedLayout = new WrappedBuilder(\n      assign({}, this.parsedLayout),\n      this.moduleName\n    ));\n  }\n}\n"],"names":["LOCAL_SHOULD_LOG","window","location","test","search","debugCompiler","makeResolutionTypeVerifier","typeToVerify","opcode","Array","isArray","length","isGetLikeTuple","type","SexpOpcodes","GetStrictKeyword","GetLexicalSymbol","context","result","handle","extractHandle","heap","program","start","getaddr","end","sizeof","debugSlice","isGetFreeComponent","GetFreeAsComponentHead","isGetFreeModifier","GetFreeAsModifierHead","isGetFreeHelper","GetFreeAsHelperHead","isGetFreeComponentOrHelper","GetFreeAsComponentOrHelperHead","isGetFreeOptionalHelper","GetFreeAsHelperHeadOrThisFallback","isGetFreeOptionalComponentOrHelper","GetFreeAsComponentOrHelperHeadOrThisFallback","assertResolverInvariants","meta","upvars","Error","owner","resolveOptionalHelper","resolver","constants","expr","ifHelper","assert","GetFreeAsDeprecatedHelperHeadOrThisFallback","name","unwrap","helper","lookupHelper","moduleName","lookupBuiltInHelper","HighLevelResolutionOpcodes","Modifier","Component","Helper","OptionalHelper","ComponentOrHelper","OptionalComponentOrHelper","Free","Local","TemplateLocal","HighLevelBuilderOpcodes","Label","StartLabels","StopLabels","Start","End","HighLevelOperands","IsStrictMode","DebugSymbols","Block","StdLib","NonSmallInt","SymbolTable","Layout","labelOperand","value","isStrictMode","undefined","stdlibOperand","symbolTableOperand","layoutOperand","Labels","labels","dict","targets","label","index","this","target","at","push","patch","address","getbyaddr","setbyaddr","encodeOp","encoder","op","isBuilderOpcode","operands","startLabels","stopLabels","then","scopeValues","definition","expect","component","lookupComponent","resolvedComponent","resolveComponent","modifier","lookupBuiltInModifier","lookupModifier","resolveModifier","resolveHelper","ifComponent","debugToString","resolveComponentOrHelper","ifValue","resolveOptionalComponentOrHelper","freeVar","andThen","valueIndex","upvarIndex","freeName","EncoderImpl","labelsStack","Stack","InstructionEncoderImpl","errors","constructor","stdlib","malloc","error","encode","Op","Primitive","commit","size","pushMachine","MachineOp","Return","finishMalloc","isPresentArray","args","TYPE_SIZE","first","isMachineOp","MACHINE_MASK","ARG_SHIFT","pushRaw","i","operand","encodeHandle","array","currentLabels","offset","evalSymbols","EMPTY_STRING_ARRAY","block","containing","CompilableTemplateImpl","parameters","EMPTY_ARRAY","current","pop","main","trustingGuardedAppend","cautiousGuardedAppend","trustingNonDynamicAppend","cautiousNonDynamicAppend","getAppend","trusting","NamedBlocksImpl","names","blocks","Object","keys","get","has","with","assign","hasAny","EMPTY_BLOCKS","namedBlocks","out","values","key","enumerate","PushPrimitiveReference","PushPrimitive","PrimitiveReference","primitive","p","isSmallInt","encodeImmediate","Call","positional","named","PushFrame","SimpleArgs","PopFrame","Fetch","$v0","CallDynamic","append","Dup","$fp","DynamicHelper","Pop","Curry","CaptureArgs","Compilers","funcs","add","func","compile","sexp","EXPRESSIONS","withPath","path","GetProperty","expression","atNames","PushEmptyArgs","flags","CompilePositional","val","PushArgs","layout","symbols","scope","hasEval","YieldBlock","to","GetBlock","SpreadBlock","CompileBlock","InvokeYield","PopScope","PushYieldableBlock","PushSymbolTable","PushBlockScope","PushCompilable","InvokeStaticBlock","InvokeVirtual","InvokeStaticBlockWithStack","callerCount","calleeCount","count","Math","min","ChildScope","SetVariable","_block","Constant","SwitchCases","bootstrap","matcher","clauses","match","callback","Enter","clause","slice","JumpEq","Jump","Exit","Replayable","body","ReturnTo","ReplayableIf","ifTrue","ifFalse","JumpUnless","Concat","parts","part","GetSymbol","sym","GetVariable","ConstantReference","_path","_handle","_name","arg","deprecate","id","Undefined","HasBlock","HasBlockParams","IfInline","condition","truthy","falsy","Not","GetDynamicVar","Log","ATTRS_BLOCK","InvokeComponent","_elementBlock","_blocks","compilable","capabilities","elementBlock","PushComponentDefinition","symbolTable","bailOut","hasCapability","InternalComponentCapabilities","prepareArgs","InvokeNonStaticComponent","$s0","$sp","Load","blockSymbols","argSymbols","argNames","blockNames","symbol","indexOf","createArgs","BeginComponentTransaction","dynamicScope","PushDynamicScope","createInstance","CreateComponent","RegisterComponentDestructor","GetComponentSelf","RootScope","reverse","SetBlock","DidRenderLayout","PopDynamicScope","CommitComponentTransaction","InvokeStaticComponent","InvokeDynamicComponent","curried","ResolveCurriedComponent","ResolveDynamicComponent","PushDynamicComponentInstance","bindableBlocks","bindableAtNames","CompileArgs","PrepareArgs","invokePreparedComponent","GetComponentLayout","PopulateLayout","WrappedComponent","attrsBlockNumber","register","WithSavedRegister","$s1","GetComponentTagName","PutComponentOperations","OpenDynamicElement","DidCreateElement","FlushElement","CloseElement","hasBlock","populateLayout","VirtualRootScope","SetupForEval","SetNamedVariables","SetBlocks","InvokeComponentLayout","StdAppend","nonDynamicAppend","ContentType","when","String","AssertSame","AppendHTML","AppendText","InvokeBareComponent","InvokeStatic","SafeString","AppendSafeHTML","Fragment","AppendDocumentFragment","Node","AppendNode","compileStd","mainHandle","build","Main","trustingGuardedNonDynamicAppend","cautiousGuardedNonDynamicAppend","trustingGuardedDynamicAppend","cautiousGuardedDynamicAppend","STDLIB_META","builder","CompileTimeCompilationContextImpl","createOp","programCompilationContext","artifacts","templateCompilationContext","STATEMENTS","INFLATE_ATTR_TABLE","INFLATE_TAG_TABLE","inflateTagName","tagName","inflateAttrName","attrName","hashToArgs","hash","map","Comment","DynamicModifier","StaticAttr","namespace","StaticComponentAttr","DynamicAttr","TrustingDynamicAttr","ComponentAttr","TrustingComponentAttr","OpenElement","tag","OpenElementWithSplat","Yield","params","AttrSplat","Debugger","debugInfo","Append","DynamicContentType","Text","TrustingAppend","InElement","guid","destination","insertBefore","PushRemoteElement","PopRemoteElement","If","inverse","ToBoolean","Each","EnterList","Iterate","ExitList","With","Let","WithDynamicVars","expressions","BindDynamicScope","DynamicScope","compiled","statements","compileStatements","maybeCompile","syntaxContext","sCompiler","pushOp","statement","DEFAULT_CAPABILITIES","dynamicLayout","dynamicTag","attributeHook","elementHook","createCaller","updateHook","wrapped","willDestroy","hasSubOwner","MINIMAL_CAPABILITIES","WrappedBuilder","attrsBlockIndex","syntax","m","clientId","templateCacheCounters","cacheHit","cacheMiss","templateFactory","templateId","parsedBlock","ownerlessTemplate","templateCache","WeakMap","factory","JSON","parse","TemplateImpl","set","__id","__meta","wrappedLayout","parsedLayout","referrer","asLayout","asWrappedLayout"],"mappings":"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"}