import { CompilableProgram, CompileTimeCompilationContext, ContainingMetadata, HandleResult, LayoutWithContext, SerializedInlineBlock, Statement, TemplateCompilationContext, CompileTimeArtifacts, CompileTimeResolver, CreateRuntimeOp, CompileTimeComponent, InternalComponentCapabilities, Nullable, WireFormat, BuilderOp, HighLevelOp, NamedBlocks, CompileTimeConstants, CompileTimeHeap, ResolutionTimeConstants, STDLib, Owner, SerializedTemplateWithLazyBlock, TemplateFactory, TemplateOk, ProgramSymbolTable } from "@glimmer/interfaces";
declare function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram;
declare function compileStatements(statements: Statement[], meta: ContainingMetadata, syntaxContext: CompileTimeCompilationContext): HandleResult;
declare let debugCompiler: (context: TemplateCompilationContext, handle: HandleResult) => void;
declare function programCompilationContext(artifacts: CompileTimeArtifacts, resolver: CompileTimeResolver, createOp: CreateRuntimeOp): CompileTimeCompilationContext;
declare function templateCompilationContext(program: CompileTimeCompilationContext, meta: ContainingMetadata): TemplateCompilationContext;
declare const DEFAULT_CAPABILITIES: InternalComponentCapabilities;
declare const MINIMAL_CAPABILITIES: InternalComponentCapabilities;
interface ResolverDelegate<R = unknown> {
    lookupHelper?(name: string, referrer: R): Nullable<number> | void;
    lookupModifier?(name: string, referrer: R): Nullable<number> | void;
    lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;
    // For debugging
    resolve?(handle: number): R;
}
declare const STATEMENT: unique symbol;
type HighLevelStatementOp = [
    {
        [STATEMENT]: undefined;
    }
];
type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;
/**
 * Invoke a block that is known statically at compile time.
 *
 * @param block a Compilable block
 */
declare function InvokeStaticBlock(op: PushStatementOp, block: WireFormat.SerializedInlineBlock): void;
/**
 * Invoke a static block, preserving some number of stack entries for use in
 * updating.
 *
 * @param block A compilable block
 * @param callerCount A number of stack entries to preserve
 */
declare function InvokeStaticBlockWithStack(op: PushStatementOp, block: WireFormat.SerializedInlineBlock, callerCount: number): void;
declare function meta(layout: LayoutWithContext): ContainingMetadata;
declare class StdLib {
    main: number;
    private trustingGuardedAppend;
    private cautiousGuardedAppend;
    private trustingNonDynamicAppend;
    private cautiousNonDynamicAppend;
    constructor(main: number, trustingGuardedAppend: number, cautiousGuardedAppend: number, trustingNonDynamicAppend: number, cautiousNonDynamicAppend: number);
    get "trusting-append"(): number;
    get "cautious-append"(): number;
    get "trusting-non-dynamic-append"(): number;
    get "cautious-non-dynamic-append"(): number;
    getAppend(trusting: boolean): number;
}
declare function compileStd(context: CompileTimeCompilationContext): StdLib;
declare class CompileTimeCompilationContextImpl implements CompileTimeCompilationContext {
    readonly resolver: CompileTimeResolver;
    readonly createOp: CreateRuntimeOp;
    readonly constants: CompileTimeConstants & ResolutionTimeConstants;
    readonly heap: CompileTimeHeap;
    readonly stdlib: STDLib;
    constructor({ constants, heap }: CompileTimeArtifacts, resolver: CompileTimeResolver, createOp: CreateRuntimeOp);
}
declare let templateCacheCounters: {
    cacheHit: number;
    cacheMiss: number;
};
// These interfaces are for backwards compatibility, some addons use these intimate APIs
interface TemplateFactoryWithIdAndMeta extends TemplateFactory {
    __id?: string;
    __meta?: {
        moduleName: string;
    };
}
interface TemplateWithIdAndReferrer extends TemplateOk {
    id: string;
    referrer: {
        moduleName: string;
        owner: Owner | null;
    };
}
/**
 * Wraps a template js in a template module to change it into a factory
 * that handles lazy parsing the template and to create per env singletons
 * of the template.
 */
declare function templateFactory({ id: templateId, moduleName, block, scope, isStrictMode }: SerializedTemplateWithLazyBlock): TemplateFactory;
interface NamedBlocksDict {
    [key: string]: Nullable<WireFormat.SerializedInlineBlock>;
}
declare class NamedBlocksImpl implements NamedBlocks {
    private blocks;
    names: string[];
    constructor(blocks: Nullable<NamedBlocksDict>);
    get(name: string): Nullable<SerializedInlineBlock>;
    has(name: string): boolean;
    with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks;
    get hasAny(): boolean;
}
declare const EMPTY_BLOCKS: NamedBlocksImpl;
declare class WrappedBuilder implements CompilableProgram {
    private layout;
    moduleName: string;
    symbolTable: ProgramSymbolTable;
    private compiled;
    private attrsBlockNumber;
    constructor(layout: LayoutWithContext, moduleName: string);
    compile(syntax: CompileTimeCompilationContext): HandleResult;
}
export { compilable, compileStatements, debugCompiler, programCompilationContext, templateCompilationContext, DEFAULT_CAPABILITIES, MINIMAL_CAPABILITIES, ResolverDelegate, InvokeStaticBlock as invokeStaticBlock, InvokeStaticBlockWithStack as invokeStaticBlockWithStack, meta, compileStd, StdLib, CompileTimeCompilationContextImpl, templateCacheCounters, templateFactory, TemplateFactoryWithIdAndMeta, TemplateWithIdAndReferrer, EMPTY_BLOCKS, WrappedBuilder };
//# sourceMappingURL=index.d.cts.map