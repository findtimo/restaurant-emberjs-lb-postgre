{"version":3,"file":"index.js","sources":["../../lib/array-utils.ts","../../lib/assert.ts","../../lib/platform-utils.ts","../../lib/present.ts","../../lib/collections.ts","../../../local-debug-flags/index.ts","../../lib/debug-steps.ts","../../lib/debug-to-string.ts","../../lib/dom.ts","../../lib/dom-utils.ts","../../lib/immediate.ts","../../lib/intern.ts","../../lib/is-serialization-first-node.ts","../../lib/object-utils.ts","../../lib/simple-cast.ts","../../lib/string.ts","../../lib/template.ts","../../lib/untouchable-this.ts","../../index.ts"],"sourcesContent":["export const EMPTY_ARRAY: readonly unknown[] = Object.freeze([]) as readonly unknown[];\n\nexport function emptyArray<T>(): T[] {\n  return EMPTY_ARRAY as T[];\n}\n\nexport const EMPTY_STRING_ARRAY = emptyArray<string>();\nexport const EMPTY_NUMBER_ARRAY = emptyArray<number>();\n\n/**\n * This function returns `true` if the input array is the special empty array sentinel,\n * which is sometimes used for optimizations.\n */\nexport function isEmptyArray(input: unknown[] | readonly unknown[]): boolean {\n  return input === EMPTY_ARRAY;\n}\n\nexport function* reverse<T>(input: T[]): IterableIterator<T> {\n  for (let i = input.length - 1; i >= 0; i--) {\n    yield input[i]!;\n  }\n}\n\nexport function* enumerate<T>(input: Iterable<T>): IterableIterator<[number, T]> {\n  let i = 0;\n  for (const item of input) {\n    yield [i++, item];\n  }\n}\n","// import Logger from './logger';\n\nimport { LOCAL_LOGGER } from '../index';\n\n// let alreadyWarned = false;\n\nexport function debugAssert(test: any, msg: string): asserts test {\n  // if (!alreadyWarned) {\n  //   alreadyWarned = true;\n  //   Logger.warn(\"Don't leave debug assertions on in public builds\");\n  // }\n\n  if (!test) {\n    throw new Error(msg || 'assertion failure');\n  }\n}\n\nexport function prodAssert() {}\n\nexport function deprecate(desc: string) {\n  LOCAL_LOGGER.warn(`DEPRECATION: ${desc}`);\n}\n\nexport default debugAssert;\n","import type { Maybe, Present } from '@glimmer/interfaces';\n\nexport type Factory<T> = new (...args: unknown[]) => T;\n\nexport function keys<T extends object>(obj: T): Array<keyof T> {\n  return Object.keys(obj) as Array<keyof T>;\n}\n\nexport function unwrap<T>(val: Maybe<T>): T {\n  if (val === null || val === undefined) throw new Error(`Expected value to be present`);\n  return val as T;\n}\n\nexport function expect<T>(val: T, message: string): Present<T> {\n  if (val === null || val === undefined) throw new Error(message);\n  return val as Present<T>;\n}\n\nexport function unreachable(message = 'unreachable'): Error {\n  return new Error(message);\n}\n\nexport function exhausted(value: never): never {\n  throw new Error(`Exhausted ${String(value)}`);\n}\n\nexport type Lit = string | number | boolean | undefined | null | void | {};\n\nexport const tuple = <T extends Lit[]>(...args: T) => args;\n","import type { Nullable, Present, PresentArray } from '@glimmer/interfaces';\n\nexport function isPresent<T>(value: T): value is Present<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function assertPresent<T extends string>(value: T): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message: string): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message?: string): asserts value is Present<T> {\n  if (!isPresent(value)) {\n    throw new Error(`Expected present, got ${typeof value === 'string' ? value : message!}`);\n  }\n}\n\nexport function isPresentArray<T>(list: readonly T[]): list is PresentArray<T> {\n  return list.length > 0;\n}\n\nexport function ifPresent<T, U, V>(\n  list: T[],\n  ifPresent: (input: PresentArray<T>) => U,\n  otherwise: () => V\n): U | V {\n  if (isPresentArray(list)) {\n    return ifPresent(list);\n  } else {\n    return otherwise();\n  }\n}\n\nexport function arrayToOption<T>(list: T[]): Nullable<PresentArray<T>> {\n  if (isPresentArray(list)) {\n    return list;\n  } else {\n    return null;\n  }\n}\n\nexport function assertPresentArray<T>(\n  list: T[],\n  message = `unexpected empty list`\n): asserts list is PresentArray<T> {\n  if (!isPresentArray(list)) {\n    throw new Error(message);\n  }\n}\n\nexport function asPresentArray<T>(list: T[], message = `unexpected empty list`): PresentArray<T> {\n  assertPresentArray(list, message);\n  return list;\n}\n\nexport function getLast<T>(list: PresentArray<T>): T;\nexport function getLast<T>(list: T[]): T | undefined;\nexport function getLast<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[list.length - 1] as T);\n}\n\nexport function getFirst<T>(list: PresentArray<T>): T;\nexport function getFirst<T>(list: T[]): T | undefined;\nexport function getFirst<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[0] as T);\n}\n\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T>,\n  mapper: (input: T) => U\n): PresentArray<U>;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null {\n  if (list === null) {\n    return null;\n  }\n  let out: U[] = [];\n\n  for (let item of list) {\n    out.push(mapper(item));\n  }\n\n  return out as PresentArray<U>;\n}\n","import type { Dict, Nullable, Stack } from '@glimmer/interfaces';\n\nimport { unwrap } from './platform-utils';\nimport { getLast } from './present';\n\nexport function dict<T = unknown>(): Dict<T> {\n  return Object.create(null);\n}\n\nexport function isDict<T>(u: T): u is Dict & T {\n  return u !== null && u !== undefined;\n}\n\nexport function isObject<T>(u: T): u is object & T {\n  return typeof u === 'function' || (typeof u === 'object' && u !== null);\n}\n\nexport class StackImpl<T> implements Stack<T> {\n  private stack: T[];\n  public current: Nullable<T> = null;\n\n  constructor(values: T[] = []) {\n    this.stack = values;\n  }\n\n  public get size() {\n    return this.stack.length;\n  }\n\n  push(item: T) {\n    this.current = item;\n    this.stack.push(item);\n  }\n\n  pop(): Nullable<T> {\n    let item = this.stack.pop();\n    this.current = getLast(this.stack) ?? null;\n\n    return item === undefined ? null : item;\n  }\n\n  nth(from: number): Nullable<T> {\n    let len = this.stack.length;\n    return len < from ? null : unwrap(this.stack[len - from]);\n  }\n\n  isEmpty(): boolean {\n    return this.stack.length === 0;\n  }\n\n  toArray(): T[] {\n    return this.stack;\n  }\n}\n","export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","/// <reference types=\"qunit\" />\n\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nimport assert from './assert';\nimport { expect } from './platform-utils';\n\nexport let beginTestSteps: (() => void) | undefined;\nexport let endTestSteps: (() => void) | undefined;\n\nexport let verifySteps:\n  | ((type: string, steps: unknown[] | ((steps: unknown[]) => void), message?: string) => void)\n  | undefined;\nexport let logStep: ((type: string, steps: unknown) => void) | undefined;\n\nif (LOCAL_DEBUG) {\n  let LOGGED_STEPS: Record<string, unknown[]> | null = null;\n\n  beginTestSteps = () => {\n    assert(LOGGED_STEPS === null, 'attempted to start steps, but it already began');\n\n    LOGGED_STEPS = {};\n  };\n\n  endTestSteps = () => {\n    assert(LOGGED_STEPS, 'attempted to end steps, but they were not started');\n\n    LOGGED_STEPS = null;\n  };\n\n  logStep = (type: string, step: unknown) => {\n    if (LOGGED_STEPS === null) return;\n\n    let steps = LOGGED_STEPS[type];\n    if (!steps) steps = LOGGED_STEPS[type] = [];\n\n    steps.push(step);\n  };\n\n  verifySteps = (\n    type: string,\n    expectedSteps: unknown[] | ((steps: unknown[]) => void),\n    message?: string\n  ) => {\n    let loggedSteps = expect(LOGGED_STEPS, 'attempetd to verify steps, but steps were not started');\n\n    let steps = loggedSteps[type] || [];\n\n    loggedSteps[type] = [];\n\n    if (Array.isArray(expectedSteps)) {\n      QUnit.config.current.assert.deepEqual(steps, expectedSteps, message);\n    } else {\n      expectedSteps(steps);\n    }\n  };\n}\n","let debugToString: undefined | ((value: unknown) => string);\n\nif (import.meta.env.DEV) {\n  let getFunctionName = (fn: Function) => {\n    let functionName = fn.name;\n\n    if (functionName === undefined) {\n      let match = /function (\\w+)\\s*\\(/u.exec(String(fn));\n\n      functionName = (match && match[1]) || '';\n    }\n\n    return functionName.replace(/^bound /u, '');\n  };\n\n  let getObjectName = (obj: object) => {\n    let name;\n    let className;\n\n    if (obj.constructor && typeof obj.constructor === 'function') {\n      className = getFunctionName(obj.constructor);\n    }\n\n    if (\n      'toString' in obj &&\n      obj.toString !== Object.prototype.toString &&\n      obj.toString !== Function.prototype.toString\n    ) {\n      name = obj.toString();\n    }\n\n    // If the class has a decent looking name, and the `toString` is one of the\n    // default Ember toStrings, replace the constructor portion of the toString\n    // with the class name. We check the length of the class name to prevent doing\n    // this when the value is minified.\n    if (\n      name &&\n      /<.*:ember\\d+>/u.test(name) &&\n      className &&\n      className[0] !== '_' &&\n      className.length > 2 &&\n      className !== 'Class'\n    ) {\n      return name.replace(/<.*:/u, `<${className}:`);\n    }\n\n    return name || className;\n  };\n\n  let getPrimitiveName = (value: any) => {\n    return String(value);\n  };\n\n  debugToString = (value: unknown) => {\n    if (typeof value === 'function') {\n      return getFunctionName(value) || `(unknown function)`;\n    } else if (typeof value === 'object' && value !== null) {\n      return getObjectName(value) || `(unknown object)`;\n    } else {\n      return getPrimitiveName(value);\n    }\n  };\n}\n\nexport default debugToString;\n","import type { Nullable, SimpleElement, SimpleNode } from '@glimmer/interfaces';\n\nexport function clearElement(parent: SimpleElement) {\n  let current: Nullable<SimpleNode> = parent.firstChild;\n\n  while (current) {\n    let next = current.nextSibling;\n    parent.removeChild(current);\n    current = next;\n  }\n}\n","import type { InsertPosition, Namespace } from '@glimmer/interfaces';\n\nexport const RAW_NODE = -1;\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n\nexport const NS_HTML = 'http://www.w3.org/1999/xhtml' as Namespace.HTML;\nexport const NS_MATHML = 'http://www.w3.org/1998/Math/MathML' as Namespace.MathML;\nexport const NS_SVG = 'http://www.w3.org/2000/svg' as Namespace.SVG;\nexport const NS_XLINK = 'http://www.w3.org/1999/xlink' as Namespace.XLink;\nexport const NS_XML = 'http://www.w3.org/XML/1998/namespace' as Namespace.XML;\nexport const NS_XMLNS = 'http://www.w3.org/2000/xmlns/' as Namespace.XMLNS;\n\nexport const INSERT_BEFORE_BEGIN = 'beforebegin' as InsertPosition.beforebegin;\nexport const INSERT_AFTER_BEGIN = 'afterbegin' as InsertPosition.afterbegin;\nexport const INSERT_BEFORE_END = 'beforeend' as InsertPosition.beforeend;\nexport const INSERT_AFTER_END = 'afterend' as InsertPosition.afterend;\n","import { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nimport { debugAssert as assert } from './assert';\n\n/*\n  Encoding notes\n\n  We use 30 bit integers for encoding, so that we don't ever encode a non-SMI\n  integer to push on the stack.\n\n  Handles are >= 0\n  Immediates are < 0\n\n  True, False, Undefined and Null are pushed as handles into the symbol table,\n  with well known handles (0, 1, 2, 3)\n\n  The negative space is divided into positives and negatives. Positives are\n  higher numbers (-1, -2, -3, etc), negatives are lower.\n\n  We only encode immediates for two reasons:\n\n  1. To transfer over the wire, so they're smaller in general\n  2. When pushing values onto the stack from the low level/inner VM, which may\n     be converted into WASM one day.\n\n  This allows the low-level VM to always use SMIs, and to minimize using JS\n  values via handles for things like the stack pointer and frame pointer.\n  Externally, most code pushes values as JS values, except when being pulled\n  from the append byte code where it was already encoded.\n\n  Logically, this is because the low level VM doesn't really care about these\n  higher level values. For instance, the result of a userland helper may be a\n  number, or a boolean, or undefined/null, but it's extra work to figure that\n  out and push it correctly, vs. just pushing the value as a JS value with a\n  handle.\n\n  Note: The details could change here in the future, this is just the current\n  strategy.\n*/\n\nexport enum ImmediateConstants {\n  MAX_SMI = 2 ** 30 - 1,\n  MIN_SMI = ~MAX_SMI,\n  SIGN_BIT = ~(2 ** 29),\n  MAX_INT = ~SIGN_BIT - 1,\n  MIN_INT = ~MAX_INT,\n\n  FALSE_HANDLE = 0,\n  TRUE_HANDLE = 1,\n  NULL_HANDLE = 2,\n  UNDEFINED_HANDLE = 3,\n\n  ENCODED_FALSE_HANDLE = FALSE_HANDLE,\n  ENCODED_TRUE_HANDLE = TRUE_HANDLE,\n  ENCODED_NULL_HANDLE = NULL_HANDLE,\n  ENCODED_UNDEFINED_HANDLE = UNDEFINED_HANDLE,\n}\n\nexport function isHandle(value: number) {\n  return value >= 0;\n}\n\nexport function isNonPrimitiveHandle(value: number) {\n  return value > ImmediateConstants.ENCODED_UNDEFINED_HANDLE;\n}\n\nexport function constants(...values: unknown[]): unknown[] {\n  return [false, true, null, undefined, ...values];\n}\n\nexport function isSmallInt(value: number) {\n  return (\n    value % 1 === 0 && value <= ImmediateConstants.MAX_INT && value >= ImmediateConstants.MIN_INT\n  );\n}\n\nexport function encodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num >= ImmediateConstants.MIN_INT && num < 0,\n      `Could not encode negative: ${num}`\n    );\n  }\n\n  return num & ImmediateConstants.SIGN_BIT;\n}\n\nexport function decodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num < ~ImmediateConstants.MAX_INT && num >= ImmediateConstants.MIN_SMI,\n      `Could not decode negative: ${num}`\n    );\n  }\n\n  return num | ~ImmediateConstants.SIGN_BIT;\n}\n\nexport function encodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num >= 0 && num <= ImmediateConstants.MAX_INT,\n      `Could not encode positive: ${num}`\n    );\n  }\n\n  return ~num;\n}\n\nexport function decodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num <= 0 && num >= ~ImmediateConstants.MAX_INT,\n      `Could not decode positive: ${num}`\n    );\n  }\n\n  return ~num;\n}\n\nexport function encodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num >= 0 && num <= ImmediateConstants.MAX_SMI,\n      `Could not encode handle: ${num}`\n    );\n  }\n\n  return num;\n}\n\nexport function decodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    assert(\n      num % 1 === 0 && num <= ImmediateConstants.MAX_SMI && num >= 0,\n      `Could not decode handle: ${num}`\n    );\n  }\n\n  return num;\n}\n\nexport function encodeImmediate(num: number) {\n  num |= 0;\n  return num < 0 ? encodeNegative(num) : encodePositive(num);\n}\n\nexport function decodeImmediate(num: number) {\n  num |= 0;\n  return num > ImmediateConstants.SIGN_BIT ? decodePositive(num) : decodeNegative(num);\n}\n\n// Warm\n[1, 2, 3].forEach((x) => decodeHandle(encodeHandle(x)));\n[1, -1].forEach((x) => decodeImmediate(encodeImmediate(x)));\n","/**\n  Strongly hint runtimes to intern the provided string.\n\n  When do I need to use this function?\n\n  For the most part, never. Pre-mature optimization is bad, and often the\n  runtime does exactly what you need it to, and more often the trade-off isn't\n  worth it.\n\n  Why?\n\n  Runtimes store strings in at least 2 different representations:\n  Ropes and Symbols (interned strings). The Rope provides a memory efficient\n  data-structure for strings created from concatenation or some other string\n  manipulation like splitting.\n\n  Unfortunately checking equality of different ropes can be quite costly as\n  runtimes must resort to clever string comparison algorithms. These\n  algorithms typically cost in proportion to the length of the string.\n  Luckily, this is where the Symbols (interned strings) shine. As Symbols are\n  unique by their string content, equality checks can be done by pointer\n  comparison.\n\n  How do I know if my string is a rope or symbol?\n\n  Typically (warning general sweeping statement, but truthy in runtimes at\n  present) static strings created as part of the JS source are interned.\n  Strings often used for comparisons can be interned at runtime if some\n  criteria are met.  One of these criteria can be the size of the entire rope.\n  For example, in chrome 38 a rope longer then 12 characters will not\n  intern, nor will segments of that rope.\n\n  Some numbers: http://jsperf.com/eval-vs-keys/8\n\n  Known Trickâ„¢\n\n  @private\n  @return {String} interned version of the provided string\n*/\nexport default function intern(str: string): string {\n  let obj: Record<string, number> = {};\n  obj[str] = 1;\n  for (let key in obj) {\n    if (key === str) {\n      return key;\n    }\n  }\n  return str;\n}\n","import type { SimpleNode } from '@glimmer/interfaces';\n\nexport const SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';\n\nexport function isSerializationFirstNode(node: SimpleNode): boolean {\n  return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;\n}\n","export let assign = Object.assign;\n\nexport function values<T>(obj: { [s: string]: T }): T[] {\n  return Object.values(obj);\n}\n\nexport type ObjectEntry<D extends object> = { [P in keyof D]: [P, D[P]] }[keyof D];\n\nexport function entries<D extends object>(dict: D): ObjectEntry<D>[] {\n  return Object.entries(dict) as ObjectEntry<D>[];\n}\n","import type { Maybe, SimpleDocument, SimpleElement, SimpleNode } from '@glimmer/interfaces';\n\nimport { DOCUMENT_NODE, ELEMENT_NODE } from './dom-utils';\nimport { unreachable } from './platform-utils';\n\ninterface GenericElementTags {\n  HTML: HTMLElement;\n  SVG: SVGElement;\n  ELEMENT: HTMLElement | SVGElement;\n}\n\ninterface GenericNodeTags {\n  NODE: Node;\n}\n\ntype GenericNodeTag = keyof GenericNodeTags;\n\ninterface BrowserElementTags extends HTMLElementTagNameMap, GenericElementTags {}\ntype BrowserElementTag = keyof BrowserElementTags;\n\ninterface BrowserTags extends BrowserElementTags, GenericNodeTags {}\ntype BrowserTag = keyof BrowserTags;\n\ntype NodeCheck<N extends Node> = (node: Node) => node is N;\ntype SugaryNodeCheck<K extends BrowserTag = BrowserTag> = NodeCheck<BrowserTags[K]> | K | K[];\ntype NodeForSugaryCheck<S extends SugaryNodeCheck<BrowserTag>> = S extends NodeCheck<infer N>\n  ? N\n  : S extends keyof BrowserTags\n    ? BrowserTags[S]\n    : S extends (keyof BrowserTags)[]\n      ? BrowserTags[S[number]]\n      : never;\n\ntype BrowserNode = Element | Document | DocumentFragment | Text | Comment | Node;\n\nexport function castToSimple(doc: Document | SimpleDocument): SimpleDocument;\nexport function castToSimple(elem: Element | SimpleElement): SimpleElement;\nexport function castToSimple(node: Node | SimpleNode): SimpleNode;\nexport function castToSimple(\n  node: Document | Element | Node | SimpleDocument | SimpleElement | SimpleNode\n) {\n  if (isDocument(node)) {\n    return node as SimpleDocument;\n  } else if (isSimpleElement(node)) {\n    return node;\n  } else {\n    return node as SimpleNode;\n  }\n}\n\n// If passed a document, verify we're in the browser and return it as a Document\nexport function castToBrowser(doc: Document | SimpleDocument): Document;\n// If we don't know what this is, but the check requires it to be an element,\n// the cast will mandate that it's a browser element\nexport function castToBrowser<S extends SugaryNodeCheck<BrowserElementTag>>(\n  node: BrowserNode | SimpleNode,\n  check: S\n): NodeForSugaryCheck<S>;\n// Finally, if it's a more generic check, the cast will mandate that it's a\n// browser node and return a BrowserNodeUtils corresponding to the check\nexport function castToBrowser<S extends SugaryNodeCheck<GenericNodeTag>>(\n  element: BrowserNode | SimpleNode,\n  check: S\n): NodeForSugaryCheck<S>;\nexport function castToBrowser<K extends keyof HTMLElementTagNameMap>(\n  element: SimpleElement | Element,\n  check: K\n): HTMLElementTagNameMap[K];\nexport function castToBrowser<S extends SugaryNodeCheck>(\n  node: SimpleNode | BrowserNode | null | undefined,\n  sugaryCheck?: S\n): Document | NodeForSugaryCheck<S> | null {\n  if (node === null || node === undefined) {\n    return null;\n  }\n\n  if (typeof document === undefined) {\n    throw new Error('Attempted to cast to a browser node in a non-browser context');\n  }\n\n  if (isDocument(node)) {\n    return node as Document;\n  }\n\n  if (node.ownerDocument !== document) {\n    throw new Error(\n      'Attempted to cast to a browser node with a node that was not created from this document'\n    );\n  }\n\n  return checkBrowserNode<S>(node, sugaryCheck!);\n}\n\nfunction checkError(from: string, check: SugaryNodeCheck): Error {\n  return new Error(`cannot cast a ${from} into ${String(check)}`);\n}\n\nfunction isDocument(node: Node | SimpleNode | SimpleDocument): node is Document | SimpleDocument {\n  return node.nodeType === DOCUMENT_NODE;\n}\n\nexport function isSimpleElement(node: Maybe<SimpleNode | Node>): node is SimpleElement {\n  return node?.nodeType === ELEMENT_NODE;\n}\n\nexport function isElement(node: Maybe<Node | SimpleNode>): node is Element {\n  return node?.nodeType === ELEMENT_NODE && node instanceof Element;\n}\n\nexport function checkBrowserNode<S extends SugaryNodeCheck>(\n  node: Node | SimpleNode | null,\n  check: S\n): NodeForSugaryCheck<S> {\n  let isMatch = false;\n\n  if (node !== null) {\n    if (typeof check === 'string') {\n      isMatch = stringCheckNode(node, check);\n    } else if (Array.isArray(check)) {\n      isMatch = check.some((c) => stringCheckNode(node, c));\n    } else {\n      throw unreachable();\n    }\n  }\n\n  if (isMatch && node instanceof Node) {\n    return node as NodeForSugaryCheck<S>;\n  } else {\n    throw checkError(`SimpleElement(${node?.constructor?.name ?? 'null'})`, check);\n  }\n}\n\nfunction stringCheckNode<S extends BrowserTag>(\n  node: Node | SimpleNode,\n  check: S\n): node is BrowserTags[S] {\n  switch (check) {\n    case 'NODE':\n      return true;\n    case 'HTML':\n      return node instanceof HTMLElement;\n    case 'SVG':\n      return node instanceof SVGElement;\n    case 'ELEMENT':\n      return node instanceof Element;\n    default:\n      if (check.toUpperCase() === check) {\n        throw new Error(`BUG: this code is missing handling for a generic node type`);\n      }\n      return node instanceof Element && node.tagName.toLowerCase() === check;\n  }\n}\n","import { enumerate } from './array-utils';\nimport { getFirst, getLast, isPresentArray } from './present';\n\nexport function strip(strings: TemplateStringsArray, ...args: unknown[]) {\n  let out = '';\n  for (const [i, string] of enumerate(strings)) {\n    let dynamic = args[i] !== undefined ? String(args[i]) : '';\n\n    out += `${string}${dynamic}`;\n  }\n\n  let lines = out.split('\\n');\n\n  while (isPresentArray(lines) && /^\\s*$/u.test(getFirst(lines))) {\n    lines.shift();\n  }\n\n  while (isPresentArray(lines) && /^\\s*$/u.test(getLast(lines))) {\n    lines.pop();\n  }\n\n  let min = Infinity;\n\n  for (let line of lines) {\n    let leading = /^\\s*/u.exec(line)![0].length;\n\n    min = Math.min(min, leading);\n  }\n\n  let stripped = [];\n\n  for (let line of lines) {\n    stripped.push(line.slice(min));\n  }\n\n  return stripped.join('\\n');\n}\n","import type { ErrHandle, HandleResult, OkHandle, Template, TemplateOk } from '@glimmer/interfaces';\n\nexport function unwrapHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    let error = handle.errors[0];\n    throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`);\n  }\n}\n\nexport function unwrapTemplate(template: Template): TemplateOk {\n  if (template.result === 'error') {\n    throw new Error(\n      `Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`\n    );\n  }\n\n  return template;\n}\n\nexport function extractHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    return handle.handle;\n  }\n}\n\nexport function isOkHandle(handle: HandleResult): handle is OkHandle {\n  return typeof handle === 'number';\n}\n\nexport function isErrHandle(handle: HandleResult): handle is ErrHandle {\n  return typeof handle === 'number';\n}\n","export default function buildUntouchableThis(source: string): null | object {\n  let context: null | object = null;\n  if (import.meta.env.DEV) {\n    let assertOnProperty = (property: string | number | symbol) => {\n      let access =\n        typeof property === 'symbol' || typeof property === 'number'\n          ? `[${String(property)}]`\n          : `.${property}`;\n\n      throw new Error(\n        `You accessed \\`this${access}\\` from a function passed to the ${source}, but the function itself was not bound to a valid \\`this\\` context. Consider updating to use a bound function (for instance, use an arrow function, \\`() => {}\\`).`\n      );\n    };\n\n    context = new Proxy(\n      {},\n      {\n        get(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n        },\n\n        set(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n\n          return false;\n        },\n\n        has(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n\n          return false;\n        },\n      }\n    );\n  }\n\n  return context;\n}\n","export * from './lib/array-utils';\nexport { default as assert, deprecate } from './lib/assert';\nexport { dict, isDict, isObject, StackImpl as Stack } from './lib/collections';\nexport { beginTestSteps, endTestSteps, logStep, verifySteps } from './lib/debug-steps';\nexport { default as debugToString } from './lib/debug-to-string';\nexport * from './lib/dom';\nexport * from './lib/dom-utils';\nexport * from './lib/immediate';\nexport { default as intern } from './lib/intern';\nexport {\n  isSerializationFirstNode,\n  SERIALIZATION_FIRST_NODE_STRING,\n} from './lib/is-serialization-first-node';\nexport { assign, entries, values } from './lib/object-utils';\nexport * from './lib/platform-utils';\nexport * from './lib/present';\nexport {\n  castToBrowser,\n  castToSimple,\n  checkBrowserNode as checkNode,\n  isElement,\n  isSimpleElement,\n} from './lib/simple-cast';\nexport * from './lib/string';\nexport * from './lib/template';\nexport { default as buildUntouchableThis } from './lib/untouchable-this';\n\nexport type FIXME<T, S extends string> = (T & S) | T;\n\n/**\n * This constant exists to make it easier to differentiate normal logs from\n * errant console.logs. LOCAL_LOGGER should only be used inside a\n * LOCAL_SHOULD_LOG check.\n *\n * It does not alleviate the need to check LOCAL_SHOULD_LOG, which is used\n * for stripping.\n */\nexport const LOCAL_LOGGER = console;\n\n/**\n * This constant exists to make it easier to differentiate normal logs from\n * errant console.logs. LOGGER can be used outside of LOCAL_SHOULD_LOG checks,\n * and is meant to be used in the rare situation where a console.* call is\n * actually appropriate.\n */\nexport const LOGGER = console;\n\nexport function assertNever(value: never, desc = 'unexpected unreachable branch'): never {\n  LOGGER.log('unreachable', value);\n  LOGGER.log(`${desc} :: ${JSON.stringify(value)} (${value})`);\n\n  throw new Error(`code reached unreachable`);\n}\n"],"names":["EMPTY_ARRAY","Object","freeze","emptyArray","EMPTY_STRING_ARRAY","EMPTY_NUMBER_ARRAY","isEmptyArray","input","reverse","i","length","enumerate","item","debugAssert","test","msg","Error","deprecate","desc","LOCAL_LOGGER","warn","keys","obj","unwrap","val","expect","message","unreachable","exhausted","value","String","tuple","args","isPresent","assertPresent","isPresentArray","list","ifPresent","otherwise","arrayToOption","assertPresentArray","asPresentArray","getLast","undefined","getFirst","mapPresentArray","mapper","out","push","dict","create","isDict","u","isObject","StackImpl","stack","current","constructor","values","this","size","pop","nth","from","len","isEmpty","toArray","LOCAL_DEBUG","window","location","search","beginTestSteps","endTestSteps","verifySteps","logStep","debugToString","LOGGED_STEPS","assert","type","step","steps","expectedSteps","loggedSteps","Array","isArray","QUnit","config","deepEqual","getFunctionName","fn","functionName","name","match","exec","replace","getObjectName","className","toString","prototype","Function","getPrimitiveName","debugToString$1","clearElement","parent","firstChild","next","nextSibling","removeChild","RAW_NODE","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NS_HTML","NS_MATHML","NS_SVG","NS_XLINK","NS_XML","NS_XMLNS","INSERT_BEFORE_BEGIN","INSERT_AFTER_BEGIN","INSERT_BEFORE_END","INSERT_AFTER_END","ImmediateConstants","isHandle","isNonPrimitiveHandle","ENCODED_UNDEFINED_HANDLE","constants","isSmallInt","MAX_INT","MIN_INT","encodeNegative","num","SIGN_BIT","decodeNegative","MIN_SMI","encodePositive","decodePositive","encodeHandle","MAX_SMI","decodeHandle","encodeImmediate","decodeImmediate","intern","str","key","forEach","x","SERIALIZATION_FIRST_NODE_STRING","isSerializationFirstNode","node","nodeValue","assign","entries","castToSimple","isDocument","isSimpleElement","castToBrowser","sugaryCheck","document","ownerDocument","checkBrowserNode","nodeType","isElement","Element","check","isMatch","stringCheckNode","some","c","Node","checkError","HTMLElement","SVGElement","toUpperCase","tagName","toLowerCase","strip","strings","string","lines","split","shift","min","Infinity","line","leading","Math","stripped","slice","join","unwrapHandle","handle","error","errors","problem","span","start","end","unwrapTemplate","template","result","extractHandle","isOkHandle","isErrHandle","buildUntouchableThis","source","context","assertOnProperty","property","access","Proxy","get","_target","set","has","console","LOGGER","assertNever","log","JSON","stringify"],"mappings":"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"}