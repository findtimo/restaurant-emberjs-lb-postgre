import{getInternalHelperManager as e,getInternalModifierManager as t,getInternalComponentManager as i,capabilityFlagsFrom as n,getComponentTemplate as a,managerHasCapability as r}from"@glimmer/manager";import{templateFactory as s}from"@glimmer/opcode-compiler";import{constants as l,enumerate as o,assert as h,unwrapTemplate as u,expect as f,unwrap as d}from"@glimmer/util";import{InternalComponentCapabilities as p,OPERAND_LEN_MASK as c,ARG_SHIFT as m,MACHINE_MASK as g,TYPE_MASK as b}from"@glimmer/vm";import{SexpOpcodes as y}from"@glimmer/wire-format";const v=[[[y.Yield,1,null]],["&default"],!1,[]],w={id:"1b32f5c2-7623-43d6-a0ad-9672898920a1",moduleName:"__default__.hbs",block:JSON.stringify(v),scope:null,isStrictMode:!0},C=Object.freeze([]),D=l(C),A=D.indexOf(C);class T{values=D.slice();indexMap=new Map(this.values.map(((e,t)=>[e,t])));value(e){let t=this.indexMap,i=t.get(e);return void 0===i&&(i=this.values.push(e)-1,t.set(e,i)),i}array(e){if(0===e.length)return A;let t=new Array(e.length);for(let i=0;i<e.length;i++)t[i]=this.value(e[i]);return this.value(t)}toPool(){return this.values}}class M{values;constructor(e){this.values=e}getValue(e){return this.values[e]}getArray(e){let t=this.getValue(e),i=new Array(t.length);for(const[e,n]of o(t))i[e]=this.getValue(n);return i}}class _ extends T{reifiedArrs={[A]:C};defaultTemplate=s(w)();helperDefinitionCount=0;modifierDefinitionCount=0;componentDefinitionCount=0;helperDefinitionCache=new WeakMap;modifierDefinitionCache=new WeakMap;componentDefinitionCache=new WeakMap;helper(t,i=null,n){let a=this.helperDefinitionCache.get(t);if(void 0===a){let i=e(t,n);if(null===i)return this.helperDefinitionCache.set(t,null),null;h(i,"BUG: expected manager or helper");let r="function"==typeof i?i:i.getHelper(t);a=this.value(r),this.helperDefinitionCache.set(t,a),this.helperDefinitionCount++}return a}modifier(e,i=null,n){let a=this.modifierDefinitionCache.get(e);if(void 0===a){let r=t(e,n);if(null===r)return this.modifierDefinitionCache.set(e,null),null;let s={resolvedName:i,manager:r,state:e};a=this.value(s),this.modifierDefinitionCache.set(e,a),this.modifierDefinitionCount++}return a}component(e,t,s){let l=this.componentDefinitionCache.get(e);if(void 0===l){let o=i(e,s);if(null===o)return this.componentDefinitionCache.set(e,null),null;h(o,"BUG: expected manager");let f,d=n(o.getCapabilities(e)),c=a(e),m=null;f=r(o,d,p.dynamicLayout)?c?.(t):c?.(t)??this.defaultTemplate,void 0!==f&&(f=u(f),m=r(o,d,p.wrapped)?f.asWrappedLayout():f.asLayout()),l={resolvedName:null,handle:-1,manager:o,capabilities:d,state:e,compilable:m},l.handle=this.value(l),this.componentDefinitionCache.set(e,l),this.componentDefinitionCount++}return l}resolvedComponent(e,t){let i=this.componentDefinitionCache.get(e);if(void 0===i){let{manager:a,state:s,template:l}=e,o=n(a.getCapabilities(e)),h=null;r(a,o,p.dynamicLayout)||(l=l??this.defaultTemplate),null!==l&&(l=u(l),h=r(a,o,p.wrapped)?l.asWrappedLayout():l.asLayout()),i={resolvedName:t,handle:-1,manager:a,capabilities:o,state:s,compilable:h},i.handle=this.value(i),this.componentDefinitionCache.set(e,i),this.componentDefinitionCount++}return f(i,"BUG: resolved component definitions cannot be null")}getValue(e){return h(e>=0,`cannot get value for handle: ${e}`),this.values[e]}getArray(e){let t=this.reifiedArrs,i=t[e];if(void 0===i){let n=this.getValue(e);i=new Array(n.length);for(const[e,t]of o(n))i[e]=this.getValue(t);t[e]=i}return i}}const P=!("undefined"!=typeof window&&window.location&&/[&?]disable_local_debug/u.test(window.location.search));class x{offset=0;constructor(e){this.heap=e}get size(){return 1+((this.heap.getbyaddr(this.offset)&c)>>m)}get isMachine(){return this.heap.getbyaddr(this.offset)&g?1:0}get type(){return this.heap.getbyaddr(this.offset)&b}get op1(){return this.heap.getbyaddr(this.offset+1)}get op2(){return this.heap.getbyaddr(this.offset+2)}get op3(){return this.heap.getbyaddr(this.offset+3)}}var z=function(e){return e[e.Allocated=0]="Allocated",e[e.Freed=1]="Freed",e[e.Purged=2]="Purged",e[e.Pointer=3]="Pointer",e}(z||{});const S=1048576;class k{heap;table;constructor(e){let{buffer:t,table:i}=e;this.heap=new Int32Array(t),this.table=i}getaddr(e){return d(this.table[e])}getbyaddr(e){return f(this.heap[e],"Access memory out of bounds of the heap")}sizeof(e){return W(this.table,e)}}function L(e){return new k(e)}class V{offset=0;heap;handleTable;handleState;handle=0;constructor(){this.heap=new Int32Array(S),this.handleTable=[],this.handleState=[]}pushRaw(e){this.sizeCheck(),this.heap[this.offset++]=e}pushOp(e){this.pushRaw(e)}pushMachine(e){this.pushRaw(e|g)}sizeCheck(){let{heap:e}=this;if(this.offset===this.heap.length){let t=new Int32Array(e.length+S);t.set(e,0),this.heap=t}}getbyaddr(e){return d(this.heap[e])}setbyaddr(e,t){this.heap[e]=t}malloc(){return this.handleTable.push(this.offset),this.handleTable.length-1}finishMalloc(e){P&&(this.handleState[e]=z.Allocated)}size(){return this.offset}getaddr(e){return d(this.handleTable[e])}sizeof(e){return W(this.handleTable,e)}free(e){this.handleState[e]=z.Freed}compact(){let e=0,{handleTable:t,handleState:i,heap:n}=this;for(let a=0;a<length;a++){let r=d(t[a]),s=d(t[a+1])-d(r),l=i[a];if(l!==z.Purged)if(l===z.Freed)i[a]=z.Purged,e+=s;else if(l===z.Allocated){for(let t=r;t<=a+s;t++)n[t-e]=d(n[t]);t[a]=r-e}else l===z.Pointer&&(t[a]=r-e)}this.offset=this.offset-e}capture(e=this.offset){let t=function(e,t,i){if(void 0!==e.slice)return e.slice(t,i);let n=new Int32Array(i);for(;t<i;t++)n[t]=d(e[t]);return n}(this.heap,0,e).buffer;return{handle:this.handle,table:this.handleTable,buffer:t}}}class N{_opcode;constructor(e,t){this.constants=e,this.heap=t,this._opcode=new x(this.heap)}opcode(e){return this._opcode.offset=e,this._opcode}}function W(e,t){return P?d(e[t+1])-d(e[t]):-1}function F(){return{constants:new _,heap:new V}}export{T as CompileTimeConstantImpl,_ as ConstantsImpl,V as HeapImpl,M as RuntimeConstantsImpl,k as RuntimeHeapImpl,x as RuntimeOpImpl,N as RuntimeProgramImpl,F as artifacts,L as hydrateHeap};
//# sourceMappingURL=index.js.map
