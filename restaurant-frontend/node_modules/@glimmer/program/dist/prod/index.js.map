{"version":3,"file":"index.js","sources":["../../lib/util/default-template.ts","../../lib/constants.ts","../../../local-debug-flags/index.ts","../../lib/opcode.ts","../../lib/program.ts","../../lib/helpers.ts"],"sourcesContent":["import type { SerializedTemplateBlock, SerializedTemplateWithLazyBlock } from '@glimmer/interfaces';\nimport { SexpOpcodes as op } from '@glimmer/wire-format';\n\n/**\n * Default component template, which is a plain yield\n */\nconst DEFAULT_TEMPLATE_BLOCK: SerializedTemplateBlock = [\n  [[op.Yield, 1, null]],\n  ['&default'],\n  false,\n  [],\n];\n\nexport const DEFAULT_TEMPLATE: SerializedTemplateWithLazyBlock = {\n  // random uuid\n  id: '1b32f5c2-7623-43d6-a0ad-9672898920a1',\n  moduleName: '__default__.hbs',\n  block: JSON.stringify(DEFAULT_TEMPLATE_BLOCK),\n  scope: null,\n  isStrictMode: true,\n};\n","import type {\n  CompileTimeConstants,\n  ComponentDefinition,\n  ComponentDefinitionState,\n  ConstantPool,\n  HelperDefinitionState,\n  ModifierDefinitionState,\n  ResolutionTimeConstants,\n  ResolvedComponentDefinition,\n  RuntimeConstants,\n  Template,\n} from '@glimmer/interfaces';\nimport {\n  capabilityFlagsFrom,\n  getComponentTemplate,\n  getInternalComponentManager,\n  getInternalHelperManager,\n  getInternalModifierManager,\n  managerHasCapability,\n} from '@glimmer/manager';\nimport { templateFactory } from '@glimmer/opcode-compiler';\nimport { assert, constants, enumerate, expect, unwrapTemplate } from '@glimmer/util';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nimport { DEFAULT_TEMPLATE } from './util/default-template';\n\nconst WELL_KNOWN_EMPTY_ARRAY: unknown = Object.freeze([]);\nconst STARTER_CONSTANTS = constants(WELL_KNOWN_EMPTY_ARRAY);\nconst WELL_KNOWN_EMPTY_ARRAY_POSITION: number = STARTER_CONSTANTS.indexOf(WELL_KNOWN_EMPTY_ARRAY);\n\nexport class CompileTimeConstantImpl implements CompileTimeConstants {\n  // `0` means NULL\n\n  protected values: unknown[] = STARTER_CONSTANTS.slice();\n  protected indexMap: Map<unknown, number> = new Map(\n    this.values.map((value, index) => [value, index])\n  );\n\n  value(value: unknown) {\n    let indexMap = this.indexMap;\n    let index = indexMap.get(value);\n\n    if (index === undefined) {\n      index = this.values.push(value) - 1;\n      indexMap.set(value, index);\n    }\n\n    return index;\n  }\n\n  array(values: unknown[]): number {\n    if (values.length === 0) {\n      return WELL_KNOWN_EMPTY_ARRAY_POSITION;\n    }\n\n    let handles: number[] = new Array(values.length);\n\n    for (let i = 0; i < values.length; i++) {\n      handles[i] = this.value(values[i]);\n    }\n\n    return this.value(handles);\n  }\n\n  toPool(): ConstantPool {\n    return this.values;\n  }\n}\n\nexport class RuntimeConstantsImpl implements RuntimeConstants {\n  protected values: unknown[];\n\n  constructor(pool: ConstantPool) {\n    this.values = pool;\n  }\n\n  getValue<T>(handle: number) {\n    return this.values[handle] as T;\n  }\n\n  getArray<T>(value: number): T[] {\n    let handles = this.getValue<number[]>(value);\n    let reified: T[] = new Array(handles.length);\n\n    for (const [i, n] of enumerate(handles)) {\n      reified[i] = this.getValue(n);\n    }\n\n    return reified;\n  }\n}\n\nexport class ConstantsImpl\n  extends CompileTimeConstantImpl\n  implements RuntimeConstants, ResolutionTimeConstants\n{\n  protected reifiedArrs: { [key: number]: unknown[] } = {\n    [WELL_KNOWN_EMPTY_ARRAY_POSITION]: WELL_KNOWN_EMPTY_ARRAY as unknown[],\n  };\n\n  defaultTemplate: Template = templateFactory(DEFAULT_TEMPLATE)();\n\n  // Used for tests and debugging purposes, and to be able to analyze large apps\n  // This is why it's enabled even in production\n  helperDefinitionCount = 0;\n  modifierDefinitionCount = 0;\n  componentDefinitionCount = 0;\n\n  private helperDefinitionCache = new WeakMap<HelperDefinitionState, number | null>();\n\n  private modifierDefinitionCache = new WeakMap<ModifierDefinitionState, number | null>();\n\n  private componentDefinitionCache = new WeakMap<\n    ComponentDefinitionState | ResolvedComponentDefinition,\n    ComponentDefinition | null\n  >();\n\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName: string | null,\n    isOptional: true\n  ): number | null;\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName?: string | null\n  ): number;\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName: string | null = null,\n    isOptional?: true\n  ): number | null {\n    let handle = this.helperDefinitionCache.get(definitionState);\n\n    if (handle === undefined) {\n      let managerOrHelper = getInternalHelperManager(definitionState, isOptional);\n\n      if (managerOrHelper === null) {\n        this.helperDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      assert(managerOrHelper, 'BUG: expected manager or helper');\n\n      let helper =\n        typeof managerOrHelper === 'function'\n          ? managerOrHelper\n          : managerOrHelper.getHelper(definitionState);\n\n      handle = this.value(helper);\n\n      this.helperDefinitionCache.set(definitionState, handle);\n      this.helperDefinitionCount++;\n    }\n\n    return handle;\n  }\n\n  modifier(\n    definitionState: ModifierDefinitionState,\n    resolvedName: string | null,\n    isOptional: true\n  ): number | null;\n  modifier(definitionState: ModifierDefinitionState, resolvedName?: string | null): number;\n  modifier(\n    definitionState: ModifierDefinitionState,\n    resolvedName: string | null = null,\n    isOptional?: true\n  ): number | null {\n    let handle = this.modifierDefinitionCache.get(definitionState);\n\n    if (handle === undefined) {\n      let manager = getInternalModifierManager(definitionState, isOptional);\n\n      if (manager === null) {\n        this.modifierDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      let definition = {\n        resolvedName,\n        manager,\n        state: definitionState,\n      };\n\n      handle = this.value(definition);\n\n      this.modifierDefinitionCache.set(definitionState, handle);\n      this.modifierDefinitionCount++;\n    }\n\n    return handle;\n  }\n\n  component(definitionState: ComponentDefinitionState, owner: object): ComponentDefinition;\n  component(\n    definitionState: ComponentDefinitionState,\n    owner: object,\n    isOptional?: true\n  ): ComponentDefinition | null {\n    let definition = this.componentDefinitionCache.get(definitionState);\n\n    if (definition === undefined) {\n      let manager = getInternalComponentManager(definitionState, isOptional);\n\n      if (manager === null) {\n        this.componentDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      assert(manager, 'BUG: expected manager');\n\n      let capabilities = capabilityFlagsFrom(manager.getCapabilities(definitionState));\n\n      let templateFactory = getComponentTemplate(definitionState);\n\n      let compilable = null;\n      let template;\n\n      if (\n        !managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout)\n      ) {\n        template = templateFactory?.(owner) ?? this.defaultTemplate;\n      } else {\n        template = templateFactory?.(owner);\n      }\n\n      if (template !== undefined) {\n        template = unwrapTemplate(template);\n\n        compilable = managerHasCapability(\n          manager,\n          capabilities,\n          InternalComponentCapabilities.wrapped\n        )\n          ? template.asWrappedLayout()\n          : template.asLayout();\n      }\n\n      definition = {\n        resolvedName: null,\n        handle: -1, // replaced momentarily\n        manager,\n        capabilities,\n        state: definitionState,\n        compilable,\n      };\n\n      definition.handle = this.value(definition);\n      this.componentDefinitionCache.set(definitionState, definition);\n      this.componentDefinitionCount++;\n    }\n\n    return definition;\n  }\n\n  resolvedComponent(\n    resolvedDefinition: ResolvedComponentDefinition,\n    resolvedName: string\n  ): ComponentDefinition {\n    let definition = this.componentDefinitionCache.get(resolvedDefinition);\n\n    if (definition === undefined) {\n      let { manager, state, template } = resolvedDefinition;\n      let capabilities = capabilityFlagsFrom(manager.getCapabilities(resolvedDefinition));\n\n      let compilable = null;\n\n      if (\n        !managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout)\n      ) {\n        template = template ?? this.defaultTemplate;\n      }\n\n      if (template !== null) {\n        template = unwrapTemplate(template);\n\n        compilable = managerHasCapability(\n          manager,\n          capabilities,\n          InternalComponentCapabilities.wrapped\n        )\n          ? template.asWrappedLayout()\n          : template.asLayout();\n      }\n\n      definition = {\n        resolvedName,\n        handle: -1, // replaced momentarily\n        manager,\n        capabilities,\n        state,\n        compilable,\n      };\n\n      definition.handle = this.value(definition);\n      this.componentDefinitionCache.set(resolvedDefinition, definition);\n      this.componentDefinitionCount++;\n    }\n\n    return expect(definition, 'BUG: resolved component definitions cannot be null');\n  }\n\n  getValue<T>(index: number) {\n    assert(index >= 0, `cannot get value for handle: ${index}`);\n\n    return this.values[index] as T;\n  }\n\n  getArray<T>(index: number): T[] {\n    let reifiedArrs = this.reifiedArrs;\n    let reified = reifiedArrs[index] as T[];\n\n    if (reified === undefined) {\n      let names: number[] = this.getValue(index);\n      reified = new Array(names.length);\n\n      for (const [i, name] of enumerate(names)) {\n        reified[i] = this.getValue(name);\n      }\n\n      reifiedArrs[index] = reified;\n    }\n\n    return reified;\n  }\n}\n","export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { OpcodeHeap, RuntimeOp, SomeVmOp } from '@glimmer/interfaces';\nimport { ARG_SHIFT, MACHINE_MASK, OPERAND_LEN_MASK, TYPE_MASK } from '@glimmer/vm';\n\nexport class RuntimeOpImpl implements RuntimeOp {\n  public offset = 0;\n  constructor(readonly heap: OpcodeHeap) {}\n\n  get size() {\n    let rawType = this.heap.getbyaddr(this.offset);\n    return ((rawType & OPERAND_LEN_MASK) >> ARG_SHIFT) + 1;\n  }\n\n  get isMachine(): 0 | 1 {\n    let rawType = this.heap.getbyaddr(this.offset);\n    return rawType & MACHINE_MASK ? 1 : 0;\n  }\n\n  get type(): SomeVmOp {\n    return (this.heap.getbyaddr(this.offset) & TYPE_MASK) as SomeVmOp;\n  }\n\n  get op1() {\n    return this.heap.getbyaddr(this.offset + 1);\n  }\n\n  get op2() {\n    return this.heap.getbyaddr(this.offset + 2);\n  }\n\n  get op3() {\n    return this.heap.getbyaddr(this.offset + 3);\n  }\n}\n","import type {\n  CompileTimeHeap,\n  ResolutionTimeConstants,\n  RuntimeConstants,\n  RuntimeHeap,\n  RuntimeProgram,\n  SerializedHeap,\n  StdLibOperand,\n} from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { expect, unwrap } from '@glimmer/util';\nimport { MACHINE_MASK } from '@glimmer/vm';\n\nimport { RuntimeOpImpl } from './opcode';\n\nconst enum TableSlotState {\n  Allocated,\n  Freed,\n  Purged,\n  Pointer,\n}\n\nexport type Placeholder = [number, () => number];\nexport type StdlibPlaceholder = [number, StdLibOperand];\n\nconst PAGE_SIZE = 0x100000;\n\nexport class RuntimeHeapImpl implements RuntimeHeap {\n  private heap: Int32Array;\n  private table: number[];\n\n  constructor(serializedHeap: SerializedHeap) {\n    let { buffer, table } = serializedHeap;\n    this.heap = new Int32Array(buffer);\n    this.table = table;\n  }\n\n  // It is illegal to close over this address, as compaction\n  // may move it. However, it is legal to use this address\n  // multiple times between compactions.\n  getaddr(handle: number): number {\n    return unwrap(this.table[handle]);\n  }\n\n  getbyaddr(address: number): number {\n    return expect(this.heap[address], 'Access memory out of bounds of the heap');\n  }\n\n  sizeof(handle: number): number {\n    return sizeof(this.table, handle);\n  }\n}\n\nexport function hydrateHeap(serializedHeap: SerializedHeap): RuntimeHeap {\n  return new RuntimeHeapImpl(serializedHeap);\n}\n\n/**\n * The Heap is responsible for dynamically allocating\n * memory in which we read/write the VM's instructions\n * from/to. When we malloc we pass out a VMHandle, which\n * is used as an indirect way of accessing the memory during\n * execution of the VM. Internally we track the different\n * regions of the memory in an int array known as the table.\n *\n * The table 32-bit aligned and has the following layout:\n *\n * | ... | hp (u32) |       info (u32)   | size (u32) |\n * | ... |  Handle  | Scope Size | State | Size       |\n * | ... | 32bits   | 30bits     | 2bits | 32bit      |\n *\n * With this information we effectively have the ability to\n * control when we want to free memory. That being said you\n * can not free during execution as raw address are only\n * valid during the execution. This means you cannot close\n * over them as you will have a bad memory access exception.\n */\nexport class HeapImpl implements CompileTimeHeap, RuntimeHeap {\n  offset = 0;\n\n  private heap: Int32Array;\n  private handleTable: number[];\n  private handleState: TableSlotState[];\n  private handle = 0;\n\n  constructor() {\n    this.heap = new Int32Array(PAGE_SIZE);\n    this.handleTable = [];\n    this.handleState = [];\n  }\n\n  pushRaw(value: number): void {\n    this.sizeCheck();\n    this.heap[this.offset++] = value;\n  }\n\n  pushOp(item: number): void {\n    this.pushRaw(item);\n  }\n\n  pushMachine(item: number): void {\n    this.pushRaw(item | MACHINE_MASK);\n  }\n\n  private sizeCheck() {\n    let { heap } = this;\n\n    if (this.offset === this.heap.length) {\n      let newHeap = new Int32Array(heap.length + PAGE_SIZE);\n      newHeap.set(heap, 0);\n      this.heap = newHeap;\n    }\n  }\n\n  getbyaddr(address: number): number {\n    return unwrap(this.heap[address]);\n  }\n\n  setbyaddr(address: number, value: number) {\n    this.heap[address] = value;\n  }\n\n  malloc(): number {\n    // push offset, info, size\n    this.handleTable.push(this.offset);\n    return this.handleTable.length - 1;\n  }\n\n  finishMalloc(handle: number): void {\n    // @TODO: At the moment, garbage collection isn't actually used, so this is\n    // wrapped to prevent us from allocating extra space in prod. In the future,\n    // if we start using the compact API, we should change this.\n    if (LOCAL_DEBUG) {\n      this.handleState[handle] = TableSlotState.Allocated;\n    }\n  }\n\n  size(): number {\n    return this.offset;\n  }\n\n  // It is illegal to close over this address, as compaction\n  // may move it. However, it is legal to use this address\n  // multiple times between compactions.\n  getaddr(handle: number): number {\n    return unwrap(this.handleTable[handle]);\n  }\n\n  sizeof(handle: number): number {\n    return sizeof(this.handleTable, handle);\n  }\n\n  free(handle: number): void {\n    this.handleState[handle] = TableSlotState.Freed;\n  }\n\n  /**\n   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift\n   * reachable memory to the bottom of the heap and freeable\n   * memory to the top of the heap. When we have shifted all\n   * the reachable memory to the top of the heap, we move the\n   * offset to the next free position.\n   */\n  compact(): void {\n    let compactedSize = 0;\n    let { handleTable, handleState, heap } = this;\n\n    for (let i = 0; i < length; i++) {\n      let offset = unwrap(handleTable[i]);\n      let size = unwrap(handleTable[i + 1]) - unwrap(offset);\n      let state = handleState[i];\n\n      if (state === TableSlotState.Purged) {\n        continue;\n      } else if (state === TableSlotState.Freed) {\n        // transition to \"already freed\" aka \"purged\"\n        // a good improvement would be to reuse\n        // these slots\n        handleState[i] = TableSlotState.Purged;\n        compactedSize += size;\n      } else if (state === TableSlotState.Allocated) {\n        for (let j = offset; j <= i + size; j++) {\n          heap[j - compactedSize] = unwrap(heap[j]);\n        }\n\n        handleTable[i] = offset - compactedSize;\n      } else if (state === TableSlotState.Pointer) {\n        handleTable[i] = offset - compactedSize;\n      }\n    }\n\n    this.offset = this.offset - compactedSize;\n  }\n\n  capture(offset = this.offset): SerializedHeap {\n    // Only called in eager mode\n    let buffer = slice(this.heap, 0, offset).buffer;\n    return {\n      handle: this.handle,\n      table: this.handleTable,\n      buffer: buffer as ArrayBuffer,\n    };\n  }\n}\n\nexport class RuntimeProgramImpl implements RuntimeProgram {\n  [key: number]: never;\n\n  private _opcode: RuntimeOpImpl;\n\n  constructor(\n    public constants: RuntimeConstants & ResolutionTimeConstants,\n    public heap: RuntimeHeap\n  ) {\n    this._opcode = new RuntimeOpImpl(this.heap);\n  }\n\n  opcode(offset: number): RuntimeOpImpl {\n    this._opcode.offset = offset;\n    return this._opcode;\n  }\n}\n\nfunction slice(arr: Int32Array, start: number, end: number): Int32Array {\n  if (arr.slice !== undefined) {\n    return arr.slice(start, end);\n  }\n\n  let ret = new Int32Array(end);\n\n  for (; start < end; start++) {\n    ret[start] = unwrap(arr[start]);\n  }\n\n  return ret;\n}\n\nfunction sizeof(table: number[], handle: number) {\n  if (LOCAL_DEBUG) {\n    return unwrap(table[handle + 1]) - unwrap(table[handle]);\n  } else {\n    return -1;\n  }\n}\n","import type { CompileTimeArtifacts, RuntimeArtifacts } from '@glimmer/interfaces';\n\nimport { ConstantsImpl } from './constants';\nimport { HeapImpl } from './program';\n\nexport function artifacts(): CompileTimeArtifacts & RuntimeArtifacts {\n  return {\n    constants: new ConstantsImpl(),\n    heap: new HeapImpl(),\n  };\n}\n"],"names":["DEFAULT_TEMPLATE_BLOCK","op","Yield","DEFAULT_TEMPLATE","id","moduleName","block","JSON","stringify","scope","isStrictMode","WELL_KNOWN_EMPTY_ARRAY","Object","freeze","STARTER_CONSTANTS","constants","WELL_KNOWN_EMPTY_ARRAY_POSITION","indexOf","CompileTimeConstantImpl","values","slice","indexMap","Map","this","map","value","index","get","undefined","push","set","array","length","handles","Array","i","toPool","RuntimeConstantsImpl","constructor","pool","getValue","handle","getArray","reified","n","enumerate","ConstantsImpl","reifiedArrs","defaultTemplate","templateFactory","helperDefinitionCount","modifierDefinitionCount","componentDefinitionCount","helperDefinitionCache","WeakMap","modifierDefinitionCache","componentDefinitionCache","helper","definitionState","_resolvedName","isOptional","managerOrHelper","getInternalHelperManager","assert","getHelper","modifier","resolvedName","manager","getInternalModifierManager","definition","state","component","owner","getInternalComponentManager","template","capabilities","capabilityFlagsFrom","getCapabilities","getComponentTemplate","compilable","managerHasCapability","InternalComponentCapabilities","dynamicLayout","unwrapTemplate","wrapped","asWrappedLayout","asLayout","resolvedComponent","resolvedDefinition","expect","names","name","LOCAL_DEBUG","window","location","test","search","RuntimeOpImpl","offset","heap","size","getbyaddr","OPERAND_LEN_MASK","ARG_SHIFT","isMachine","MACHINE_MASK","type","TYPE_MASK","op1","op2","op3","TableSlotState","PAGE_SIZE","RuntimeHeapImpl","table","serializedHeap","buffer","Int32Array","getaddr","unwrap","address","sizeof","hydrateHeap","HeapImpl","handleTable","handleState","pushRaw","sizeCheck","pushOp","item","pushMachine","newHeap","setbyaddr","malloc","finishMalloc","Allocated","free","Freed","compact","compactedSize","Purged","j","Pointer","capture","arr","start","end","ret","RuntimeProgramImpl","_opcode","opcode","artifacts"],"mappings":"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"}