import { CompileTimeConstants, ComponentDefinition, ComponentDefinitionState, ConstantPool, HelperDefinitionState, ModifierDefinitionState, ResolutionTimeConstants, ResolvedComponentDefinition, RuntimeConstants, Template, CompileTimeArtifacts, RuntimeArtifacts, OpcodeHeap, RuntimeOp, SomeVmOp, CompileTimeHeap, RuntimeHeap, RuntimeProgram, SerializedHeap, StdLibOperand } from "@glimmer/interfaces";
declare class CompileTimeConstantImpl implements CompileTimeConstants {
    // `0` means NULL
    protected values: unknown[];
    protected indexMap: Map<unknown, number>;
    value(value: unknown): number;
    array(values: unknown[]): number;
    toPool(): ConstantPool;
}
declare class RuntimeConstantsImpl implements RuntimeConstants {
    protected values: unknown[];
    constructor(pool: ConstantPool);
    getValue<T>(handle: number): T;
    getArray<T>(value: number): T[];
}
declare class ConstantsImpl extends CompileTimeConstantImpl implements RuntimeConstants, ResolutionTimeConstants {
    protected reifiedArrs: {
        [key: number]: unknown[];
    };
    defaultTemplate: Template;
    // Used for tests and debugging purposes, and to be able to analyze large apps
    // This is why it's enabled even in production
    helperDefinitionCount: number;
    modifierDefinitionCount: number;
    componentDefinitionCount: number;
    private helperDefinitionCache;
    private modifierDefinitionCache;
    private componentDefinitionCache;
    helper(definitionState: HelperDefinitionState, 
    // TODO: Add a way to expose resolved name for debugging
    _resolvedName: string | null, isOptional: true): number | null;
    helper(definitionState: HelperDefinitionState, 
    // TODO: Add a way to expose resolved name for debugging
    _resolvedName?: string | null): number;
    modifier(definitionState: ModifierDefinitionState, resolvedName: string | null, isOptional: true): number | null;
    modifier(definitionState: ModifierDefinitionState, resolvedName?: string | null): number;
    component(definitionState: ComponentDefinitionState, owner: object): ComponentDefinition;
    resolvedComponent(resolvedDefinition: ResolvedComponentDefinition, resolvedName: string): ComponentDefinition;
    getValue<T>(index: number): T;
    getArray<T>(index: number): T[];
}
declare function artifacts(): CompileTimeArtifacts & RuntimeArtifacts;
declare class RuntimeOpImpl implements RuntimeOp {
    readonly heap: OpcodeHeap;
    offset: number;
    constructor(heap: OpcodeHeap);
    get size(): number;
    get isMachine(): 0 | 1;
    get type(): SomeVmOp;
    get op1(): number;
    get op2(): number;
    get op3(): number;
}
type Placeholder = [
    number,
    () => number
];
type StdlibPlaceholder = [
    number,
    StdLibOperand
];
declare class RuntimeHeapImpl implements RuntimeHeap {
    private heap;
    private table;
    constructor(serializedHeap: SerializedHeap);
    // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.
    getaddr(handle: number): number;
    getbyaddr(address: number): number;
    sizeof(handle: number): number;
}
declare function hydrateHeap(serializedHeap: SerializedHeap): RuntimeHeap;
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */
declare class HeapImpl implements CompileTimeHeap, RuntimeHeap {
    offset: number;
    private heap;
    private handleTable;
    private handleState;
    private handle;
    constructor();
    pushRaw(value: number): void;
    pushOp(item: number): void;
    pushMachine(item: number): void;
    private sizeCheck;
    getbyaddr(address: number): number;
    setbyaddr(address: number, value: number): void;
    malloc(): number;
    finishMalloc(handle: number): void;
    size(): number;
    // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.
    getaddr(handle: number): number;
    sizeof(handle: number): number;
    free(handle: number): void;
    /**
     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
     * reachable memory to the bottom of the heap and freeable
     * memory to the top of the heap. When we have shifted all
     * the reachable memory to the top of the heap, we move the
     * offset to the next free position.
     */
    compact(): void;
    capture(offset?: number): SerializedHeap;
}
declare class RuntimeProgramImpl implements RuntimeProgram {
    constants: RuntimeConstants & ResolutionTimeConstants;
    heap: RuntimeHeap;
    [key: number]: never;
    private _opcode;
    constructor(constants: RuntimeConstants & ResolutionTimeConstants, heap: RuntimeHeap);
    opcode(offset: number): RuntimeOpImpl;
}
export { CompileTimeConstantImpl, RuntimeConstantsImpl, ConstantsImpl, artifacts, RuntimeOpImpl, Placeholder, StdlibPlaceholder, RuntimeHeapImpl, hydrateHeap, HeapImpl, RuntimeProgramImpl };
//# sourceMappingURL=index.d.cts.map