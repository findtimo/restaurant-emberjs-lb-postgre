import{scheduleDestroyed as t,scheduleDestroy as e}from"@glimmer/global-context";import{debugToString as r}from"@glimmer/util";var o=function(t){return t[t.Live=0]="Live",t[t.Destroying=1]="Destroying",t[t.Destroyed=2]="Destroyed",t}(o||{});let n,s,i=new WeakMap;function a(t,e){return null===t?e:Array.isArray(t)?(t.push(e),t):[t,e]}function d(t,e){Array.isArray(t)?t.forEach(e):null!==t&&e(t)}function l(t,e,r){{let o=t===e,n=Array.isArray(t)&&-1!==t.indexOf(e);if(!o&&!n)throw new Error(String(r))}if(Array.isArray(t)&&t.length>1){let r=t.indexOf(e);return t.splice(r,1),t}return null}function u(t){let e=i.get(t);return void 0===e&&(e={parents:null,children:null,eagerDestructors:null,destructors:null,state:o.Live},e.source=t,i.set(t,e)),e}function c(t,e){if(w(t))throw new Error("Attempted to associate a destroyable child with an object that is already destroying or destroyed");let r=u(t),o=u(e);return r.children=a(r.children,e),o.parents=a(o.parents,t),e}function y(t,e,r=!1){if(w(t))throw new Error("Attempted to register a destructor with an object that is already destroying or destroyed");let o=u(t),n=!0===r?"eagerDestructors":"destructors";return o[n]=a(o[n],e),e}function h(t,e,r=!1){if(w(t))throw new Error("Attempted to unregister a destructor with an object that is already destroying or destroyed");let o=u(t),n=!0===r?"eagerDestructors":"destructors";o[n]=l(o[n],e,"attempted to remove a destructor that was not registered with the destroyable")}function f(r){let n=u(r);if(n.state>=o.Destroying)return;let{parents:s,children:i,eagerDestructors:a,destructors:c}=n;n.state=o.Destroying,d(i,f),d(a,(t=>t(r))),d(c,(t=>e(r,t))),t((()=>{d(s,(t=>function(t,e){let r=u(e);r.state===o.Live&&(r.children=l(r.children,t,"attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors."))}(r,t))),n.state=o.Destroyed}))}function g(t){let{children:e}=u(t);d(e,f)}function p(t){let e=i.get(t);return void 0!==e&&null!==e.children}function w(t){let e=i.get(t);return void 0!==e&&e.state>=o.Destroying}function m(t){let e=i.get(t);return void 0!==e&&e.state>=o.Destroyed}{let t=!1;n=()=>{if(t)throw i=new WeakMap,new Error("Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`");t=!0,i=new Map},s=()=>{if(!t)throw new Error("Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`");t=!1;let e=i;i=new WeakMap;let n=[];if(e.forEach((t=>{t.state!==o.Destroyed&&n.push(t.source)})),n.length>0){let t=n.map(r).join("\n    "),e=new Error(`Some destroyables were not destroyed during this test:\n    ${t}`);throw e.destroyables=n,e}}}export{p as _hasDestroyableChildren,s as assertDestroyablesDestroyed,c as associateDestroyableChild,f as destroy,g as destroyChildren,n as enableDestroyableTracking,m as isDestroyed,w as isDestroying,y as registerDestructor,h as unregisterDestructor};
//# sourceMappingURL=index.js.map
