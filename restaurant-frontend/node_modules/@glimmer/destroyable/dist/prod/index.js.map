{"version":3,"file":"index.js","sources":["../../index.ts"],"sourcesContent":["import type { Destroyable, Destructor } from '@glimmer/interfaces';\nimport { scheduleDestroy, scheduleDestroyed } from '@glimmer/global-context';\nimport { debugToString } from '@glimmer/util';\n\nconst enum DestroyingState {\n  Live = 0,\n  Destroying = 1,\n  Destroyed = 2,\n}\n\ntype OneOrMany<T> = null | T | T[];\n\ninterface DestroyableMeta<T extends Destroyable> {\n  source?: T;\n  parents: OneOrMany<Destroyable>;\n  children: OneOrMany<Destroyable>;\n  eagerDestructors: OneOrMany<Destructor<T>>;\n  destructors: OneOrMany<Destructor<T>>;\n  state: DestroyingState;\n}\n\ninterface UndestroyedDestroyablesError extends Error {\n  destroyables: object[];\n}\n\nlet DESTROYABLE_META:\n  | Map<Destroyable, DestroyableMeta<Destroyable>>\n  | WeakMap<Destroyable, DestroyableMeta<Destroyable>> = new WeakMap();\n\nfunction push<T extends object>(collection: OneOrMany<T>, newItem: T): OneOrMany<T> {\n  if (collection === null) {\n    return newItem;\n  } else if (Array.isArray(collection)) {\n    collection.push(newItem);\n    return collection;\n  } else {\n    return [collection, newItem];\n  }\n}\n\nfunction iterate<T extends object>(collection: OneOrMany<T>, fn: (item: T) => void) {\n  if (Array.isArray(collection)) {\n    collection.forEach(fn);\n  } else if (collection !== null) {\n    fn(collection);\n  }\n}\n\nfunction remove<T extends object>(collection: OneOrMany<T>, item: T, message: string | false) {\n  if (import.meta.env.DEV) {\n    let collectionIsItem = collection === item;\n    let collectionContainsItem = Array.isArray(collection) && collection.indexOf(item) !== -1;\n\n    if (!collectionIsItem && !collectionContainsItem) {\n      throw new Error(String(message));\n    }\n  }\n\n  if (Array.isArray(collection) && collection.length > 1) {\n    let index = collection.indexOf(item);\n    collection.splice(index, 1);\n    return collection;\n  } else {\n    return null;\n  }\n}\n\nfunction getDestroyableMeta<T extends Destroyable>(destroyable: T): DestroyableMeta<T> {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  if (meta === undefined) {\n    meta = {\n      parents: null,\n      children: null,\n      eagerDestructors: null,\n      destructors: null,\n      state: DestroyingState.Live,\n    };\n\n    if (import.meta.env.DEV) {\n      meta.source = destroyable as object;\n    }\n\n    DESTROYABLE_META.set(destroyable, meta);\n  }\n\n  return meta as unknown as DestroyableMeta<T>;\n}\n\nexport function associateDestroyableChild<T extends Destroyable>(parent: Destroyable, child: T): T {\n  if (import.meta.env.DEV && isDestroying(parent)) {\n    throw new Error(\n      'Attempted to associate a destroyable child with an object that is already destroying or destroyed'\n    );\n  }\n\n  let parentMeta = getDestroyableMeta(parent);\n  let childMeta = getDestroyableMeta(child);\n\n  parentMeta.children = push(parentMeta.children, child);\n  childMeta.parents = push(childMeta.parents, parent);\n\n  return child;\n}\n\nexport function registerDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): Destructor<T> {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to register a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' =\n    eager === true ? 'eagerDestructors' : 'destructors';\n\n  meta[destructorsKey] = push(meta[destructorsKey], destructor);\n\n  return destructor;\n}\n\nexport function unregisterDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): void {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to unregister a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' =\n    eager === true ? 'eagerDestructors' : 'destructors';\n\n  meta[destructorsKey] = remove(\n    meta[destructorsKey],\n    destructor,\n    import.meta.env.DEV &&\n      'attempted to remove a destructor that was not registered with the destroyable'\n  );\n}\n\n////////////\n\nexport function destroy(destroyable: Destroyable) {\n  let meta = getDestroyableMeta(destroyable);\n\n  if (meta.state >= DestroyingState.Destroying) return;\n\n  let { parents, children, eagerDestructors, destructors } = meta;\n\n  meta.state = DestroyingState.Destroying;\n\n  iterate(children, destroy);\n  iterate(eagerDestructors, (destructor) => destructor(destroyable));\n  iterate(destructors, (destructor) => scheduleDestroy(destroyable, destructor));\n\n  scheduleDestroyed(() => {\n    iterate(parents, (parent) => removeChildFromParent(destroyable, parent));\n\n    meta.state = DestroyingState.Destroyed;\n  });\n}\n\nfunction removeChildFromParent(child: Destroyable, parent: Destroyable) {\n  let parentMeta = getDestroyableMeta(parent);\n\n  if (parentMeta.state === DestroyingState.Live) {\n    parentMeta.children = remove(\n      parentMeta.children,\n      child,\n      import.meta.env.DEV &&\n        \"attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors.\"\n    );\n  }\n}\n\nexport function destroyChildren(destroyable: Destroyable) {\n  let { children } = getDestroyableMeta(destroyable);\n\n  iterate(children, destroy);\n}\n\nexport function _hasDestroyableChildren(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.children !== null;\n}\n\nexport function isDestroying(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DestroyingState.Destroying;\n}\n\nexport function isDestroyed(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DestroyingState.Destroyed;\n}\n\n////////////\n\nexport let enableDestroyableTracking: undefined | (() => void);\nexport let assertDestroyablesDestroyed: undefined | (() => void);\n\nif (import.meta.env.DEV) {\n  let isTesting = false;\n\n  enableDestroyableTracking = () => {\n    if (isTesting) {\n      // Reset destroyable meta just in case, before throwing the error\n      DESTROYABLE_META = new WeakMap();\n      throw new Error(\n        'Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`'\n      );\n    }\n\n    isTesting = true;\n    DESTROYABLE_META = new Map();\n  };\n\n  assertDestroyablesDestroyed = () => {\n    if (!isTesting) {\n      throw new Error(\n        'Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`'\n      );\n    }\n\n    isTesting = false;\n\n    let map = DESTROYABLE_META as Map<Destroyable, DestroyableMeta<Destroyable>>;\n    DESTROYABLE_META = new WeakMap();\n\n    let undestroyed: object[] = [];\n\n    map.forEach((meta) => {\n      if (meta.state !== DestroyingState.Destroyed) {\n        undestroyed.push(meta.source!);\n      }\n    });\n\n    if (undestroyed.length > 0) {\n      let objectsToString = undestroyed.map(debugToString!).join('\\n    ');\n      let error = new Error(\n        `Some destroyables were not destroyed during this test:\\n    ${objectsToString}`\n      ) as UndestroyedDestroyablesError;\n\n      error.destroyables = undestroyed;\n\n      throw error;\n    }\n  };\n}\n"],"names":["DestroyingState","enableDestroyableTracking","assertDestroyablesDestroyed","DESTROYABLE_META","WeakMap","push","collection","newItem","Array","isArray","iterate","fn","forEach","remove","item","message","collectionIsItem","collectionContainsItem","indexOf","Error","String","length","index","splice","getDestroyableMeta","destroyable","meta","get","undefined","parents","children","eagerDestructors","destructors","state","Live","source","set","associateDestroyableChild","parent","child","isDestroying","parentMeta","childMeta","registerDestructor","destructor","eager","destructorsKey","unregisterDestructor","destroy","Destroying","scheduleDestroy","scheduleDestroyed","removeChildFromParent","Destroyed","destroyChildren","_hasDestroyableChildren","isDestroyed","isTesting","Map","map","undestroyed","objectsToString","debugToString","join","error","destroyables"],"mappings":"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"}