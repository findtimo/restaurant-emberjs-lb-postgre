import{debugToString as e,castToBrowser as t}from"@glimmer/util";import{associateDestroyableChild as n,registerDestructor as r}from"@glimmer/destroyable";import{valueForRef as o,createComputeRef as a,createConstRef as i,UNDEFINED_REFERENCE as s}from"@glimmer/reference";import{track as l,createUpdatableTag as u,untrack as c}from"@glimmer/validator";import{check as f,CheckNumber as p}from"@glimmer/debug";import{InternalComponentCapabilities as d}from"@glimmer/vm";const m=new WeakMap;function h(e){return m.get(e)}function g(e,t){m.set(e,t)}function b(e){if("symbol"==typeof e)return null;const t=Number(e);return isNaN(t)?null:t%1==0?t:null}class w{constructor(e){this.named=e}get(e,t){const n=this.named[t];if(void 0!==n)return o(n)}has(e,t){return t in this.named}ownKeys(){return Object.keys(this.named)}isExtensible(){return!1}getOwnPropertyDescriptor(e,t){if(!(t in this.named))throw new Error(`args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \`${String(t)}\``);return{enumerable:!0,configurable:!0}}}class y{constructor(e){this.positional=e}get(e,t){let{positional:n}=this;if("length"===t)return n.length;const r=b(t);return null!==r&&r<n.length?o(n[r]):e[t]}isExtensible(){return!1}has(e,t){const n=b(t);return null!==n&&n<this.positional.length}}const v=(e,t)=>{const{named:n,positional:r}=e;const a=new w(n),i=new y(r),s=Object.create(null);{const e=function(e,t){throw new Error(`You attempted to set ${String(t)} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`)},n=()=>{throw new Error(`Object.keys() was called on the positional arguments array for a ${t}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`)};a.set=e,i.set=e,i.ownKeys=n}const u=new Proxy(s,a),c=new Proxy([],i);return g(u,((e,t)=>function(e,t){return l((()=>{t in e&&o(e[t])}))}(n,t))),g(c,((e,t)=>function(e,t){return l((()=>{"[]"===t&&e.forEach(o);const n=b(t);null!==n&&n<e.length&&o(e[n])}))}(r,t))),{named:u,positional:c}},E=new WeakSet;function D(e){return E.add(e),Object.freeze(e),e}const k=d.Empty;function M(e){return k|C(e,"dynamicLayout")|C(e,"dynamicTag")|C(e,"prepareArgs")|C(e,"createArgs")|C(e,"attributeHook")|C(e,"elementHook")|C(e,"dynamicScope")|C(e,"createCaller")|C(e,"updateHook")|C(e,"createInstance")|C(e,"wrapped")|C(e,"willDestroy")|C(e,"hasSubOwner")}function C(e,t){return e[t]?d[t]:k}function j(e,t,n){return f(t,p),!!(t&n)}function S(e,t){return f(e,p),!!(e&t)}function O(e,t={}){if("3.23"!==e)throw new Error("Invalid helper manager compatibility specified");if(!t.hasValue&&!t.hasScheduledEffect||t.hasValue&&t.hasScheduledEffect)throw new Error("You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.");if(t.hasScheduledEffect)throw new Error("The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead");return D({hasValue:Boolean(t.hasValue),hasDestroyable:Boolean(t.hasDestroyable),hasScheduledEffect:Boolean(t.hasScheduledEffect)})}function T(e){return e.capabilities.hasValue}function $(e){return e.capabilities.hasDestroyable}class A{constructor(e){this.factory=e}helperManagerDelegates=new WeakMap;undefinedDelegate=null;getDelegateForOwner(e){let t=this.helperManagerDelegates.get(e);if(void 0===t){let{factory:n}=this;if(t=n(e),!E.has(t.capabilities))throw new Error(`Custom helper managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.23')\` (imported via \`import { capabilities } from '@ember/helper';\`). Received: \`${JSON.stringify(t.capabilities)}\` for: \`${t}\``);this.helperManagerDelegates.set(e,t)}return t}getDelegateFor(e){if(void 0===e){let{undefinedDelegate:e}=this;if(null===e){let{factory:t}=this;this.undefinedDelegate=e=t(void 0)}return e}return this.getDelegateForOwner(e)}getHelper(e){return(t,r)=>{let o=this.getDelegateFor(r);const l=v(t,"helper"),u=o.createHelper(e,l);if(T(o)){let t=a((()=>o.getValue(u)),null,o.getDebugName&&o.getDebugName(e));return $(o)&&n(t,o.getDestroyable(u)),t}if($(o)){let t=i(void 0,o.getDebugName?.(e)??"unknown helper");return n(t,o.getDestroyable(u)),t}return s}}}class N{capabilities=D({hasValue:!0,hasDestroyable:!1,hasScheduledEffect:!1});createHelper(e,t){return{fn:e,args:t}}getValue({fn:e,args:t}){if(Object.keys(t.named).length>0){return e(...[...t.positional,t.named])}return e(...t.positional)}getDebugName(e){return e.name?`(helper function ${e.name})`:"(anonymous helper function)"}}const H=new WeakMap,V=new WeakMap,L=new WeakMap,W=Object.getPrototypeOf;function x(t,n,r){if(("object"!=typeof r||null===r)&&"function"!=typeof r)throw new Error(`Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${e(r)}`);if(t.has(r))throw new Error(`Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${e(r)}`);return t.set(r,n),r}function F(e,t){let n=t;for(;null!=n;){const t=e.get(n);if(void 0!==t)return t;n=W(n)}}function P(e,t){return x(V,e,t)}function B(t,n){if("function"!=typeof t&&("object"!=typeof t||null===t))throw new Error(`Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${t}`);const r=F(V,t);if(void 0===r){if(!0===n)return null;throw new Error(`Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${e(t)}`)}return r}function I(e,t){return x(L,e,t)}const R=new A((()=>new N));function Y(t,n){if("function"!=typeof t&&("object"!=typeof t||null===t))throw new Error(`Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${t}`);let r=F(L,t);if(void 0===r&&"function"==typeof t&&(r=R),r)return r;if(!0===n)return null;throw new Error(`Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${e(t)}`)}function J(e,t){return x(H,e,t)}function U(t,n){if("function"!=typeof t&&("object"!=typeof t||null===t))throw new Error(`Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${t}`);const r=F(H,t);if(void 0===r){if(!0===n)return null;throw new Error(`Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${e(t)}`)}return r}function K(e){return void 0!==F(H,e)}function z(e){return function(e){return"function"==typeof e}(e)||void 0!==F(L,e)}function q(e){return void 0!==F(V,e)}const G={dynamicLayout:!1,dynamicTag:!1,prepareArgs:!1,createArgs:!0,attributeHook:!1,elementHook:!1,createCaller:!1,dynamicScope:!0,updateHook:!0,createInstance:!0,wrapped:!1,willDestroy:!1,hasSubOwner:!1};function Q(e,t={}){if("3.13"!==e)throw new Error("Invalid component manager compatibility specified");let n=Boolean(t.updateHook);return D({asyncLifeCycleCallbacks:Boolean(t.asyncLifecycleCallbacks),destructor:Boolean(t.destructor),updateHook:n})}function X(e){return e.capabilities.asyncLifeCycleCallbacks}function Z(e){return e.capabilities.updateHook}class _{componentManagerDelegates=new WeakMap;constructor(e){this.factory=e}getDelegateFor(e){let{componentManagerDelegates:t}=this,n=t.get(e);if(void 0===n){let{factory:r}=this;if(n=r(e),!E.has(n.capabilities))throw new Error(`Custom component managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.13')\` (imported via \`import { capabilities } from '@ember/component';\`). Received: \`${JSON.stringify(n.capabilities)}\` for: \`${n}\``);t.set(e,n)}return n}create(e,t,n){let r=this.getDelegateFor(e),o=v(n.capture(),"component"),a=r.createComponent(t,o);return new ee(a,r,o)}getDebugName(e){return"function"==typeof e?e.name:e.toString()}update(e){let{delegate:t}=e;if(Z(t)){let{component:n,args:r}=e;t.updateComponent(n,r)}}didCreate({component:e,delegate:t}){X(t)&&t.didCreateComponent(e)}didUpdate({component:e,delegate:t}){(function(e){return X(e)&&Z(e)})(t)&&t.didUpdateComponent(e)}didRenderLayout(){}didUpdateLayout(){}getSelf({component:e,delegate:t}){return i(t.getContext(e),"this")}getDestroyable(e){const{delegate:t}=e;if(function(e){return e.capabilities.destructor}(t)){const{component:n}=e;return r(e,(()=>t.destroyComponent(n))),e}return null}getCapabilities(){return G}}class ee{constructor(e,t,n){this.component=e,this.delegate=t,this.args=n}}function te(e,t={}){if("3.22"!==e)throw new Error("Invalid modifier manager compatibility specified");return D({disableAutoTracking:Boolean(t.disableAutoTracking)})}class ne{componentManagerDelegates=new WeakMap;constructor(e){this.factory=e}getDelegateFor(e){let{componentManagerDelegates:t}=this,n=t.get(e);if(void 0===n){let{factory:r}=this;if(n=r(e),!E.has(n.capabilities))throw new Error(`Custom modifier managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.22')\` (imported via \`import { capabilities } from '@ember/modifier';\`). Received: \`${JSON.stringify(n.capabilities)}\` for: \`${n}\``);t.set(e,n)}return n}create(e,t,n,o){let a,i=this.getDelegateFor(e),s=v(o,"modifier"),l=i.createModifier(n,s);return a={tag:u(),element:t,delegate:i,args:s,modifier:l},a.debugName="function"==typeof n?n.name:n.toString(),r(a,(()=>i.destroyModifier(l,s))),a}getDebugName({debugName:e}){return e}getTag({tag:e}){return e}install({element:e,args:n,modifier:r,delegate:o}){let{capabilities:a}=o;!0===a.disableAutoTracking?c((()=>o.installModifier(r,t(e,"ELEMENT"),n))):o.installModifier(r,t(e,"ELEMENT"),n)}update({args:e,modifier:t,delegate:n}){let{capabilities:r}=n;!0===r.disableAutoTracking?c((()=>n.updateModifier(t,e))):n.updateModifier(t,e)}getDestroyable(e){return e}}function re(e,t){return J(new _(e),t)}function oe(e,t){return P(new ne(e),t)}function ae(e,t){return I(new A(e),t)}const ie=new WeakMap,se=Object.getPrototypeOf;function le(t,n){if(null===n||"object"!=typeof n&&"function"!=typeof n)throw new Error(`Cannot call \`setComponentTemplate\` on \`${e(n)}\``);if(ie.has(n))throw new Error(`Cannot call \`setComponentTemplate\` multiple times on the same class (\`${e(n)}\`)`);return ie.set(n,t),n}function ue(e){let t=e;for(;null!==t;){let e=ie.get(t);if(void 0!==e)return e;t=se(t)}}export{_ as CustomComponentManager,A as CustomHelperManager,ne as CustomModifierManager,M as capabilityFlagsFrom,Q as componentCapabilities,ue as getComponentTemplate,h as getCustomTagFor,U as getInternalComponentManager,Y as getInternalHelperManager,B as getInternalModifierManager,S as hasCapability,$ as hasDestroyable,K as hasInternalComponentManager,z as hasInternalHelperManager,q as hasInternalModifierManager,T as hasValue,O as helperCapabilities,j as managerHasCapability,te as modifierCapabilities,re as setComponentManager,le as setComponentTemplate,g as setCustomTagFor,ae as setHelperManager,J as setInternalComponentManager,I as setInternalHelperManager,P as setInternalModifierManager,oe as setModifierManager};
//# sourceMappingURL=index.js.map
