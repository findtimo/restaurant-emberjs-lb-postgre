import { Helper, InternalComponentManager, InternalModifierManager, Owner, HelperCapabilities, HelperCapabilitiesVersions, HelperDefinitionState, HelperManager, HelperManagerWithDestroyable, HelperManagerWithValue, InternalHelperManager, ComponentManager, ModifierManager, Arguments, ComponentCapabilities, ComponentCapabilitiesVersions, ComponentDefinitionState, Destroyable, InternalComponentCapabilities, Nullable, VMArguments, CapturedArguments, ModifierCapabilities, ModifierCapabilitiesVersions, SimpleElement, UpdatableTag, TemplateFactory, AttributeHookCapability, CapabilityMask, CreateArgsCapability, CreateCallerCapability, CreateInstanceCapability, DynamicLayoutCapability, DynamicScopeCapability, DynamicTagCapability, ElementHookCapability, Expand, HasSubOwnerCapability, InternalComponentCapability, PrepareArgsCapability, UpdateHookCapability, WillDestroyCapability, WithCreateInstance, WithDynamicLayout, WithPrepareArgs, WithSubOwner, WithUpdateHook, WrappedCapability } from "@glimmer/interfaces";
import { Reference } from "@glimmer/reference";
import { Tag } from "@glimmer/validator";
import { InternalComponentCapabilities as InternalComponentCapabilities$0 } from "@glimmer/vm";
type Manager = ComponentManager<unknown> | ModifierManager<unknown> | HelperManager<unknown>;
type ManagerFactory<O, D extends Manager = Manager> = (owner: O) => D;
declare function setComponentManager<O extends Owner, T extends object>(factory: ManagerFactory<O, ComponentManager<unknown>>, obj: T): T;
declare function setModifierManager<O extends Owner, T extends object>(factory: ManagerFactory<O, ModifierManager<unknown>>, obj: T): T;
declare function setHelperManager<O extends Owner, T extends object>(factory: ManagerFactory<O | undefined, HelperManager<unknown>>, obj: T): T;
declare function helperCapabilities<Version extends keyof HelperCapabilitiesVersions>(managerAPI: Version, options?: Partial<HelperCapabilities>): HelperCapabilities;
////////////
declare function hasValue(manager: HelperManager<unknown>): manager is HelperManagerWithValue<unknown>;
declare function hasDestroyable(manager: HelperManager<unknown>): manager is HelperManagerWithDestroyable<unknown>;
////////////
declare class CustomHelperManager<O extends Owner = Owner> implements InternalHelperManager<O> {
    private factory;
    constructor(factory: ManagerFactory<O | undefined, HelperManager<unknown>>);
    private helperManagerDelegates;
    private undefinedDelegate;
    private getDelegateForOwner;
    getDelegateFor(owner: O | undefined): HelperManager<unknown>;
    getHelper(definition: HelperDefinitionState): Helper;
}
///////////
declare function setInternalModifierManager<T extends object>(manager: InternalModifierManager, definition: T): T;
declare function getInternalModifierManager(definition: object): InternalModifierManager;
declare function getInternalModifierManager(definition: object, isOptional: true | undefined): InternalModifierManager | null;
declare function setInternalHelperManager<T extends object, O extends Owner>(manager: CustomHelperManager<O> | Helper<O>, definition: T): T;
declare function getInternalHelperManager(definition: object): CustomHelperManager | Helper;
declare function getInternalHelperManager(definition: object, isOptional: true | undefined): CustomHelperManager | Helper | null;
declare function setInternalComponentManager<T extends object>(factory: InternalComponentManager, obj: T): T;
declare function getInternalComponentManager(definition: object): InternalComponentManager;
declare function getInternalComponentManager(definition: object, isOptional: true | undefined): InternalComponentManager | null;
///////////
declare function hasInternalComponentManager(definition: object): boolean;
declare function hasInternalHelperManager(definition: object): boolean;
declare function hasInternalModifierManager(definition: object): boolean;
declare function componentCapabilities<Version extends keyof ComponentCapabilitiesVersions>(managerAPI: Version, options?: ComponentCapabilitiesVersions[Version]): ComponentCapabilities;
/**
 The CustomComponentManager allows addons to provide custom component
 implementations that integrate seamlessly into Ember. This is accomplished
 through a delegate, registered with the custom component manager, which
 implements a set of hooks that determine component behavior.
 
 To create a custom component manager, instantiate a new CustomComponentManager
 class and pass the delegate as the first argument:
 
 ```js
 let manager = new CustomComponentManager({
 // ...delegate implementation...
 });
 ```
 
 ## Delegate Hooks
 
 Throughout the lifecycle of a component, the component manager will invoke
 delegate hooks that are responsible for surfacing those lifecycle changes to
 the end developer.
 
 * `create()` - invoked when a new instance of a component should be created
 * `update()` - invoked when the arguments passed to a component change
 * `getContext()` - returns the object that should be
 */
declare class CustomComponentManager<O extends Owner, ComponentInstance> implements InternalComponentManager<CustomComponentState<ComponentInstance>> {
    private factory;
    private componentManagerDelegates;
    constructor(factory: ManagerFactory<O, ComponentManager<ComponentInstance>>);
    private getDelegateFor;
    create(owner: O, definition: ComponentDefinitionState, vmArgs: VMArguments): CustomComponentState<ComponentInstance>;
    getDebugName(definition: ComponentDefinitionState): string;
    update(bucket: CustomComponentState<ComponentInstance>): void;
    didCreate({ component, delegate }: CustomComponentState<ComponentInstance>): void;
    didUpdate({ component, delegate }: CustomComponentState<ComponentInstance>): void;
    didRenderLayout(): void;
    didUpdateLayout(): void;
    getSelf({ component, delegate }: CustomComponentState<ComponentInstance>): Reference;
    getDestroyable(bucket: CustomComponentState<ComponentInstance>): Nullable<Destroyable>;
    getCapabilities(): InternalComponentCapabilities;
}
/**
 * Stores internal state about a component instance after it's been created.
 */
declare class CustomComponentState<ComponentInstance> {
    component: ComponentInstance;
    delegate: ComponentManager<ComponentInstance>;
    args: Arguments;
    constructor(component: ComponentInstance, delegate: ComponentManager<ComponentInstance>, args: Arguments);
}
declare function modifierCapabilities<Version extends keyof ModifierCapabilitiesVersions>(managerAPI: Version, optionalFeatures?: ModifierCapabilitiesVersions[Version]): ModifierCapabilities;
interface CustomModifierState<ModifierInstance> {
    tag: UpdatableTag;
    element: SimpleElement;
    modifier: ModifierInstance;
    delegate: ModifierManager<ModifierInstance>;
    args: Arguments;
    debugName?: string;
}
/**
 The CustomModifierManager allows addons to provide custom modifier
 implementations that integrate seamlessly into Ember. This is accomplished
 through a delegate, registered with the custom modifier manager, which
 implements a set of hooks that determine modifier behavior.
 To create a custom modifier manager, instantiate a new CustomModifierManager
 class and pass the delegate as the first argument:
 
 ```js
 let manager = new CustomModifierManager({
 // ...delegate implementation...
 });
 ```
 
 ## Delegate Hooks
 
 Throughout the lifecycle of a modifier, the modifier manager will invoke
 delegate hooks that are responsible for surfacing those lifecycle changes to
 the end developer.
 * `createModifier()` - invoked when a new instance of a modifier should be created
 * `installModifier()` - invoked when the modifier is installed on the element
 * `updateModifier()` - invoked when the arguments passed to a modifier change
 * `destroyModifier()` - invoked when the modifier is about to be destroyed
 */
declare class CustomModifierManager<O extends Owner, ModifierInstance> implements InternalModifierManager<CustomModifierState<ModifierInstance>> {
    private factory;
    private componentManagerDelegates;
    constructor(factory: ManagerFactory<O, ModifierManager<ModifierInstance>>);
    private getDelegateFor;
    create(owner: O, element: SimpleElement, definition: object, capturedArgs: CapturedArguments): CustomModifierState<ModifierInstance>;
    getDebugName({ debugName }: CustomModifierState<ModifierInstance>): string;
    getTag({ tag }: CustomModifierState<ModifierInstance>): UpdatableTag;
    install({ element, args, modifier, delegate }: CustomModifierState<ModifierInstance>): void;
    update({ args, modifier, delegate }: CustomModifierState<ModifierInstance>): void;
    getDestroyable(state: CustomModifierState<ModifierInstance>): CustomModifierState<ModifierInstance>;
}
declare function setComponentTemplate(factory: TemplateFactory, obj: object): object;
declare function getComponentTemplate(obj: object): TemplateFactory | undefined;
declare function getCustomTagFor(obj: object): ((obj: object, key: string) => Tag) | undefined;
declare function setCustomTagFor(obj: object, customTagFn: (obj: object, key: string) => Tag): void;
type CapabilityOptions = Expand<{
    [P in keyof Omit<typeof InternalComponentCapabilities$0, "Empty">]?: boolean | undefined;
}>;
/**
 * Converts a ComponentCapabilities object into a 32-bit integer representation.
 */
declare function capabilityFlagsFrom(capabilities: CapabilityOptions): CapabilityMask;
type InternalComponentCapabilityFor<C extends InternalComponentCapability> = C extends DynamicLayoutCapability ? WithDynamicLayout : C extends DynamicTagCapability ? InternalComponentManager : C extends PrepareArgsCapability ? WithPrepareArgs : C extends CreateArgsCapability ? InternalComponentManager : C extends AttributeHookCapability ? InternalComponentManager : C extends ElementHookCapability ? InternalComponentManager : C extends DynamicScopeCapability ? InternalComponentManager : C extends CreateCallerCapability ? InternalComponentManager : C extends UpdateHookCapability ? WithUpdateHook : C extends CreateInstanceCapability ? WithCreateInstance : C extends WrappedCapability ? InternalComponentManager : C extends WillDestroyCapability ? InternalComponentManager : C extends HasSubOwnerCapability ? WithSubOwner : never;
declare function managerHasCapability<F extends InternalComponentCapability>(_manager: InternalComponentManager, capabilities: CapabilityMask, capability: F): _manager is InternalComponentCapabilityFor<F>;
declare function hasCapability(capabilities: CapabilityMask, capability: InternalComponentCapability): boolean;
export { getInternalComponentManager, getInternalHelperManager, getInternalModifierManager, hasInternalComponentManager, hasInternalHelperManager, hasInternalModifierManager, setInternalComponentManager, setInternalHelperManager, setInternalModifierManager, componentCapabilities, CustomComponentManager, CustomHelperManager, hasDestroyable, hasValue, helperCapabilities, setComponentManager, setHelperManager, setModifierManager, CustomModifierManager, modifierCapabilities, getComponentTemplate, setComponentTemplate, getCustomTagFor, setCustomTagFor, capabilityFlagsFrom, hasCapability, managerHasCapability };
//# sourceMappingURL=index.d.ts.map