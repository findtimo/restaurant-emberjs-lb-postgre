{"version":3,"file":"index.js","sources":["../../lib/util/args-proxy.ts","../../lib/util/capabilities.ts","../../lib/public/helper.ts","../../lib/internal/defaults.ts","../../lib/internal/api.ts","../../lib/public/component.ts","../../lib/public/modifier.ts","../../lib/public/api.ts","../../lib/public/template.ts"],"sourcesContent":["import type {\n  Arguments,\n  CapturedArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n} from '@glimmer/interfaces';\nimport type { Tag } from '@glimmer/validator';\nimport { valueForRef } from '@glimmer/reference';\nimport { track } from '@glimmer/validator';\n\nconst CUSTOM_TAG_FOR = new WeakMap<object, (obj: object, key: string) => Tag>();\n\nexport function getCustomTagFor(obj: object): ((obj: object, key: string) => Tag) | undefined {\n  return CUSTOM_TAG_FOR.get(obj);\n}\n\nexport function setCustomTagFor(obj: object, customTagFn: (obj: object, key: string) => Tag) {\n  CUSTOM_TAG_FOR.set(obj, customTagFn);\n}\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\nfunction tagForNamedArg(namedArgs: CapturedNamedArguments, key: string): Tag {\n  return track(() => {\n    if (key in namedArgs) {\n      valueForRef(namedArgs[key]!);\n    }\n  });\n}\n\nfunction tagForPositionalArg(positionalArgs: CapturedPositionalArguments, key: string): Tag {\n  return track(() => {\n    if (key === '[]') {\n      // consume all of the tags in the positional array\n      positionalArgs.forEach(valueForRef);\n    }\n\n    const parsed = convertToInt(key);\n\n    if (parsed !== null && parsed < positionalArgs.length) {\n      // consume the tag of the referenced index\n      valueForRef(positionalArgs[parsed]!);\n    }\n  });\n}\n\nclass NamedArgsProxy implements ProxyHandler<{}> {\n  declare set?: (target: {}, prop: string | number | symbol) => boolean;\n\n  constructor(private named: CapturedNamedArguments) {}\n\n  get(_target: {}, prop: string | number | symbol) {\n    const ref = this.named[prop as string];\n\n    if (ref !== undefined) {\n      return valueForRef(ref);\n    }\n  }\n\n  has(_target: {}, prop: string | number | symbol) {\n    return prop in this.named;\n  }\n\n  ownKeys() {\n    return Object.keys(this.named);\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  getOwnPropertyDescriptor(_target: {}, prop: string | number | symbol) {\n    if (import.meta.env.DEV && !(prop in this.named)) {\n      throw new Error(\n        `args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \\`${String(\n          prop\n        )}\\``\n      );\n    }\n\n    return {\n      enumerable: true,\n      configurable: true,\n    };\n  }\n}\n\nclass PositionalArgsProxy implements ProxyHandler<[]> {\n  declare set?: (target: [], prop: string | number | symbol) => boolean;\n  declare ownKeys?: (target: []) => string[];\n\n  constructor(private positional: CapturedPositionalArguments) {}\n\n  get(target: [], prop: string | number | symbol) {\n    let { positional } = this;\n\n    if (prop === 'length') {\n      return positional.length;\n    }\n\n    const parsed = convertToInt(prop);\n\n    if (parsed !== null && parsed < positional.length) {\n      return valueForRef(positional[parsed]!);\n    }\n\n    return (target as any)[prop];\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  has(_target: [], prop: string | number | symbol) {\n    const parsed = convertToInt(prop);\n\n    return parsed !== null && parsed < this.positional.length;\n  }\n}\n\nexport const argsProxyFor = (\n  capturedArgs: CapturedArguments,\n  type: 'component' | 'helper' | 'modifier'\n): Arguments => {\n  const { named, positional } = capturedArgs;\n\n  let getNamedTag = (_obj: object, key: string) => tagForNamedArg(named, key);\n  let getPositionalTag = (_obj: object, key: string) => tagForPositionalArg(positional, key);\n\n  const namedHandler = new NamedArgsProxy(named);\n  const positionalHandler = new PositionalArgsProxy(positional);\n\n  const namedTarget = Object.create(null);\n  const positionalTarget: unknown[] = [];\n\n  if (import.meta.env.DEV) {\n    const setHandler = function (_target: unknown, prop: symbol | string | number): never {\n      throw new Error(\n        `You attempted to set ${String(\n          prop\n        )} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`\n      );\n    };\n\n    const forInDebugHandler = (): never => {\n      throw new Error(\n        `Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`\n      );\n    };\n\n    namedHandler.set = setHandler;\n    positionalHandler.set = setHandler;\n    positionalHandler.ownKeys = forInDebugHandler;\n  }\n\n  const namedProxy = new Proxy(namedTarget, namedHandler);\n  const positionalProxy = new Proxy(positionalTarget, positionalHandler);\n\n  setCustomTagFor(namedProxy, getNamedTag);\n  setCustomTagFor(positionalProxy, getPositionalTag);\n\n  return {\n    named: namedProxy,\n    positional: positionalProxy,\n  };\n};\n","import type {\n  AttributeHookCapability,\n  Capabilities,\n  CapabilityMask,\n  CreateArgsCapability,\n  CreateCallerCapability,\n  CreateInstanceCapability,\n  DynamicLayoutCapability,\n  DynamicScopeCapability,\n  DynamicTagCapability,\n  ElementHookCapability,\n  Expand,\n  HasSubOwnerCapability,\n  InternalComponentCapability,\n  InternalComponentManager,\n  PrepareArgsCapability,\n  UpdateHookCapability,\n  WillDestroyCapability,\n  WithCreateInstance,\n  WithDynamicLayout,\n  WithPrepareArgs,\n  WithSubOwner,\n  WithUpdateHook,\n  WrappedCapability,\n} from '@glimmer/interfaces';\nimport { check, CheckNumber } from '@glimmer/debug';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nexport const FROM_CAPABILITIES = import.meta.env.DEV ? new WeakSet() : undefined;\n\nexport function buildCapabilities<T extends object>(capabilities: T): T & Capabilities {\n  if (import.meta.env.DEV) {\n    FROM_CAPABILITIES!.add(capabilities);\n    Object.freeze(capabilities);\n  }\n\n  return capabilities as T & Capabilities;\n}\n\nconst EMPTY = InternalComponentCapabilities.Empty;\n\ntype CapabilityOptions = Expand<{\n  [P in keyof Omit<typeof InternalComponentCapabilities, 'Empty'>]?: boolean | undefined;\n}>;\n\n/**\n * Converts a ComponentCapabilities object into a 32-bit integer representation.\n */\nexport function capabilityFlagsFrom(capabilities: CapabilityOptions): CapabilityMask {\n  return (EMPTY |\n    capability(capabilities, 'dynamicLayout') |\n    capability(capabilities, 'dynamicTag') |\n    capability(capabilities, 'prepareArgs') |\n    capability(capabilities, 'createArgs') |\n    capability(capabilities, 'attributeHook') |\n    capability(capabilities, 'elementHook') |\n    capability(capabilities, 'dynamicScope') |\n    capability(capabilities, 'createCaller') |\n    capability(capabilities, 'updateHook') |\n    capability(capabilities, 'createInstance') |\n    capability(capabilities, 'wrapped') |\n    capability(capabilities, 'willDestroy') |\n    capability(capabilities, 'hasSubOwner')) as CapabilityMask;\n}\n\nfunction capability(\n  capabilities: CapabilityOptions,\n  capability: keyof CapabilityOptions\n): InternalComponentCapability {\n  return capabilities[capability] ? InternalComponentCapabilities[capability] : EMPTY;\n}\n\nexport type InternalComponentCapabilityFor<C extends InternalComponentCapability> =\n  C extends DynamicLayoutCapability\n    ? WithDynamicLayout\n    : C extends DynamicTagCapability\n      ? InternalComponentManager\n      : C extends PrepareArgsCapability\n        ? WithPrepareArgs\n        : C extends CreateArgsCapability\n          ? InternalComponentManager\n          : C extends AttributeHookCapability\n            ? InternalComponentManager\n            : C extends ElementHookCapability\n              ? InternalComponentManager\n              : C extends DynamicScopeCapability\n                ? InternalComponentManager\n                : C extends CreateCallerCapability\n                  ? InternalComponentManager\n                  : C extends UpdateHookCapability\n                    ? WithUpdateHook\n                    : C extends CreateInstanceCapability\n                      ? WithCreateInstance\n                      : C extends WrappedCapability\n                        ? InternalComponentManager\n                        : C extends WillDestroyCapability\n                          ? InternalComponentManager\n                          : C extends HasSubOwnerCapability\n                            ? WithSubOwner\n                            : never;\n\nexport function managerHasCapability<F extends InternalComponentCapability>(\n  _manager: InternalComponentManager,\n  capabilities: CapabilityMask,\n  capability: F\n): _manager is InternalComponentCapabilityFor<F> {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n\nexport function hasCapability(\n  capabilities: CapabilityMask,\n  capability: InternalComponentCapability\n): boolean {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n","import type {\n  Helper,\n  HelperCapabilities,\n  HelperCapabilitiesVersions,\n  HelperDefinitionState,\n  HelperManager,\n  HelperManagerWithDestroyable,\n  HelperManagerWithValue,\n  InternalHelperManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { associateDestroyableChild } from '@glimmer/destroyable';\nimport { createComputeRef, createConstRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './index';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function helperCapabilities<Version extends keyof HelperCapabilitiesVersions>(\n  managerAPI: Version,\n  options: Partial<HelperCapabilities> = {}\n): HelperCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.23') {\n    throw new Error('Invalid helper manager compatibility specified');\n  }\n\n  if (\n    import.meta.env.DEV &&\n    (!(options.hasValue || options.hasScheduledEffect) ||\n      (options.hasValue && options.hasScheduledEffect))\n  ) {\n    throw new Error(\n      'You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.'\n    );\n  }\n\n  if (import.meta.env.DEV && options.hasScheduledEffect) {\n    throw new Error(\n      'The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead'\n    );\n  }\n\n  return buildCapabilities({\n    hasValue: Boolean(options.hasValue),\n    hasDestroyable: Boolean(options.hasDestroyable),\n    hasScheduledEffect: Boolean(options.hasScheduledEffect),\n  });\n}\n\n////////////\n\nexport function hasValue(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithValue<unknown> {\n  return manager.capabilities.hasValue;\n}\n\nexport function hasDestroyable(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithDestroyable<unknown> {\n  return manager.capabilities.hasDestroyable;\n}\n\n////////////\n\nexport class CustomHelperManager<O extends Owner = Owner> implements InternalHelperManager<O> {\n  constructor(private factory: ManagerFactory<O | undefined, HelperManager<unknown>>) {}\n\n  private helperManagerDelegates = new WeakMap<O, HelperManager<unknown>>();\n  private undefinedDelegate: HelperManager<unknown> | null = null;\n\n  private getDelegateForOwner(owner: O) {\n    let delegate = this.helperManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom helper managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.23')\\` (imported via \\`import { capabilities } from '@ember/helper';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      this.helperManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  getDelegateFor(owner: O | undefined) {\n    if (owner === undefined) {\n      let { undefinedDelegate } = this;\n\n      if (undefinedDelegate === null) {\n        let { factory } = this;\n        this.undefinedDelegate = undefinedDelegate = factory(undefined);\n      }\n\n      return undefinedDelegate;\n    } else {\n      return this.getDelegateForOwner(owner);\n    }\n  }\n\n  getHelper(definition: HelperDefinitionState): Helper {\n    return (capturedArgs, owner) => {\n      let manager = this.getDelegateFor(owner as O | undefined);\n\n      const args = argsProxyFor(capturedArgs, 'helper');\n      const bucket = manager.createHelper(definition, args);\n\n      if (hasValue(manager)) {\n        let cache = createComputeRef(\n          () => (manager as HelperManagerWithValue<unknown>).getValue(bucket),\n          null,\n          import.meta.env.DEV && manager.getDebugName && manager.getDebugName(definition)\n        );\n\n        if (hasDestroyable(manager)) {\n          associateDestroyableChild(cache, manager.getDestroyable(bucket));\n        }\n\n        return cache;\n      } else if (hasDestroyable(manager)) {\n        let ref = createConstRef(\n          undefined,\n          import.meta.env.DEV && (manager.getDebugName?.(definition) ?? 'unknown helper')\n        );\n\n        associateDestroyableChild(ref, manager.getDestroyable(bucket));\n\n        return ref;\n      } else {\n        return UNDEFINED_REFERENCE;\n      }\n    };\n  }\n}\n","import type {\n  CapturedArguments as Arguments,\n  HelperCapabilities,\n  HelperManagerWithValue,\n} from '@glimmer/interfaces';\n\nimport { buildCapabilities } from '../util/capabilities';\n\ntype FnArgs<Args extends Arguments = Arguments> =\n  | [...Args['positional'], Args['named']]\n  | [...Args['positional']];\n\ntype AnyFunction = (...args: any[]) => unknown;\n\ninterface State {\n  fn: AnyFunction;\n  args: Arguments;\n}\n\nexport class FunctionHelperManager implements HelperManagerWithValue<State> {\n  capabilities = buildCapabilities({\n    hasValue: true,\n    hasDestroyable: false,\n    hasScheduledEffect: false,\n  }) as HelperCapabilities;\n\n  createHelper(fn: AnyFunction, args: Arguments): State {\n    return { fn, args };\n  }\n\n  getValue({ fn, args }: State): unknown {\n    if (Object.keys(args.named).length > 0) {\n      let argsForFn: FnArgs<Arguments> = [...args.positional, args.named];\n\n      return fn(...argsForFn);\n    }\n\n    return fn(...args.positional);\n  }\n\n  getDebugName(fn: AnyFunction): string {\n    if (fn.name) {\n      return `(helper function ${fn.name})`;\n    }\n\n    return '(anonymous helper function)';\n  }\n}\n","import type {\n  Helper,\n  InternalComponentManager,\n  InternalModifierManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/util';\n\nimport { CustomHelperManager } from '../public/helper';\nimport { FunctionHelperManager } from './defaults';\n\ntype InternalManager =\n  | InternalComponentManager\n  | InternalModifierManager\n  | CustomHelperManager\n  | Helper;\n\nconst COMPONENT_MANAGERS = new WeakMap<object, InternalComponentManager>();\n\nconst MODIFIER_MANAGERS = new WeakMap<object, InternalModifierManager>();\n\nconst HELPER_MANAGERS = new WeakMap<object, CustomHelperManager | Helper>();\n\n///////////\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nfunction setManager<Def extends object>(\n  map: WeakMap<object, object>,\n  manager: object,\n  obj: Def\n): Def {\n  if (\n    import.meta.env.DEV &&\n    (typeof obj !== 'object' || obj === null) &&\n    typeof obj !== 'function'\n  ) {\n    throw new Error(\n      `Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  if (import.meta.env.DEV && map.has(obj)) {\n    throw new Error(\n      `Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  map.set(obj, manager);\n  return obj;\n}\n\nfunction getManager<M extends InternalManager>(\n  map: WeakMap<object, M>,\n  obj: object\n): M | undefined {\n  let pointer = obj;\n  while (pointer !== undefined && pointer !== null) {\n    const manager = map.get(pointer);\n\n    if (manager !== undefined) {\n      return manager;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n\n///////////\n\nexport function setInternalModifierManager<T extends object>(\n  manager: InternalModifierManager,\n  definition: T\n): T {\n  return setManager(MODIFIER_MANAGERS, manager, definition);\n}\n\nexport function getInternalModifierManager(definition: object): InternalModifierManager;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalModifierManager | null;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalModifierManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(MODIFIER_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\nexport function setInternalHelperManager<T extends object, O extends Owner>(\n  manager: CustomHelperManager<O> | Helper<O>,\n  definition: T\n): T {\n  return setManager(HELPER_MANAGERS, manager, definition);\n}\n\nconst DEFAULT_MANAGER = new CustomHelperManager(() => new FunctionHelperManager());\n\nexport function getInternalHelperManager(definition: object): CustomHelperManager | Helper;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional: true | undefined\n): CustomHelperManager | Helper | null;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional?: true | undefined\n): CustomHelperManager | Helper | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`\n    );\n  }\n\n  let manager = getManager(HELPER_MANAGERS, definition);\n\n  // Functions are special-cased because functions are defined\n  // as the \"default\" helper, per: https://github.com/emberjs/rfcs/pull/756\n  if (manager === undefined && typeof definition === 'function') {\n    manager = DEFAULT_MANAGER;\n  }\n\n  if (manager) {\n    return manager;\n  } else if (isOptional === true) {\n    return null;\n  } else if (import.meta.env.DEV) {\n    throw new Error(\n      `Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString!(\n        definition\n      )}`\n    );\n  }\n\n  return null;\n}\n\nexport function setInternalComponentManager<T extends object>(\n  factory: InternalComponentManager,\n  obj: T\n): T {\n  return setManager(COMPONENT_MANAGERS, factory, obj);\n}\n\nexport function getInternalComponentManager(definition: object): InternalComponentManager;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalComponentManager | null;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalComponentManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(COMPONENT_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\n///////////\n\nexport function hasInternalComponentManager(definition: object): boolean {\n  return (\n    hasDefaultComponentManager(definition) ||\n    getManager(COMPONENT_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalHelperManager(definition: object): boolean {\n  return (\n    hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalModifierManager(definition: object): boolean {\n  return (\n    hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined\n  );\n}\n\nfunction hasDefaultComponentManager(_definition: object): boolean {\n  return false;\n}\n\nfunction hasDefaultHelperManager(definition: object): boolean {\n  return typeof definition === 'function';\n}\n\nfunction hasDefaultModifierManager(_definition: object): boolean {\n  return false;\n}\n","import type {\n  Arguments,\n  ComponentCapabilities,\n  ComponentCapabilitiesVersions,\n  ComponentDefinitionState,\n  ComponentManager,\n  ComponentManagerWithAsyncLifeCycleCallbacks,\n  ComponentManagerWithAsyncUpdateHook,\n  ComponentManagerWithDestructors,\n  ComponentManagerWithUpdateHook,\n  Destroyable,\n  InternalComponentCapabilities,\n  InternalComponentManager,\n  Nullable,\n  Owner,\n  VMArguments,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { createConstRef } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './api';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nconst CAPABILITIES = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: true,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport function componentCapabilities<Version extends keyof ComponentCapabilitiesVersions>(\n  managerAPI: Version,\n  options: ComponentCapabilitiesVersions[Version] = {}\n): ComponentCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.13') {\n    throw new Error('Invalid component manager compatibility specified');\n  }\n\n  let updateHook = Boolean((options as ComponentCapabilitiesVersions['3.13']).updateHook);\n\n  return buildCapabilities({\n    asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),\n    destructor: Boolean(options.destructor),\n    updateHook,\n  });\n}\n\nexport function hasAsyncLifeCycleCallbacks<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncLifeCycleCallbacks<ComponentInstance> {\n  return delegate.capabilities.asyncLifeCycleCallbacks;\n}\n\nexport function hasUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithUpdateHook<ComponentInstance> {\n  return delegate.capabilities.updateHook;\n}\n\nexport function hasAsyncUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncUpdateHook<ComponentInstance> {\n  return hasAsyncLifeCycleCallbacks(delegate) && hasUpdateHook(delegate);\n}\n\nexport function hasDestructors<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithDestructors<ComponentInstance> {\n  return delegate.capabilities.destructor;\n}\n\n/**\n  The CustomComponentManager allows addons to provide custom component\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom component manager, which\n  implements a set of hooks that determine component behavior.\n\n  To create a custom component manager, instantiate a new CustomComponentManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomComponentManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a component, the component manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n\n  * `create()` - invoked when a new instance of a component should be created\n  * `update()` - invoked when the arguments passed to a component change\n  * `getContext()` - returns the object that should be\n*/\nexport class CustomComponentManager<O extends Owner, ComponentInstance>\n  implements InternalComponentManager<CustomComponentState<ComponentInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ComponentManager<ComponentInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ComponentManager<ComponentInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom component managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.13')\\` (imported via \\`import { capabilities } from '@ember/component';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(\n    owner: O,\n    definition: ComponentDefinitionState,\n    vmArgs: VMArguments\n  ): CustomComponentState<ComponentInstance> {\n    let delegate = this.getDelegateFor(owner);\n    let args = argsProxyFor(vmArgs.capture(), 'component');\n\n    let component: ComponentInstance = delegate.createComponent(definition, args);\n\n    return new CustomComponentState(component, delegate, args);\n  }\n\n  getDebugName(definition: ComponentDefinitionState): string {\n    return typeof definition === 'function' ? definition.name : definition.toString();\n  }\n\n  update(bucket: CustomComponentState<ComponentInstance>): void {\n    let { delegate } = bucket;\n    if (hasUpdateHook(delegate)) {\n      let { component, args } = bucket;\n\n      delegate.updateComponent(component, args);\n    }\n  }\n\n  didCreate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncLifeCycleCallbacks(delegate)) {\n      delegate.didCreateComponent(component);\n    }\n  }\n\n  didUpdate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncUpdateHook(delegate)) {\n      delegate.didUpdateComponent(component);\n    }\n  }\n\n  didRenderLayout(): void {}\n\n  didUpdateLayout(): void {}\n\n  getSelf({ component, delegate }: CustomComponentState<ComponentInstance>): Reference {\n    return createConstRef(delegate.getContext(component), 'this');\n  }\n\n  getDestroyable(bucket: CustomComponentState<ComponentInstance>): Nullable<Destroyable> {\n    const { delegate } = bucket;\n\n    if (hasDestructors(delegate)) {\n      const { component } = bucket;\n\n      registerDestructor(bucket, () => delegate.destroyComponent(component));\n      return bucket;\n    }\n\n    return null;\n  }\n\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n}\n\n/**\n * Stores internal state about a component instance after it's been created.\n */\nexport class CustomComponentState<ComponentInstance> {\n  constructor(\n    public component: ComponentInstance,\n    public delegate: ComponentManager<ComponentInstance>,\n    public args: Arguments\n  ) {}\n}\n","import type {\n  Arguments,\n  CapturedArguments,\n  InternalModifierManager,\n  ModifierCapabilities,\n  ModifierCapabilitiesVersions,\n  ModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { valueForRef } from '@glimmer/reference';\nimport { castToBrowser, dict } from '@glimmer/util';\nimport { createUpdatableTag, untrack } from '@glimmer/validator';\n\nimport type { ManagerFactory } from '.';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function modifierCapabilities<Version extends keyof ModifierCapabilitiesVersions>(\n  managerAPI: Version,\n  optionalFeatures: ModifierCapabilitiesVersions[Version] = {}\n): ModifierCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.22') {\n    throw new Error('Invalid modifier manager compatibility specified');\n  }\n\n  return buildCapabilities({\n    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking),\n  });\n}\n\nexport interface CustomModifierState<ModifierInstance> {\n  tag: UpdatableTag;\n  element: SimpleElement;\n  modifier: ModifierInstance;\n  delegate: ModifierManager<ModifierInstance>;\n  args: Arguments;\n  debugName?: string;\n}\n\n/**\n  The CustomModifierManager allows addons to provide custom modifier\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom modifier manager, which\n  implements a set of hooks that determine modifier behavior.\n  To create a custom modifier manager, instantiate a new CustomModifierManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomModifierManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a modifier, the modifier manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n  * `createModifier()` - invoked when a new instance of a modifier should be created\n  * `installModifier()` - invoked when the modifier is installed on the element\n  * `updateModifier()` - invoked when the arguments passed to a modifier change\n  * `destroyModifier()` - invoked when the modifier is about to be destroyed\n*/\nexport class CustomModifierManager<O extends Owner, ModifierInstance>\n  implements InternalModifierManager<CustomModifierState<ModifierInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ModifierManager<ModifierInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ModifierManager<ModifierInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom modifier managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.22')\\` (imported via \\`import { capabilities } from '@ember/modifier';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(owner: O, element: SimpleElement, definition: object, capturedArgs: CapturedArguments) {\n    let delegate = this.getDelegateFor(owner);\n\n    let args = argsProxyFor(capturedArgs, 'modifier');\n    let instance: ModifierInstance = delegate.createModifier(definition, args);\n\n    let tag = createUpdatableTag();\n    let state: CustomModifierState<ModifierInstance>;\n\n    state = {\n      tag,\n      element,\n      delegate,\n      args,\n      modifier: instance,\n    };\n\n    if (import.meta.env.DEV) {\n      state.debugName = typeof definition === 'function' ? definition.name : definition.toString();\n    }\n\n    registerDestructor(state, () => delegate.destroyModifier(instance, args));\n\n    return state;\n  }\n\n  getDebugName({ debugName }: CustomModifierState<ModifierInstance>) {\n    return debugName!;\n  }\n\n  getTag({ tag }: CustomModifierState<ModifierInstance>) {\n    return tag;\n  }\n\n  install({ element, args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args));\n    } else {\n      delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args);\n    }\n  }\n\n  update({ args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.updateModifier(modifier, args));\n    } else {\n      delegate.updateModifier(modifier, args);\n    }\n  }\n\n  getDestroyable(state: CustomModifierState<ModifierInstance>) {\n    return state;\n  }\n}\n\nexport function reifyArgs({ named, positional }: CapturedArguments): {\n  named: Record<string, unknown>;\n  positional: unknown[];\n} {\n  let reifiedNamed = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reifiedNamed[key] = valueForRef(value);\n  }\n\n  let reifiedPositional = positional.map(valueForRef);\n\n  return {\n    named: reifiedNamed,\n    positional: reifiedPositional,\n  };\n}\n","import type { ComponentManager, HelperManager, ModifierManager, Owner } from '@glimmer/interfaces';\n\nimport {\n  setInternalComponentManager,\n  setInternalHelperManager,\n  setInternalModifierManager,\n} from '../internal/api';\nimport { CustomComponentManager } from './component';\nimport { CustomHelperManager } from './helper';\nimport { CustomModifierManager } from './modifier';\n\ntype Manager = ComponentManager<unknown> | ModifierManager<unknown> | HelperManager<unknown>;\n\nexport type ManagerFactory<O, D extends Manager = Manager> = (owner: O) => D;\n\nexport function setComponentManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ComponentManager<unknown>>,\n  obj: T\n): T {\n  return setInternalComponentManager(new CustomComponentManager(factory), obj);\n}\n\nexport function setModifierManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ModifierManager<unknown>>,\n  obj: T\n): T {\n  return setInternalModifierManager(new CustomModifierManager(factory), obj);\n}\n\nexport function setHelperManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O | undefined, HelperManager<unknown>>,\n  obj: T\n): T {\n  return setInternalHelperManager(new CustomHelperManager(factory), obj);\n}\n","import type { TemplateFactory } from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/util';\n\nconst TEMPLATES: WeakMap<object, TemplateFactory> = new WeakMap();\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport function setComponentTemplate(factory: TemplateFactory, obj: object) {\n  if (\n    import.meta.env.DEV &&\n    !(obj !== null && (typeof obj === 'object' || typeof obj === 'function'))\n  ) {\n    throw new Error(`Cannot call \\`setComponentTemplate\\` on \\`${debugToString!(obj)}\\``);\n  }\n\n  if (import.meta.env.DEV && TEMPLATES.has(obj)) {\n    throw new Error(\n      `Cannot call \\`setComponentTemplate\\` multiple times on the same class (\\`${debugToString!(\n        obj\n      )}\\`)`\n    );\n  }\n\n  TEMPLATES.set(obj, factory);\n\n  return obj;\n}\n\nexport function getComponentTemplate(obj: object): TemplateFactory | undefined {\n  let pointer = obj;\n\n  while (pointer !== null) {\n    let template = TEMPLATES.get(pointer);\n\n    if (template !== undefined) {\n      return template;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n"],"names":["CUSTOM_TAG_FOR","WeakMap","getCustomTagFor","obj","get","setCustomTagFor","customTagFn","set","convertToInt","prop","num","Number","isNaN","NamedArgsProxy","constructor","named","this","_target","ref","undefined","valueForRef","has","ownKeys","Object","keys","isExtensible","getOwnPropertyDescriptor","Error","String","enumerable","configurable","PositionalArgsProxy","positional","target","length","parsed","argsProxyFor","capturedArgs","type","namedHandler","positionalHandler","namedTarget","create","setHandler","forInDebugHandler","namedProxy","Proxy","positionalProxy","getNamedTag","_obj","key","namedArgs","track","tagForNamedArg","getPositionalTag","positionalArgs","forEach","tagForPositionalArg","FROM_CAPABILITIES","WeakSet","buildCapabilities","capabilities","add","freeze","EMPTY","InternalComponentCapabilities","Empty","capabilityFlagsFrom","capability","managerHasCapability","_manager","check","CheckNumber","hasCapability","helperCapabilities","managerAPI","options","hasValue","hasScheduledEffect","Boolean","hasDestroyable","manager","CustomHelperManager","factory","helperManagerDelegates","undefinedDelegate","getDelegateForOwner","owner","delegate","JSON","stringify","getDelegateFor","getHelper","definition","args","bucket","createHelper","cache","createComputeRef","getValue","getDebugName","associateDestroyableChild","getDestroyable","createConstRef","UNDEFINED_REFERENCE","FunctionHelperManager","fn","name","COMPONENT_MANAGERS","MODIFIER_MANAGERS","HELPER_MANAGERS","getPrototypeOf","setManager","map","debugToString","getManager","pointer","setInternalModifierManager","getInternalModifierManager","isOptional","setInternalHelperManager","DEFAULT_MANAGER","getInternalHelperManager","setInternalComponentManager","getInternalComponentManager","hasInternalComponentManager","hasInternalHelperManager","hasDefaultHelperManager","hasInternalModifierManager","CAPABILITIES","dynamicLayout","dynamicTag","prepareArgs","createArgs","attributeHook","elementHook","createCaller","dynamicScope","updateHook","createInstance","wrapped","willDestroy","hasSubOwner","componentCapabilities","asyncLifeCycleCallbacks","asyncLifecycleCallbacks","destructor","hasAsyncLifeCycleCallbacks","hasUpdateHook","CustomComponentManager","componentManagerDelegates","vmArgs","capture","component","createComponent","CustomComponentState","toString","update","updateComponent","didCreate","didCreateComponent","didUpdate","hasAsyncUpdateHook","didUpdateComponent","didRenderLayout","didUpdateLayout","getSelf","getContext","hasDestructors","registerDestructor","destroyComponent","getCapabilities","modifierCapabilities","optionalFeatures","disableAutoTracking","CustomModifierManager","element","state","instance","createModifier","tag","createUpdatableTag","modifier","debugName","destroyModifier","getTag","install","untrack","installModifier","castToBrowser","updateModifier","setComponentManager","setModifierManager","setHelperManager","TEMPLATES","setComponentTemplate","getComponentTemplate","template"],"mappings":"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"}