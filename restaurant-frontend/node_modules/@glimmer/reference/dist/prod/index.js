import{setProp as t,getProp as e,toIterator as n,getPath as r}from"@glimmer/global-context";import{expect as i,isDict as u,EMPTY_ARRAY as l,isObject as s}from"@glimmer/util";import{CONSTANT_TAG as a,validateTag as o,track as c,valueForTag as p,consumeTag as d,INITIAL as h,createTag as f,dirtyTag as g}from"@glimmer/validator";const m=Symbol("REFERENCE"),b=1,v=2;class k{[m];tag=null;lastRevision=h;lastValue;children=null;compute=null;update=null;debugLabel;constructor(t){this[m]=t}}function w(t){const e=new k(v);return e.tag=a,e.lastValue=t,e.debugLabel=String(t),e}const y=w(void 0),M=w(null),L=w(!0),E=w(!1);function _(t,e){const n=new k(0);return n.lastValue=t,n.tag=a,n.debugLabel=e,n}function x(t,e){const n=new k(v);return n.lastValue=t,n.tag=a,n.debugLabel=e,n}function V(t,e=null,n="unknown"){const r=new k(b);return r.compute=t,r.update=e,r.debugLabel=`(result of a \`${n}\` helper)`,r}function $(t){return A(t)?V((()=>C(t)),null,t.debugLabel):t}function F(t){return 3===t[m]}function R(t){const e=V((()=>C(t)),(e=>N(t,e)));return e.debugLabel=t.debugLabel,e[m]=3,e}function S(t){return t.tag===a}function A(t){return null!==t.update}function C(t){const e=t;let{tag:n}=e;if(n===a)return e.lastValue;const{lastRevision:r}=e;let i;if(null!==n&&o(n,r))i=e.lastValue;else{const{compute:t}=e,r=c((()=>{i=e.lastValue=t()}),e.debugLabel);n=e.tag=r,e.lastRevision=p(r)}return d(n),i}function N(t,e){i(t.update,"called update on a non-updatable reference")(e)}function W(n,r){const i=n,l=i[m];let s,a=i.children;if(null===a)a=i.children=new Map;else if(s=a.get(r),void 0!==s)return s;if(l===v){const t=C(i);s=u(t)?x(t[r],`${i.debugLabel}.${r}`):y}else s=V((()=>{const t=C(i);if(u(t))return e(t,r)}),(e=>{const n=C(i);if(u(n))return t(n,r,e)})),s.debugLabel=`${i.debugLabel}.${r}`;return a.set(r,s),s}function j(t,e){let n=t;for(const t of e)n=W(n,t);return n}let q;q=(t,e)=>{const n=V((()=>C(e)),A(e)?t=>N(e,t):null);return n[m]=e[m],n.debugLabel=t,n};const z={},B=(t,e)=>e,D=(t,e)=>String(e),G=t=>null===t?z:t;function H(t){switch(t){case"@key":return K(B);case"@index":return K(D);case"@identity":return K(G);default:return function(t){if("@"===t[0])throw new Error(`invalid keypath: '${t}', valid keys: @index, @identity, or a path`);return K((e=>r(e,t)))}(t)}}class I{_weakMap;_primitiveMap;get weakMap(){return void 0===this._weakMap&&(this._weakMap=new WeakMap),this._weakMap}get primitiveMap(){return void 0===this._primitiveMap&&(this._primitiveMap=new Map),this._primitiveMap}set(t,e){s(t)?this.weakMap.set(t,e):this.primitiveMap.set(t,e)}get(t){return s(t)?this.weakMap.get(t):this.primitiveMap.get(t)}}const J=new I;function K(t){let e=new I;return(n,r)=>{let i=t(n,r),u=e.get(i)||0;return e.set(i,u+1),0===u?i:function(t,e){let n=J.get(t);void 0===n&&(n=[],J.set(t,n));let r=n[e];return void 0===r&&(r={value:t,count:e},n[e]=r),r}(i,u)}}function O(t,e){return V((()=>{let r=C(t),i=H(e);if(Array.isArray(r))return new T(r,i);let u=n(r);return null===u?new T(l,(()=>null)):new Q(u,i)}))}function P(t){let e=t,n=f();return V((()=>(d(n),e)),(t=>{e!==t&&(e=t,g(n))}))}class Q{constructor(t,e){this.inner=t,this.keyFor=e}isEmpty(){return this.inner.isEmpty()}next(){let t=this.inner.next();return null!==t&&(t.key=this.keyFor(t.value,t.memo)),t}}class T{current;pos=0;constructor(t,e){this.iterator=t,this.keyFor=e,0===t.length?this.current={kind:"empty"}:this.current={kind:"first",value:t[this.pos]}}isEmpty(){return"empty"===this.current.kind}next(){let t,e=this.current;if("first"===e.kind)this.current={kind:"progress"},t=e.value;else{if(this.pos>=this.iterator.length-1)return null;t=this.iterator[++this.pos]}let{keyFor:n}=this;return{key:n(t,this.pos),value:t,memo:this.pos}}}export{E as FALSE_REFERENCE,M as NULL_REFERENCE,m as REFERENCE,L as TRUE_REFERENCE,y as UNDEFINED_REFERENCE,W as childRefFor,j as childRefFromParts,V as createComputeRef,_ as createConstRef,q as createDebugAliasRef,R as createInvokableRef,P as createIteratorItemRef,O as createIteratorRef,w as createPrimitiveRef,$ as createReadOnlyRef,x as createUnboundRef,S as isConstRef,F as isInvokableRef,A as isUpdatableRef,N as updateRef,C as valueForRef};
//# sourceMappingURL=index.js.map
