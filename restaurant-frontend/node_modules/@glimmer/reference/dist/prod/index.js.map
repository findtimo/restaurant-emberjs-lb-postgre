{"version":3,"file":"index.js","sources":["../../lib/reference.ts","../../lib/iterable.ts"],"sourcesContent":["import type {\n  ComputeReference,\n  ConstantReference,\n  InvokableReference,\n  Nullable,\n  Reference,\n  ReferenceSymbol,\n  ReferenceType,\n  UnboundReference,\n} from '@glimmer/interfaces';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport { getProp, setProp } from '@glimmer/global-context';\nimport { expect, isDict } from '@glimmer/util';\nimport {\n  CONSTANT_TAG,\n  consumeTag,\n  INITIAL,\n  track,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\n\nexport const REFERENCE: ReferenceSymbol = Symbol('REFERENCE') as ReferenceSymbol;\n\nconst CONSTANT: ConstantReference = 0;\nconst COMPUTE: ComputeReference = 1;\nconst UNBOUND: UnboundReference = 2;\nconst INVOKABLE: InvokableReference = 3;\n\nexport type { Reference as default };\nexport type { Reference };\n\n//////////\n\nexport interface ReferenceEnvironment {\n  getProp(obj: unknown, path: string): unknown;\n  setProp(obj: unknown, path: string, value: unknown): unknown;\n}\n\nclass ReferenceImpl<T = unknown> implements Reference<T> {\n  [REFERENCE]: ReferenceType;\n  public tag: Nullable<Tag> = null;\n  public lastRevision: Revision = INITIAL;\n  public lastValue?: T;\n\n  public children: Nullable<Map<string | Reference, Reference>> = null;\n\n  public compute: Nullable<() => T> = null;\n  public update: Nullable<(val: T) => void> = null;\n\n  public debugLabel?: string;\n\n  constructor(type: ReferenceType) {\n    this[REFERENCE] = type;\n  }\n}\n\nexport function createPrimitiveRef<T extends string | symbol | number | boolean | null | undefined>(\n  value: T\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.tag = CONSTANT_TAG;\n  ref.lastValue = value;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = String(value);\n  }\n\n  return ref;\n}\n\nexport const UNDEFINED_REFERENCE = createPrimitiveRef(undefined);\nexport const NULL_REFERENCE = createPrimitiveRef(null);\nexport const TRUE_REFERENCE = createPrimitiveRef(true as const);\nexport const FALSE_REFERENCE = createPrimitiveRef(false as const);\n\nexport function createConstRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(CONSTANT);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createUnboundRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createComputeRef<T = unknown>(\n  compute: () => T,\n  update: Nullable<(value: T) => void> = null,\n  debugLabel: false | string = 'unknown'\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(COMPUTE);\n\n  ref.compute = compute;\n  ref.update = update;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = `(result of a \\`${debugLabel}\\` helper)`;\n  }\n\n  return ref;\n}\n\nexport function createReadOnlyRef(ref: Reference): Reference {\n  if (!isUpdatableRef(ref)) return ref;\n\n  return createComputeRef(() => valueForRef(ref), null, ref.debugLabel);\n}\n\nexport function isInvokableRef(ref: Reference) {\n  return ref[REFERENCE] === INVOKABLE;\n}\n\nexport function createInvokableRef(inner: Reference): Reference {\n  const ref = createComputeRef(\n    () => valueForRef(inner),\n    (value) => updateRef(inner, value)\n  );\n  ref.debugLabel = inner.debugLabel;\n  ref[REFERENCE] = INVOKABLE;\n\n  return ref;\n}\n\nexport function isConstRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.tag === CONSTANT_TAG;\n}\n\nexport function isUpdatableRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.update !== null;\n}\n\nexport function valueForRef<T>(_ref: Reference<T>): T {\n  const ref = _ref as ReferenceImpl<T>;\n\n  let { tag } = ref;\n\n  if (tag === CONSTANT_TAG) {\n    return ref.lastValue as T;\n  }\n\n  const { lastRevision } = ref;\n  let lastValue;\n\n  if (tag === null || !validateTag(tag, lastRevision)) {\n    const { compute } = ref;\n\n    const newTag = track(\n      () => {\n        lastValue = ref.lastValue = compute!();\n      },\n      import.meta.env.DEV && ref.debugLabel\n    );\n\n    tag = ref.tag = newTag;\n\n    ref.lastRevision = valueForTag(newTag);\n  } else {\n    lastValue = ref.lastValue;\n  }\n\n  consumeTag(tag);\n\n  return lastValue as T;\n}\n\nexport function updateRef(_ref: Reference, value: unknown) {\n  const ref = _ref as ReferenceImpl;\n\n  const update = expect(ref.update, 'called update on a non-updatable reference');\n\n  update(value);\n}\n\nexport function childRefFor(_parentRef: Reference, path: string): Reference {\n  const parentRef = _parentRef as ReferenceImpl;\n\n  const type = parentRef[REFERENCE];\n\n  let children = parentRef.children;\n  let child: Reference;\n\n  if (children === null) {\n    children = parentRef.children = new Map();\n  } else {\n    child = children.get(path)!;\n\n    if (child !== undefined) {\n      return child;\n    }\n  }\n\n  if (type === UNBOUND) {\n    const parent = valueForRef(parentRef);\n\n    if (isDict(parent)) {\n      child = createUnboundRef(\n        (parent as Record<string, unknown>)[path],\n        import.meta.env.DEV && `${parentRef.debugLabel}.${path}`\n      );\n    } else {\n      child = UNDEFINED_REFERENCE;\n    }\n  } else {\n    child = createComputeRef(\n      () => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return getProp(parent, path);\n        }\n      },\n      (val) => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return setProp(parent, path, val);\n        }\n      }\n    );\n\n    if (import.meta.env.DEV) {\n      child.debugLabel = `${parentRef.debugLabel}.${path}`;\n    }\n  }\n\n  children.set(path, child);\n\n  return child;\n}\n\nexport function childRefFromParts(root: Reference, parts: string[]): Reference {\n  let reference = root;\n\n  for (const part of parts) {\n    reference = childRefFor(reference, part);\n  }\n\n  return reference;\n}\n\nexport let createDebugAliasRef: undefined | ((debugLabel: string, inner: Reference) => Reference);\n\nif (import.meta.env.DEV) {\n  createDebugAliasRef = (debugLabel: string, inner: Reference) => {\n    const update = isUpdatableRef(inner) ? (value: unknown) => updateRef(inner, value) : null;\n    const ref = createComputeRef(() => valueForRef(inner), update);\n\n    ref[REFERENCE] = inner[REFERENCE];\n\n    ref.debugLabel = debugLabel;\n\n    return ref;\n  };\n}\n","import type { Dict, Nullable } from '@glimmer/interfaces';\nimport { getPath, toIterator } from '@glimmer/global-context';\nimport { EMPTY_ARRAY, isObject } from '@glimmer/util';\nimport { consumeTag, createTag, dirtyTag } from '@glimmer/validator';\n\nimport type { Reference, ReferenceEnvironment } from './reference';\n\nimport { createComputeRef, valueForRef } from './reference';\n\nexport interface IterationItem<T, U> {\n  key: unknown;\n  value: T;\n  memo: U;\n}\n\nexport interface AbstractIterator<T, U, V extends IterationItem<T, U>> {\n  isEmpty(): boolean;\n  next(): Nullable<V>;\n}\n\nexport type OpaqueIterationItem = IterationItem<unknown, unknown>;\nexport type OpaqueIterator = AbstractIterator<unknown, unknown, OpaqueIterationItem>;\n\nexport interface IteratorDelegate {\n  isEmpty(): boolean;\n  next(): { value: unknown; memo: unknown } | null;\n}\n\nexport interface IteratorReferenceEnvironment extends ReferenceEnvironment {\n  getPath(obj: unknown, path: string): unknown;\n  toIterator(obj: unknown): Nullable<IteratorDelegate>;\n}\n\ntype KeyFor = (item: unknown, index: unknown) => unknown;\n\nconst NULL_IDENTITY = {};\n\nconst KEY: KeyFor = (_, index) => index;\nconst INDEX: KeyFor = (_, index) => String(index);\nconst IDENTITY: KeyFor = (item) => {\n  if (item === null) {\n    // Returning null as an identity will cause failures since the iterator\n    // can't tell that it's actually supposed to be null\n    return NULL_IDENTITY;\n  }\n\n  return item;\n};\n\nfunction keyForPath(path: string): KeyFor {\n  if (import.meta.env.DEV && path[0] === '@') {\n    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);\n  }\n  return uniqueKeyFor((item) => getPath(item as object, path));\n}\n\nfunction makeKeyFor(key: string) {\n  switch (key) {\n    case '@key':\n      return uniqueKeyFor(KEY);\n    case '@index':\n      return uniqueKeyFor(INDEX);\n    case '@identity':\n      return uniqueKeyFor(IDENTITY);\n    default:\n      return keyForPath(key);\n  }\n}\n\nclass WeakMapWithPrimitives<T> {\n  private _weakMap?: WeakMap<object, T>;\n  private _primitiveMap?: Map<unknown, T>;\n\n  private get weakMap() {\n    if (this._weakMap === undefined) {\n      this._weakMap = new WeakMap();\n    }\n\n    return this._weakMap;\n  }\n\n  private get primitiveMap() {\n    if (this._primitiveMap === undefined) {\n      this._primitiveMap = new Map();\n    }\n\n    return this._primitiveMap;\n  }\n\n  set(key: unknown, value: T) {\n    if (isObject(key)) {\n      this.weakMap.set(key, value);\n    } else {\n      this.primitiveMap.set(key, value);\n    }\n  }\n\n  get(key: unknown): T | undefined {\n    if (isObject(key)) {\n      return this.weakMap.get(key);\n    } else {\n      return this.primitiveMap.get(key);\n    }\n  }\n}\n\nconst IDENTITIES = new WeakMapWithPrimitives<object[]>();\n\nfunction identityForNthOccurence(value: any, count: number) {\n  let identities = IDENTITIES.get(value);\n\n  if (identities === undefined) {\n    identities = [];\n    IDENTITIES.set(value, identities);\n  }\n\n  let identity = identities[count];\n\n  if (identity === undefined) {\n    identity = { value, count };\n    identities[count] = identity;\n  }\n\n  return identity;\n}\n\n/**\n * When iterating over a list, it's possible that an item with the same unique\n * key could be encountered twice:\n *\n * ```js\n * let arr = ['same', 'different', 'same', 'same'];\n * ```\n *\n * In general, we want to treat these items as _unique within the list_. To do\n * this, we track the occurences of every item as we iterate the list, and when\n * an item occurs more than once, we generate a new unique key just for that\n * item, and that occurence within the list. The next time we iterate the list,\n * and encounter an item for the nth time, we can get the _same_ key, and let\n * Glimmer know that it should reuse the DOM for the previous nth occurence.\n */\nfunction uniqueKeyFor(keyFor: KeyFor) {\n  let seen = new WeakMapWithPrimitives<number>();\n\n  return (value: unknown, memo: unknown) => {\n    let key = keyFor(value, memo);\n    let count = seen.get(key) || 0;\n\n    seen.set(key, count + 1);\n\n    if (count === 0) {\n      return key;\n    }\n\n    return identityForNthOccurence(key, count);\n  };\n}\n\nexport function createIteratorRef(listRef: Reference, key: string) {\n  return createComputeRef(() => {\n    let iterable = valueForRef(listRef) as { [Symbol.iterator]: any } | null | false;\n\n    let keyFor = makeKeyFor(key);\n\n    if (Array.isArray(iterable)) {\n      return new ArrayIterator(iterable, keyFor);\n    }\n\n    let maybeIterator = toIterator(iterable);\n\n    if (maybeIterator === null) {\n      return new ArrayIterator(EMPTY_ARRAY, () => null);\n    }\n\n    return new IteratorWrapper(maybeIterator, keyFor);\n  });\n}\n\nexport function createIteratorItemRef(_value: unknown) {\n  let value = _value;\n  let tag = createTag();\n\n  return createComputeRef(\n    () => {\n      consumeTag(tag);\n      return value;\n    },\n    (newValue) => {\n      if (value !== newValue) {\n        value = newValue;\n        dirtyTag(tag);\n      }\n    }\n  );\n}\n\nclass IteratorWrapper implements OpaqueIterator {\n  constructor(\n    private inner: IteratorDelegate,\n    private keyFor: KeyFor\n  ) {}\n\n  isEmpty() {\n    return this.inner.isEmpty();\n  }\n\n  next() {\n    let nextValue = this.inner.next() as OpaqueIterationItem;\n\n    if (nextValue !== null) {\n      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);\n    }\n\n    return nextValue;\n  }\n}\n\nclass ArrayIterator implements OpaqueIterator {\n  private current: { kind: 'empty' } | { kind: 'first'; value: unknown } | { kind: 'progress' };\n  private pos = 0;\n\n  constructor(\n    private iterator: unknown[] | readonly unknown[],\n    private keyFor: KeyFor\n  ) {\n    if (iterator.length === 0) {\n      this.current = { kind: 'empty' };\n    } else {\n      this.current = { kind: 'first', value: iterator[this.pos] };\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.current.kind === 'empty';\n  }\n\n  next(): Nullable<IterationItem<unknown, number>> {\n    let value: unknown;\n\n    let current = this.current;\n    if (current.kind === 'first') {\n      this.current = { kind: 'progress' };\n      value = current.value;\n    } else if (this.pos >= this.iterator.length - 1) {\n      return null;\n    } else {\n      value = this.iterator[++this.pos];\n    }\n\n    let { keyFor } = this;\n\n    let key = keyFor(value as Dict, this.pos);\n    let memo = this.pos;\n\n    return { key, value, memo };\n  }\n}\n"],"names":["REFERENCE","Symbol","COMPUTE","UNBOUND","ReferenceImpl","tag","lastRevision","INITIAL","lastValue","children","compute","update","debugLabel","constructor","type","this","createPrimitiveRef","value","ref","CONSTANT_TAG","String","UNDEFINED_REFERENCE","undefined","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createConstRef","createUnboundRef","createComputeRef","createReadOnlyRef","isUpdatableRef","valueForRef","isInvokableRef","createInvokableRef","inner","updateRef","isConstRef","_ref","validateTag","newTag","track","valueForTag","consumeTag","expect","childRefFor","_parentRef","path","parentRef","child","Map","get","parent","isDict","getProp","val","setProp","set","childRefFromParts","root","parts","reference","part","createDebugAliasRef","NULL_IDENTITY","KEY","_","index","INDEX","IDENTITY","item","makeKeyFor","key","uniqueKeyFor","Error","getPath","keyForPath","WeakMapWithPrimitives","_weakMap","_primitiveMap","weakMap","WeakMap","primitiveMap","isObject","IDENTITIES","keyFor","seen","memo","count","identities","identity","identityForNthOccurence","createIteratorRef","listRef","iterable","Array","isArray","ArrayIterator","maybeIterator","toIterator","EMPTY_ARRAY","IteratorWrapper","createIteratorItemRef","_value","createTag","newValue","dirtyTag","isEmpty","next","nextValue","current","pos","iterator","length","kind"],"mappings":"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"}