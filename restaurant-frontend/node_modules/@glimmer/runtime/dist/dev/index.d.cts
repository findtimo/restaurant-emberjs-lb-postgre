import { RichIteratorResult, Bounds, Cursor, Nullable, SimpleElement, SimpleNode, InternalComponentCapabilities, InternalComponentManager, CapturedArguments, CurriedType, Owner, GlimmerTreeChanges, SimpleDocument, SimpleComment, SimpleText, AttrNamespace, ElementNamespace, GlimmerTreeConstruction, ComponentInstanceWithCreate, Environment, EnvironmentOptions, ModifierInstance, RuntimeArtifacts, RuntimeContext, RuntimeResolver, Transaction, TransactionSymbol, CapturedRenderNode, DebugRenderTree, RenderNode, Arguments, CompilableProgram, CompileTimeCompilationContext, ComponentDefinitionState, DynamicScope, ElementBuilder, RenderResult, TemplateIterator, Dict, PartialScope, Scope, ScopeBlock, ScopeSlot, CompilableTemplate, Destroyable, ResolutionTimeConstants, RuntimeConstants, RuntimeProgram, UpdatingOpcode, RuntimeHeap, RuntimeOp, ExceptionHandler, LiveBlock, UpdatableBlock, CursorStackSymbol, ElementOperations, Maybe, SimpleDocumentFragment, AttributeCursor, AttributeOperation, BlockArguments, BlockValue, CapturedBlockArguments, CapturedNamedArguments, CapturedPositionalArguments, NamedArguments, PositionalArguments, VMArguments } from '@glimmer/interfaces';
import { VM as PublicVM } from "@glimmer/interfaces";
import { UpdatingVM as IUpdatingVM } from "@glimmer/interfaces";
import { Reference, OpaqueIterationItem, OpaqueIterator } from "@glimmer/reference";
import { Cache, Tag } from "@glimmer/validator";
import { MachineRegister, Register, SyscallRegister } from "@glimmer/vm";
import { Stack as Stack$0 } from "@glimmer/util";
declare class CursorImpl implements Cursor {
    element: SimpleElement;
    nextSibling: Nullable<SimpleNode>;
    constructor(element: SimpleElement, nextSibling: Nullable<SimpleNode>);
}
declare class ConcreteBounds implements Bounds {
    parentNode: SimpleElement;
    private first;
    private last;
    constructor(parentNode: SimpleElement, first: SimpleNode, last: SimpleNode);
    parentElement(): SimpleElement;
    firstNode(): SimpleNode;
    lastNode(): SimpleNode;
}
declare function clear(bounds: Bounds): Nullable<SimpleNode>;
type DebugGet = (path: string) => unknown;
type DebugCallback = (context: unknown, get: DebugGet) => void;
// For testing purposes
declare function setDebuggerCallback(cb: DebugCallback): void;
declare function resetDebuggerCallback(): void;
declare class TemplateOnlyComponentManager implements InternalComponentManager {
    getCapabilities(): InternalComponentCapabilities;
    getDebugName({ name }: TemplateOnlyComponentDefinition): string;
    getSelf(): Reference;
    getDestroyable(): null;
}
declare const TEMPLATE_ONLY_COMPONENT_MANAGER: TemplateOnlyComponentManager;
// This is only exported for types, don't use this class directly
declare class TemplateOnlyComponentDefinition {
    moduleName: string;
    name: string;
    constructor(moduleName?: string, name?: string);
    toString(): string;
}
/**
 This utility function is used to declare a given component has no backing class. When the rendering engine detects this it
 is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_
 without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).
 Specifically, this means that the template will be rendered as "outer HTML".
 
 In general, this method will be used by build time tooling and would not be directly written in an application. However,
 at times it may be useful to use directly to leverage the "outer HTML" semantics mentioned above. For example, if an addon would like
 to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the
 `template-only-glimmer-components` optional feature.
 
 @example
 
 ```js
 import { templateOnlyComponent } from '@glimmer/runtime';
 
 export default templateOnlyComponent();
 ```
 
 @public
 @method templateOnly
 @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes
 @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE
 */
declare function templateOnlyComponent(moduleName?: string, name?: string): TemplateOnlyComponentDefinition;
declare const TYPE: unique symbol;
declare const INNER: unique symbol;
declare const OWNER: unique symbol;
declare const ARGS: unique symbol;
declare const RESOLVED: unique symbol;
declare class CurriedValue<T extends CurriedType = CurriedType> {
    [TYPE]: T;
    [INNER]: object | string | CurriedValue<T>;
    [OWNER]: Owner;
    [ARGS]: CapturedArguments | null;
    [RESOLVED]: boolean;
    /** @internal */
    constructor(type: T, inner: object | string | CurriedValue<T>, owner: Owner, args: CapturedArguments | null, resolved?: boolean);
}
declare function curry<T extends CurriedType>(type: T, spec: object | string | CurriedValue<T>, owner: Owner, args: CapturedArguments | null, resolved?: boolean): CurriedValue<T>;
declare class DOMOperations {
    protected document: SimpleDocument;
    protected uselessElement: SimpleElement; // Set by this.setupUselessElement() in constructor
    constructor(document: SimpleDocument);
    // split into separate method so that NodeDOMTreeConstruction
    // can override it.
    protected setupUselessElement(): void;
    createElement(tag: string, context?: SimpleElement): SimpleElement;
    insertBefore(parent: SimpleElement, node: SimpleNode, reference: Nullable<SimpleNode>): void;
    insertHTMLBefore(parent: SimpleElement, nextSibling: Nullable<SimpleNode>, html: string): Bounds;
    createTextNode(text: string): SimpleText;
    createComment(data: string): SimpleComment;
}
declare function isWhitespace(string: string): boolean;
declare class DOMChangesImpl extends DOMOperations implements GlimmerTreeChanges {
    protected document: SimpleDocument;
    protected namespace: Nullable<string>;
    constructor(document: SimpleDocument);
    setAttribute(element: SimpleElement, name: string, value: string): void;
    removeAttribute(element: SimpleElement, name: string): void;
    insertAfter(element: SimpleElement, node: SimpleNode, reference: SimpleNode): void;
}
declare const DOMChanges: typeof DOMChangesImpl;
declare class TreeConstruction extends DOMOperations implements GlimmerTreeConstruction {
    createElementNS(namespace: ElementNamespace, tag: string): SimpleElement;
    setAttribute(element: SimpleElement, name: string, value: string, namespace?: Nullable<AttrNamespace>): void;
}
declare const DOMTreeConstruction: typeof TreeConstruction;
type DOMTreeConstruction = TreeConstruction;
/*
* @method normalizeProperty
* @param element {HTMLElement}
* @param slotName {String}
* @returns {Object} { name, type }
*/
declare function normalizeProperty(element: SimpleElement, slotName: string): {
    normalized: any;
    type: any;
};
declare class DebugRenderTreeImpl<TBucket extends object> implements DebugRenderTree<TBucket> {
    private stack;
    private refs;
    private roots;
    private nodes;
    begin(): void;
    create(state: TBucket, node: RenderNode): void;
    update(state: TBucket): void;
    didRender(state: TBucket, bounds: Bounds): void;
    willDestroy(state: TBucket): void;
    commit(): void;
    capture(): CapturedRenderNode[];
    private reset;
    private enter;
    private exit;
    private nodeFor;
    private appendChild;
    private captureRefs;
    private captureNode;
    private captureTemplate;
    private captureBounds;
}
declare module DebugRenderTreeImplWrapper {
    export { DebugRenderTreeImpl };
}
import DebugRenderTree$0 = DebugRenderTreeImplWrapper.DebugRenderTreeImpl;
declare const TRANSACTION: TransactionSymbol;
declare class TransactionImpl implements Transaction {
    scheduledInstallModifiers: ModifierInstance[];
    scheduledUpdateModifiers: ModifierInstance[];
    createdComponents: ComponentInstanceWithCreate[];
    updatedComponents: ComponentInstanceWithCreate[];
    didCreate(component: ComponentInstanceWithCreate): void;
    didUpdate(component: ComponentInstanceWithCreate): void;
    scheduleInstallModifier(modifier: ModifierInstance): void;
    scheduleUpdateModifier(modifier: ModifierInstance): void;
    commit(): void;
}
declare class EnvironmentImpl implements Environment {
    private delegate;
    [TRANSACTION]: Nullable<TransactionImpl>;
    protected appendOperations: GlimmerTreeConstruction;
    protected updateOperations?: GlimmerTreeChanges | undefined;
    // Delegate methods and values
    isInteractive: boolean;
    debugRenderTree: DebugRenderTree$0<object> | undefined;
    constructor(options: EnvironmentOptions, delegate: EnvironmentDelegate);
    getAppendOperations(): GlimmerTreeConstruction;
    getDOM(): GlimmerTreeChanges;
    begin(): void;
    private get transaction();
    didCreate(component: ComponentInstanceWithCreate): void;
    didUpdate(component: ComponentInstanceWithCreate): void;
    scheduleInstallModifier(modifier: ModifierInstance): void;
    scheduleUpdateModifier(modifier: ModifierInstance): void;
    commit(): void;
}
interface EnvironmentDelegate {
    /**
     * Used to determine the the environment is interactive (e.g. SSR is not
     * interactive). Interactive environments schedule modifiers, among other things.
     */
    isInteractive: boolean;
    /**
     * Used to enable debug tooling
     */
    enableDebugTooling: boolean;
    /**
     * Callback to be called when an environment transaction commits
     */
    onTransactionCommit: () => void;
}
declare function runtimeContext(options: EnvironmentOptions, delegate: EnvironmentDelegate, artifacts: RuntimeArtifacts, resolver: RuntimeResolver): RuntimeContext;
declare function inTransaction(env: Environment, block: () => void): void;
/**
 Use the `{{array}}` helper to create an array to pass as an option to your
 components.
 
 ```handlebars
 <MyComponent @people={{array
 'Tom Dale'
 'Yehuda Katz'
 this.myOtherPerson}}
 />
 ```
 or
 ```handlebars
 {{my-component people=(array
 'Tom Dale'
 'Yehuda Katz'
 this.myOtherPerson)
 }}
 ```
 
 Would result in an object such as:
 
 ```js
 ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]
 ```
 
 Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.
 
 @method array
 @param {Array} options
 @return {Array} Array
 @public
 */
declare const array: object;
/**
 Concatenates the given arguments into a string.
 
 Example:
 
 ```handlebars
 {{some-component name=(concat firstName " " lastName)}}
 
 {{! would pass name="<first name value> <last name value>" to the component}}
 ```
 
 or for angle bracket invocation, you actually don't need concat at all.
 
 ```handlebars
 <SomeComponent @name="{{firstName}} {{lastName}}" />
 ```
 
 @public
 @method concat
 */
declare const concat: object;
/**
 The `fn` helper allows you to ensure a function that you are passing off
 to another component, helper, or modifier has access to arguments that are
 available in the template.
 
 For example, if you have an `each` helper looping over a number of items, you
 may need to pass a function that expects to receive the item as an argument
 to a component invoked within the loop. Here's how you could use the `fn`
 helper to pass both the function and its arguments together:
 
 ```app/templates/components/items-listing.hbs
 {{#each @items as |item|}}
 <DisplayItem @item=item @select={{fn this.handleSelected item}} />
 {{/each}}
 ```
 
 ```app/components/items-list.js
 import Component from '@glimmer/component';
 import { action } from '@ember/object';
 
 export default class ItemsList extends Component {
 handleSelected = (item) => {
 // ...snip...
 }
 }
 ```
 
 In this case the `display-item` component will receive a normal function
 that it can invoke. When it invokes the function, the `handleSelected`
 function will receive the `item` and any arguments passed, thanks to the
 `fn` helper.
 
 Let's take look at what that means in a couple circumstances:
 
 - When invoked as `this.args.select()` the `handleSelected` function will
 receive the `item` from the loop as its first and only argument.
 - When invoked as `this.args.select('foo')` the `handleSelected` function
 will receive the `item` from the loop as its first argument and the
 string `'foo'` as its second argument.
 
 In the example above, we used an arrow function to ensure that
 `handleSelected` is properly bound to the `items-list`, but let's explore what
 happens if we left out the arrow function:
 
 ```app/components/items-list.js
 import Component from '@glimmer/component';
 
 export default class ItemsList extends Component {
 handleSelected(item) {
 // ...snip...
 }
 }
 ```
 
 In this example, when `handleSelected` is invoked inside the `display-item`
 component, it will **not** have access to the component instance. In other
 words, it will have no `this` context, so please make sure your functions
 are bound (via an arrow function or other means) before passing into `fn`!
 
 See also [partial application](https://en.wikipedia.org/wiki/Partial_application).
 
 @method fn
 @public
 */
declare const fn: object;
/**
 Dynamically look up a property on an object. The second argument to `{{get}}`
 should have a string value, although it can be bound.
 
 For example, these two usages are equivalent:
 
 ```app/components/developer-detail.js
 import Component from '@glimmer/component';
 import { tracked } from '@glimmer/tracking';
 
 export default class extends Component {
 @tracked developer = {
 name: "Sandi Metz",
 language: "Ruby"
 }
 }
 ```
 
 ```handlebars
 {{this.developer.name}}
 {{get this.developer "name"}}
 ```
 
 If there were several facts about a person, the `{{get}}` helper can dynamically
 pick one:
 
 ```app/templates/application.hbs
 <DeveloperDetail @factName="language" />
 ```
 
 ```handlebars
 {{get this.developer @factName}}
 ```
 
 For a more complex example, this template would allow the user to switch
 between showing the user's height and weight with a click:
 
 ```app/components/developer-detail.js
 import Component from '@glimmer/component';
 import { tracked } from '@glimmer/tracking';
 
 export default class extends Component {
 @tracked developer = {
 name: "Sandi Metz",
 language: "Ruby"
 }
 
 @tracked currentFact = 'name'
 
 showFact = (fact) => {
 this.currentFact = fact;
 }
 }
 ```
 
 ```app/components/developer-detail.js
 {{get this.developer this.currentFact}}
 
 <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
 <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
 ```
 
 The `{{get}}` helper can also respect mutable values itself. For example:
 
 ```app/components/developer-detail.js
 <Input @value={{mut (get this.person this.currentFact)}} />
 
 <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
 <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
 ```
 
 Would allow the user to swap what fact is being displayed, and also edit
 that fact via a two-way mutable binding.
 
 @public
 @method get
 */
declare const get: object;
/**
 Use the `{{hash}}` helper to create a hash to pass as an option to your
 components. This is specially useful for contextual components where you can
 just yield a hash:
 
 ```handlebars
 {{yield (hash
 name='Sarah'
 title=office
 )}}
 ```
 
 Would result in an object such as:
 
 ```js
 { name: 'Sarah', title: this.get('office') }
 ```
 
 Where the `title` is bound to updates of the `office` property.
 
 Note that the hash is an empty object with no prototype chain, therefore
 common methods like `toString` are not available in the resulting hash.
 If you need to use such a method, you can use the `call` or `apply`
 approach:
 
 ```js
 function toString(obj) {
 return Object.prototype.toString.apply(obj);
 }
 ```
 
 @method hash
 @param {Object} options
 @return {Object} Hash
 @public
 */
declare const hash: object;
////////////
declare function invokeHelper(context: object, definition: object, computeArgs?: (context: object) => Partial<Arguments>): Cache<unknown>;
declare const on: {};
declare function renderSync(env: Environment, iterator: TemplateIterator): RenderResult;
declare function renderMain(runtime: RuntimeContext, context: CompileTimeCompilationContext, owner: Owner, self: Reference, treeBuilder: ElementBuilder, layout: CompilableProgram, dynamicScope?: DynamicScope): TemplateIterator;
declare function renderComponent(runtime: RuntimeContext, treeBuilder: ElementBuilder, context: CompileTimeCompilationContext, owner: Owner, definition: ComponentDefinitionState, args?: Record<string, unknown>, dynamicScope?: DynamicScope): TemplateIterator;
declare class DynamicScopeImpl implements DynamicScope {
    private bucket;
    constructor(bucket?: Dict<Reference>);
    get(key: string): Reference;
    set(key: string, reference: Reference): Reference;
    child(): DynamicScopeImpl;
}
declare class PartialScopeImpl implements PartialScope {
    // the 0th slot is `self`
    readonly slots: Array<ScopeSlot>;
    readonly owner: Owner;
    private callerScope;
    // named arguments and blocks passed to a layout that uses eval
    private evalScope;
    // locals in scope when the partial was invoked
    private partialMap;
    static root(self: Reference<unknown>, size: number, owner: Owner): PartialScope;
    static sized(size: number, owner: Owner): Scope;
    constructor(slots: Array<ScopeSlot>, owner: Owner, callerScope: Scope | null, evalScope: Dict<ScopeSlot> | null, partialMap: Dict<Reference<unknown>> | null);
    init({ self }: {
        self: Reference<unknown>;
    }): this;
    getSelf(): Reference<unknown>;
    getSymbol(symbol: number): Reference<unknown>;
    getBlock(symbol: number): Nullable<ScopeBlock>;
    getEvalScope(): Nullable<Dict<ScopeSlot>>;
    getPartialMap(): Nullable<Dict<Reference<unknown>>>;
    bind(symbol: number, value: ScopeSlot): void;
    bindSelf(self: Reference<unknown>): void;
    bindSymbol(symbol: number, value: Reference<unknown>): void;
    bindBlock(symbol: number, value: Nullable<ScopeBlock>): void;
    bindEvalScope(map: Nullable<Dict<ScopeSlot>>): void;
    bindPartialMap(map: Dict<Reference<unknown>>): void;
    bindCallerScope(scope: Nullable<Scope>): void;
    getCallerScope(): Nullable<Scope>;
    child(): Scope;
    private get;
    private set;
}
interface SafeString {
    toHTML(): string;
}
interface LowLevelRegisters {
    [MachineRegister.pc]: number;
    [MachineRegister.ra]: number;
    [MachineRegister.sp]: number;
    [MachineRegister.fp]: number;
}
interface Stack {
    push(value: unknown): void;
    get(position: number): number;
    pop<T>(): T;
}
interface Externs {
    debugBefore(opcode: RuntimeOp): unknown;
    debugAfter(state: unknown): void;
}
declare class LowLevelVM {
    stack: Stack;
    heap: RuntimeHeap;
    program: RuntimeProgram;
    externs: Externs;
    readonly registers: LowLevelRegisters;
    currentOpSize: number;
    constructor(stack: Stack, heap: RuntimeHeap, program: RuntimeProgram, externs: Externs, registers: LowLevelRegisters);
    fetchRegister(register: MachineRegister): number;
    loadRegister(register: MachineRegister, value: number): void;
    setPc(pc: number): void;
    // Start a new frame and save $ra and $fp on the stack
    pushFrame(): void;
    // Restore $ra, $sp and $fp
    popFrame(): void;
    pushSmallFrame(): void;
    popSmallFrame(): void;
    // Jump to an address in `program`
    goto(offset: number): void;
    target(offset: number): number;
    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    call(handle: number): void;
    // Put a specific `program` address in $ra
    returnTo(offset: number): void;
    // Return to the `program` address stored in $ra
    return(): void;
    nextStatement(): Nullable<RuntimeOp>;
    evaluateOuter(opcode: RuntimeOp, vm: VM): void;
    evaluateInner(opcode: RuntimeOp, vm: VM): void;
    evaluateMachine(opcode: RuntimeOp): void;
    evaluateSyscall(opcode: RuntimeOp, vm: VM): void;
}
// These symbols represent "friend" properties that are used inside of
// the VM in other classes, but are not intended to be a part of
// Glimmer's API.
declare const INNER_VM: unique symbol;
declare const DESTROYABLE_STACK: unique symbol;
declare const STACKS: unique symbol;
declare const REGISTERS: unique symbol;
declare const HEAP: unique symbol;
declare const CONSTANTS: unique symbol;
declare const ARGS$0: unique symbol;
interface EvaluationStack {
    [REGISTERS]: LowLevelRegisters;
    push(value: unknown): void;
    dup(position?: MachineRegister): void;
    copy(from: number, to: number): void;
    pop<T>(n?: number): T;
    peek<T>(offset?: number): T;
    get<T>(offset: number, base?: number): T;
    set(value: unknown, offset: number, base?: number): void;
    slice<T = unknown>(start: number, end: number): T[];
    capture(items: number): unknown[];
    reset(): void;
    toArray(): unknown[];
}
declare function dynamicAttribute(element: SimpleElement, attr: string, namespace: Nullable<AttrNamespace>, isTrusting?: boolean): DynamicAttribute;
declare abstract class DynamicAttribute implements AttributeOperation {
    attribute: AttributeCursor;
    constructor(attribute: AttributeCursor);
    abstract set(dom: ElementBuilder, value: unknown, env: Environment): void;
    abstract update(value: unknown, env: Environment): void;
}
declare class SimpleDynamicAttribute extends DynamicAttribute {
    set(dom: ElementBuilder, value: unknown, _env: Environment): void;
    update(value: unknown, _env: Environment): void;
}
interface FirstNode {
    firstNode(): SimpleNode;
}
interface LastNode {
    lastNode(): SimpleNode;
}
declare const CURSOR_STACK: CursorStackSymbol;
declare class NewElementBuilder implements ElementBuilder {
    dom: GlimmerTreeConstruction;
    updateOperations: GlimmerTreeChanges;
    constructing: Nullable<SimpleElement>;
    operations: Nullable<ElementOperations>;
    private env;
    [CURSOR_STACK]: Stack$0<Cursor>;
    private modifierStack;
    private blockStack;
    static forInitialRender(env: Environment, cursor: CursorImpl): NewElementBuilder;
    static resume(env: Environment, block: UpdatableBlock): NewElementBuilder;
    constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>);
    protected initialize(): this;
    debugBlocks(): LiveBlock[];
    get element(): SimpleElement;
    get nextSibling(): Nullable<SimpleNode>;
    get hasBlocks(): boolean;
    protected block(): LiveBlock;
    popElement(): void;
    pushSimpleBlock(): LiveBlock;
    pushUpdatableBlock(): UpdatableBlockImpl;
    pushBlockList(list: LiveBlock[]): LiveBlockList;
    protected pushLiveBlock<T extends LiveBlock>(block: T, isRemote?: boolean): T;
    popBlock(): LiveBlock;
    __openBlock(): void;
    __closeBlock(): void;
    // todo return seems unused
    openElement(tag: string): SimpleElement;
    __openElement(tag: string): SimpleElement;
    flushElement(modifiers: Nullable<ModifierInstance[]>): void;
    __flushElement(parent: SimpleElement, constructing: SimpleElement): void;
    closeElement(): Nullable<ModifierInstance[]>;
    pushRemoteElement(element: SimpleElement, guid: string, insertBefore: Maybe<SimpleNode>): Nullable<RemoteLiveBlock>;
    __pushRemoteElement(element: SimpleElement, _guid: string, insertBefore: Maybe<SimpleNode>): Nullable<RemoteLiveBlock>;
    popRemoteElement(): void;
    protected pushElement(element: SimpleElement, nextSibling?: Maybe<SimpleNode>): void;
    private pushModifiers;
    private popModifiers;
    didAppendBounds(bounds: Bounds): Bounds;
    didAppendNode<T extends SimpleNode>(node: T): T;
    didOpenElement(element: SimpleElement): SimpleElement;
    willCloseElement(): void;
    appendText(string: string): SimpleText;
    __appendText(text: string): SimpleText;
    __appendNode(node: SimpleNode): SimpleNode;
    __appendFragment(fragment: SimpleDocumentFragment): Bounds;
    __appendHTML(html: string): Bounds;
    appendDynamicHTML(value: string): void;
    appendDynamicText(value: string): SimpleText;
    appendDynamicFragment(value: SimpleDocumentFragment): void;
    appendDynamicNode(value: SimpleNode): void;
    private trustedContent;
    private untrustedContent;
    appendComment(string: string): SimpleComment;
    __appendComment(string: string): SimpleComment;
    __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void;
    __setProperty(name: string, value: unknown): void;
    setStaticAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void;
    setDynamicAttribute(name: string, value: unknown, trusting: boolean, namespace: Nullable<AttrNamespace>): DynamicAttribute;
}
declare class SimpleLiveBlock implements LiveBlock {
    private parent;
    protected first: Nullable<FirstNode>;
    protected last: Nullable<LastNode>;
    protected nesting: number;
    constructor(parent: SimpleElement);
    parentElement(): SimpleElement;
    firstNode(): SimpleNode;
    lastNode(): SimpleNode;
    openElement(element: SimpleElement): void;
    closeElement(): void;
    didAppendNode(node: SimpleNode): void;
    didAppendBounds(bounds: Bounds): void;
    finalize(stack: ElementBuilder): void;
}
declare class RemoteLiveBlock extends SimpleLiveBlock {
    constructor(parent: SimpleElement);
}
declare class UpdatableBlockImpl extends SimpleLiveBlock implements UpdatableBlock {
    reset(): Nullable<SimpleNode>;
}
// FIXME: All the noops in here indicate a modelling problem
declare class LiveBlockList implements LiveBlock {
    private readonly parent;
    boundList: LiveBlock[];
    constructor(parent: SimpleElement, boundList: LiveBlock[]);
    parentElement(): SimpleElement;
    firstNode(): SimpleNode;
    lastNode(): SimpleNode;
    openElement(_element: SimpleElement): void;
    closeElement(): void;
    didAppendNode(_node: SimpleNode): void;
    didAppendBounds(_bounds: Bounds): void;
    finalize(_stack: ElementBuilder): void;
}
declare function clientBuilder(env: Environment, cursor: CursorImpl): ElementBuilder;
declare class UpdatingVM implements IUpdatingVM {
    env: Environment;
    dom: GlimmerTreeChanges;
    alwaysRevalidate: boolean;
    private frameStack;
    constructor(env: Environment, { alwaysRevalidate }: {
        alwaysRevalidate?: boolean;
    });
    execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler): void;
    private _execute;
    private get frame();
    goto(index: number): void;
    try(ops: UpdatingOpcode[], handler: Nullable<ExceptionHandler>): void;
    throw(): void;
}
interface VMState {
    readonly pc: number;
    readonly scope: Scope;
    readonly dynamicScope: DynamicScope;
    readonly stack: unknown[];
}
interface ResumableVMState {
    resume(runtime: RuntimeContext, builder: ElementBuilder): InternalVM;
}
declare abstract class BlockOpcode implements UpdatingOpcode, Bounds {
    protected state: ResumableVMState;
    protected runtime: RuntimeContext;
    children: UpdatingOpcode[];
    protected readonly bounds: LiveBlock;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: LiveBlock, children: UpdatingOpcode[]);
    parentElement(): import("@glimmer/interfaces").SimpleElement;
    firstNode(): import("@glimmer/interfaces").SimpleNode;
    lastNode(): import("@glimmer/interfaces").SimpleNode;
    evaluate(vm: UpdatingVM): void;
}
declare class TryOpcode extends BlockOpcode implements ExceptionHandler {
    type: string;
    protected bounds: UpdatableBlock; // Hides property on base class
    evaluate(vm: UpdatingVM): void;
    handleException(): void;
}
declare class ListItemOpcode extends TryOpcode {
    key: unknown;
    memo: Reference;
    value: Reference;
    retained: boolean;
    index: number;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: UpdatableBlock, key: unknown, memo: Reference, value: Reference);
    updateReferences(item: OpaqueIterationItem): void;
    shouldRemove(): boolean;
    reset(): void;
}
declare class ListBlockOpcode extends BlockOpcode {
    private iterableRef;
    type: string;
    children: ListItemOpcode[];
    private opcodeMap;
    private marker;
    private lastIterator;
    protected readonly bounds: LiveBlockList;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: LiveBlockList, children: ListItemOpcode[], iterableRef: Reference<OpaqueIterator>);
    initializeChild(opcode: ListItemOpcode): void;
    evaluate(vm: UpdatingVM): void;
    private sync;
    private retainItem;
    private insertItem;
    private moveItem;
    private deleteItem;
}
/*
The calling convention is:

* 0-N block arguments at the bottom
* 0-N positional arguments next (left-to-right)
* 0-N named arguments next
*/
declare class VMArgumentsImpl implements VMArguments {
    private stack;
    positional: PositionalArgumentsImpl;
    named: NamedArgumentsImpl;
    blocks: BlockArgumentsImpl;
    empty(stack: EvaluationStack): this;
    setup(stack: EvaluationStack, names: readonly string[], blockNames: readonly string[], positionalCount: number, atNames: boolean): void;
    get base(): number;
    get length(): number;
    at(pos: number): Reference;
    realloc(offset: number): void;
    capture(): CapturedArguments;
    clear(): void;
}
declare class PositionalArgumentsImpl implements PositionalArguments {
    base: number;
    length: number;
    private stack;
    private _references;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number): void;
    at(position: number): Reference;
    capture(): CapturedPositionalArguments;
    prepend(other: Reference[]): void;
    private get references();
}
declare class NamedArgumentsImpl implements NamedArguments {
    base: number;
    length: number;
    private stack;
    private _references;
    private _names;
    private _atNames;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number, names: readonly string[], atNames: boolean): void;
    get names(): readonly string[];
    get atNames(): readonly string[];
    has(name: string): boolean;
    get(name: string, atNames?: boolean): Reference;
    capture(): CapturedNamedArguments;
    merge(other: Record<string, Reference>): void;
    private get references();
    private toSyntheticName;
    private toAtName;
}
declare class BlockArgumentsImpl implements BlockArguments {
    private stack;
    private internalValues;
    private _symbolNames;
    internalTag: Nullable<Tag>;
    names: readonly string[];
    length: number;
    base: number;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number, names: readonly string[]): void;
    get values(): readonly BlockValue[];
    has(name: string): boolean;
    get(name: string): Nullable<ScopeBlock>;
    capture(): CapturedBlockArguments;
    get symbolNames(): readonly string[];
}
declare function createCapturedArgs(named: Dict<Reference>, positional: Reference[]): CapturedArguments;
declare function reifyNamed(named: CapturedNamedArguments): Dict<unknown>;
declare function reifyPositional(positional: CapturedPositionalArguments): unknown[];
declare function reifyArgs(args: CapturedArguments): {
    named: Dict<unknown>;
    positional: unknown[];
};
declare const EMPTY_NAMED: CapturedNamedArguments;
declare const EMPTY_POSITIONAL: CapturedPositionalArguments;
declare const EMPTY_ARGS: CapturedArguments;
/**
 * This interface is used by internal opcodes, and is more stable than
 * the implementation of the Append VM itself.
 */
interface InternalVM {
    readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;
    readonly [ARGS$0]: VMArgumentsImpl;
    readonly env: Environment;
    readonly stack: EvaluationStack;
    readonly runtime: RuntimeContext;
    readonly context: CompileTimeCompilationContext;
    loadValue(register: MachineRegister, value: number): void;
    loadValue(register: Register, value: unknown): void;
    loadValue(register: Register | MachineRegister, value: unknown): void;
    fetchValue(register: MachineRegister.ra | MachineRegister.pc): number;
    // TODO: Something better than a type assertion?
    fetchValue<T>(register: Register): T;
    fetchValue(register: Register): unknown;
    load(register: Register): void;
    fetch(register: Register): void;
    compile(block: CompilableTemplate): number;
    scope(): Scope;
    elements(): ElementBuilder;
    getOwner(): Owner;
    getSelf(): Reference;
    updateWith(opcode: UpdatingOpcode): void;
    associateDestroyable(d: Destroyable): void;
    beginCacheGroup(name?: string): void;
    commitCacheGroup(): void;
    /// Iteration ///
    enterList(iterableRef: Reference<OpaqueIterator>, offset: number): void;
    exitList(): void;
    enterItem(item: OpaqueIterationItem): ListItemOpcode;
    registerItem(item: ListItemOpcode): void;
    pushRootScope(size: number, owner: Owner): PartialScope;
    pushChildScope(): void;
    popScope(): void;
    pushScope(scope: Scope): void;
    dynamicScope(): DynamicScope;
    bindDynamicScope(names: string[]): void;
    pushDynamicScope(): void;
    popDynamicScope(): void;
    enter(args: number): void;
    exit(): void;
    goto(pc: number): void;
    call(handle: number): void;
    pushFrame(): void;
    referenceForSymbol(symbol: number): Reference;
    execute(initialize?: (vm: this) => void): RenderResult;
    pushUpdating(list?: UpdatingOpcode[]): void;
    next(): RichIteratorResult<null, RenderResult>;
}
declare class VM implements PublicVM, InternalVM {
    readonly runtime: RuntimeContext;
    private readonly elementStack;
    readonly context: CompileTimeCompilationContext;
    private readonly [STACKS];
    private readonly [HEAP];
    private readonly destructor;
    private readonly [DESTROYABLE_STACK];
    readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;
    readonly [ARGS$0]: VMArgumentsImpl;
    readonly [INNER_VM]: LowLevelVM;
    get stack(): EvaluationStack;
    /* Registers */
    get pc(): number;
    s0: unknown;
    s1: unknown;
    t0: unknown;
    t1: unknown;
    v0: unknown;
    // Fetch a value from a register onto the stack
    fetch(register: SyscallRegister): void;
    // Load a value from the stack into a register
    load(register: SyscallRegister): void;
    // Fetch a value from a register
    fetchValue(register: MachineRegister): number;
    fetchValue<T>(register: Register): T;
    // Load a value into a register
    loadValue<T>(register: Register | MachineRegister, value: T): void;
    /**
     * Migrated to Inner
     */
    // Start a new frame and save $ra and $fp on the stack
    pushFrame(): void;
    // Restore $ra, $sp and $fp
    popFrame(): void;
    // Jump to an address in `program`
    goto(offset: number): void;
    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    call(handle: number): void;
    // Put a specific `program` address in $ra
    returnTo(offset: number): void;
    // Return to the `program` address stored in $ra
    return(): void;
    /**
     * End of migrated.
     */
    constructor(runtime: RuntimeContext, { pc, scope, dynamicScope, stack }: VMState, elementStack: ElementBuilder, context: CompileTimeCompilationContext);
    static initial(runtime: RuntimeContext, context: CompileTimeCompilationContext, { handle, self, dynamicScope, treeBuilder, numSymbols, owner }: InitOptions): InternalVM;
    static empty(runtime: RuntimeContext, { handle, treeBuilder, dynamicScope, owner }: MinimalInitOptions, context: CompileTimeCompilationContext): InternalVM;
    private resume;
    compile(block: CompilableTemplate): number;
    get program(): RuntimeProgram;
    get env(): Environment;
    captureState(args: number, pc?: number): VMState;
    capture(args: number, pc?: number): ResumableVMState;
    beginCacheGroup(name?: string): void;
    commitCacheGroup(): void;
    enter(args: number): void;
    enterItem({ key, value, memo }: OpaqueIterationItem): ListItemOpcode;
    registerItem(opcode: ListItemOpcode): void;
    enterList(iterableRef: Reference<OpaqueIterator>, offset: number): void;
    private didEnter;
    exit(): void;
    exitList(): void;
    pushUpdating(list?: UpdatingOpcode[]): void;
    popUpdating(): UpdatingOpcode[];
    updateWith(opcode: UpdatingOpcode): void;
    listBlock(): ListBlockOpcode;
    associateDestroyable(child: Destroyable): void;
    tryUpdating(): Nullable<UpdatingOpcode[]>;
    updating(): UpdatingOpcode[];
    elements(): ElementBuilder;
    scope(): Scope;
    dynamicScope(): DynamicScope;
    pushChildScope(): void;
    pushDynamicScope(): DynamicScope;
    pushRootScope(size: number, owner: Owner): PartialScope;
    pushScope(scope: Scope): void;
    popScope(): void;
    popDynamicScope(): void;
    /// SCOPE HELPERS
    getOwner(): Owner;
    getSelf(): Reference<any>;
    referenceForSymbol(symbol: number): Reference;
    /// EXECUTION
    execute(initialize?: (vm: this) => void): RenderResult;
    private _execute;
    next(): RichIteratorResult<null, RenderResult>;
    bindDynamicScope(names: string[]): void;
}
interface MinimalInitOptions {
    handle: number;
    treeBuilder: ElementBuilder;
    dynamicScope: DynamicScope;
    owner: Owner;
}
interface InitOptions extends MinimalInitOptions {
    self: Reference;
    numSymbols: number;
}
declare const SERIALIZATION_FIRST_NODE_STRING = "%+b:0%";
declare function isSerializationFirstNode(node: SimpleNode): boolean;
declare class RehydratingCursor extends CursorImpl {
    readonly startingBlockDepth: number;
    candidate: Nullable<SimpleNode>;
    openBlockDepth: number;
    injectedOmittedNode: boolean;
    constructor(element: SimpleElement, nextSibling: Nullable<SimpleNode>, startingBlockDepth: number);
}
declare class RehydrateBuilder extends NewElementBuilder implements ElementBuilder {
    private unmatchedAttributes;
    [CURSOR_STACK]: Stack$0<RehydratingCursor>; // Hides property on base class
    blockDepth: number;
    startingBlockOffset: number;
    constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>);
    get currentCursor(): Nullable<RehydratingCursor>;
    get candidate(): Nullable<SimpleNode>;
    set candidate(node: Nullable<SimpleNode>);
    disableRehydration(nextSibling: Nullable<SimpleNode>): void;
    enableRehydration(candidate: Nullable<SimpleNode>): void;
    pushElement(/** called from parent constructor before we initialize this */
    this: RehydrateBuilder | (NewElementBuilder & Partial<Pick<RehydrateBuilder, "blockDepth" | "candidate">>), element: SimpleElement, nextSibling?: Maybe<SimpleNode>): void;
    // clears until the end of the current container
    // either the current open block or higher
    private clearMismatch;
    __openBlock(): void;
    __closeBlock(): void;
    __appendNode(node: SimpleNode): SimpleNode;
    __appendHTML(html: string): Bounds;
    protected remove(node: SimpleNode): Nullable<SimpleNode>;
    private markerBounds;
    __appendText(string: string): SimpleText;
    __appendComment(string: string): SimpleComment;
    __openElement(tag: string): SimpleElement;
    __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void;
    __setProperty(name: string, value: string): void;
    __flushElement(parent: SimpleElement, constructing: SimpleElement): void;
    willCloseElement(): void;
    getMarker(element: HTMLElement, guid: string): Nullable<SimpleNode>;
    __pushRemoteElement(element: SimpleElement, cursorId: string, insertBefore: Maybe<SimpleNode>): Nullable<RemoteLiveBlock>;
    didAppendBounds(bounds: Bounds): Bounds;
}
declare function rehydrationBuilder(env: Environment, cursor: CursorImpl): ElementBuilder;
type IteratorResult<T> = RichIteratorResult<null, T>;
export { clear, ConcreteBounds, CursorImpl, DebugCallback, resetDebuggerCallback, setDebuggerCallback, TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition as TemplateOnlyComponent, templateOnlyComponent, TemplateOnlyComponentManager, CurriedValue, curry, DOMChanges, DOMTreeConstruction, DOMChangesImpl as IDOMChanges, isWhitespace, normalizeProperty, EnvironmentDelegate, EnvironmentImpl, inTransaction, runtimeContext, array, concat, fn, get, hash, invokeHelper, on, renderComponent, renderMain, renderSync, DynamicScopeImpl, PartialScopeImpl, InternalVM, VM as LowLevelVM, UpdatingVM, createCapturedArgs, EMPTY_ARGS, EMPTY_NAMED, EMPTY_POSITIONAL, reifyArgs, reifyNamed, reifyPositional, DynamicAttribute, dynamicAttribute, SimpleDynamicAttribute, clientBuilder, NewElementBuilder, RemoteLiveBlock, UpdatableBlockImpl, isSerializationFirstNode, RehydrateBuilder, rehydrationBuilder, SERIALIZATION_FIRST_NODE_STRING, IteratorResult };
export type { SafeString };
export { destroy, isDestroyed, isDestroying, registerDestructor } from "@glimmer/destroyable";
//# sourceMappingURL=index.d.cts.map