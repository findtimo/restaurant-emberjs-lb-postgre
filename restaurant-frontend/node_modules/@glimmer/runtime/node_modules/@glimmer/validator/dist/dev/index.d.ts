import { Tag, ConstantTag, UpdatableTag, DirtyableTag, MonomorphicTagId, TagComputeSymbol, TagTypeSymbol } from "@glimmer/interfaces";
interface DebugTransaction {
    beginTrackingTransaction?: undefined | ((debuggingContext?: string | false, deprecate?: boolean) => void);
    endTrackingTransaction?: undefined | (() => void);
    runInTrackingTransaction?: undefined | (<T>(fn: () => T, debuggingContext?: string | false) => T);
    resetTrackingTransaction?: undefined | (() => string);
    setTrackingTransactionEnv?: undefined | ((env: {
        debugMessage?(obj?: unknown, keyName?: string): string;
    }) => void);
    assertTagNotConsumed?: undefined | (<T>(tag: Tag, obj?: T, keyName?: keyof T | string | symbol) => void);
    markTagAsConsumed?: undefined | ((_tag: Tag) => void);
    logTrackingStack?: undefined | ((transaction?: Transaction) => string);
}
declare const debug: DebugTransaction;
interface Transaction {
    parent: Transaction | null;
    debugLabel?: string | undefined;
}
///////////
type TagMeta = Map<PropertyKey, UpdatableTag>;
declare function dirtyTagFor<T extends object>(obj: T, key: keyof T | string | symbol, meta?: TagMeta): void;
declare function tagMetaFor(obj: object): TagMeta;
declare function tagFor<T extends object>(obj: T, key: keyof T | string | symbol, meta?: TagMeta): UpdatableTag | ConstantTag;
type Getter<T, K extends keyof T> = (self: T) => T[K] | undefined;
type Setter<T, K extends keyof T> = (self: T, value: T[K]) => void;
declare function trackedData<T extends object, K extends keyof T>(key: K, initializer?: (this: T) => T[K]): {
    getter: Getter<T, K>;
    setter: Setter<T, K>;
};
declare function beginTrackFrame(debuggingContext?: string | false): void;
declare function endTrackFrame(): Tag;
declare function beginUntrackFrame(): void;
declare function endUntrackFrame(): void;
// This function is only for handling errors and resetting to a valid state
declare function resetTracking(): string | void;
declare function isTracking(): boolean;
declare function consumeTag(tag: Tag): void;
//////////
declare const CACHE_KEY: unique symbol;
// public interface
interface Cache<T = unknown> {
    [CACHE_KEY]: T;
}
declare function createCache<T>(fn: () => T, debuggingLabel?: string | false): Cache<T>;
declare function getValue<T>(cache: Cache<T>): T | undefined;
declare function isConst(cache: Cache): boolean;
//////////
// Legacy tracking APIs
// track() shouldn't be necessary at all in the VM once the autotracking
// refactors are merged, and we should generally be moving away from it. It may
// be necessary in Ember for a while longer, but I think we'll be able to drop
// it in favor of cache sooner rather than later.
declare function track(block: () => void, debugLabel?: string | false): Tag;
// untrack() is currently mainly used to handle places that were previously not
// tracked, and that tracking now would cause backtracking rerender assertions.
// I think once we move everyone forward onto modern APIs, we'll probably be
// able to remove it, but I'm not sure yet.
declare function untrack<T>(callback: () => T): T;
//////////
type Revision = number;
declare const CONSTANT: Revision;
declare const INITIAL: Revision;
declare const VOLATILE: Revision;
declare function bump(): void;
//////////
declare const COMPUTE: TagComputeSymbol;
//////////
/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */
declare function valueForTag(tag: Tag): Revision;
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */
declare function validateTag(tag: Tag, snapshot: Revision): boolean;
//////////
declare const TYPE: TagTypeSymbol;
// this is basically a const
declare let ALLOW_CYCLES: WeakMap<Tag, boolean> | undefined;
declare class MonomorphicTagImpl<T extends MonomorphicTagId = MonomorphicTagId> {
    static combine(this: void, tags: Tag[]): Tag;
    private revision;
    private lastChecked;
    private lastValue;
    private isUpdating;
    subtag: Tag | Tag[] | null;
    private subtagBufferCache;
    [TYPE]: T;
    constructor(type: T);
    [COMPUTE](): Revision;
    static updateTag(this: void, _tag: UpdatableTag, _subtag: Tag): void;
    static dirtyTag(this: void, tag: DirtyableTag | UpdatableTag, disableConsumptionAssertion?: boolean): void;
}
declare const DIRTY_TAG: typeof MonomorphicTagImpl.dirtyTag;
declare const UPDATE_TAG: typeof MonomorphicTagImpl.updateTag;
//////////
declare function createTag(): DirtyableTag;
declare function createUpdatableTag(): UpdatableTag;
//////////
declare const CONSTANT_TAG: ConstantTag;
declare function isConstTag(tag: Tag): tag is ConstantTag;
declare class VolatileTag implements Tag {
    readonly [TYPE]: 100;
    [COMPUTE](): Revision;
}
declare const VOLATILE_TAG: VolatileTag;
declare class CurrentTag implements Tag {
    readonly [TYPE]: 101;
    [COMPUTE](): Revision;
}
declare const CURRENT_TAG: CurrentTag;
//////////
declare const combine: typeof MonomorphicTagImpl.combine;
export { debug, dirtyTagFor, tagFor, TagMeta, tagMetaFor, trackedData, beginTrackFrame, beginUntrackFrame, Cache, consumeTag, createCache, endTrackFrame, endUntrackFrame, getValue, isConst, isTracking, resetTracking, track, untrack, ALLOW_CYCLES, bump, combine, COMPUTE, CONSTANT, CONSTANT_TAG, createTag, createUpdatableTag, CURRENT_TAG, CurrentTag, DIRTY_TAG as dirtyTag, INITIAL, isConstTag, Revision, UPDATE_TAG as updateTag, validateTag, valueForTag, VOLATILE, VOLATILE_TAG, VolatileTag };
export type { CombinatorTag, ConstantTag, DirtyableTag, Tag, UpdatableTag } from '@glimmer/interfaces';
//# sourceMappingURL=index.d.ts.map