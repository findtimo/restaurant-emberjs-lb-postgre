'use strict';

var util = require('@glimmer/util');
var wireFormat = require('@glimmer/wire-format');
var syntax = require('@glimmer/syntax');
var vm = require('@glimmer/vm');

let HeadKind = /*#__PURE__*/function (HeadKind) {
  HeadKind["Block"] = "Block";
  HeadKind["Call"] = "Call";
  HeadKind["Element"] = "Element";
  HeadKind["AppendPath"] = "AppendPath";
  HeadKind["AppendExpr"] = "AppendExpr";
  HeadKind["Literal"] = "Literal";
  HeadKind["Modifier"] = "Modifier";
  HeadKind["DynamicComponent"] = "DynamicComponent";
  HeadKind["Comment"] = "Comment";
  HeadKind["Splat"] = "Splat";
  HeadKind["Keyword"] = "Keyword";
  return HeadKind;
}({});
let VariableKind = /*#__PURE__*/function (VariableKind) {
  VariableKind["Local"] = "Local";
  VariableKind["Free"] = "Free";
  VariableKind["Arg"] = "Arg";
  VariableKind["Block"] = "Block";
  VariableKind["This"] = "This";
  return VariableKind;
}({});
function normalizeStatement(statement) {
  if (Array.isArray(statement)) {
    if (statementIsExpression(statement)) {
      return normalizeAppendExpression(statement);
    } else if (isSugaryArrayStatement(statement)) {
      return normalizeSugaryArrayStatement(statement);
    } else {
      return normalizeVerboseStatement(statement);
    }
  } else if (typeof statement === 'string') {
    return normalizeAppendHead(normalizeDottedPath(statement), false);
  } else {
    throw util.assertNever(statement);
  }
}
function normalizeAppendHead(head, trusted) {
  if (head.type === ExpressionKind.GetPath) {
    return {
      kind: HeadKind.AppendPath,
      path: head,
      trusted
    };
  } else {
    return {
      kind: HeadKind.AppendExpr,
      expr: head,
      trusted
    };
  }
}
function isSugaryArrayStatement(statement) {
  if (Array.isArray(statement) && typeof statement[0] === 'string') {
    switch (statement[0][0]) {
      case '(':
      case '#':
      case '<':
      case '!':
        return true;
      default:
        return false;
    }
  }
  return false;
}
function normalizeSugaryArrayStatement(statement) {
  const name = statement[0];
  switch (name[0]) {
    case '(':
      {
        let params = null;
        let hash = null;
        if (statement.length === 3) {
          params = normalizeParams(statement[1]);
          hash = normalizeHash(statement[2]);
        } else if (statement.length === 2) {
          if (Array.isArray(statement[1])) {
            params = normalizeParams(statement[1]);
          } else {
            hash = normalizeHash(statement[1]);
          }
        }
        return {
          kind: HeadKind.Call,
          head: normalizeCallHead(name),
          params,
          hash,
          trusted: false
        };
      }
    case '#':
      {
        const {
          head: path,
          params,
          hash,
          blocks,
          blockParams
        } = normalizeBuilderBlockStatement(statement);
        return {
          kind: HeadKind.Block,
          head: path,
          params,
          hash,
          blocks,
          blockParams
        };
      }
    case '!':
      {
        const name = statement[0].slice(1);
        const {
          params,
          hash,
          blocks,
          blockParams
        } = normalizeBuilderBlockStatement(statement);
        return {
          kind: HeadKind.Keyword,
          name,
          params,
          hash,
          blocks,
          blockParams
        };
      }
    case '<':
      {
        let attrs = util.dict();
        let block = [];
        if (statement.length === 3) {
          attrs = normalizeAttrs(statement[1]);
          block = normalizeBlock(statement[2]);
        } else if (statement.length === 2) {
          if (Array.isArray(statement[1])) {
            block = normalizeBlock(statement[1]);
          } else {
            attrs = normalizeAttrs(statement[1]);
          }
        }
        return {
          kind: HeadKind.Element,
          name: util.expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),
          attrs,
          block
        };
      }
    default:
      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);
  }
}
function normalizeVerboseStatement(statement) {
  switch (statement[0]) {
    case Builder.Literal:
      {
        return {
          kind: HeadKind.Literal,
          value: statement[1]
        };
      }
    case Builder.Append:
      {
        return normalizeAppendExpression(statement[1], statement[2]);
      }
    case Builder.Modifier:
      {
        return {
          kind: HeadKind.Modifier,
          params: normalizeParams(statement[1]),
          hash: normalizeHash(statement[2])
        };
      }
    case Builder.DynamicComponent:
      {
        return {
          kind: HeadKind.DynamicComponent,
          expr: normalizeExpression(statement[1]),
          hash: normalizeHash(statement[2]),
          block: normalizeBlock(statement[3])
        };
      }
    case Builder.Comment:
      {
        return {
          kind: HeadKind.Comment,
          value: statement[1]
        };
      }
  }
}
function extractBlockHead(name) {
  const result = /^(#|!)(.*)$/u.exec(name);
  if (result === null) {
    throw new Error(`Unexpected missing # in block head`);
  }
  return normalizeDottedPath(result[2]);
}
function normalizeCallHead(name) {
  const result = /^\((.*)\)$/u.exec(name);
  if (result === null) {
    throw new Error(`Unexpected missing () in call head`);
  }
  return normalizeDottedPath(result[1]);
}
function normalizePath(head, tail = []) {
  const pathHead = normalizePathHead(head);
  if (util.isPresentArray(tail)) {
    return {
      type: ExpressionKind.GetPath,
      path: {
        head: pathHead,
        tail
      }
    };
  } else {
    return {
      type: ExpressionKind.GetVar,
      variable: pathHead
    };
  }
}
function normalizeDottedPath(whole) {
  const {
    kind,
    name: rest
  } = normalizePathHead(whole);
  const [name, ...tail] = rest.split('.');
  const variable = {
    kind,
    name,
    mode: 'loose'
  };
  if (util.isPresentArray(tail)) {
    return {
      type: ExpressionKind.GetPath,
      path: {
        head: variable,
        tail
      }
    };
  } else {
    return {
      type: ExpressionKind.GetVar,
      variable
    };
  }
}
function normalizePathHead(whole) {
  let kind;
  let name;
  if (/^this(?:\.|$)/u.test(whole)) {
    return {
      kind: VariableKind.This,
      name: whole,
      mode: 'loose'
    };
  }
  switch (whole[0]) {
    case '^':
      kind = VariableKind.Free;
      name = whole.slice(1);
      break;
    case '@':
      kind = VariableKind.Arg;
      name = whole.slice(1);
      break;
    case '&':
      kind = VariableKind.Block;
      name = whole.slice(1);
      break;
    default:
      kind = VariableKind.Local;
      name = whole;
  }
  return {
    kind,
    name,
    mode: 'loose'
  };
}
function normalizeBuilderBlockStatement(statement) {
  const head = statement[0];
  let blocks = util.dict();
  let params = null;
  let hash = null;
  let blockParams = null;
  if (statement.length === 2) {
    blocks = normalizeBlocks(statement[1]);
  } else if (statement.length === 3) {
    if (Array.isArray(statement[1])) {
      params = normalizeParams(statement[1]);
    } else {
      ({
        hash,
        blockParams
      } = normalizeBlockHash(statement[1]));
    }
    blocks = normalizeBlocks(statement[2]);
  } else if (statement.length === 4) {
    params = normalizeParams(statement[1]);
    ({
      hash,
      blockParams
    } = normalizeBlockHash(statement[2]));
    blocks = normalizeBlocks(statement[3]);
  }
  return {
    head: extractBlockHead(head),
    params,
    hash,
    blockParams,
    blocks
  };
}
function normalizeBlockHash(hash) {
  if (hash === null) {
    return {
      hash: null,
      blockParams: null
    };
  }
  let out = null;
  let blockParams = null;
  entries(hash, (key, value) => {
    if (key === 'as') {
      blockParams = Array.isArray(value) ? value : [value];
    } else {
      out = out || util.dict();
      out[key] = normalizeExpression(value);
    }
  });
  return {
    hash: out,
    blockParams
  };
}
function entries(dict, callback) {
  Object.keys(dict).forEach(key => {
    const value = dict[key];
    callback(key, value);
  });
}
function normalizeBlocks(value) {
  if (Array.isArray(value)) {
    return {
      default: normalizeBlock(value)
    };
  } else {
    return mapObject(value, normalizeBlock);
  }
}
function normalizeBlock(block) {
  return block.map(s => normalizeStatement(s));
}
function normalizeAttrs(attrs) {
  return mapObject(attrs, a => normalizeAttr(a).expr);
}
function normalizeAttr(attr) {
  if (attr === 'splat') {
    return {
      expr: HeadKind.Splat,
      trusted: false
    };
  } else {
    const expr = normalizeExpression(attr);
    return {
      expr,
      trusted: false
    };
  }
}
function mapObject(object, mapper) {
  const out = util.dict();
  Object.keys(object).forEach(k => {
    out[k] = mapper(object[k], k);
  });
  return out;
}
function extractElement(input) {
  const match = /^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(input);
  return match?.[1] ?? null;
}
let Builder = /*#__PURE__*/function (Builder) {
  Builder[Builder["Literal"] = 0] = "Literal";
  Builder[Builder["Comment"] = 1] = "Comment";
  Builder[Builder["Append"] = 2] = "Append";
  Builder[Builder["Modifier"] = 3] = "Modifier";
  Builder[Builder["DynamicComponent"] = 4] = "DynamicComponent";
  Builder[Builder["Get"] = 5] = "Get";
  Builder[Builder["Concat"] = 6] = "Concat";
  Builder[Builder["HasBlock"] = 7] = "HasBlock";
  Builder[Builder["HasBlockParams"] = 8] = "HasBlockParams";
  return Builder;
}({});
let ExpressionKind = /*#__PURE__*/function (ExpressionKind) {
  ExpressionKind["Literal"] = "Literal";
  ExpressionKind["Call"] = "Call";
  ExpressionKind["GetPath"] = "GetPath";
  ExpressionKind["GetVar"] = "GetVar";
  ExpressionKind["Concat"] = "Concat";
  ExpressionKind["HasBlock"] = "HasBlock";
  ExpressionKind["HasBlockParams"] = "HasBlockParams";
  return ExpressionKind;
}({});
function normalizeAppendExpression(expression, forceTrusted = false) {
  if (expression === null || expression === undefined) {
    return {
      expr: {
        type: ExpressionKind.Literal,
        value: expression
      },
      kind: HeadKind.AppendExpr,
      trusted: false
    };
  } else if (Array.isArray(expression)) {
    switch (expression[0]) {
      case Builder.Literal:
        return {
          expr: {
            type: ExpressionKind.Literal,
            value: expression[1]
          },
          kind: HeadKind.AppendExpr,
          trusted: false
        };
      case Builder.Get:
        {
          return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);
        }
      case Builder.Concat:
        {
          const expr = {
            type: ExpressionKind.Concat,
            params: normalizeParams(expression.slice(1))
          };
          return {
            expr,
            kind: HeadKind.AppendExpr,
            trusted: forceTrusted
          };
        }
      case Builder.HasBlock:
        return {
          expr: {
            type: ExpressionKind.HasBlock,
            name: expression[1]
          },
          kind: HeadKind.AppendExpr,
          trusted: forceTrusted
        };
      case Builder.HasBlockParams:
        return {
          expr: {
            type: ExpressionKind.HasBlockParams,
            name: expression[1]
          },
          kind: HeadKind.AppendExpr,
          trusted: forceTrusted
        };
      default:
        {
          if (isBuilderCallExpression(expression)) {
            return {
              expr: normalizeCallExpression(expression),
              kind: HeadKind.AppendExpr,
              trusted: forceTrusted
            };
          } else {
            throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${expression[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`);
          }
        }
      // BuilderCallExpression
    }
  } else if (typeof expression !== 'object') {
    switch (typeof expression) {
      case 'string':
        {
          return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);
        }
      case 'boolean':
      case 'number':
        return {
          expr: {
            type: ExpressionKind.Literal,
            value: expression
          },
          kind: HeadKind.AppendExpr,
          trusted: true
        };
      default:
        throw util.assertNever(expression);
    }
  } else {
    throw util.assertNever(expression);
  }
}
function normalizeExpression(expression) {
  if (expression === null || expression === undefined) {
    return {
      type: ExpressionKind.Literal,
      value: expression
    };
  } else if (Array.isArray(expression)) {
    switch (expression[0]) {
      case Builder.Literal:
        return {
          type: ExpressionKind.Literal,
          value: expression[1]
        };
      case Builder.Get:
        {
          return normalizePath(expression[1], expression[2]);
        }
      case Builder.Concat:
        {
          const expr = {
            type: ExpressionKind.Concat,
            params: normalizeParams(expression.slice(1))
          };
          return expr;
        }
      case Builder.HasBlock:
        return {
          type: ExpressionKind.HasBlock,
          name: expression[1]
        };
      case Builder.HasBlockParams:
        return {
          type: ExpressionKind.HasBlockParams,
          name: expression[1]
        };
      default:
        {
          if (isBuilderCallExpression(expression)) {
            return normalizeCallExpression(expression);
          } else {
            throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${expression[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`);
          }
        }
      // BuilderCallExpression
    }
  } else if (typeof expression !== 'object') {
    switch (typeof expression) {
      case 'string':
        {
          return normalizeDottedPath(expression);
        }
      case 'boolean':
      case 'number':
        return {
          type: ExpressionKind.Literal,
          value: expression
        };
      default:
        throw util.assertNever(expression);
    }
  } else {
    throw util.assertNever(expression);
  }
}
function statementIsExpression(statement) {
  if (!Array.isArray(statement)) {
    return false;
  }
  const name = statement[0];
  if (typeof name === 'number') {
    switch (name) {
      case Builder.Literal:
      case Builder.Get:
      case Builder.Concat:
      case Builder.HasBlock:
      case Builder.HasBlockParams:
        return true;
      default:
        return false;
    }
  }
  if (name[0] === '(') {
    return true;
  }
  return false;
}
function isBuilderCallExpression(value) {
  return typeof value[0] === 'string' && value[0][0] === '(';
}
function normalizeParams(input) {
  return input.map(normalizeExpression);
}
function normalizeHash(input) {
  if (input === null) return null;
  return mapObject(input, normalizeExpression);
}
function normalizeCallExpression(expr) {
  switch (expr.length) {
    case 1:
      return {
        type: ExpressionKind.Call,
        head: normalizeCallHead(expr[0]),
        params: null,
        hash: null
      };
    case 2:
      {
        if (Array.isArray(expr[1])) {
          return {
            type: ExpressionKind.Call,
            head: normalizeCallHead(expr[0]),
            params: normalizeParams(expr[1]),
            hash: null
          };
        } else {
          return {
            type: ExpressionKind.Call,
            head: normalizeCallHead(expr[0]),
            params: null,
            hash: normalizeHash(expr[1])
          };
        }
      }
    case 3:
      return {
        type: ExpressionKind.Call,
        head: normalizeCallHead(expr[0]),
        params: normalizeParams(expr[1]),
        hash: normalizeHash(expr[2])
      };
  }
}

class ProgramSymbols {
  _freeVariables = [];
  _symbols = ['this'];
  top = this;
  toSymbols() {
    return this._symbols.slice(1);
  }
  toUpvars() {
    return this._freeVariables;
  }
  freeVar(name) {
    return addString(this._freeVariables, name);
  }
  block(name) {
    return this.symbol(name);
  }
  arg(name) {
    return addString(this._symbols, name);
  }
  local(name) {
    throw new Error(`No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`);
  }
  this() {
    return 0;
  }
  hasLocal(_name) {
    return false;
  }

  // any symbol
  symbol(name) {
    return addString(this._symbols, name);
  }
  child(locals) {
    return new LocalSymbols(this, locals);
  }
}
class LocalSymbols {
  locals = util.dict();
  constructor(parent, locals) {
    this.parent = parent;
    for (let local of locals) {
      this.locals[local] = parent.top.symbol(local);
    }
  }
  get paramSymbols() {
    return util.values(this.locals);
  }
  get top() {
    return this.parent.top;
  }
  freeVar(name) {
    return this.parent.freeVar(name);
  }
  arg(name) {
    return this.parent.arg(name);
  }
  block(name) {
    return this.parent.block(name);
  }
  local(name) {
    if (name in this.locals) {
      return this.locals[name];
    } else {
      return this.parent.local(name);
    }
  }
  this() {
    return this.parent.this();
  }
  hasLocal(name) {
    if (name in this.locals) {
      return true;
    } else {
      return this.parent.hasLocal(name);
    }
  }
  child(locals) {
    return new LocalSymbols(this, locals);
  }
}
function addString(array, item) {
  let index = array.indexOf(item);
  if (index === -1) {
    index = array.length;
    array.push(item);
    return index;
  } else {
    return index;
  }
}
function unimpl(message) {
  return new Error(`unimplemented ${message}`);
}
function buildStatements(statements, symbols) {
  let out = [];
  statements.forEach(s => out.push(...buildStatement(normalizeStatement(s), symbols)));
  return out;
}
function buildNormalizedStatements(statements, symbols) {
  let out = [];
  statements.forEach(s => out.push(...buildStatement(s, symbols)));
  return out;
}
function buildStatement(normalized, symbols = new ProgramSymbols()) {
  switch (normalized.kind) {
    case HeadKind.AppendPath:
      {
        return [[normalized.trusted ? wireFormat.SexpOpcodes.TrustingAppend : wireFormat.SexpOpcodes.Append, buildGetPath(normalized.path, symbols)]];
      }
    case HeadKind.AppendExpr:
      {
        return [[normalized.trusted ? wireFormat.SexpOpcodes.TrustingAppend : wireFormat.SexpOpcodes.Append, buildExpression(normalized.expr, normalized.trusted ? 'TrustedAppend' : 'Append', symbols)]];
      }
    case HeadKind.Call:
      {
        let {
          head: path,
          params,
          hash,
          trusted
        } = normalized;
        let builtParams = params ? buildParams(params, symbols) : null;
        let builtHash = hash ? buildHash(hash, symbols) : null;
        let builtExpr = buildCallHead(path, trusted ? wireFormat.VariableResolutionContext.AmbiguousInvoke : wireFormat.VariableResolutionContext.AmbiguousAppendInvoke, symbols);
        return [[trusted ? wireFormat.SexpOpcodes.TrustingAppend : wireFormat.SexpOpcodes.Append, [wireFormat.SexpOpcodes.Call, builtExpr, builtParams, builtHash]]];
      }
    case HeadKind.Literal:
      {
        return [[wireFormat.SexpOpcodes.Append, normalized.value]];
      }
    case HeadKind.Comment:
      {
        return [[wireFormat.SexpOpcodes.Comment, normalized.value]];
      }
    case HeadKind.Block:
      {
        let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);
        let hash = buildHash(normalized.hash, symbols);
        let params = buildParams(normalized.params, symbols);
        let path = buildCallHead(normalized.head, wireFormat.VariableResolutionContext.ResolveAsComponentHead, symbols);
        return [[wireFormat.SexpOpcodes.Block, path, params, hash, blocks]];
      }
    case HeadKind.Keyword:
      {
        return [buildKeyword(normalized, symbols)];
      }
    case HeadKind.Element:
      return buildElement(normalized, symbols);
    case HeadKind.Modifier:
      throw unimpl('modifier');
    case HeadKind.DynamicComponent:
      throw unimpl('dynamic component');
    default:
      throw util.assertNever(normalized);
  }
}
function s(arr, ...interpolated) {
  let result = arr.reduce((result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`, '');
  return [Builder.Literal, result];
}
function c(arr, ...interpolated) {
  let result = arr.reduce((result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`, '');
  return [Builder.Comment, result];
}
function unicode(charCode) {
  return String.fromCharCode(parseInt(charCode, 16));
}
const NEWLINE = '\n';
function buildKeyword(normalized, symbols) {
  let {
    name
  } = normalized;
  let params = buildParams(normalized.params, symbols);
  let childSymbols = symbols.child(normalized.blockParams || []);
  let block = buildBlock(normalized.blocks['default'], childSymbols, childSymbols.paramSymbols);
  let inverse = normalized.blocks['else'] ? buildBlock(normalized.blocks['else'], symbols, []) : null;
  switch (name) {
    case 'with':
      return [wireFormat.SexpOpcodes.With, util.expect(params, 'with requires params')[0], block, inverse];
    case 'if':
      return [wireFormat.SexpOpcodes.If, util.expect(params, 'if requires params')[0], block, inverse];
    case 'each':
      {
        let keyExpr = normalized.hash ? normalized.hash['key'] : null;
        let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;
        return [wireFormat.SexpOpcodes.Each, util.expect(params, 'if requires params')[0], key, block, inverse];
      }
    default:
      throw new Error('unimplemented keyword');
  }
}
function buildElement({
  name,
  attrs,
  block
}, symbols) {
  let out = [hasSplat(attrs) ? [wireFormat.SexpOpcodes.OpenElementWithSplat, name] : [wireFormat.SexpOpcodes.OpenElement, name]];
  if (attrs) {
    let {
      params,
      args
    } = buildElementParams(attrs, symbols);
    out.push(...params);
    util.assert(args === null, `Can't pass args to a simple element`);
  }
  out.push([wireFormat.SexpOpcodes.FlushElement]);
  if (Array.isArray(block)) {
    block.forEach(s => out.push(...buildStatement(s, symbols)));
  } else if (block === null) ; else {
    throw util.assertNever(block);
  }
  out.push([wireFormat.SexpOpcodes.CloseElement]);
  return out;
}
function hasSplat(attrs) {
  if (attrs === null) return false;
  return Object.keys(attrs).some(a => attrs[a] === HeadKind.Splat);
}
function buildElementParams(attrs, symbols) {
  let params = [];
  let keys = [];
  let values = [];
  for (const [key, value] of Object.entries(attrs)) {
    if (value === HeadKind.Splat) {
      params.push([wireFormat.SexpOpcodes.AttrSplat, symbols.block('&attrs')]);
    } else if (key[0] === '@') {
      keys.push(key);
      values.push(buildExpression(value, 'Strict', symbols));
    } else {
      params.push(...buildAttributeValue(key, value,
      // TODO: extract namespace from key
      extractNamespace(key), symbols));
    }
  }
  return {
    params,
    args: util.isPresentArray(keys) && util.isPresentArray(values) ? [keys, values] : null
  };
}
function extractNamespace(name) {
  if (name === 'xmlns') {
    return util.NS_XMLNS;
  }
  let match = /^([^:]*):([^:]*)$/u.exec(name);
  if (match === null) {
    return null;
  }
  let namespace = match[1];
  switch (namespace) {
    case 'xlink':
      return util.NS_XLINK;
    case 'xml':
      return util.NS_XML;
    case 'xmlns':
      return util.NS_XMLNS;
  }
  return null;
}
function buildAttributeValue(name, value, namespace, symbols) {
  switch (value.type) {
    case ExpressionKind.Literal:
      {
        let val = value.value;
        if (val === false) {
          return [];
        } else if (val === true) {
          return [[wireFormat.SexpOpcodes.StaticAttr, name, '', namespace ?? undefined]];
        } else if (typeof val === 'string') {
          return [[wireFormat.SexpOpcodes.StaticAttr, name, val, namespace ?? undefined]];
        } else {
          throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);
        }
      }
    default:
      return [[wireFormat.SexpOpcodes.DynamicAttr, name, buildExpression(value, 'AttrValue', symbols), namespace ?? undefined]];
  }
}
function varContext(context, bare) {
  switch (context) {
    case 'Append':
      return bare ? 'AppendBare' : 'AppendInvoke';
    case 'TrustedAppend':
      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';
    case 'AttrValue':
      return bare ? 'AttrValueBare' : 'AttrValueInvoke';
    default:
      return context;
  }
}
function buildExpression(expr, context, symbols) {
  switch (expr.type) {
    case ExpressionKind.GetPath:
      {
        return buildGetPath(expr, symbols);
      }
    case ExpressionKind.GetVar:
      {
        return buildVar(expr.variable, varContext(context, true), symbols);
      }
    case ExpressionKind.Concat:
      {
        return [wireFormat.SexpOpcodes.Concat, buildConcat(expr.params, symbols)];
      }
    case ExpressionKind.Call:
      {
        let builtParams = buildParams(expr.params, symbols);
        let builtHash = buildHash(expr.hash, symbols);
        let builtExpr = buildCallHead(expr.head, context === 'Strict' ? 'SubExpression' : varContext(context, false), symbols);
        return [wireFormat.SexpOpcodes.Call, builtExpr, builtParams, builtHash];
      }
    case ExpressionKind.HasBlock:
      {
        return [wireFormat.SexpOpcodes.HasBlock, buildVar({
          kind: VariableKind.Block,
          name: expr.name,
          mode: 'loose'
        }, wireFormat.VariableResolutionContext.Strict, symbols)];
      }
    case ExpressionKind.HasBlockParams:
      {
        return [wireFormat.SexpOpcodes.HasBlockParams, buildVar({
          kind: VariableKind.Block,
          name: expr.name,
          mode: 'loose'
        }, wireFormat.VariableResolutionContext.Strict, symbols)];
      }
    case ExpressionKind.Literal:
      {
        if (expr.value === undefined) {
          return [wireFormat.SexpOpcodes.Undefined];
        } else {
          return expr.value;
        }
      }
    default:
      util.assertNever(expr);
  }
}
function buildCallHead(callHead, context, symbols) {
  if (callHead.type === ExpressionKind.GetVar) {
    return buildVar(callHead.variable, context, symbols);
  } else {
    return buildGetPath(callHead, symbols);
  }
}
function buildGetPath(head, symbols) {
  return buildVar(head.path.head, wireFormat.VariableResolutionContext.Strict, symbols, head.path.tail);
}
function buildVar(head, context, symbols, path) {
  let op = wireFormat.SexpOpcodes.GetSymbol;
  let sym;
  switch (head.kind) {
    case VariableKind.Free:
      if (context === 'Strict') {
        op = wireFormat.SexpOpcodes.GetStrictKeyword;
      } else if (context === 'AppendBare') {
        op = wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback;
      } else if (context === 'AppendInvoke') {
        op = wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHead;
      } else if (context === 'TrustedAppendBare') {
        op = wireFormat.SexpOpcodes.GetFreeAsHelperHeadOrThisFallback;
      } else if (context === 'TrustedAppendInvoke') {
        op = wireFormat.SexpOpcodes.GetFreeAsHelperHead;
      } else if (context === 'AttrValueBare') {
        op = wireFormat.SexpOpcodes.GetFreeAsHelperHeadOrThisFallback;
      } else if (context === 'AttrValueInvoke') {
        op = wireFormat.SexpOpcodes.GetFreeAsHelperHead;
      } else if (context === 'SubExpression') {
        op = wireFormat.SexpOpcodes.GetFreeAsHelperHead;
      } else {
        op = expressionContextOp(context);
      }
      sym = symbols.freeVar(head.name);
      break;
    default:
      op = wireFormat.SexpOpcodes.GetSymbol;
      sym = getSymbolForVar(head.kind, symbols, head.name);
  }
  if (path === undefined || path.length === 0) {
    return [op, sym];
  } else {
    return [op, sym, path];
  }
}
function getSymbolForVar(kind, symbols, name) {
  switch (kind) {
    case VariableKind.Arg:
      return symbols.arg(name);
    case VariableKind.Block:
      return symbols.block(name);
    case VariableKind.Local:
      return symbols.local(name);
    case VariableKind.This:
      return symbols.this();
    default:
      return util.exhausted(kind);
  }
}
function expressionContextOp(context) {
  switch (context) {
    case wireFormat.VariableResolutionContext.Strict:
      return wireFormat.SexpOpcodes.GetStrictKeyword;
    case wireFormat.VariableResolutionContext.AmbiguousAppend:
      return wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback;
    case wireFormat.VariableResolutionContext.AmbiguousAppendInvoke:
      return wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHead;
    case wireFormat.VariableResolutionContext.AmbiguousInvoke:
      return wireFormat.SexpOpcodes.GetFreeAsHelperHeadOrThisFallback;
    case wireFormat.VariableResolutionContext.ResolveAsCallHead:
      return wireFormat.SexpOpcodes.GetFreeAsHelperHead;
    case wireFormat.VariableResolutionContext.ResolveAsModifierHead:
      return wireFormat.SexpOpcodes.GetFreeAsModifierHead;
    case wireFormat.VariableResolutionContext.ResolveAsComponentHead:
      return wireFormat.SexpOpcodes.GetFreeAsComponentHead;
    default:
      return util.exhausted(context);
  }
}
function buildParams(exprs, symbols) {
  if (exprs === null || !util.isPresentArray(exprs)) return null;
  return exprs.map(e => buildExpression(e, 'Strict', symbols));
}
function buildConcat(exprs, symbols) {
  return exprs.map(e => buildExpression(e, 'AttrValue', symbols));
}
function buildHash(exprs, symbols) {
  if (exprs === null) return null;
  let out = [[], []];
  for (const [key, value] of Object.entries(exprs)) {
    out[0].push(key);
    out[1].push(buildExpression(value, 'Strict', symbols));
  }
  return out;
}
function buildBlocks(blocks, blockParams, parent) {
  let keys = [];
  let values = [];
  for (const [name, block] of Object.entries(blocks)) {
    keys.push(name);
    if (name === 'default') {
      let symbols = parent.child(blockParams || []);
      values.push(buildBlock(block, symbols, symbols.paramSymbols));
    } else {
      values.push(buildBlock(block, parent, []));
    }
  }
  return [keys, values];
}
function buildBlock(block, symbols, locals = []) {
  return [buildNormalizedStatements(block, symbols), locals];
}

class Template extends syntax.node('Template').fields() {}
class InElement extends syntax.node('InElement').fields() {}
class Not extends syntax.node('Not').fields() {}
class If extends syntax.node('If').fields() {}
class IfInline extends syntax.node('IfInline').fields() {}
class Each extends syntax.node('Each').fields() {}
class With extends syntax.node('With').fields() {}
class Let extends syntax.node('Let').fields() {}
class WithDynamicVars extends syntax.node('WithDynamicVars').fields() {}
class GetDynamicVar extends syntax.node('GetDynamicVar').fields() {}
class Log extends syntax.node('Log').fields() {}
class InvokeComponent extends syntax.node('InvokeComponent').fields() {}
class NamedBlocks extends syntax.node('NamedBlocks').fields() {}
class NamedBlock extends syntax.node('NamedBlock').fields() {}
class EndBlock extends syntax.node('EndBlock').fields() {}
class AppendTrustedHTML extends syntax.node('AppendTrustedHTML').fields() {}
class AppendTextNode extends syntax.node('AppendTextNode').fields() {}
class AppendComment extends syntax.node('AppendComment').fields() {}
class Component extends syntax.node('Component').fields() {}
class StaticAttr extends syntax.node('StaticAttr').fields() {}
class DynamicAttr extends syntax.node('DynamicAttr').fields() {}
class SimpleElement extends syntax.node('SimpleElement').fields() {}
class ElementParameters extends syntax.node('ElementParameters').fields() {}
class Yield extends syntax.node('Yield').fields() {}
class Debugger extends syntax.node('Debugger').fields() {}
class CallExpression extends syntax.node('CallExpression').fields() {}
class DeprecatedCallExpression extends syntax.node('DeprecatedCallExpression').fields() {}
class Modifier extends syntax.node('Modifier').fields() {}
class InvokeBlock extends syntax.node('InvokeBlock').fields() {}
class SplatAttr extends syntax.node('SplatAttr').fields() {}
class PathExpression extends syntax.node('PathExpression').fields() {}
class GetWithResolver extends syntax.node('GetWithResolver').fields() {}
class GetSymbol extends syntax.node('GetSymbol').fields() {}
class GetFreeWithContext extends syntax.node('GetFreeWithContext').fields() {}
/** strict mode */
class GetFree extends syntax.node('GetFree').fields() {}
class Missing extends syntax.node('Missing').fields() {}
class InterpolateExpression extends syntax.node('InterpolateExpression').fields() {}
class HasBlock extends syntax.node('HasBlock').fields() {}
class HasBlockParams extends syntax.node('HasBlockParams').fields() {}
class Curry extends syntax.node('Curry').fields() {}
class Positional extends syntax.node('Positional').fields() {}
class NamedArguments extends syntax.node('NamedArguments').fields() {}
class NamedArgument extends syntax.node('NamedArgument').fields() {}
class Args extends syntax.node('Args').fields() {}
class Tail extends syntax.node('Tail').fields() {}

class PresentList {
  constructor(list) {
    this.list = list;
  }
  toArray() {
    return this.list;
  }
  map(callback) {
    let result = util.mapPresentArray(this.list, callback);
    return new PresentList(result);
  }
  filter(predicate) {
    let out = [];
    for (let item of this.list) {
      if (predicate(item)) {
        out.push(item);
      }
    }
    return OptionalList(out);
  }
  toPresentArray() {
    return this.list;
  }
  into({
    ifPresent
  }) {
    return ifPresent(this);
  }
}
class EmptyList {
  list = [];
  map(_callback) {
    return new EmptyList();
  }
  filter(_predicate) {
    return new EmptyList();
  }
  toArray() {
    return this.list;
  }
  toPresentArray() {
    return null;
  }
  into({
    ifEmpty
  }) {
    return ifEmpty();
  }
}

// export type OptionalList<T> = PresentList<T> | EmptyList<T>;

function OptionalList(value) {
  if (util.isPresentArray(value)) {
    return new PresentList(value);
  } else {
    return new EmptyList();
  }
}

class ResultImpl {
  static all(...results) {
    let out = [];
    for (let result of results) {
      if (result.isErr) {
        return result.cast();
      } else {
        out.push(result.value);
      }
    }
    return Ok(out);
  }
}
const Result = ResultImpl;
class OkImpl extends ResultImpl {
  isOk = true;
  isErr = false;
  constructor(value) {
    super();
    this.value = value;
  }
  expect(_message) {
    return this.value;
  }
  ifOk(callback) {
    callback(this.value);
    return this;
  }
  andThen(callback) {
    return callback(this.value);
  }
  mapOk(callback) {
    return Ok(callback(this.value));
  }
  ifErr(_callback) {
    return this;
  }
  mapErr(_callback) {
    return this;
  }
}
class ErrImpl extends ResultImpl {
  isOk = false;
  isErr = true;
  constructor(reason) {
    super();
    this.reason = reason;
  }
  expect(message) {
    throw new Error(message || 'expected an Ok, got Err');
  }
  andThen(_callback) {
    return this.cast();
  }
  mapOk(_callback) {
    return this.cast();
  }
  ifOk(_callback) {
    return this;
  }
  mapErr(callback) {
    return Err(callback(this.reason));
  }
  ifErr(callback) {
    callback(this.reason);
    return this;
  }
  cast() {
    return this;
  }
}
function Ok(value) {
  return new OkImpl(value);
}
function Err(reason) {
  return new ErrImpl(reason);
}
class ResultArray {
  constructor(items = []) {
    this.items = items;
  }
  add(item) {
    this.items.push(item);
  }
  toArray() {
    let err = this.items.filter(item => item instanceof ErrImpl)[0];
    if (err !== undefined) {
      return err.cast();
    } else {
      return Ok(this.items.map(item => item.value));
    }
  }
  toOptionalList() {
    return this.toArray().mapOk(arr => OptionalList(arr));
  }
}

function hasPath(node) {
  return node.callee.type === 'Path';
}
function isHelperInvocation(node) {
  if (!hasPath(node)) {
    return false;
  }
  return !node.args.isEmpty();
}
function isSimplePath(path) {
  if (path.type === 'Path') {
    let {
      ref: head,
      tail: parts
    } = path;
    return head.type === 'Free' && !syntax.ASTv2.isStrictResolution(head.resolution) && parts.length === 0;
  } else {
    return false;
  }
}
function isStrictHelper(expr) {
  if (expr.callee.type !== 'Path') {
    return true;
  }
  if (expr.callee.ref.type !== 'Free') {
    return true;
  }
  return syntax.ASTv2.isStrictResolution(expr.callee.ref.resolution);
}
function assertIsValidModifier(helper) {
  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {
    return;
  }
  throw syntax.generateSyntaxError(`\`${printPath(helper.callee)}\` is not a valid name for a modifier`, helper.loc);
}
function printPath(path) {
  switch (path.type) {
    case 'Literal':
      return JSON.stringify(path.value);
    case 'Path':
      {
        let printedPath = [printPathHead(path.ref)];
        printedPath.push(...path.tail.map(t => t.chars));
        return printedPath.join('.');
      }
    case 'Call':
      return `(${printPath(path.callee)} ...)`;
    case 'DeprecatedCall':
      return `${path.callee.name}`;
    case 'Interpolate':
      throw util.unreachable('a concat statement cannot appear as the head of an expression');
  }
}
function printPathHead(head) {
  switch (head.type) {
    case 'Arg':
      return head.name.chars;
    case 'Free':
    case 'Local':
      return head.name;
    case 'This':
      return 'this';
  }
}

class NormalizeExpressions {
  visit(node, state) {
    switch (node.type) {
      case 'Literal':
        return Ok(this.Literal(node));
      case 'Interpolate':
        return this.Interpolate(node, state);
      case 'Path':
        return this.PathExpression(node);
      case 'Call':
        {
          let translated = CALL_KEYWORDS.translate(node, state);
          if (translated !== null) {
            return translated;
          }
          return this.CallExpression(node, state);
        }
      case 'DeprecatedCall':
        return this.DeprecaedCallExpression(node, state);
    }
  }
  visitList(nodes, state) {
    return new ResultArray(nodes.map(e => VISIT_EXPRS.visit(e, state))).toOptionalList();
  }

  /**
   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.
   *
   * TODO since keywords don't support tails anyway, distinguish PathExpression from
   * VariableReference in ASTv2.
   */
  PathExpression(path) {
    let ref = this.VariableReference(path.ref);
    let {
      tail
    } = path;
    if (util.isPresentArray(tail)) {
      let tailLoc = tail[0].loc.extend(util.getLast(tail).loc);
      return Ok(new PathExpression({
        loc: path.loc,
        head: ref,
        tail: new Tail({
          loc: tailLoc,
          members: tail
        })
      }));
    } else {
      return Ok(ref);
    }
  }
  VariableReference(ref) {
    return ref;
  }
  Literal(literal) {
    return literal;
  }
  Interpolate(expr, state) {
    let parts = expr.parts.map(convertPathToCallIfKeyword);
    return VISIT_EXPRS.visitList(parts, state).mapOk(parts => new InterpolateExpression({
      loc: expr.loc,
      parts: parts
    }));
  }
  CallExpression(expr, state) {
    if (!hasPath(expr)) {
      throw new Error(`unimplemented subexpression at the head of a subexpression`);
    } else {
      return Result.all(VISIT_EXPRS.visit(expr.callee, state), VISIT_EXPRS.Args(expr.args, state)).mapOk(([callee, args]) => new CallExpression({
        loc: expr.loc,
        callee,
        args
      }));
    }
  }
  DeprecaedCallExpression({
    arg,
    callee,
    loc
  }, _state) {
    return Ok(new DeprecatedCallExpression({
      loc,
      arg,
      callee
    }));
  }
  Args({
    positional,
    named,
    loc
  }, state) {
    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(([positional, named]) => new Args({
      loc,
      positional,
      named
    }));
  }
  Positional(positional, state) {
    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(list => new Positional({
      loc: positional.loc,
      list
    }));
  }
  NamedArguments(named, state) {
    let pairs = named.entries.map(arg => {
      let value = convertPathToCallIfKeyword(arg.value);
      return VISIT_EXPRS.visit(value, state).mapOk(value => new NamedArgument({
        loc: arg.loc,
        key: arg.name,
        value
      }));
    });
    return new ResultArray(pairs).toOptionalList().mapOk(pairs => new NamedArguments({
      loc: named.loc,
      entries: pairs
    }));
  }
}
function convertPathToCallIfKeyword(path) {
  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in syntax.KEYWORDS_TYPES) {
    return new syntax.ASTv2.CallExpression({
      callee: path,
      args: syntax.ASTv2.Args.empty(path.loc),
      loc: path.loc
    });
  }
  return path;
}
const VISIT_EXPRS = new NormalizeExpressions();

class KeywordImpl {
  types;
  constructor(keyword, type, delegate) {
    this.keyword = keyword;
    this.delegate = delegate;
    let nodes = new Set();
    for (let nodeType of KEYWORD_NODES[type]) {
      nodes.add(nodeType);
    }
    this.types = nodes;
  }
  match(node) {
    if (!this.types.has(node.type)) {
      return false;
    }
    let path = getCalleeExpression(node);
    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {
      if (path.tail.length > 0) {
        if (path.ref.resolution.serialize() === 'Loose') {
          // cannot be a keyword reference, keywords do not allow paths (must be
          // relying on implicit this fallback)
          return false;
        }
      }
      return path.ref.name === this.keyword;
    } else {
      return false;
    }
  }
  translate(node, state) {
    if (this.match(node)) {
      let path = getCalleeExpression(node);
      if (path !== null && path.type === 'Path' && path.tail.length > 0) {
        return Err(syntax.generateSyntaxError(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${path.loc.asString()}\`, but it cannot be used with additional path segments. \n\nError caused by`, node.loc));
      }
      let param = this.delegate.assert(node, state);
      return param.andThen(param => this.delegate.translate({
        node,
        state
      }, param));
    } else {
      return null;
    }
  }
}
const KEYWORD_NODES = {
  Call: ['Call'],
  Block: ['InvokeBlock'],
  Append: ['AppendContent'],
  Modifier: ['ElementModifier']
};

/**
 * A "generic" keyword is something like `has-block`, which makes sense in the context
 * of sub-expression or append
 */

function keyword(keyword, type, delegate) {
  return new KeywordImpl(keyword, type, delegate);
}
function getCalleeExpression(node) {
  switch (node.type) {
    // This covers the inside of attributes and expressions, as well as the callee
    // of call nodes
    case 'Path':
      return node;
    case 'AppendContent':
      return getCalleeExpression(node.value);
    case 'Call':
    case 'InvokeBlock':
    case 'ElementModifier':
      return node.callee;
    default:
      return null;
  }
}
class Keywords {
  _keywords = [];
  _type;
  constructor(type) {
    this._type = type;
  }
  kw(name, delegate) {
    this._keywords.push(keyword(name, this._type, delegate));
    return this;
  }
  translate(node, state) {
    for (let keyword of this._keywords) {
      let result = keyword.translate(node, state);
      if (result !== null) {
        return result;
      }
    }
    let path = getCalleeExpression(node);
    if (path && path.type === 'Path' && path.ref.type === 'Free' && syntax.isKeyword(path.ref.name)) {
      let {
        name
      } = path.ref;
      let usedType = this._type;
      let validTypes = syntax.KEYWORDS_TYPES[name];
      if (!validTypes.includes(usedType)) {
        return Err(syntax.generateSyntaxError(`The \`${name}\` keyword was used incorrectly. It was used as ${typesToReadableName[usedType]}, but its valid usages are:\n\n${generateTypesMessage(name, validTypes)}\n\nError caused by`, node.loc));
      }
    }
    return null;
  }
}
const typesToReadableName = {
  Append: 'an append statement',
  Block: 'a block statement',
  Call: 'a call expression',
  Modifier: 'a modifier'
};
function generateTypesMessage(name, types) {
  return types.map(type => {
    switch (type) {
      case 'Append':
        return `- As an append statement, as in: {{${name}}}`;
      case 'Block':
        return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;
      case 'Call':
        return `- As an expression, as in: (${name})`;
      case 'Modifier':
        return `- As a modifier, as in: <div {{${name}}}></div>`;
      default:
        return util.exhausted(type);
    }
  }).join('\n\n');
}

/**
 * This function builds keyword definitions for a particular type of AST node (`KeywordType`).
 *
 * You can build keyword definitions for:
 *
 * - `Expr`: A `SubExpression` or `PathExpression`
 * - `Block`: A `BlockStatement`
 *   - A `BlockStatement` is a keyword candidate if its head is a
 *     `PathExpression`
 * - `Append`: An `AppendStatement`
 *
 * A node is a keyword candidate if:
 *
 * - A `PathExpression` is a keyword candidate if it has no tail, and its
 *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is
 *   the keyword's name.
 * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword
 *   candidate if its head is a keyword candidate.
 *
 * The keyword infrastructure guarantees that:
 *
 * - If a node is not a keyword candidate, it is never passed to any keyword's
 *   `assert` method.
 * - If a node is not the `KeywordType` for a particular keyword, it will not
 *   be passed to the keyword's `assert` method.
 *
 * `Expr` keywords are used in expression positions and should return HIR
 * expressions. `Block` and `Append` keywords are used in statement
 * positions and should return HIR statements.
 *
 * A keyword definition has two parts:
 *
 * - `match`, which determines whether an AST node matches the keyword, and can
 *   optionally return some information extracted from the AST node.
 * - `translate`, which takes a matching AST node as well as the extracted
 *   information and returns an appropriate HIR instruction.
 *
 * # Example
 *
 * This keyword:
 *
 * - turns `(hello)` into `"hello"`
 *   - as long as `hello` is not in scope
 * - makes it an error to pass any arguments (such as `(hello world)`)
 *
 * ```ts
 * keywords('SubExpr').kw('hello', {
 *   assert(node: ExprKeywordNode): Result<void> | false {
 *     // we don't want to transform `hello` as a `PathExpression`
 *     if (node.type !== 'SubExpression') {
 *       return false;
 *     }
 *
 *     // node.head would be `LocalVarHead` if `hello` was in scope
 *     if (node.head.type !== 'FreeVarHead') {
 *       return false;
 *     }
 *
 *     if (node.params.length || node.hash) {
 *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);
 *     } else {
 *       return Ok();
 *     }
 *   },
 *
 *   translate(node: ASTv2.SubExpression): hir.Expression {
 *     return ASTv2.builders.literal("hello", node.loc)
 *   }
 * })
 * ```
 *
 * The keyword infrastructure checks to make sure that the node is the right
 * type before calling `assert`, so you only need to consider `SubExpression`
 * and `PathExpression` here. It also checks to make sure that the node passed
 * to `assert` has the keyword name in the right place.
 *
 * Note the important difference between returning `false` from `assert`,
 * which just means that the node didn't match, and returning `Err`, which
 * means that the node matched, but there was a keyword-specific syntax
 * error.
 */
function keywords(type) {
  return new Keywords(type);
}

function toAppend({
  assert,
  translate
}) {
  return {
    assert,
    translate({
      node,
      state
    }, value) {
      let result = translate({
        node,
        state
      }, value);
      return result.mapOk(text => new AppendTextNode({
        text,
        loc: node.loc
      }));
    }
  };
}

const CurriedTypeToReadableType = {
  [vm.CurriedTypes.Component]: 'component',
  [vm.CurriedTypes.Helper]: 'helper',
  [vm.CurriedTypes.Modifier]: 'modifier'
};
function assertCurryKeyword(curriedType) {
  return (node, state) => {
    let readableType = CurriedTypeToReadableType[curriedType];
    let stringsAllowed = curriedType === vm.CurriedTypes.Component;
    let {
      args
    } = node;
    let definition = args.nth(0);
    if (definition === null) {
      return Err(syntax.generateSyntaxError(`(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`, args.loc));
    }
    if (definition.type === 'Literal') {
      if (stringsAllowed && state.isStrict) {
        return Err(syntax.generateSyntaxError(`(${readableType}) cannot resolve string values in strict mode templates`, node.loc));
      } else if (!stringsAllowed) {
        return Err(syntax.generateSyntaxError(`(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`, node.loc));
      }
    }
    args = new syntax.ASTv2.Args({
      positional: new syntax.ASTv2.PositionalArguments({
        exprs: args.positional.exprs.slice(1),
        loc: args.positional.loc
      }),
      named: args.named,
      loc: args.loc
    });
    return Ok({
      definition,
      args
    });
  };
}
function translateCurryKeyword(curriedType) {
  return ({
    node,
    state
  }, {
    definition,
    args
  }) => {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => new Curry({
      loc: node.loc,
      curriedType,
      definition,
      args
    }));
  };
}
function curryKeyword(curriedType) {
  return {
    assert: assertCurryKeyword(curriedType),
    translate: translateCurryKeyword(curriedType)
  };
}

function assertGetDynamicVarKeyword(node) {
  let call = node.type === 'AppendContent' ? node.value : node;
  let named = call.type === 'Call' ? call.args.named : null;
  let positionals = call.type === 'Call' ? call.args.positional : null;
  if (named && !named.isEmpty()) {
    return Err(syntax.generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc));
  }
  let varName = positionals?.nth(0);
  if (!varName) {
    return Err(syntax.generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));
  }
  if (positionals && positionals.size > 1) {
    return Err(syntax.generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc));
  }
  return Ok(varName);
}
function translateGetDynamicVarKeyword({
  node,
  state
}, name) {
  return VISIT_EXPRS.visit(name, state).mapOk(name => new GetDynamicVar({
    name,
    loc: node.loc
  }));
}
const getDynamicVarKeyword = {
  assert: assertGetDynamicVarKeyword,
  translate: translateGetDynamicVarKeyword
};

function assertHasBlockKeyword(type) {
  return node => {
    let call = node.type === 'AppendContent' ? node.value : node;
    let named = call.type === 'Call' ? call.args.named : null;
    let positionals = call.type === 'Call' ? call.args.positional : null;
    if (named && !named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));
    }
    if (!positionals || positionals.isEmpty()) {
      return Ok(syntax.SourceSlice.synthetic('default'));
    } else if (positionals.exprs.length === 1) {
      let positional = positionals.exprs[0];
      if (syntax.ASTv2.isLiteral(positional, 'string')) {
        return Ok(positional.toSlice());
      } else {
        return Err(syntax.generateSyntaxError(`(${type}) can only receive a string literal as its first argument`, call.loc));
      }
    } else {
      return Err(syntax.generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc));
    }
  };
}
function translateHasBlockKeyword(type) {
  return ({
    node,
    state: {
      scope
    }
  }, target) => {
    let block = type === 'has-block' ? new HasBlock({
      loc: node.loc,
      target,
      symbol: scope.allocateBlock(target.chars)
    }) : new HasBlockParams({
      loc: node.loc,
      target,
      symbol: scope.allocateBlock(target.chars)
    });
    return Ok(block);
  };
}
function hasBlockKeyword(type) {
  return {
    assert: assertHasBlockKeyword(type),
    translate: translateHasBlockKeyword(type)
  };
}

function assertIfUnlessInlineKeyword(type) {
  return originalNode => {
    let inverted = type === 'unless';
    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;
    let named = node.type === 'Call' ? node.args.named : null;
    let positional = node.type === 'Call' ? node.args.positional : null;
    if (named && !named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`(${type}) cannot receive named parameters, received ${named.entries.map(e => e.name.chars).join(', ')}`, originalNode.loc));
    }
    let condition = positional?.nth(0);
    if (!positional || !condition) {
      return Err(syntax.generateSyntaxError(`When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${inverted ? 'false' : 'true'}. Did not receive any parameters`, originalNode.loc));
    }
    let truthy = positional.nth(1);
    let falsy = positional.nth(2);
    if (truthy === null) {
      return Err(syntax.generateSyntaxError(`When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${inverted ? 'false' : 'true'}. Received only one parameter, the condition`, originalNode.loc));
    }
    if (positional.size > 3) {
      return Err(syntax.generateSyntaxError(`When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${inverted ? 'false' : 'true'}, and 3. the value to return if the condition is ${inverted ? 'true' : 'false'}. Received ${positional?.size ?? 0} parameters`, originalNode.loc));
    }
    return Ok({
      condition,
      truthy,
      falsy
    });
  };
}
function translateIfUnlessInlineKeyword(type) {
  let inverted = type === 'unless';
  return ({
    node,
    state
  }, {
    condition,
    truthy,
    falsy
  }) => {
    let conditionResult = VISIT_EXPRS.visit(condition, state);
    let truthyResult = VISIT_EXPRS.visit(truthy, state);
    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);
    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(([condition, truthy, falsy]) => {
      if (inverted) {
        condition = new Not({
          value: condition,
          loc: node.loc
        });
      }
      return new IfInline({
        loc: node.loc,
        condition,
        truthy,
        falsy
      });
    });
  };
}
function ifUnlessInlineKeyword(type) {
  return {
    assert: assertIfUnlessInlineKeyword(type),
    translate: translateIfUnlessInlineKeyword(type)
  };
}

function assertLogKeyword(node) {
  let {
    args: {
      named,
      positional
    }
  } = node;
  if (named && !named.isEmpty()) {
    return Err(syntax.generateSyntaxError(`(log) does not take any named arguments`, node.loc));
  }
  return Ok(positional);
}
function translateLogKeyword({
  node,
  state
}, positional) {
  return VISIT_EXPRS.Positional(positional, state).mapOk(positional => new Log({
    positional,
    loc: node.loc
  }));
}
const logKeyword = {
  assert: assertLogKeyword,
  translate: translateLogKeyword
};

const APPEND_KEYWORDS = keywords('Append').kw('has-block', toAppend(hasBlockKeyword('has-block'))).kw('has-block-params', toAppend(hasBlockKeyword('has-block-params'))).kw('-get-dynamic-var', toAppend(getDynamicVarKeyword)).kw('log', toAppend(logKeyword)).kw('if', toAppend(ifUnlessInlineKeyword('if'))).kw('unless', toAppend(ifUnlessInlineKeyword('unless'))).kw('yield', {
  assert(node) {
    let {
      args
    } = node;
    if (args.named.isEmpty()) {
      return Ok({
        target: syntax.src.SourceSpan.synthetic('default').toSlice(),
        positional: args.positional
      });
    } else {
      let target = args.named.get('to');
      if (args.named.size > 1 || target === null) {
        return Err(syntax.generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc));
      }
      if (syntax.ASTv2.isLiteral(target, 'string')) {
        return Ok({
          target: target.toSlice(),
          positional: args.positional
        });
      } else {
        return Err(syntax.generateSyntaxError(`you can only yield to a literal string value`, target.loc));
      }
    }
  },
  translate({
    node,
    state
  }, {
    target,
    positional
  }) {
    return VISIT_EXPRS.Positional(positional, state).mapOk(positional => new Yield({
      loc: node.loc,
      target,
      to: state.scope.allocateBlock(target.chars),
      positional
    }));
  }
}).kw('debugger', {
  assert(node) {
    let {
      args
    } = node;
    let {
      positional
    } = args;
    if (args.isEmpty()) {
      return Ok(undefined);
    } else {
      if (positional.isEmpty()) {
        return Err(syntax.generateSyntaxError(`debugger does not take any named arguments`, node.loc));
      } else {
        return Err(syntax.generateSyntaxError(`debugger does not take any positional arguments`, node.loc));
      }
    }
  },
  translate({
    node,
    state: {
      scope
    }
  }) {
    scope.setHasDebugger();
    return Ok(new Debugger({
      loc: node.loc,
      scope
    }));
  }
}).kw('component', {
  assert: assertCurryKeyword(vm.CurriedTypes.Component),
  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => new InvokeComponent({
      loc: node.loc,
      definition,
      args,
      blocks: null
    }));
  }
}).kw('helper', {
  assert: assertCurryKeyword(vm.CurriedTypes.Helper),
  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {
      let text = new CallExpression({
        callee: definition,
        args,
        loc: node.loc
      });
      return new AppendTextNode({
        loc: node.loc,
        text
      });
    });
  }
});

const BLOCK_KEYWORDS = keywords('Block').kw('in-element', {
  assert(node) {
    let {
      args
    } = node;
    let guid = args.get('guid');
    if (guid) {
      return Err(syntax.generateSyntaxError(`Cannot pass \`guid\` to \`{{#in-element}}\``, guid.loc));
    }
    let insertBefore = args.get('insertBefore');
    let destination = args.nth(0);
    if (destination === null) {
      return Err(syntax.generateSyntaxError(`{{#in-element}} requires a target element as its first positional parameter`, args.loc));
    }

    // TODO Better syntax checks

    return Ok({
      insertBefore,
      destination
    });
  },
  translate({
    node,
    state
  }, {
    insertBefore,
    destination
  }) {
    let named = node.blocks.get('default');
    let body = VISIT_STMTS.NamedBlock(named, state);
    let destinationResult = VISIT_EXPRS.visit(destination, state);
    return Result.all(body, destinationResult).andThen(([body, destination]) => {
      if (insertBefore) {
        return VISIT_EXPRS.visit(insertBefore, state).mapOk(insertBefore => ({
          body,
          destination,
          insertBefore
        }));
      } else {
        return Ok({
          body,
          destination,
          insertBefore: new Missing({
            loc: node.callee.loc.collapse('end')
          })
        });
      }
    }).mapOk(({
      body,
      destination,
      insertBefore
    }) => new InElement({
      loc: node.loc,
      block: body,
      insertBefore,
      guid: state.generateUniqueCursor(),
      destination
    }));
  }
}).kw('if', {
  assert(node) {
    let {
      args
    } = node;
    if (!args.named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`{{#if}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, node.loc));
    }
    if (args.positional.size > 1) {
      return Err(syntax.generateSyntaxError(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`, node.loc));
    }
    let condition = args.nth(0);
    if (condition === null) {
      return Err(syntax.generateSyntaxError(`{{#if}} requires a condition as its first positional parameter, did not receive any parameters`, node.loc));
    }
    return Ok({
      condition
    });
  },
  translate({
    node,
    state
  }, {
    condition
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');
    let conditionResult = VISIT_EXPRS.visit(condition, state);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);
    return Result.all(conditionResult, blockResult, inverseResult).mapOk(([condition, block, inverse]) => new If({
      loc: node.loc,
      condition,
      block,
      inverse
    }));
  }
}).kw('unless', {
  assert(node) {
    let {
      args
    } = node;
    if (!args.named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`{{#unless}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, node.loc));
    }
    if (args.positional.size > 1) {
      return Err(syntax.generateSyntaxError(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`, node.loc));
    }
    let condition = args.nth(0);
    if (condition === null) {
      return Err(syntax.generateSyntaxError(`{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`, node.loc));
    }
    return Ok({
      condition
    });
  },
  translate({
    node,
    state
  }, {
    condition
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');
    let conditionResult = VISIT_EXPRS.visit(condition, state);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);
    return Result.all(conditionResult, blockResult, inverseResult).mapOk(([condition, block, inverse]) => new If({
      loc: node.loc,
      condition: new Not({
        value: condition,
        loc: node.loc
      }),
      block,
      inverse
    }));
  }
}).kw('each', {
  assert(node) {
    let {
      args
    } = node;
    if (!args.named.entries.every(e => e.name.chars === 'key')) {
      return Err(syntax.generateSyntaxError(`{{#each}} can only receive the 'key' named parameter, received ${args.named.entries.filter(e => e.name.chars !== 'key').map(e => e.name.chars).join(', ')}`, args.named.loc));
    }
    if (args.positional.size > 1) {
      return Err(syntax.generateSyntaxError(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`, args.positional.loc));
    }
    let value = args.nth(0);
    let key = args.get('key');
    if (value === null) {
      return Err(syntax.generateSyntaxError(`{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`, args.loc));
    }
    return Ok({
      value,
      key
    });
  },
  translate({
    node,
    state
  }, {
    value,
    key
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');
    let valueResult = VISIT_EXPRS.visit(value, state);
    let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);
    return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(([value, key, block, inverse]) => new Each({
      loc: node.loc,
      value,
      key,
      block,
      inverse
    }));
  }
}).kw('with', {
  assert(node) {
    let {
      args
    } = node;
    if (!args.named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`{{#with}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, args.named.loc));
    }
    if (args.positional.size > 1) {
      return Err(syntax.generateSyntaxError(`{{#with}} can only receive one positional parameter. Received ${args.positional.size} parameters`, args.positional.loc));
    }
    let value = args.nth(0);
    if (value === null) {
      return Err(syntax.generateSyntaxError(`{{#with}} requires a value as its first positional parameter, did not receive any parameters`, args.loc));
    }
    return Ok({
      value
    });
  },
  translate({
    node,
    state
  }, {
    value
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');
    let valueResult = VISIT_EXPRS.visit(value, state);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);
    return Result.all(valueResult, blockResult, inverseResult).mapOk(([value, block, inverse]) => new With({
      loc: node.loc,
      value,
      block,
      inverse
    }));
  }
}).kw('let', {
  assert(node) {
    let {
      args
    } = node;
    if (!args.named.isEmpty()) {
      return Err(syntax.generateSyntaxError(`{{#let}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, args.named.loc));
    }
    if (args.positional.size === 0) {
      return Err(syntax.generateSyntaxError(`{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`, args.positional.loc));
    }
    if (node.blocks.get('else')) {
      return Err(syntax.generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc));
    }
    return Ok({
      positional: args.positional
    });
  },
  translate({
    node,
    state
  }, {
    positional
  }) {
    let block = node.blocks.get('default');
    let positionalResult = VISIT_EXPRS.Positional(positional, state);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    return Result.all(positionalResult, blockResult).mapOk(([positional, block]) => new Let({
      loc: node.loc,
      positional,
      block
    }));
  }
}).kw('-with-dynamic-vars', {
  assert(node) {
    return Ok({
      named: node.args.named
    });
  },
  translate({
    node,
    state
  }, {
    named
  }) {
    let block = node.blocks.get('default');
    let namedResult = VISIT_EXPRS.NamedArguments(named, state);
    let blockResult = VISIT_STMTS.NamedBlock(block, state);
    return Result.all(namedResult, blockResult).mapOk(([named, block]) => new WithDynamicVars({
      loc: node.loc,
      named,
      block
    }));
  }
}).kw('component', {
  assert: assertCurryKeyword(vm.CurriedTypes.Component),
  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);
    return Result.all(definitionResult, argsResult, blocksResult).mapOk(([definition, args, blocks]) => new InvokeComponent({
      loc: node.loc,
      definition,
      args,
      blocks
    }));
  }
});

const CALL_KEYWORDS = keywords('Call').kw('has-block', hasBlockKeyword('has-block')).kw('has-block-params', hasBlockKeyword('has-block-params')).kw('-get-dynamic-var', getDynamicVarKeyword).kw('log', logKeyword).kw('if', ifUnlessInlineKeyword('if')).kw('unless', ifUnlessInlineKeyword('unless')).kw('component', curryKeyword(vm.CurriedTypes.Component)).kw('helper', curryKeyword(vm.CurriedTypes.Helper)).kw('modifier', curryKeyword(vm.CurriedTypes.Modifier));

const MODIFIER_KEYWORDS = keywords('Modifier');

// There is a small whitelist of namespaced attributes specially
// enumerated in
// https://www.w3.org/TR/html/syntax.html#attributes-0
//
// > When a foreign element has one of the namespaced attributes given by
// > the local name and namespace of the first and second cells of a row
// > from the following table, it must be written using the name given by
// > the third cell from the same row.
//
// In all other cases, colons are interpreted as a regular character
// with no special meaning:
//
// > No other namespaced attribute can be expressed in the HTML syntax.

const XLINK = 'http://www.w3.org/1999/xlink';
const XML = 'http://www.w3.org/XML/1998/namespace';
const XMLNS = 'http://www.w3.org/2000/xmlns/';
const WHITELIST = {
  'xlink:actuate': XLINK,
  'xlink:arcrole': XLINK,
  'xlink:href': XLINK,
  'xlink:role': XLINK,
  'xlink:show': XLINK,
  'xlink:title': XLINK,
  'xlink:type': XLINK,
  'xml:base': XML,
  'xml:lang': XML,
  'xml:space': XML,
  xmlns: XMLNS,
  'xmlns:xlink': XMLNS
};
function getAttrNamespace(attrName) {
  return WHITELIST[attrName];
}
const DEFLATE_TAG_TABLE = {
  div: wireFormat.WellKnownTagNames.div,
  span: wireFormat.WellKnownTagNames.span,
  p: wireFormat.WellKnownTagNames.p,
  a: wireFormat.WellKnownTagNames.a
};
const INFLATE_TAG_TABLE = ['div', 'span', 'p', 'a'];
function deflateTagName(tagName) {
  return DEFLATE_TAG_TABLE[tagName] ?? tagName;
}
function inflateTagName(tagName) {
  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];
}
const DEFLATE_ATTR_TABLE = {
  class: wireFormat.WellKnownAttrNames.class,
  id: wireFormat.WellKnownAttrNames.id,
  value: wireFormat.WellKnownAttrNames.value,
  name: wireFormat.WellKnownAttrNames.name,
  type: wireFormat.WellKnownAttrNames.type,
  style: wireFormat.WellKnownAttrNames.style,
  href: wireFormat.WellKnownAttrNames.href
};
const INFLATE_ATTR_TABLE = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];
function deflateAttrName(attrName) {
  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;
}
function inflateAttrName(attrName) {
  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];
}

class ClassifiedElement {
  delegate;
  constructor(element, delegate, state) {
    this.element = element;
    this.state = state;
    this.delegate = delegate;
  }
  toStatement() {
    return this.prepare().andThen(prepared => this.delegate.toStatement(this, prepared));
  }
  attr(attr) {
    let name = attr.name;
    let rawValue = attr.value;
    let namespace = getAttrNamespace(name.chars) || undefined;
    if (syntax.ASTv2.isLiteral(rawValue, 'string')) {
      return Ok(new StaticAttr({
        loc: attr.loc,
        name,
        value: rawValue.toSlice(),
        namespace,
        kind: {
          component: this.delegate.dynamicFeatures
        }
      }));
    }
    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk(value => {
      let isTrusting = attr.trusting;
      return new DynamicAttr({
        loc: attr.loc,
        name,
        value: value,
        namespace,
        kind: {
          trusting: isTrusting,
          component: this.delegate.dynamicFeatures
        }
      });
    });
  }
  modifier(modifier) {
    if (isHelperInvocation(modifier)) {
      assertIsValidModifier(modifier);
    }
    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);
    if (translated !== null) {
      return translated;
    }
    let head = VISIT_EXPRS.visit(modifier.callee, this.state);
    let args = VISIT_EXPRS.Args(modifier.args, this.state);
    return Result.all(head, args).mapOk(([head, args]) => new Modifier({
      loc: modifier.loc,
      callee: head,
      args
    }));
  }
  attrs() {
    let attrs = new ResultArray();
    let args = new ResultArray();

    // Unlike most attributes, the `type` attribute can change how
    // subsequent attributes are interpreted by the browser. To address
    // this, in simple cases, we special case the `type` attribute to be set
    // last. For elements with splattributes, where attribute order affects
    // precedence, this re-ordering happens at runtime instead.
    // See https://github.com/glimmerjs/glimmer-vm/pull/726
    let typeAttr = null;
    let simple = this.element.attrs.filter(attr => attr.type === 'SplatAttr').length === 0;
    for (let attr of this.element.attrs) {
      if (attr.type === 'SplatAttr') {
        attrs.add(Ok(new SplatAttr({
          loc: attr.loc,
          symbol: this.state.scope.allocateBlock('attrs')
        })));
      } else if (attr.name.chars === 'type' && simple) {
        typeAttr = attr;
      } else {
        attrs.add(this.attr(attr));
      }
    }
    for (let arg of this.element.componentArgs) {
      args.add(this.delegate.arg(arg, this));
    }
    if (typeAttr) {
      attrs.add(this.attr(typeAttr));
    }
    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({
      attrs,
      args: new NamedArguments({
        loc: syntax.maybeLoc(args, syntax.src.SourceSpan.NON_EXISTENT),
        entries: OptionalList(args)
      })
    }));
  }
  prepare() {
    let attrs = this.attrs();
    let modifiers = new ResultArray(this.element.modifiers.map(m => this.modifier(m))).toArray();
    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {
      let {
        attrs,
        args
      } = result;
      let elementParams = [...attrs, ...modifiers];
      let params = new ElementParameters({
        loc: syntax.maybeLoc(elementParams, syntax.src.SourceSpan.NON_EXISTENT),
        body: OptionalList(elementParams)
      });
      return {
        args,
        params
      };
    });
  }
}
function hasDynamicFeatures({
  attrs,
  modifiers
}) {
  // ElementModifier needs the special ComponentOperations
  if (modifiers.length > 0) {
    return true;
  }

  // Splattributes need the special ComponentOperations to merge into
  return !!attrs.filter(attr => attr.type === 'SplatAttr')[0];
}

class ClassifiedComponent {
  dynamicFeatures = true;
  constructor(tag, element) {
    this.tag = tag;
    this.element = element;
  }
  arg(attr, {
    state
  }) {
    let name = attr.name;
    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(value => new NamedArgument({
      loc: attr.loc,
      key: name,
      value
    }));
  }
  toStatement(component, {
    args,
    params
  }) {
    let {
      element,
      state
    } = component;
    return this.blocks(state).mapOk(blocks => new Component({
      loc: element.loc,
      tag: this.tag,
      params,
      args,
      blocks
    }));
  }
  blocks(state) {
    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);
  }
}

class ClassifiedSimpleElement {
  constructor(tag, element, dynamicFeatures) {
    this.tag = tag;
    this.element = element;
    this.dynamicFeatures = dynamicFeatures;
  }
  isComponent = false;
  arg(attr) {
    return Err(syntax.generateSyntaxError(`${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`, attr.loc));
  }
  toStatement(classified, {
    params
  }) {
    let {
      state,
      element
    } = classified;
    let body = VISIT_STMTS.visitList(this.element.body, state);
    return body.mapOk(body => new SimpleElement({
      loc: element.loc,
      tag: this.tag,
      params,
      body: body.toArray(),
      dynamicFeatures: this.dynamicFeatures
    }));
  }
}

class NormalizationStatements {
  visitList(nodes, state) {
    return new ResultArray(nodes.map(e => VISIT_STMTS.visit(e, state))).toOptionalList().mapOk(list => list.filter(s => s !== null));
  }
  visit(node, state) {
    switch (node.type) {
      case 'GlimmerComment':
        return Ok(null);
      case 'AppendContent':
        return this.AppendContent(node, state);
      case 'HtmlText':
        return Ok(this.TextNode(node));
      case 'HtmlComment':
        return Ok(this.HtmlComment(node));
      case 'InvokeBlock':
        return this.InvokeBlock(node, state);
      case 'InvokeComponent':
        return this.Component(node, state);
      case 'SimpleElement':
        return this.SimpleElement(node, state);
    }
  }
  InvokeBlock(node, state) {
    let translated = BLOCK_KEYWORDS.translate(node, state);
    if (translated !== null) {
      return translated;
    }
    let head = VISIT_EXPRS.visit(node.callee, state);
    let args = VISIT_EXPRS.Args(node.args, state);
    return Result.all(head, args).andThen(([head, args]) => this.NamedBlocks(node.blocks, state).mapOk(blocks => new InvokeBlock({
      loc: node.loc,
      head,
      args,
      blocks
    })));
  }
  NamedBlocks(blocks, state) {
    let list = new ResultArray(blocks.blocks.map(b => this.NamedBlock(b, state)));
    return list.toArray().mapOk(list => new NamedBlocks({
      loc: blocks.loc,
      blocks: OptionalList(list)
    }));
  }
  NamedBlock(named, state) {
    let body = state.visitBlock(named.block);
    return body.mapOk(body => {
      return new NamedBlock({
        loc: named.loc,
        name: named.name,
        body: body.toArray(),
        scope: named.block.scope
      });
    });
  }
  SimpleElement(element, state) {
    return new ClassifiedElement(element, new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)), state).toStatement();
  }
  Component(component, state) {
    return VISIT_EXPRS.visit(component.callee, state).andThen(callee => new ClassifiedElement(component, new ClassifiedComponent(callee, component), state).toStatement());
  }
  AppendContent(append, state) {
    let translated = APPEND_KEYWORDS.translate(append, state);
    if (translated !== null) {
      return translated;
    }
    let value = VISIT_EXPRS.visit(append.value, state);
    return value.mapOk(value => {
      if (append.trusting) {
        return new AppendTrustedHTML({
          loc: append.loc,
          html: value
        });
      } else {
        return new AppendTextNode({
          loc: append.loc,
          text: value
        });
      }
    });
  }
  TextNode(text) {
    return new AppendTextNode({
      loc: text.loc,
      text: new syntax.ASTv2.LiteralExpression({
        loc: text.loc,
        value: text.chars
      })
    });
  }
  HtmlComment(comment) {
    return new AppendComment({
      loc: comment.loc,
      value: comment.text
    });
  }
}
const VISIT_STMTS = new NormalizationStatements();

/**
 * This is the mutable state for this compiler pass.
 */
class NormalizationState {
  _currentScope;
  _cursorCount = 0;
  constructor(block, isStrict) {
    this.isStrict = isStrict;
    this._currentScope = block;
  }
  generateUniqueCursor() {
    return `%cursor:${this._cursorCount++}%`;
  }
  get scope() {
    return this._currentScope;
  }
  visitBlock(block) {
    let oldBlock = this._currentScope;
    this._currentScope = block.scope;
    try {
      return VISIT_STMTS.visitList(block.body, this);
    } finally {
      this._currentScope = oldBlock;
    }
  }
}

/**
 * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special
 * instructions for keywords like `{{yield}}`, `(has-block)` and
 * `{{#in-element}}`.
 *
 * Most importantly, it also classifies HTML element syntax into:
 *
 * 1. simple HTML element (with optional splattributes)
 * 2. component invocation
 *
 * Because the @glimmer/syntax AST gives us a string for an element's tag,
 * this pass also normalizes that string into an expression.
 *
 * ```
 * // normalized into a path expression whose head is `this` and tail is
 * // `["x"]`
 * <this.x />
 *
 * {{#let expr as |t|}}
 *   // `"t"` is normalized into a variable lookup.
 *   <t />
 *
 *   // normalized into a path expression whose head is the variable lookup
 *   // `t` and tail is `["input"]`.
 *   <t.input />
 * {{/let}}
 *
 * // normalized into a free variable lookup for `SomeComponent` (with the
 * // context `ComponentHead`).
 * <SomeComponent />
 *
 * // normalized into a path expression whose head is the free variable
 * // `notInScope` (with the context `Expression`), and whose tail is
 * // `["SomeComponent"]`. In resolver mode, this path will be rejected later,
 * // since it cannot serve as an input to the resolver.
 * <notInScope.SomeComponent />
 * ```
 */
function normalize(source, root, isStrict) {
  // create a new context for the normalization pass
  let state = new NormalizationState(root.table, isStrict);
  let body = VISIT_STMTS.visitList(root.body, state);
  return body.mapOk(body => new Template({
    loc: root.loc,
    scope: root.table,
    body: body.toArray()
  }));
}

class WireFormatDebugger {
  upvars;
  symbols;
  constructor([_statements, symbols, _hasEval, upvars]) {
    this.upvars = upvars;
    this.symbols = symbols;
  }
  format(program) {
    let out = [];
    for (let statement of program[0]) {
      out.push(this.formatOpcode(statement));
    }
    return out;
  }
  formatOpcode(opcode) {
    if (Array.isArray(opcode)) {
      switch (opcode[0]) {
        case wireFormat.SexpOpcodes.Append:
          return ['append', this.formatOpcode(opcode[1])];
        case wireFormat.SexpOpcodes.TrustingAppend:
          return ['trusting-append', this.formatOpcode(opcode[1])];
        case wireFormat.SexpOpcodes.Block:
          return ['block', this.formatOpcode(opcode[1]), this.formatParams(opcode[2]), this.formatHash(opcode[3]), this.formatBlocks(opcode[4])];
        case wireFormat.SexpOpcodes.InElement:
          return ['in-element', opcode[1], this.formatOpcode(opcode[2]), opcode[3] ? this.formatOpcode(opcode[3]) : undefined];
        case wireFormat.SexpOpcodes.OpenElement:
          return ['open-element', inflateTagName(opcode[1])];
        case wireFormat.SexpOpcodes.OpenElementWithSplat:
          return ['open-element-with-splat', inflateTagName(opcode[1])];
        case wireFormat.SexpOpcodes.CloseElement:
          return ['close-element'];
        case wireFormat.SexpOpcodes.FlushElement:
          return ['flush-element'];
        case wireFormat.SexpOpcodes.StaticAttr:
          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];
        case wireFormat.SexpOpcodes.StaticComponentAttr:
          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];
        case wireFormat.SexpOpcodes.DynamicAttr:
          return ['dynamic-attr', inflateAttrName(opcode[1]), this.formatOpcode(opcode[2]), opcode[3]];
        case wireFormat.SexpOpcodes.ComponentAttr:
          return ['component-attr', inflateAttrName(opcode[1]), this.formatOpcode(opcode[2]), opcode[3]];
        case wireFormat.SexpOpcodes.AttrSplat:
          return ['attr-splat'];
        case wireFormat.SexpOpcodes.Yield:
          return ['yield', opcode[1], this.formatParams(opcode[2])];
        case wireFormat.SexpOpcodes.DynamicArg:
          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];
        case wireFormat.SexpOpcodes.StaticArg:
          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];
        case wireFormat.SexpOpcodes.TrustingDynamicAttr:
          return ['trusting-dynamic-attr', inflateAttrName(opcode[1]), this.formatOpcode(opcode[2]), opcode[3]];
        case wireFormat.SexpOpcodes.TrustingComponentAttr:
          return ['trusting-component-attr', inflateAttrName(opcode[1]), this.formatOpcode(opcode[2]), opcode[3]];
        case wireFormat.SexpOpcodes.Debugger:
          return ['debugger', opcode[1]];
        case wireFormat.SexpOpcodes.Comment:
          return ['comment', opcode[1]];
        case wireFormat.SexpOpcodes.Modifier:
          return ['modifier', this.formatOpcode(opcode[1]), this.formatParams(opcode[2]), this.formatHash(opcode[3])];
        case wireFormat.SexpOpcodes.Component:
          return ['component', this.formatOpcode(opcode[1]), this.formatElementParams(opcode[2]), this.formatHash(opcode[3]), this.formatBlocks(opcode[4])];
        case wireFormat.SexpOpcodes.HasBlock:
          return ['has-block', this.formatOpcode(opcode[1])];
        case wireFormat.SexpOpcodes.HasBlockParams:
          return ['has-block-params', this.formatOpcode(opcode[1])];
        case wireFormat.SexpOpcodes.Curry:
          return ['curry', this.formatOpcode(opcode[1]), this.formatCurryType(opcode[2]), this.formatParams(opcode[3]), this.formatHash(opcode[4])];
        case wireFormat.SexpOpcodes.Undefined:
          return ['undefined'];
        case wireFormat.SexpOpcodes.Call:
          return ['call', this.formatOpcode(opcode[1]), this.formatParams(opcode[2]), this.formatHash(opcode[3])];
        case wireFormat.SexpOpcodes.Concat:
          return ['concat', this.formatParams(opcode[1])];
        case wireFormat.SexpOpcodes.GetStrictKeyword:
          return ['get-strict-free', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback:
          return ['GetFreeAsComponentOrHelperHeadOrThisFallback', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHead:
          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsHelperHeadOrThisFallback:
          return ['GetFreeAsHelperHeadOrThisFallback', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback:
          return ['GetFreeAsDeprecatedHelperHeadOrThisFallback', this.upvars[opcode[1]]];
        case wireFormat.SexpOpcodes.GetFreeAsHelperHead:
          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsComponentHead:
          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetFreeAsModifierHead:
          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];
        case wireFormat.SexpOpcodes.GetSymbol:
          {
            if (opcode[1] === 0) {
              return ['get-symbol', 'this', opcode[2]];
            } else {
              return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];
            }
          }
        case wireFormat.SexpOpcodes.GetLexicalSymbol:
          {
            return ['get-template-symbol', opcode[1], opcode[2]];
          }
        case wireFormat.SexpOpcodes.If:
          return ['if', this.formatOpcode(opcode[1]), this.formatBlock(opcode[2]), opcode[3] ? this.formatBlock(opcode[3]) : null];
        case wireFormat.SexpOpcodes.IfInline:
          return ['if-inline'];
        case wireFormat.SexpOpcodes.Not:
          return ['not'];
        case wireFormat.SexpOpcodes.Each:
          return ['each', this.formatOpcode(opcode[1]), opcode[2] ? this.formatOpcode(opcode[2]) : null, this.formatBlock(opcode[3]), opcode[4] ? this.formatBlock(opcode[4]) : null];
        case wireFormat.SexpOpcodes.With:
          return ['with', this.formatOpcode(opcode[1]), this.formatBlock(opcode[2]), opcode[3] ? this.formatBlock(opcode[3]) : null];
        case wireFormat.SexpOpcodes.Let:
          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];
        case wireFormat.SexpOpcodes.Log:
          return ['log', this.formatParams(opcode[1])];
        case wireFormat.SexpOpcodes.WithDynamicVars:
          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];
        case wireFormat.SexpOpcodes.GetDynamicVar:
          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];
        case wireFormat.SexpOpcodes.InvokeComponent:
          return ['component', this.formatOpcode(opcode[1]), this.formatParams(opcode[2]), this.formatHash(opcode[3]), this.formatBlocks(opcode[4])];
      }
    } else {
      return opcode;
    }
  }
  formatCurryType(value) {
    switch (value) {
      case vm.CurriedTypes.Component:
        return 'component';
      case vm.CurriedTypes.Helper:
        return 'helper';
      case vm.CurriedTypes.Modifier:
        return 'modifier';
      default:
        throw util.exhausted(value);
    }
  }
  formatElementParams(opcodes) {
    if (opcodes === null) return null;
    return opcodes.map(o => this.formatOpcode(o));
  }
  formatParams(opcodes) {
    if (opcodes === null) return null;
    return opcodes.map(o => this.formatOpcode(o));
  }
  formatHash(hash) {
    if (hash === null) return null;
    return hash[0].reduce((accum, key, index) => {
      accum[key] = this.formatOpcode(hash[1][index]);
      return accum;
    }, util.dict());
  }
  formatBlocks(blocks) {
    if (blocks === null) return null;
    return blocks[0].reduce((accum, key, index) => {
      accum[key] = this.formatBlock(blocks[1][index]);
      return accum;
    }, util.dict());
  }
  formatBlock(block) {
    return {
      statements: block[0].map(s => this.formatOpcode(s)),
      parameters: block[1]
    };
  }
}

class ExpressionEncoder {
  expr(expr) {
    switch (expr.type) {
      case 'Missing':
        return undefined;
      case 'Literal':
        return this.Literal(expr);
      case 'CallExpression':
        return this.CallExpression(expr);
      case 'DeprecatedCallExpression':
        return this.DeprecatedCallExpression(expr);
      case 'PathExpression':
        return this.PathExpression(expr);
      case 'Arg':
        return [wireFormat.SexpOpcodes.GetSymbol, expr.symbol];
      case 'Local':
        return this.Local(expr);
      case 'This':
        return [wireFormat.SexpOpcodes.GetSymbol, 0];
      case 'Free':
        return [expr.resolution.resolution(), expr.symbol];
      case 'HasBlock':
        return this.HasBlock(expr);
      case 'HasBlockParams':
        return this.HasBlockParams(expr);
      case 'Curry':
        return this.Curry(expr);
      case 'Not':
        return this.Not(expr);
      case 'IfInline':
        return this.IfInline(expr);
      case 'InterpolateExpression':
        return this.InterpolateExpression(expr);
      case 'GetDynamicVar':
        return this.GetDynamicVar(expr);
      case 'Log':
        return this.Log(expr);
    }
  }
  Literal({
    value
  }) {
    if (value === undefined) {
      return [wireFormat.SexpOpcodes.Undefined];
    } else {
      return value;
    }
  }
  Missing() {
    return undefined;
  }
  HasBlock({
    symbol
  }) {
    return [wireFormat.SexpOpcodes.HasBlock, [wireFormat.SexpOpcodes.GetSymbol, symbol]];
  }
  HasBlockParams({
    symbol
  }) {
    return [wireFormat.SexpOpcodes.HasBlockParams, [wireFormat.SexpOpcodes.GetSymbol, symbol]];
  }
  Curry({
    definition,
    curriedType,
    args
  }) {
    return [wireFormat.SexpOpcodes.Curry, EXPR.expr(definition), curriedType, EXPR.Positional(args.positional), EXPR.NamedArguments(args.named)];
  }
  Local({
    isTemplateLocal,
    symbol
  }) {
    return [isTemplateLocal ? wireFormat.SexpOpcodes.GetLexicalSymbol : wireFormat.SexpOpcodes.GetSymbol, symbol];
  }
  GetWithResolver({
    symbol
  }) {
    return [wireFormat.SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback, symbol];
  }
  PathExpression({
    head,
    tail
  }) {
    let getOp = EXPR.expr(head);
    return [...getOp, EXPR.Tail(tail)];
  }
  InterpolateExpression({
    parts
  }) {
    return [wireFormat.SexpOpcodes.Concat, parts.map(e => EXPR.expr(e)).toArray()];
  }
  CallExpression({
    callee,
    args
  }) {
    return [wireFormat.SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];
  }
  DeprecatedCallExpression({
    arg,
    callee
  }) {
    return [wireFormat.SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback, callee.symbol, [arg.chars]];
  }
  Tail({
    members
  }) {
    return util.mapPresentArray(members, member => member.chars);
  }
  Args({
    positional,
    named
  }) {
    return [this.Positional(positional), this.NamedArguments(named)];
  }
  Positional({
    list
  }) {
    return list.map(l => EXPR.expr(l)).toPresentArray();
  }
  NamedArgument({
    key,
    value
  }) {
    return [key.chars, EXPR.expr(value)];
  }
  NamedArguments({
    entries: pairs
  }) {
    let list = pairs.toArray();
    if (util.isPresentArray(list)) {
      let names = [];
      let values = [];
      for (let pair of list) {
        let [name, value] = EXPR.NamedArgument(pair);
        names.push(name);
        values.push(value);
      }
      util.assertPresentArray(names);
      util.assertPresentArray(values);
      return [names, values];
    } else {
      return null;
    }
  }
  Not({
    value
  }) {
    return [wireFormat.SexpOpcodes.Not, EXPR.expr(value)];
  }
  IfInline({
    condition,
    truthy,
    falsy
  }) {
    let expr = [wireFormat.SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];
    if (falsy) {
      expr.push(EXPR.expr(falsy));
    }
    return expr;
  }
  GetDynamicVar({
    name
  }) {
    return [wireFormat.SexpOpcodes.GetDynamicVar, EXPR.expr(name)];
  }
  Log({
    positional
  }) {
    return [wireFormat.SexpOpcodes.Log, this.Positional(positional)];
  }
}
const EXPR = new ExpressionEncoder();

class WireStatements {
  constructor(statements) {
    this.statements = statements;
  }
  toArray() {
    return this.statements;
  }
}
class ContentEncoder {
  list(statements) {
    let out = [];
    for (let statement of statements) {
      let result = CONTENT.content(statement);
      if (result && result instanceof WireStatements) {
        out.push(...result.toArray());
      } else {
        out.push(result);
      }
    }
    return out;
  }
  content(stmt) {
    return this.visitContent(stmt);
  }
  visitContent(stmt) {
    switch (stmt.type) {
      case 'Debugger':
        return [wireFormat.SexpOpcodes.Debugger, stmt.scope.getDebugInfo()];
      case 'AppendComment':
        return this.AppendComment(stmt);
      case 'AppendTextNode':
        return this.AppendTextNode(stmt);
      case 'AppendTrustedHTML':
        return this.AppendTrustedHTML(stmt);
      case 'Yield':
        return this.Yield(stmt);
      case 'Component':
        return this.Component(stmt);
      case 'SimpleElement':
        return this.SimpleElement(stmt);
      case 'InElement':
        return this.InElement(stmt);
      case 'InvokeBlock':
        return this.InvokeBlock(stmt);
      case 'If':
        return this.If(stmt);
      case 'Each':
        return this.Each(stmt);
      case 'With':
        return this.With(stmt);
      case 'Let':
        return this.Let(stmt);
      case 'WithDynamicVars':
        return this.WithDynamicVars(stmt);
      case 'InvokeComponent':
        return this.InvokeComponent(stmt);
      default:
        return util.exhausted(stmt);
    }
  }
  Yield({
    to,
    positional
  }) {
    return [wireFormat.SexpOpcodes.Yield, to, EXPR.Positional(positional)];
  }
  InElement({
    guid,
    insertBefore,
    destination,
    block
  }) {
    let wireBlock = CONTENT.NamedBlock(block)[1];
    // let guid = args.guid;
    let wireDestination = EXPR.expr(destination);
    let wireInsertBefore = EXPR.expr(insertBefore);
    if (wireInsertBefore === undefined) {
      return [wireFormat.SexpOpcodes.InElement, wireBlock, guid, wireDestination];
    } else {
      return [wireFormat.SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];
    }
  }
  InvokeBlock({
    head,
    args,
    blocks
  }) {
    return [wireFormat.SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];
  }
  AppendTrustedHTML({
    html
  }) {
    return [wireFormat.SexpOpcodes.TrustingAppend, EXPR.expr(html)];
  }
  AppendTextNode({
    text
  }) {
    return [wireFormat.SexpOpcodes.Append, EXPR.expr(text)];
  }
  AppendComment({
    value
  }) {
    return [wireFormat.SexpOpcodes.Comment, value.chars];
  }
  SimpleElement({
    tag,
    params,
    body,
    dynamicFeatures
  }) {
    let op = dynamicFeatures ? wireFormat.SexpOpcodes.OpenElementWithSplat : wireFormat.SexpOpcodes.OpenElement;
    return new WireStatements([[op, deflateTagName(tag.chars)], ...CONTENT.ElementParameters(params).toArray(), [wireFormat.SexpOpcodes.FlushElement], ...CONTENT.list(body), [wireFormat.SexpOpcodes.CloseElement]]);
  }
  Component({
    tag,
    params,
    args,
    blocks
  }) {
    let wireTag = EXPR.expr(tag);
    let wirePositional = CONTENT.ElementParameters(params);
    let wireNamed = EXPR.NamedArguments(args);
    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);
    return [wireFormat.SexpOpcodes.Component, wireTag, wirePositional.toPresentArray(), wireNamed, wireNamedBlocks];
  }
  ElementParameters({
    body
  }) {
    return body.map(p => CONTENT.ElementParameter(p));
  }
  ElementParameter(param) {
    switch (param.type) {
      case 'SplatAttr':
        return [wireFormat.SexpOpcodes.AttrSplat, param.symbol];
      case 'DynamicAttr':
        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];
      case 'StaticAttr':
        return [staticAttrOp(param.kind), ...staticAttr(param)];
      case 'Modifier':
        return [wireFormat.SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];
    }
  }
  NamedBlocks({
    blocks
  }) {
    let names = [];
    let serializedBlocks = [];
    for (let block of blocks.toArray()) {
      let [name, serializedBlock] = CONTENT.NamedBlock(block);
      names.push(name);
      serializedBlocks.push(serializedBlock);
    }
    return names.length > 0 ? [names, serializedBlocks] : null;
  }
  NamedBlock({
    name,
    body,
    scope
  }) {
    let nameChars = name.chars;
    if (nameChars === 'inverse') {
      nameChars = 'else';
    }
    return [nameChars, [CONTENT.list(body), scope.slots]];
  }
  If({
    condition,
    block,
    inverse
  }) {
    return [wireFormat.SexpOpcodes.If, EXPR.expr(condition), CONTENT.NamedBlock(block)[1], inverse ? CONTENT.NamedBlock(inverse)[1] : null];
  }
  Each({
    value,
    key,
    block,
    inverse
  }) {
    return [wireFormat.SexpOpcodes.Each, EXPR.expr(value), key ? EXPR.expr(key) : null, CONTENT.NamedBlock(block)[1], inverse ? CONTENT.NamedBlock(inverse)[1] : null];
  }
  With({
    value,
    block,
    inverse
  }) {
    return [wireFormat.SexpOpcodes.With, EXPR.expr(value), CONTENT.NamedBlock(block)[1], inverse ? CONTENT.NamedBlock(inverse)[1] : null];
  }
  Let({
    positional,
    block
  }) {
    return [wireFormat.SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];
  }
  WithDynamicVars({
    named,
    block
  }) {
    return [wireFormat.SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];
  }
  InvokeComponent({
    definition,
    args,
    blocks
  }) {
    return [wireFormat.SexpOpcodes.InvokeComponent, EXPR.expr(definition), EXPR.Positional(args.positional), EXPR.NamedArguments(args.named), blocks ? CONTENT.NamedBlocks(blocks) : null];
  }
}
const CONTENT = new ContentEncoder();
function staticAttr({
  name,
  value,
  namespace
}) {
  let out = [deflateAttrName(name.chars), value.chars];
  if (namespace) {
    out.push(namespace);
  }
  return out;
}
function dynamicAttr({
  name,
  value,
  namespace
}) {
  let out = [deflateAttrName(name.chars), EXPR.expr(value)];
  if (namespace) {
    out.push(namespace);
  }
  return out;
}
function staticAttrOp(kind) {
  if (kind.component) {
    return wireFormat.SexpOpcodes.StaticComponentAttr;
  } else {
    return wireFormat.SexpOpcodes.StaticAttr;
  }
}
function dynamicAttrOp(kind) {
  if (kind.component) {
    return kind.trusting ? wireFormat.SexpOpcodes.TrustingComponentAttr : wireFormat.SexpOpcodes.ComponentAttr;
  } else {
    return kind.trusting ? wireFormat.SexpOpcodes.TrustingDynamicAttr : wireFormat.SexpOpcodes.DynamicAttr;
  }
}

function visit(template) {
  let statements = CONTENT.list(template.body);
  let scope = template.scope;
  let block = [statements, scope.symbols, scope.hasEval, scope.upvars];
  return block;
}

const defaultId = (() => {
  const req = typeof module === 'object' && typeof module.require === 'function' ? module.require : globalThis.require;
  if (req) {
    try {
      const crypto = req('crypto');
      const idFn = src => {
        const hash = crypto.createHash('sha1');
        hash.update(src, 'utf8');
        // trim to 6 bytes of data (2^48 - 1)
        return hash.digest('base64').substring(0, 8);
      };
      idFn('test');
      return idFn;
    } catch {
      // do nothing
    }
  }
  return function idFn() {
    return null;
  };
})();
const defaultOptions = {
  id: defaultId
};

/*
 * Compile a string into a template javascript string.
 *
 * Example usage:
 *     import { precompile } from '@glimmer/compiler';
 *     import { templateFactory } from 'glimmer-runtime';
 *     let templateJs = precompile("Howdy {{name}}");
 *     let factory = templateFactory(new Function("return " + templateJs)());
 *     let template = factory.create(env);
 *
 * @method precompile
 * @param {string} string a Glimmer template string
 * @return {string} a template javascript string
 */
function precompileJSON(string, options = defaultOptions) {
  const source = new syntax.src.Source(string ?? '', options.meta?.moduleName);
  const [ast, locals] = syntax.normalize(source, {
    lexicalScope: () => false,
    ...options
  });
  const block = normalize(source, ast, options.strictMode ?? false).mapOk(pass2In => {
    return visit(pass2In);
  });
  if (block.isOk) {
    return [block.value, locals];
  } else {
    throw block.reason;
  }
}

// UUID used as a unique placeholder for placing a snippet of JS code into
// the otherwise JSON stringified value below.
const SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';

/*
 * Compile a string into a template javascript string.
 *
 * Example usage:
 *     import { precompile } from '@glimmer/compiler';
 *     import { templateFactory } from 'glimmer-runtime';
 *     let templateJs = precompile("Howdy {{name}}");
 *     let factory = templateFactory(new Function("return " + templateJs)());
 *     let template = factory.create(env);
 *
 * @method precompile
 * @param {string} string a Glimmer template string
 * @return {string} a template javascript string
 */
function precompile(source, options = defaultOptions) {
  const [block, usedLocals] = precompileJSON(source, options);
  const moduleName = options.meta?.moduleName;
  const idFn = options.id || defaultId;
  const blockJSON = JSON.stringify(block);
  const templateJSONObject = {
    id: idFn(JSON.stringify(options.meta) + blockJSON),
    block: blockJSON,
    moduleName: moduleName ?? '(unknown template module)',
    // lying to the type checker here because we're going to
    // replace it just below, after stringification
    scope: SCOPE_PLACEHOLDER,
    isStrictMode: options.strictMode ?? false
  };
  if (usedLocals.length === 0) {
    delete templateJSONObject.scope;
  }

  // JSON is javascript
  let stringified = JSON.stringify(templateJSONObject);
  if (usedLocals.length > 0) {
    const scopeFn = `()=>[${usedLocals.join(',')}]`;
    stringified = stringified.replace(`"${SCOPE_PLACEHOLDER}"`, scopeFn);
  }
  return stringified;
}

exports.Builder = Builder;
exports.NEWLINE = NEWLINE;
exports.ProgramSymbols = ProgramSymbols;
exports.WireFormatDebugger = WireFormatDebugger;
exports.buildStatement = buildStatement;
exports.buildStatements = buildStatements;
exports.c = c;
exports.defaultId = defaultId;
exports.precompile = precompile;
exports.precompileJSON = precompileJSON;
exports.s = s;
exports.unicode = unicode;
//# sourceMappingURL=index.cjs.map
