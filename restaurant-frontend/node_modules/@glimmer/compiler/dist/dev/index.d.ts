import { Nullable, PresentArray, WireFormat, Dict, SerializedTemplateBlock, TemplateJavascript } from "@glimmer/interfaces";
import { PrecompileOptions, PrecompileOptionsWithLexicalScope, TemplateIdFn } from "@glimmer/syntax";
type BuilderParams = BuilderExpression[];
type BuilderHash = Nullable<Dict<BuilderExpression>>;
type BuilderBlockHash = BuilderHash | {
    as: string | string[];
};
type BuilderBlocks = Dict<BuilderBlock>;
type BuilderAttrs = Dict<BuilderAttr>;
type NormalizedParams = NormalizedExpression[];
type NormalizedHash = Dict<NormalizedExpression>;
type NormalizedBlock = NormalizedStatement[];
type NormalizedBlocks = Dict<NormalizedBlock>;
type NormalizedAttrs = Dict<NormalizedAttr>;
type NormalizedAttr = HeadKind.Splat | NormalizedExpression;
declare enum HeadKind {
    Block = "Block",
    Call = "Call",
    Element = "Element",
    AppendPath = "AppendPath",
    AppendExpr = "AppendExpr",
    Literal = "Literal",
    Modifier = "Modifier",
    DynamicComponent = "DynamicComponent",
    Comment = "Comment",
    Splat = "Splat",
    Keyword = "Keyword"
}
declare enum VariableKind {
    Local = "Local",
    Free = "Free",
    Arg = "Arg",
    Block = "Block",
    This = "This"
}
interface Variable {
    kind: VariableKind;
    name: string;
    /**
     * Differences:
     *
     * - strict mode variables always refer to in-scope variables
     * - loose mode variables use this algorithm:
     *   1. otherwise, fall back to `this.<name>`
     */
    mode: "loose" | "strict";
}
interface Path {
    head: Variable;
    tail: PresentArray<string>;
}
interface AppendExpr {
    kind: HeadKind.AppendExpr;
    expr: NormalizedExpression;
    trusted: boolean;
}
interface AppendPath {
    kind: HeadKind.AppendPath;
    path: NormalizedPath;
    trusted: boolean;
}
interface NormalizedKeywordStatement {
    kind: HeadKind.Keyword;
    name: string;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    blockParams: Nullable<string[]>;
    blocks: NormalizedBlocks;
}
type NormalizedStatement = {
    kind: HeadKind.Call;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    trusted: boolean;
} | {
    kind: HeadKind.Block;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    blockParams: Nullable<string[]>;
    blocks: NormalizedBlocks;
} | NormalizedKeywordStatement | {
    kind: HeadKind.Element;
    name: string;
    attrs: NormalizedAttrs;
    block: NormalizedBlock;
} | {
    kind: HeadKind.Comment;
    value: string;
} | {
    kind: HeadKind.Literal;
    value: string;
} | AppendPath | AppendExpr | {
    kind: HeadKind.Modifier;
    params: NormalizedParams;
    hash: Nullable<NormalizedHash>;
} | {
    kind: HeadKind.DynamicComponent;
    expr: NormalizedExpression;
    hash: Nullable<NormalizedHash>;
    block: NormalizedBlock;
};
type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;
type BuilderBlockStatement = [
    string,
    BuilderBlock | BuilderBlocks
] | [
    string,
    BuilderParams | BuilderBlockHash,
    BuilderBlock | BuilderBlocks
] | [
    string,
    BuilderParams,
    BuilderBlockHash,
    BuilderBlock | BuilderBlocks
];
type BuilderElement = [
    string
] | [
    string,
    BuilderAttrs,
    BuilderBlock
] | [
    string,
    BuilderBlock
] | [
    string,
    BuilderAttrs
];
type BuilderComment = [
    Builder.Comment,
    string
];
declare enum Builder {
    Literal = 0,
    Comment = 1,
    Append = 2,
    Modifier = 3,
    DynamicComponent = 4,
    Get = 5,
    Concat = 6,
    HasBlock = 7,
    HasBlockParams = 8
}
type VerboseStatement = [
    Builder.Literal,
    string
] | [
    Builder.Comment,
    string
] | [
    Builder.Append,
    BuilderExpression,
    true
] | [
    Builder.Append,
    BuilderExpression
] | [
    Builder.Modifier,
    Params,
    Hash
] | [
    Builder.DynamicComponent,
    BuilderExpression,
    Hash,
    BuilderBlock
];
type BuilderStatement = VerboseStatement | SugaryArrayStatement | TupleBuilderExpression | string;
type BuilderAttr = "splat" | BuilderExpression;
type TupleBuilderExpression = [
    Builder.Literal,
    string | boolean | null | undefined
] | [
    Builder.Get,
    string
] | [
    Builder.Get,
    string,
    string[]
] | [
    Builder.Concat,
    ...BuilderExpression[]
] | [
    Builder.HasBlock,
    string
] | [
    Builder.HasBlockParams,
    string
] | BuilderCallExpression;
type Params = BuilderParams;
type Hash = Dict<BuilderExpression>;
declare enum ExpressionKind {
    Literal = "Literal",
    Call = "Call",
    GetPath = "GetPath",
    GetVar = "GetVar",
    Concat = "Concat",
    HasBlock = "HasBlock",
    HasBlockParams = "HasBlockParams"
}
interface NormalizedCallExpression {
    type: ExpressionKind.Call;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
}
interface NormalizedPath {
    type: ExpressionKind.GetPath;
    path: Path;
}
interface NormalizedVar {
    type: ExpressionKind.GetVar;
    variable: Variable;
}
type NormalizedHead = NormalizedPath | NormalizedVar;
interface NormalizedConcat {
    type: ExpressionKind.Concat;
    params: [
        NormalizedExpression,
        ...NormalizedExpression[]
    ];
}
type NormalizedExpression = {
    type: ExpressionKind.Literal;
    value: null | undefined | boolean | string | number;
} | NormalizedCallExpression | NormalizedPath | NormalizedVar | NormalizedConcat | {
    type: ExpressionKind.HasBlock;
    name: string;
} | {
    type: ExpressionKind.HasBlockParams;
    name: string;
};
// | [Builder.Get, string]
// | [Builder.Get, string, string[]]
// | [Builder.Concat, Params]
// | [Builder.HasBlock, string]
// | [Builder.HasBlockParams, string]
type BuilderExpression = TupleBuilderExpression | BuilderCallExpression | null | undefined | boolean | string | number;
type MiniBuilderBlock = BuilderStatement[];
type BuilderBlock = MiniBuilderBlock;
type BuilderCallExpression = [
    string
] | [
    string,
    Params | Hash
] | [
    string,
    Params,
    Hash
];
interface Symbols {
    top: ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(params: string[]): LocalSymbols;
}
declare class ProgramSymbols implements Symbols {
    _freeVariables: string[];
    _symbols: string[];
    top: this;
    toSymbols(): string[];
    toUpvars(): string[];
    freeVar(name: string): number;
    block(name: string): number;
    arg(name: string): number;
    local(name: string): never;
    this(): number;
    hasLocal(_name: string): false;
    // any symbol
    symbol(name: string): number;
    child(locals: string[]): LocalSymbols;
}
declare class LocalSymbols implements Symbols {
    private parent;
    private locals;
    constructor(parent: Symbols, locals: string[]);
    get paramSymbols(): number[];
    get top(): ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(locals: string[]): LocalSymbols;
}
declare function buildStatements(statements: BuilderStatement[], symbols: Symbols): WireFormat.Statement[];
declare function buildStatement(normalized: NormalizedStatement, symbols?: Symbols): WireFormat.Statement[];
declare function s(arr: TemplateStringsArray, ...interpolated: unknown[]): [
    Builder.Literal,
    string
];
declare function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment;
declare function unicode(charCode: string): string;
declare const NEWLINE = "\n";
declare const defaultId: TemplateIdFn;
/*
* Compile a string into a template javascript string.
*
* Example usage:
*     import { precompile } from '@glimmer/compiler';
*     import { templateFactory } from 'glimmer-runtime';
*     let templateJs = precompile("Howdy {{name}}");
*     let factory = templateFactory(new Function("return " + templateJs)());
*     let template = factory.create(env);
*
* @method precompile
* @param {string} string a Glimmer template string
* @return {string} a template javascript string
*/
declare function precompileJSON(string: Nullable<string>, options?: PrecompileOptions | PrecompileOptionsWithLexicalScope): [
    block: SerializedTemplateBlock,
    usedLocals: string[]
];
/*
* Compile a string into a template javascript string.
*
* Example usage:
*     import { precompile } from '@glimmer/compiler';
*     import { templateFactory } from 'glimmer-runtime';
*     let templateJs = precompile("Howdy {{name}}");
*     let factory = templateFactory(new Function("return " + templateJs)());
*     let template = factory.create(env);
*
* @method precompile
* @param {string} string a Glimmer template string
* @return {string} a template javascript string
*/
declare function precompile(source: string, options?: PrecompileOptions | PrecompileOptionsWithLexicalScope): TemplateJavascript;
declare class WireFormatDebugger {
    private upvars;
    private symbols;
    constructor([_statements, symbols, _hasEval, upvars]: SerializedTemplateBlock);
    format(program: SerializedTemplateBlock): unknown;
    formatOpcode(opcode: WireFormat.Syntax): unknown;
    private formatCurryType;
    private formatElementParams;
    private formatParams;
    private formatHash;
    private formatBlocks;
    private formatBlock;
}
export { buildStatement, buildStatements, c, NEWLINE, ProgramSymbols, s, unicode, Builder, BuilderStatement, defaultId, precompile, precompileJSON, PrecompileOptions, WireFormatDebugger };
//# sourceMappingURL=index.d.ts.map