{"version":3,"file":"index.js","sources":["../../lib/builder/builder-interface.ts","../../lib/builder/builder.ts","../../../local-debug-flags/index.ts","../../lib/passes/2-encoding/mir.ts","../../lib/shared/list.ts","../../lib/shared/result.ts","../../lib/passes/1-normalization/utils/is-node.ts","../../lib/passes/1-normalization/visitors/expressions.ts","../../lib/passes/1-normalization/keywords/impl.ts","../../lib/passes/1-normalization/keywords/utils/call-to-append.ts","../../lib/passes/1-normalization/keywords/utils/curry.ts","../../lib/passes/1-normalization/keywords/utils/dynamic-vars.ts","../../lib/passes/1-normalization/keywords/utils/has-block.ts","../../lib/passes/1-normalization/keywords/utils/if-unless.ts","../../lib/passes/1-normalization/keywords/utils/log.ts","../../lib/passes/1-normalization/keywords/append.ts","../../lib/passes/1-normalization/keywords/block.ts","../../lib/passes/1-normalization/keywords/call.ts","../../lib/passes/1-normalization/keywords/modifier.ts","../../lib/utils.ts","../../lib/passes/1-normalization/visitors/element/classified.ts","../../lib/passes/1-normalization/visitors/element/component.ts","../../lib/passes/1-normalization/visitors/element/simple-element.ts","../../lib/passes/1-normalization/visitors/statements.ts","../../lib/passes/1-normalization/context.ts","../../lib/wire-format-debug.ts","../../lib/passes/2-encoding/expressions.ts","../../lib/passes/2-encoding/content.ts","../../lib/compiler.ts","../../lib/passes/1-normalization/index.ts","../../lib/passes/2-encoding/index.ts"],"sourcesContent":["import type { Dict, DictValue, Nullable, PresentArray } from '@glimmer/interfaces';\nimport { assertNever, dict, expect, isPresentArray } from '@glimmer/util';\n\nexport type BuilderParams = BuilderExpression[];\nexport type BuilderHash = Nullable<Dict<BuilderExpression>>;\nexport type BuilderBlockHash = BuilderHash | { as: string | string[] };\nexport type BuilderBlocks = Dict<BuilderBlock>;\nexport type BuilderAttrs = Dict<BuilderAttr>;\n\nexport type NormalizedParams = NormalizedExpression[];\nexport type NormalizedHash = Dict<NormalizedExpression>;\nexport type NormalizedBlock = NormalizedStatement[];\nexport type NormalizedBlocks = Dict<NormalizedBlock>;\nexport type NormalizedAttrs = Dict<NormalizedAttr>;\nexport type NormalizedAttr = HeadKind.Splat | NormalizedExpression;\n\nexport interface NormalizedElement {\n  name: string;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface NormalizedAngleInvocation {\n  head: NormalizedExpression;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport enum HeadKind {\n  Block = 'Block',\n  Call = 'Call',\n  Element = 'Element',\n  AppendPath = 'AppendPath',\n  AppendExpr = 'AppendExpr',\n  Literal = 'Literal',\n  Modifier = 'Modifier',\n  DynamicComponent = 'DynamicComponent',\n  Comment = 'Comment',\n  Splat = 'Splat',\n  Keyword = 'Keyword',\n}\n\nexport enum VariableKind {\n  Local = 'Local',\n  Free = 'Free',\n  Arg = 'Arg',\n  Block = 'Block',\n  This = 'This',\n}\n\nexport interface Variable {\n  kind: VariableKind;\n  name: string;\n  /**\n   * Differences:\n   *\n   * - strict mode variables always refer to in-scope variables\n   * - loose mode variables use this algorithm:\n   *   1. otherwise, fall back to `this.<name>`\n   */\n  mode: 'loose' | 'strict';\n}\n\nexport interface Path {\n  head: Variable;\n  tail: PresentArray<string>;\n}\n\nexport interface AppendExpr {\n  kind: HeadKind.AppendExpr;\n  expr: NormalizedExpression;\n  trusted: boolean;\n}\n\nexport interface AppendPath {\n  kind: HeadKind.AppendPath;\n  path: NormalizedPath;\n  trusted: boolean;\n}\n\nexport interface NormalizedKeywordStatement {\n  kind: HeadKind.Keyword;\n  name: string;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport type NormalizedStatement =\n  | {\n      kind: HeadKind.Call;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      trusted: boolean;\n    }\n  | {\n      kind: HeadKind.Block;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      blockParams: Nullable<string[]>;\n      blocks: NormalizedBlocks;\n    }\n  | NormalizedKeywordStatement\n  | {\n      kind: HeadKind.Element;\n      name: string;\n      attrs: NormalizedAttrs;\n      block: NormalizedBlock;\n    }\n  | { kind: HeadKind.Comment; value: string }\n  | { kind: HeadKind.Literal; value: string }\n  | AppendPath\n  | AppendExpr\n  | { kind: HeadKind.Modifier; params: NormalizedParams; hash: Nullable<NormalizedHash> }\n  | {\n      kind: HeadKind.DynamicComponent;\n      expr: NormalizedExpression;\n      hash: Nullable<NormalizedHash>;\n      block: NormalizedBlock;\n    };\n\nexport function normalizeStatement(statement: BuilderStatement): NormalizedStatement {\n  if (Array.isArray(statement)) {\n    if (statementIsExpression(statement)) {\n      return normalizeAppendExpression(statement);\n    } else if (isSugaryArrayStatement(statement)) {\n      return normalizeSugaryArrayStatement(statement);\n    } else {\n      return normalizeVerboseStatement(statement);\n    }\n  } else if (typeof statement === 'string') {\n    return normalizeAppendHead(normalizeDottedPath(statement), false);\n  } else {\n    throw assertNever(statement);\n  }\n}\n\nexport function normalizeAppendHead(\n  head: NormalizedHead,\n  trusted: boolean\n): AppendExpr | AppendPath {\n  if (head.type === ExpressionKind.GetPath) {\n    return {\n      kind: HeadKind.AppendPath,\n      path: head,\n      trusted,\n    };\n  } else {\n    return {\n      kind: HeadKind.AppendExpr,\n      expr: head,\n      trusted,\n    };\n  }\n}\n\nfunction isSugaryArrayStatement(statement: BuilderStatement): statement is SugaryArrayStatement {\n  if (Array.isArray(statement) && typeof statement[0] === 'string') {\n    switch (statement[0][0]) {\n      case '(':\n      case '#':\n      case '<':\n      case '!':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nexport type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;\n\nexport function normalizeSugaryArrayStatement(\n  statement: SugaryArrayStatement\n): NormalizedStatement {\n  const name = statement[0];\n\n  switch (name[0]) {\n    case '(': {\n      let params: Nullable<NormalizedParams> = null;\n      let hash: Nullable<NormalizedHash> = null;\n\n      if (statement.length === 3) {\n        params = normalizeParams(statement[1] as Params);\n        hash = normalizeHash(statement[2] as Hash);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          params = normalizeParams(statement[1] as Params);\n        } else {\n          hash = normalizeHash(statement[1] as Hash);\n        }\n      }\n\n      return {\n        kind: HeadKind.Call,\n        head: normalizeCallHead(name),\n        params,\n        hash,\n        trusted: false,\n      };\n    }\n\n    case '#': {\n      const {\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      } = normalizeBuilderBlockStatement(statement as BuilderBlockStatement);\n\n      return {\n        kind: HeadKind.Block,\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '!': {\n      const name = statement[0].slice(1);\n      const { params, hash, blocks, blockParams } = normalizeBuilderBlockStatement(\n        statement as BuilderBlockStatement\n      );\n\n      return {\n        kind: HeadKind.Keyword,\n        name,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '<': {\n      let attrs: NormalizedAttrs = dict();\n      let block: NormalizedBlock = [];\n\n      if (statement.length === 3) {\n        attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        block = normalizeBlock(statement[2] as BuilderBlock);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          block = normalizeBlock(statement[1] as BuilderBlock);\n        } else {\n          attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        }\n      }\n\n      return {\n        kind: HeadKind.Element,\n        name: expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),\n        attrs,\n        block,\n      };\n    }\n\n    default:\n      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);\n  }\n}\n\nfunction normalizeVerboseStatement(statement: VerboseStatement): NormalizedStatement {\n  switch (statement[0]) {\n    case Builder.Literal: {\n      return {\n        kind: HeadKind.Literal,\n        value: statement[1],\n      };\n    }\n\n    case Builder.Append: {\n      return normalizeAppendExpression(statement[1], statement[2]);\n    }\n\n    case Builder.Modifier: {\n      return {\n        kind: HeadKind.Modifier,\n        params: normalizeParams(statement[1]),\n        hash: normalizeHash(statement[2]),\n      };\n    }\n\n    case Builder.DynamicComponent: {\n      return {\n        kind: HeadKind.DynamicComponent,\n        expr: normalizeExpression(statement[1]),\n        hash: normalizeHash(statement[2]),\n        block: normalizeBlock(statement[3]),\n      };\n    }\n\n    case Builder.Comment: {\n      return {\n        kind: HeadKind.Comment,\n        value: statement[1],\n      };\n    }\n  }\n}\n\nfunction extractBlockHead(name: string): NormalizedHead {\n  const result = /^(#|!)(.*)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing # in block head`);\n  }\n\n  return normalizeDottedPath(result[2] as string);\n}\n\nfunction normalizeCallHead(name: string): NormalizedHead {\n  const result = /^\\((.*)\\)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing () in call head`);\n  }\n\n  return normalizeDottedPath(result[1] as string);\n}\n\nfunction normalizePath(head: string, tail: string[] = []): NormalizedHead {\n  const pathHead = normalizePathHead(head);\n\n  if (isPresentArray(tail)) {\n    return {\n      type: ExpressionKind.GetPath,\n      path: {\n        head: pathHead,\n        tail,\n      },\n    };\n  } else {\n    return {\n      type: ExpressionKind.GetVar,\n      variable: pathHead,\n    };\n  }\n}\n\nfunction normalizeDottedPath(whole: string): NormalizedHead {\n  const { kind, name: rest } = normalizePathHead(whole);\n\n  const [name, ...tail] = rest.split('.') as [string, ...string[]];\n\n  const variable: Variable = { kind, name, mode: 'loose' };\n\n  if (isPresentArray(tail)) {\n    return { type: ExpressionKind.GetPath, path: { head: variable, tail } };\n  } else {\n    return { type: ExpressionKind.GetVar, variable };\n  }\n}\n\nexport function normalizePathHead(whole: string): Variable {\n  let kind: VariableKind;\n  let name: string;\n\n  if (/^this(?:\\.|$)/u.test(whole)) {\n    return {\n      kind: VariableKind.This,\n      name: whole,\n      mode: 'loose',\n    };\n  }\n\n  switch (whole[0]) {\n    case '^':\n      kind = VariableKind.Free;\n      name = whole.slice(1);\n      break;\n\n    case '@':\n      kind = VariableKind.Arg;\n      name = whole.slice(1);\n      break;\n\n    case '&':\n      kind = VariableKind.Block;\n      name = whole.slice(1);\n      break;\n\n    default:\n      kind = VariableKind.Local;\n      name = whole;\n  }\n\n  return { kind, name, mode: 'loose' };\n}\n\nexport type BuilderBlockStatement =\n  | [string, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];\n\nexport interface NormalizedBuilderBlockStatement {\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport function normalizeBuilderBlockStatement(\n  statement: BuilderBlockStatement\n): NormalizedBuilderBlockStatement {\n  const head = statement[0];\n  let blocks: NormalizedBlocks = dict();\n  let params: Nullable<NormalizedParams> = null;\n  let hash: Nullable<NormalizedHash> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  if (statement.length === 2) {\n    blocks = normalizeBlocks(statement[1]);\n  } else if (statement.length === 3) {\n    if (Array.isArray(statement[1])) {\n      params = normalizeParams(statement[1]);\n    } else {\n      ({ hash, blockParams } = normalizeBlockHash(statement[1]));\n    }\n\n    blocks = normalizeBlocks(statement[2]);\n  } else if (statement.length === 4) {\n    params = normalizeParams(statement[1]);\n    ({ hash, blockParams } = normalizeBlockHash(statement[2]));\n    blocks = normalizeBlocks(statement[3]);\n  }\n\n  return {\n    head: extractBlockHead(head),\n    params,\n    hash,\n    blockParams,\n    blocks,\n  };\n}\n\nfunction normalizeBlockHash(hash: BuilderBlockHash): {\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n} {\n  if (hash === null) {\n    return { hash: null, blockParams: null };\n  }\n\n  let out: Nullable<Dict<NormalizedExpression>> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  entries(hash, (key, value) => {\n    if (key === 'as') {\n      blockParams = Array.isArray(value) ? (value as string[]) : [value as string];\n    } else {\n      out = out || dict();\n      out[key] = normalizeExpression(value as BuilderExpression);\n    }\n  });\n\n  return { hash: out, blockParams };\n}\n\nexport function entries<D extends Dict>(\n  dict: D,\n  callback: <K extends keyof D>(key: K, value: D[K]) => void\n): void {\n  Object.keys(dict).forEach((key) => {\n    const value = dict[key];\n    callback(key, value as D[keyof D]);\n  });\n}\n\nfunction normalizeBlocks(value: BuilderBlock | BuilderBlocks): NormalizedBlocks {\n  if (Array.isArray(value)) {\n    return { default: normalizeBlock(value) };\n  } else {\n    return mapObject(value, normalizeBlock);\n  }\n}\n\nfunction normalizeBlock(block: BuilderBlock): NormalizedBlock {\n  return block.map((s) => normalizeStatement(s));\n}\n\nfunction normalizeAttrs(attrs: BuilderAttrs): NormalizedAttrs {\n  return mapObject(attrs, (a) => normalizeAttr(a).expr);\n}\n\nfunction normalizeAttr(attr: BuilderAttr): { expr: NormalizedAttr; trusted: boolean } {\n  if (attr === 'splat') {\n    return { expr: HeadKind.Splat, trusted: false };\n  } else {\n    const expr = normalizeExpression(attr);\n    return { expr, trusted: false };\n  }\n}\n\nfunction mapObject<T extends Dict<unknown>, Out>(\n  object: T,\n  mapper: (value: DictValue<T>, key: keyof T) => Out\n): { [P in keyof T]: Out } {\n  const out = dict() as { [P in keyof T]?: Out };\n\n  Object.keys(object).forEach(<K extends keyof T>(k: K) => {\n    out[k] = mapper(object[k] as DictValue<T>, k);\n  });\n\n  return out as { [P in keyof T]: Out };\n}\n\nexport type BuilderElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport type BuilderComment = [Builder.Comment, string];\n\nexport type InvocationElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport function isElement(input: [string, ...unknown[]]): input is BuilderElement {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function extractElement(input: string): Nullable<string> {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input);\n\n  return match?.[1] ?? null;\n}\n\nexport function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement {\n  // TODO Paths\n  const match = /^<(@[\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement {\n  // TODO Paths\n  const match = /^#[\\s\\S]?([\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport enum Builder {\n  Literal,\n  Comment,\n  Append,\n  Modifier,\n  DynamicComponent,\n  Get,\n  Concat,\n  HasBlock,\n  HasBlockParams,\n}\n\nexport type VerboseStatement =\n  | [Builder.Literal, string]\n  | [Builder.Comment, string]\n  | [Builder.Append, BuilderExpression, true]\n  | [Builder.Append, BuilderExpression]\n  | [Builder.Modifier, Params, Hash]\n  | [Builder.DynamicComponent, BuilderExpression, Hash, BuilderBlock];\n\nexport type BuilderStatement =\n  | VerboseStatement\n  | SugaryArrayStatement\n  | TupleBuilderExpression\n  | string;\n\nexport type BuilderAttr = 'splat' | BuilderExpression;\n\nexport type TupleBuilderExpression =\n  | [Builder.Literal, string | boolean | null | undefined]\n  | [Builder.Get, string]\n  | [Builder.Get, string, string[]]\n  | [Builder.Concat, ...BuilderExpression[]]\n  | [Builder.HasBlock, string]\n  | [Builder.HasBlockParams, string]\n  | BuilderCallExpression;\n\ntype Params = BuilderParams;\ntype Hash = Dict<BuilderExpression>;\n\nexport enum ExpressionKind {\n  Literal = 'Literal',\n  Call = 'Call',\n  GetPath = 'GetPath',\n  GetVar = 'GetVar',\n  Concat = 'Concat',\n  HasBlock = 'HasBlock',\n  HasBlockParams = 'HasBlockParams',\n}\n\nexport interface NormalizedCallExpression {\n  type: ExpressionKind.Call;\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n}\n\nexport interface NormalizedPath {\n  type: ExpressionKind.GetPath;\n  path: Path;\n}\n\nexport interface NormalizedVar {\n  type: ExpressionKind.GetVar;\n  variable: Variable;\n}\n\nexport type NormalizedHead = NormalizedPath | NormalizedVar;\n\nexport interface NormalizedConcat {\n  type: ExpressionKind.Concat;\n  params: [NormalizedExpression, ...NormalizedExpression[]];\n}\n\nexport type NormalizedExpression =\n  | {\n      type: ExpressionKind.Literal;\n      value: null | undefined | boolean | string | number;\n    }\n  | NormalizedCallExpression\n  | NormalizedPath\n  | NormalizedVar\n  | NormalizedConcat\n  | {\n      type: ExpressionKind.HasBlock;\n      name: string;\n    }\n  | {\n      type: ExpressionKind.HasBlockParams;\n      name: string;\n    };\n\nexport function normalizeAppendExpression(\n  expression: BuilderExpression,\n  forceTrusted = false\n): AppendExpr | AppendPath {\n  if (expression === null || expression === undefined) {\n    return {\n      expr: {\n        type: ExpressionKind.Literal,\n        value: expression,\n      },\n      kind: HeadKind.AppendExpr,\n      trusted: false,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression[1] },\n          kind: HeadKind.AppendExpr,\n          trusted: false,\n        };\n\n      case Builder.Get: {\n        return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return {\n          expr,\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n      }\n\n      case Builder.HasBlock:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlock,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlockParams,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return {\n            expr: normalizeCallExpression(expression),\n            kind: HeadKind.AppendExpr,\n            trusted: forceTrusted,\n          };\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);\n      }\n      case 'boolean':\n      case 'number':\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression },\n          kind: HeadKind.AppendExpr,\n          trusted: true,\n        };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\nexport function normalizeExpression(expression: BuilderExpression): NormalizedExpression {\n  if (expression === null || expression === undefined) {\n    return {\n      type: ExpressionKind.Literal,\n      value: expression,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return { type: ExpressionKind.Literal, value: expression[1] };\n\n      case Builder.Get: {\n        return normalizePath(expression[1], expression[2]);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return expr;\n      }\n\n      case Builder.HasBlock:\n        return {\n          type: ExpressionKind.HasBlock,\n          name: expression[1],\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          type: ExpressionKind.HasBlockParams,\n          name: expression[1],\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return normalizeCallExpression(expression);\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeDottedPath(expression);\n      }\n      case 'boolean':\n      case 'number':\n        return { type: ExpressionKind.Literal, value: expression };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\n// | [Builder.Get, string]\n// | [Builder.Get, string, string[]]\n// | [Builder.Concat, Params]\n// | [Builder.HasBlock, string]\n// | [Builder.HasBlockParams, string]\n\nexport type BuilderExpression =\n  | TupleBuilderExpression\n  | BuilderCallExpression\n  | null\n  | undefined\n  | boolean\n  | string\n  | number;\n\nexport function isBuilderExpression(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is TupleBuilderExpression | BuilderCallExpression {\n  return Array.isArray(expr);\n}\n\nexport function isLiteral(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is [Builder.Literal, string | boolean | undefined] {\n  return Array.isArray(expr) && expr[0] === 'literal';\n}\n\nexport function statementIsExpression(\n  statement: BuilderStatement\n): statement is TupleBuilderExpression {\n  if (!Array.isArray(statement)) {\n    return false;\n  }\n\n  const name = statement[0];\n\n  if (typeof name === 'number') {\n    switch (name) {\n      case Builder.Literal:\n      case Builder.Get:\n      case Builder.Concat:\n      case Builder.HasBlock:\n      case Builder.HasBlockParams:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  if (name[0] === '(') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isBuilderCallExpression(\n  value: TupleBuilderExpression | BuilderCallExpression\n): value is BuilderCallExpression {\n  return typeof value[0] === 'string' && value[0][0] === '(';\n}\n\nexport type MiniBuilderBlock = BuilderStatement[];\n\nexport type BuilderBlock = MiniBuilderBlock;\n\nexport type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];\n\nexport function normalizeParams(input: Params): NormalizedParams {\n  return input.map(normalizeExpression);\n}\n\nexport function normalizeHash(input: Nullable<Hash>): Nullable<NormalizedHash> {\n  if (input === null) return null;\n  return mapObject(input, normalizeExpression);\n}\n\nexport function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression {\n  switch (expr.length) {\n    case 1:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: null,\n        hash: null,\n      };\n    case 2: {\n      if (Array.isArray(expr[1])) {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: normalizeParams(expr[1]),\n          hash: null,\n        };\n      } else {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: null,\n          hash: normalizeHash(expr[1]),\n        };\n      }\n    }\n\n    case 3:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: normalizeParams(expr[1]),\n        hash: normalizeHash(expr[2]),\n      };\n  }\n}\n","import type {\n  AttrNamespace,\n  Dict,\n  Expressions,\n  GetContextualFreeOpcode,\n  Nullable,\n  PresentArray,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  assertNever,\n  dict,\n  exhausted,\n  expect,\n  isPresentArray,\n  NS_XLINK,\n  NS_XML,\n  NS_XMLNS,\n  values,\n} from '@glimmer/util';\nimport { SexpOpcodes as Op, VariableResolutionContext } from '@glimmer/wire-format';\n\nimport type {\n  BuilderComment,\n  BuilderStatement,\n  NormalizedAngleInvocation,\n  NormalizedAttrs,\n  NormalizedBlock,\n  NormalizedBlocks,\n  NormalizedElement,\n  NormalizedExpression,\n  NormalizedHash,\n  NormalizedHead,\n  NormalizedKeywordStatement,\n  NormalizedParams,\n  NormalizedPath,\n  NormalizedStatement,\n  Variable,\n} from './builder-interface';\n\nimport {\n  Builder,\n  ExpressionKind,\n  HeadKind,\n  normalizeStatement,\n  VariableKind,\n} from './builder-interface';\n\ninterface Symbols {\n  top: ProgramSymbols;\n  freeVar(name: string): number;\n  arg(name: string): number;\n  block(name: string): number;\n  local(name: string): number;\n  this(): number;\n\n  hasLocal(name: string): boolean;\n\n  child(params: string[]): LocalSymbols;\n}\n\nexport class ProgramSymbols implements Symbols {\n  _freeVariables: string[] = [];\n  _symbols: string[] = ['this'];\n\n  top = this;\n\n  toSymbols(): string[] {\n    return this._symbols.slice(1);\n  }\n\n  toUpvars(): string[] {\n    return this._freeVariables;\n  }\n\n  freeVar(name: string): number {\n    return addString(this._freeVariables, name);\n  }\n\n  block(name: string): number {\n    return this.symbol(name);\n  }\n\n  arg(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  local(name: string): never {\n    throw new Error(\n      `No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`\n    );\n  }\n\n  this(): number {\n    return 0;\n  }\n\n  hasLocal(_name: string): false {\n    return false;\n  }\n\n  // any symbol\n  symbol(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nclass LocalSymbols implements Symbols {\n  private locals: Dict<number> = dict();\n\n  constructor(\n    private parent: Symbols,\n    locals: string[]\n  ) {\n    for (let local of locals) {\n      this.locals[local] = parent.top.symbol(local);\n    }\n  }\n\n  get paramSymbols(): number[] {\n    return values(this.locals);\n  }\n\n  get top(): ProgramSymbols {\n    return this.parent.top;\n  }\n\n  freeVar(name: string): number {\n    return this.parent.freeVar(name);\n  }\n\n  arg(name: string): number {\n    return this.parent.arg(name);\n  }\n\n  block(name: string): number {\n    return this.parent.block(name);\n  }\n\n  local(name: string): number {\n    if (name in this.locals) {\n      return this.locals[name] as number;\n    } else {\n      return this.parent.local(name);\n    }\n  }\n\n  this(): number {\n    return this.parent.this();\n  }\n\n  hasLocal(name: string): boolean {\n    if (name in this.locals) {\n      return true;\n    } else {\n      return this.parent.hasLocal(name);\n    }\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nfunction addString(array: string[], item: string): number {\n  let index = array.indexOf(item);\n\n  if (index === -1) {\n    index = array.length;\n    array.push(item);\n    return index;\n  } else {\n    return index;\n  }\n}\n\nexport interface BuilderGetFree {\n  type: 'GetFree';\n  head: string;\n  tail: string[];\n}\n\nfunction unimpl(message: string): Error {\n  return new Error(`unimplemented ${message}`);\n}\n\nexport function buildStatements(\n  statements: BuilderStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(normalizeStatement(s), symbols)));\n\n  return out;\n}\n\nexport function buildNormalizedStatements(\n  statements: NormalizedStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(s, symbols)));\n\n  return out;\n}\n\nexport function buildStatement(\n  normalized: NormalizedStatement,\n  symbols: Symbols = new ProgramSymbols()\n): WireFormat.Statement[] {\n  switch (normalized.kind) {\n    case HeadKind.AppendPath: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildGetPath(normalized.path, symbols),\n        ],\n      ];\n    }\n\n    case HeadKind.AppendExpr: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildExpression(\n            normalized.expr,\n            normalized.trusted ? 'TrustedAppend' : 'Append',\n            symbols\n          ),\n        ],\n      ];\n    }\n\n    case HeadKind.Call: {\n      let { head: path, params, hash, trusted } = normalized;\n      let builtParams: Nullable<WireFormat.Core.Params> = params\n        ? buildParams(params, symbols)\n        : null;\n      let builtHash: WireFormat.Core.Hash = hash ? buildHash(hash, symbols) : null;\n      let builtExpr: WireFormat.Expression = buildCallHead(\n        path,\n        trusted\n          ? VariableResolutionContext.AmbiguousInvoke\n          : VariableResolutionContext.AmbiguousAppendInvoke,\n        symbols\n      );\n\n      return [\n        [trusted ? Op.TrustingAppend : Op.Append, [Op.Call, builtExpr, builtParams, builtHash]],\n      ];\n    }\n\n    case HeadKind.Literal: {\n      return [[Op.Append, normalized.value]];\n    }\n\n    case HeadKind.Comment: {\n      return [[Op.Comment, normalized.value]];\n    }\n\n    case HeadKind.Block: {\n      let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);\n      let hash = buildHash(normalized.hash, symbols);\n      let params = buildParams(normalized.params, symbols);\n      let path = buildCallHead(\n        normalized.head,\n        VariableResolutionContext.ResolveAsComponentHead,\n        symbols\n      );\n\n      return [[Op.Block, path, params, hash, blocks]];\n    }\n\n    case HeadKind.Keyword: {\n      return [buildKeyword(normalized, symbols)];\n    }\n\n    case HeadKind.Element:\n      return buildElement(normalized, symbols);\n\n    case HeadKind.Modifier:\n      throw unimpl('modifier');\n\n    case HeadKind.DynamicComponent:\n      throw unimpl('dynamic component');\n\n    default:\n      throw assertNever(normalized);\n  }\n}\n\nexport function s(\n  arr: TemplateStringsArray,\n  ...interpolated: unknown[]\n): [Builder.Literal, string] {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Literal, result];\n}\n\nexport function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Comment, result];\n}\n\nexport function unicode(charCode: string): string {\n  return String.fromCharCode(parseInt(charCode, 16));\n}\n\nexport const NEWLINE = '\\n';\n\nfunction buildKeyword(\n  normalized: NormalizedKeywordStatement,\n  symbols: Symbols\n): WireFormat.Statement {\n  let { name } = normalized;\n  let params = buildParams(normalized.params, symbols);\n  let childSymbols = symbols.child(normalized.blockParams || []);\n\n  let block = buildBlock(\n    normalized.blocks['default'] as NormalizedBlock,\n    childSymbols,\n    childSymbols.paramSymbols\n  );\n  let inverse = normalized.blocks['else']\n    ? buildBlock(normalized.blocks['else'], symbols, [])\n    : null;\n\n  switch (name) {\n    case 'with':\n      return [Op.With, expect(params, 'with requires params')[0], block, inverse];\n    case 'if':\n      return [Op.If, expect(params, 'if requires params')[0], block, inverse];\n    case 'each': {\n      let keyExpr = normalized.hash ? normalized.hash['key'] : null;\n      let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;\n      return [Op.Each, expect(params, 'if requires params')[0], key, block, inverse];\n    }\n\n    default:\n      throw new Error('unimplemented keyword');\n  }\n}\n\nfunction buildElement(\n  { name, attrs, block }: NormalizedElement,\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [\n    hasSplat(attrs) ? [Op.OpenElementWithSplat, name] : [Op.OpenElement, name],\n  ];\n  if (attrs) {\n    let { params, args } = buildElementParams(attrs, symbols);\n    out.push(...params);\n    assert(args === null, `Can't pass args to a simple element`);\n  }\n  out.push([Op.FlushElement]);\n\n  if (Array.isArray(block)) {\n    block.forEach((s) => out.push(...buildStatement(s, symbols)));\n  } else if (block === null) {\n    // do nothing\n  } else {\n    throw assertNever(block);\n  }\n\n  out.push([Op.CloseElement]);\n\n  return out;\n}\n\nfunction hasSplat(attrs: Nullable<NormalizedAttrs>): boolean {\n  if (attrs === null) return false;\n\n  return Object.keys(attrs).some((a) => attrs[a] === HeadKind.Splat);\n}\n\nexport function buildAngleInvocation(\n  { attrs, block, head }: NormalizedAngleInvocation,\n  symbols: Symbols\n): WireFormat.Statements.Component {\n  let paramList: WireFormat.ElementParameter[] = [];\n  let args: WireFormat.Core.Hash = null;\n  let blockList: WireFormat.Statement[] = [];\n\n  if (attrs) {\n    let built = buildElementParams(attrs, symbols);\n    paramList = built.params;\n    args = built.args;\n  }\n\n  if (block) blockList = buildNormalizedStatements(block, symbols);\n\n  return [\n    Op.Component,\n    buildExpression(head, VariableResolutionContext.ResolveAsComponentHead, symbols),\n    isPresentArray(paramList) ? paramList : null,\n    args,\n    [['default'], [[blockList, []]]],\n  ];\n}\n\nexport function buildElementParams(\n  attrs: NormalizedAttrs,\n  symbols: Symbols\n): { params: WireFormat.ElementParameter[]; args: WireFormat.Core.Hash } {\n  let params: WireFormat.ElementParameter[] = [];\n  let keys: string[] = [];\n  let values: WireFormat.Expression[] = [];\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === HeadKind.Splat) {\n      params.push([Op.AttrSplat, symbols.block('&attrs')]);\n    } else if (key[0] === '@') {\n      keys.push(key);\n      values.push(buildExpression(value, 'Strict', symbols));\n    } else {\n      params.push(\n        ...buildAttributeValue(\n          key,\n          value,\n          // TODO: extract namespace from key\n          extractNamespace(key),\n          symbols\n        )\n      );\n    }\n  }\n\n  return { params, args: isPresentArray(keys) && isPresentArray(values) ? [keys, values] : null };\n}\n\nexport function extractNamespace(name: string): Nullable<AttrNamespace> {\n  if (name === 'xmlns') {\n    return NS_XMLNS;\n  }\n\n  let match = /^([^:]*):([^:]*)$/u.exec(name);\n\n  if (match === null) {\n    return null;\n  }\n\n  let namespace = match[1];\n\n  switch (namespace) {\n    case 'xlink':\n      return NS_XLINK;\n    case 'xml':\n      return NS_XML;\n    case 'xmlns':\n      return NS_XMLNS;\n  }\n\n  return null;\n}\n\nexport function buildAttributeValue(\n  name: string,\n  value: NormalizedExpression,\n  namespace: Nullable<AttrNamespace>,\n  symbols: Symbols\n): WireFormat.Attribute[] {\n  switch (value.type) {\n    case ExpressionKind.Literal: {\n      let val = value.value;\n\n      if (val === false) {\n        return [];\n      } else if (val === true) {\n        return [[Op.StaticAttr, name, '', namespace ?? undefined]];\n      } else if (typeof val === 'string') {\n        return [[Op.StaticAttr, name, val, namespace ?? undefined]];\n      } else {\n        throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);\n      }\n    }\n\n    default:\n      return [\n        [\n          Op.DynamicAttr,\n          name,\n          buildExpression(value, 'AttrValue', symbols),\n          namespace ?? undefined,\n        ],\n      ];\n  }\n}\n\ntype ExprResolution =\n  | VariableResolutionContext\n  | 'Append'\n  | 'TrustedAppend'\n  | 'AttrValue'\n  | 'SubExpression'\n  | 'Strict';\n\nfunction varContext(context: ExprResolution, bare: boolean): VarResolution {\n  switch (context) {\n    case 'Append':\n      return bare ? 'AppendBare' : 'AppendInvoke';\n    case 'TrustedAppend':\n      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';\n    case 'AttrValue':\n      return bare ? 'AttrValueBare' : 'AttrValueInvoke';\n    default:\n      return context;\n  }\n}\n\nexport function buildExpression(\n  expr: NormalizedExpression,\n  context: ExprResolution,\n  symbols: Symbols\n): WireFormat.Expression {\n  switch (expr.type) {\n    case ExpressionKind.GetPath: {\n      return buildGetPath(expr, symbols);\n    }\n\n    case ExpressionKind.GetVar: {\n      return buildVar(expr.variable, varContext(context, true), symbols);\n    }\n\n    case ExpressionKind.Concat: {\n      return [Op.Concat, buildConcat(expr.params, symbols)];\n    }\n\n    case ExpressionKind.Call: {\n      let builtParams = buildParams(expr.params, symbols);\n      let builtHash = buildHash(expr.hash, symbols);\n      let builtExpr = buildCallHead(\n        expr.head,\n        context === 'Strict' ? 'SubExpression' : varContext(context, false),\n        symbols\n      );\n\n      return [Op.Call, builtExpr, builtParams, builtHash];\n    }\n\n    case ExpressionKind.HasBlock: {\n      return [\n        Op.HasBlock,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.HasBlockParams: {\n      return [\n        Op.HasBlockParams,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.Literal: {\n      if (expr.value === undefined) {\n        return [Op.Undefined];\n      } else {\n        return expr.value;\n      }\n    }\n\n    default:\n      assertNever(expr);\n  }\n}\n\nexport function buildCallHead(\n  callHead: NormalizedHead,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar | Expressions.GetPath {\n  if (callHead.type === ExpressionKind.GetVar) {\n    return buildVar(callHead.variable, context, symbols);\n  } else {\n    return buildGetPath(callHead, symbols);\n  }\n}\n\nexport function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath {\n  return buildVar(head.path.head, VariableResolutionContext.Strict, symbols, head.path.tail);\n}\n\ntype VarResolution =\n  | VariableResolutionContext\n  | 'AppendBare'\n  | 'AppendInvoke'\n  | 'TrustedAppendBare'\n  | 'TrustedAppendInvoke'\n  | 'AttrValueBare'\n  | 'AttrValueInvoke'\n  | 'SubExpression'\n  | 'Strict';\n\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path: PresentArray<string>\n): Expressions.GetPath;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path?: PresentArray<string>\n): Expressions.GetPath | Expressions.GetVar {\n  let op: Expressions.GetVar[0] = Op.GetSymbol;\n  let sym: number;\n  switch (head.kind) {\n    case VariableKind.Free:\n      if (context === 'Strict') {\n        op = Op.GetStrictKeyword;\n      } else if (context === 'AppendBare') {\n        op = Op.GetFreeAsComponentOrHelperHeadOrThisFallback;\n      } else if (context === 'AppendInvoke') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'TrustedAppendBare') {\n        op = Op.GetFreeAsHelperHeadOrThisFallback;\n      } else if (context === 'TrustedAppendInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueBare') {\n        op = Op.GetFreeAsHelperHeadOrThisFallback;\n      } else if (context === 'AttrValueInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'SubExpression') {\n        op = Op.GetFreeAsHelperHead;\n      } else {\n        op = expressionContextOp(context);\n      }\n      sym = symbols.freeVar(head.name);\n      break;\n    default:\n      op = Op.GetSymbol;\n      sym = getSymbolForVar(head.kind, symbols, head.name);\n  }\n\n  if (path === undefined || path.length === 0) {\n    return [op, sym];\n  } else {\n    return [op, sym, path];\n  }\n}\n\nfunction getSymbolForVar(\n  kind: Exclude<VariableKind, VariableKind.Free>,\n  symbols: Symbols,\n  name: string\n) {\n  switch (kind) {\n    case VariableKind.Arg:\n      return symbols.arg(name);\n    case VariableKind.Block:\n      return symbols.block(name);\n    case VariableKind.Local:\n      return symbols.local(name);\n    case VariableKind.This:\n      return symbols.this();\n    default:\n      return exhausted(kind);\n  }\n}\n\nexport function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOpcode {\n  switch (context) {\n    case VariableResolutionContext.Strict:\n      return Op.GetStrictKeyword;\n    case VariableResolutionContext.AmbiguousAppend:\n      return Op.GetFreeAsComponentOrHelperHeadOrThisFallback;\n    case VariableResolutionContext.AmbiguousAppendInvoke:\n      return Op.GetFreeAsComponentOrHelperHead;\n    case VariableResolutionContext.AmbiguousInvoke:\n      return Op.GetFreeAsHelperHeadOrThisFallback;\n    case VariableResolutionContext.ResolveAsCallHead:\n      return Op.GetFreeAsHelperHead;\n    case VariableResolutionContext.ResolveAsModifierHead:\n      return Op.GetFreeAsModifierHead;\n    case VariableResolutionContext.ResolveAsComponentHead:\n      return Op.GetFreeAsComponentHead;\n    default:\n      return exhausted(context);\n  }\n}\n\nexport function buildParams(\n  exprs: Nullable<NormalizedParams>,\n  symbols: Symbols\n): Nullable<WireFormat.Core.Params> {\n  if (exprs === null || !isPresentArray(exprs)) return null;\n\n  return exprs.map((e) => buildExpression(e, 'Strict', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildConcat(\n  exprs: [NormalizedExpression, ...NormalizedExpression[]],\n  symbols: Symbols\n): WireFormat.Core.ConcatParams {\n  return exprs.map((e) => buildExpression(e, 'AttrValue', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildHash(exprs: Nullable<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash {\n  if (exprs === null) return null;\n\n  let out: [string[], WireFormat.Expression[]] = [[], []];\n\n  for (const [key, value] of Object.entries(exprs)) {\n    out[0].push(key);\n    out[1].push(buildExpression(value, 'Strict', symbols));\n  }\n\n  return out as WireFormat.Core.Hash;\n}\n\nexport function buildBlocks(\n  blocks: NormalizedBlocks,\n  blockParams: Nullable<string[]>,\n  parent: Symbols\n): WireFormat.Core.Blocks {\n  let keys: string[] = [];\n  let values: WireFormat.SerializedInlineBlock[] = [];\n\n  for (const [name, block] of Object.entries(blocks)) {\n    keys.push(name);\n\n    if (name === 'default') {\n      let symbols = parent.child(blockParams || []);\n\n      values.push(buildBlock(block, symbols, symbols.paramSymbols));\n    } else {\n      values.push(buildBlock(block, parent, []));\n    }\n  }\n\n  return [keys, values];\n}\n\nfunction buildBlock(\n  block: NormalizedBlock,\n  symbols: Symbols,\n  locals: number[] = []\n): WireFormat.SerializedInlineBlock {\n  return [buildNormalizedStatements(block, symbols), locals];\n}\n","export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { CurriedType, PresentArray } from '@glimmer/interfaces';\nimport type {\n  ASTv2,\n  BlockSymbolTable,\n  ProgramSymbolTable,\n  SourceSlice,\n  SymbolTable,\n} from '@glimmer/syntax';\nimport { node } from '@glimmer/syntax';\n\nimport type { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';\n\nexport class Template extends node('Template').fields<{\n  scope: ProgramSymbolTable;\n  body: Statement[];\n}>() {}\n\nexport class InElement extends node('InElement').fields<{\n  guid: string;\n  insertBefore: ExpressionNode | Missing;\n  destination: ExpressionNode;\n  block: NamedBlock;\n}>() {}\n\nexport class Not extends node('Not').fields<{ value: ExpressionNode }>() {}\n\nexport class If extends node('If').fields<{\n  condition: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class IfInline extends node('IfInline').fields<{\n  condition: ExpressionNode;\n  truthy: ExpressionNode;\n  falsy: ExpressionNode | null;\n}>() {}\n\nexport class Each extends node('Each').fields<{\n  value: ExpressionNode;\n  key: ExpressionNode | null;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class With extends node('With').fields<{\n  value: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class Let extends node('Let').fields<{\n  positional: Positional;\n  block: NamedBlock;\n}>() {}\n\nexport class WithDynamicVars extends node('WithDynamicVars').fields<{\n  named: NamedArguments;\n  block: NamedBlock;\n}>() {}\n\nexport class GetDynamicVar extends node('GetDynamicVar').fields<{\n  name: ExpressionNode;\n}>() {}\n\nexport class Log extends node('Log').fields<{\n  positional: Positional;\n}>() {}\n\nexport class InvokeComponent extends node('InvokeComponent').fields<{\n  definition: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks | null;\n}>() {}\n\nexport class NamedBlocks extends node('NamedBlocks').fields<{\n  blocks: OptionalList<NamedBlock>;\n}>() {}\n\nexport class NamedBlock extends node('NamedBlock').fields<{\n  scope: BlockSymbolTable;\n  name: SourceSlice;\n  body: Statement[];\n}>() {}\nexport class EndBlock extends node('EndBlock').fields() {}\nexport class AppendTrustedHTML extends node('AppendTrustedHTML').fields<{\n  html: ExpressionNode;\n}>() {}\nexport class AppendTextNode extends node('AppendTextNode').fields<{ text: ExpressionNode }>() {}\nexport class AppendComment extends node('AppendComment').fields<{ value: SourceSlice }>() {}\n\nexport class Component extends node('Component').fields<{\n  tag: ExpressionNode;\n  params: ElementParameters;\n  args: NamedArguments;\n  blocks: NamedBlocks;\n}>() {}\n\nexport interface AttrKind {\n  // triple-curly\n  trusting: boolean;\n  // this attribute is on an element with component features:\n  //   - <CapCase ...>\n  //   - modifiers\n  //   - <dynamic.tag ...>\n  component: boolean;\n}\n\nexport class StaticAttr extends node('StaticAttr').fields<{\n  kind: { component: boolean };\n  name: SourceSlice;\n  value: SourceSlice;\n  namespace?: string | undefined;\n}>() {}\n\nexport class DynamicAttr extends node('DynamicAttr').fields<{\n  kind: AttrKind;\n  name: SourceSlice;\n  value: ExpressionNode;\n  namespace?: string | undefined;\n}>() {}\n\nexport class SimpleElement extends node('SimpleElement').fields<{\n  tag: SourceSlice;\n  params: ElementParameters;\n  body: Statement[];\n  dynamicFeatures: boolean;\n}>() {}\n\nexport class ElementParameters extends node('ElementParameters').fields<{\n  body: AnyOptionalList<ElementParameter>;\n}>() {}\n\nexport class Yield extends node('Yield').fields<{\n  target: SourceSlice;\n  to: number;\n  positional: Positional;\n}>() {}\nexport class Debugger extends node('Debugger').fields<{ scope: SymbolTable }>() {}\n\nexport class CallExpression extends node('CallExpression').fields<{\n  callee: ExpressionNode;\n  args: Args;\n}>() {}\nexport class DeprecatedCallExpression extends node('DeprecatedCallExpression').fields<{\n  arg: SourceSlice;\n  callee: ASTv2.FreeVarReference;\n}>() {}\n\nexport class Modifier extends node('Modifier').fields<{ callee: ExpressionNode; args: Args }>() {}\nexport class InvokeBlock extends node('InvokeBlock').fields<{\n  head: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks;\n}>() {}\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\nexport class PathExpression extends node('PathExpression').fields<{\n  head: ExpressionNode;\n  tail: Tail;\n}>() {}\nexport class GetWithResolver extends node('GetWithResolver').fields<{\n  symbol: number;\n}>() {}\n\nexport class GetSymbol extends node('GetSymbol').fields<{ symbol: number }>() {}\nexport class GetFreeWithContext extends node('GetFreeWithContext').fields<{\n  symbol: number;\n  context: ASTv2.FreeVarResolution;\n}>() {}\n/** strict mode */\nexport class GetFree extends node('GetFree').fields<{\n  symbol: number;\n}>() {}\n\nexport class Missing extends node('Missing').fields() {}\nexport class InterpolateExpression extends node('InterpolateExpression').fields<{\n  parts: PresentList<ExpressionNode>;\n}>() {}\nexport class HasBlock extends node('HasBlock').fields<{ target: SourceSlice; symbol: number }>() {}\nexport class HasBlockParams extends node('HasBlockParams').fields<{\n  target: SourceSlice;\n  symbol: number;\n}>() {}\nexport class Curry extends node('Curry').fields<{\n  definition: ExpressionNode;\n  curriedType: CurriedType;\n  args: Args;\n}>() {}\nexport class Positional extends node('Positional').fields<{\n  list: OptionalList<ExpressionNode>;\n}>() {}\nexport class NamedArguments extends node('NamedArguments').fields<{\n  entries: OptionalList<NamedArgument>;\n}>() {}\nexport class NamedArgument extends node('NamedArgument').fields<{\n  key: SourceSlice;\n  value: ExpressionNode;\n}>() {}\nexport class Args extends node('Args').fields<{\n  positional: Positional;\n  named: NamedArguments;\n}>() {}\nexport class Tail extends node('Tail').fields<{ members: PresentArray<SourceSlice> }>() {}\n\nexport type ExpressionNode =\n  | ASTv2.LiteralExpression\n  | Missing\n  | PathExpression\n  | ASTv2.VariableReference\n  | InterpolateExpression\n  | CallExpression\n  | DeprecatedCallExpression\n  | Not\n  | IfInline\n  | HasBlock\n  | HasBlockParams\n  | Curry\n  | GetDynamicVar\n  | Log;\n\nexport type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;\n\nexport type Internal =\n  | Args\n  | Positional\n  | NamedArguments\n  | NamedArgument\n  | Tail\n  | NamedBlock\n  | NamedBlocks\n  | ElementParameters;\nexport type ExprLike = ExpressionNode | Internal;\nexport type Statement =\n  | InElement\n  | Debugger\n  | Yield\n  | AppendTrustedHTML\n  | AppendTextNode\n  | Component\n  | SimpleElement\n  | InvokeBlock\n  | AppendComment\n  | If\n  | Each\n  | With\n  | Let\n  | WithDynamicVars\n  | InvokeComponent;\n","import type { Nullable, PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray, mapPresentArray } from '@glimmer/util';\n\nexport interface OptionalList<T> {\n  map<U>(callback: (input: T) => U): MapList<T, U, AnyOptionalList<T>>;\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S\n  ): AnyOptionalList<S>;\n  toArray(): T[];\n  toPresentArray(): Nullable<PresentArray<T>>;\n  into<U, V>(options: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V;\n}\n\nexport class PresentList<T> implements OptionalList<T> {\n  constructor(readonly list: PresentArray<T>) {}\n\n  toArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  map<U>(callback: (input: T) => U): MapList<T, U, PresentList<T>> {\n    let result = mapPresentArray(this.list, callback);\n    return new PresentList(result) as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(predicate: (value: T) => value is S): AnyOptionalList<S> {\n    let out: S[] = [];\n\n    for (let item of this.list) {\n      if (predicate(item)) {\n        out.push(item);\n      }\n    }\n\n    return OptionalList(out);\n  }\n\n  toPresentArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  into<U, V>({ ifPresent }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifPresent(this);\n  }\n}\n\nexport class EmptyList<T> implements OptionalList<T> {\n  readonly list: T[] = [];\n\n  map<U>(_callback: (input: T) => U): MapList<T, U, EmptyList<T>> {\n    return new EmptyList() as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(_predicate: (value: T) => value is S): AnyOptionalList<S> {\n    return new EmptyList();\n  }\n\n  toArray(): T[] {\n    return this.list;\n  }\n\n  toPresentArray(): Nullable<PresentArray<T>> {\n    return null;\n  }\n\n  into<U, V>({ ifEmpty }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifEmpty();\n  }\n}\n\n// export type OptionalList<T> = PresentList<T> | EmptyList<T>;\n\nexport function OptionalList<T>(value: readonly T[]): AnyOptionalList<T> {\n  if (isPresentArray(value)) {\n    return new PresentList(value);\n  } else {\n    return new EmptyList<T>();\n  }\n}\n\nexport type AnyOptionalList<T> = (PresentList<T> | EmptyList<T>) & OptionalList<T>;\n\nexport type MapList<T, U, L extends OptionalList<T>> = L extends PresentList<T>\n  ? PresentList<U>\n  : L extends EmptyList<T>\n    ? EmptyList<U>\n    : never;\n","import type { GlimmerSyntaxError } from '@glimmer/syntax';\n\nimport type { AnyOptionalList } from './list';\n\nimport { OptionalList } from './list';\n\nabstract class ResultImpl<T> {\n  static all<T extends Result<unknown>[]>(...results: T): MapAll<T> {\n    let out: unknown[] = [];\n\n    for (let result of results) {\n      if (result.isErr) {\n        return result.cast();\n      } else {\n        out.push(result.value);\n      }\n    }\n\n    return Ok(out as MapAllOk<T>);\n  }\n\n  abstract mapOk<U>(callback: (value: T) => U): Result<U>;\n  abstract readonly isOk: boolean;\n  abstract readonly isErr: boolean;\n}\n\nexport const Result = ResultImpl;\n\nclass OkImpl<T> extends ResultImpl<T> {\n  readonly isOk = true;\n  readonly isErr = false;\n\n  constructor(readonly value: T) {\n    super();\n  }\n\n  expect(_message?: string): T {\n    return this.value;\n  }\n\n  ifOk(callback: (value: T) => void): this {\n    callback(this.value);\n    return this;\n  }\n\n  andThen<U>(callback: (value: T) => Result<U>): Result<U> {\n    return callback(this.value);\n  }\n\n  mapOk<U>(callback: (value: T) => U): Result<U> {\n    return Ok(callback(this.value));\n  }\n\n  ifErr(_callback: (value: GlimmerSyntaxError) => void): this {\n    return this;\n  }\n\n  mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return this;\n  }\n}\n\nclass ErrImpl<T> extends ResultImpl<T> {\n  readonly isOk = false;\n  readonly isErr = true;\n\n  constructor(readonly reason: GlimmerSyntaxError) {\n    super();\n  }\n\n  expect(message?: string): T {\n    throw new Error(message || 'expected an Ok, got Err');\n  }\n\n  andThen<U>(_callback: (value: T) => Result<U>): Result<U> {\n    return this.cast<U>();\n  }\n\n  mapOk<U>(_callback: (value: T) => U): Result<U> {\n    return this.cast<U>();\n  }\n\n  ifOk(_callback: (value: T) => void): this {\n    return this;\n  }\n\n  mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return Err(callback(this.reason));\n  }\n\n  ifErr(callback: (value: GlimmerSyntaxError) => void): this {\n    callback(this.reason);\n    return this;\n  }\n\n  cast<U>(): Result<U> {\n    return this as unknown as Result<U>;\n  }\n}\n\nexport function isResult<T>(input: MaybeResult<T>): input is Result<T> {\n  return input instanceof ResultImpl;\n}\n\nexport function intoResult<T>(input: MaybeResult<T>): Result<T> {\n  if (isResult(input)) {\n    return input;\n  } else {\n    return Ok(input);\n  }\n}\n\nexport type Result<T> = OkImpl<T> | ErrImpl<T>;\n\ntype MapAllOk<T extends Result<unknown>[]> = {\n  [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;\n};\n\ntype MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;\n\nexport function Ok<T>(value: T): Result<T> {\n  return new OkImpl(value);\n}\n\nexport type Ok<T> = OkImpl<T>;\n\nexport function Err<T>(reason: GlimmerSyntaxError): Result<T> {\n  return new ErrImpl(reason);\n}\n\nexport type Err<T> = ErrImpl<T>;\n\nexport type MaybeResult<T> = T | Result<T>;\n\nexport class MapIntoResultArray<T> {\n  constructor(private items: T[]) {}\n\n  map<U>(mapper: (item: T) => Result<U>): Result<U[]> {\n    let out = new ResultArray<U>();\n\n    for (let item of this.items) {\n      out.add(mapper(item));\n    }\n\n    return out.toArray();\n  }\n}\n\nexport class ResultArray<T> {\n  constructor(private items: Result<T>[] = []) {}\n\n  add(item: Result<T>): void {\n    this.items.push(item);\n  }\n\n  toArray(): Result<T[]> {\n    let err = this.items.filter((item): item is ErrImpl<T> => item instanceof ErrImpl)[0];\n\n    if (err !== undefined) {\n      return err.cast<T[]>();\n    } else {\n      return Ok((this.items as OkImpl<T>[]).map((item) => item.value));\n    }\n  }\n\n  toOptionalList(): Result<AnyOptionalList<T>> {\n    return this.toArray().mapOk((arr) => OptionalList(arr));\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport type { SourceSlice } from '@glimmer/syntax';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { unreachable } from '@glimmer/util';\n\nexport type HasPath<Node extends ASTv2.CallNode = ASTv2.CallNode> = Node & {\n  head: ASTv2.PathExpression;\n};\n\nexport type HasArguments =\n  | {\n      params: PresentArray<ASTv2.ExpressionNode>;\n    }\n  | {\n      hash: {\n        pairs: PresentArray<ASTv2.NamedArgument>;\n      };\n    };\n\nexport type HelperInvocation<Node extends ASTv2.CallNode = ASTv2.CallNode> = HasPath<Node> &\n  HasArguments;\n\nexport function hasPath<N extends ASTv2.CallNode>(node: N): node is HasPath<N> {\n  return node.callee.type === 'Path';\n}\n\nexport function isHelperInvocation<N extends ASTv2.CallNode>(\n  node: ASTv2.CallNode\n): node is HelperInvocation<N> {\n  if (!hasPath(node)) {\n    return false;\n  }\n\n  return !node.args.isEmpty();\n}\n\nexport interface SimplePath extends ASTv2.PathExpression {\n  tail: [SourceSlice];\n  data: false;\n  this: false;\n}\n\nexport type SimpleHelper<N extends HasPath> = N & {\n  path: SimplePath;\n};\n\nexport function isSimplePath(path: ASTv2.ExpressionNode): path is SimplePath {\n  if (path.type === 'Path') {\n    let { ref: head, tail: parts } = path;\n\n    return head.type === 'Free' && !ASTv2.isStrictResolution(head.resolution) && parts.length === 0;\n  } else {\n    return false;\n  }\n}\n\nexport function isStrictHelper(expr: HasPath): boolean {\n  if (expr.callee.type !== 'Path') {\n    return true;\n  }\n\n  if (expr.callee.ref.type !== 'Free') {\n    return true;\n  }\n\n  return ASTv2.isStrictResolution(expr.callee.ref.resolution);\n}\n\nexport function assertIsValidModifier<N extends HasPath>(\n  helper: N\n): asserts helper is SimpleHelper<N> {\n  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {\n    return;\n  }\n\n  throw generateSyntaxError(\n    `\\`${printPath(helper.callee)}\\` is not a valid name for a modifier`,\n    helper.loc\n  );\n}\n\nfunction printPath(path: ASTv2.ExpressionNode): string {\n  switch (path.type) {\n    case 'Literal':\n      return JSON.stringify(path.value);\n    case 'Path': {\n      let printedPath = [printPathHead(path.ref)];\n      printedPath.push(...path.tail.map((t) => t.chars));\n      return printedPath.join('.');\n    }\n    case 'Call':\n      return `(${printPath(path.callee)} ...)`;\n    case 'DeprecatedCall':\n      return `${path.callee.name}`;\n    case 'Interpolate':\n      throw unreachable('a concat statement cannot appear as the head of an expression');\n  }\n}\n\nfunction printPathHead(head: ASTv2.VariableReference): string {\n  switch (head.type) {\n    case 'Arg':\n      return head.name.chars;\n    case 'Free':\n    case 'Local':\n      return head.name;\n    case 'This':\n      return 'this';\n  }\n}\n\n/**\n * This function is checking whether an AST node is a triple-curly, which means that it's\n * a \"trusting\" node. In the Handlebars AST, this is indicated by the `escaped` flag, which\n * is a bit of a double-negative, so we change the terminology here for clarity.\n */\nexport function isTrustingNode(\n  value: ASTv2.AppendContent | ASTv2.HtmlText | ASTv2.InterpolateExpression\n): boolean {\n  if (value.type === 'AppendContent') {\n    return value.trusting;\n  } else {\n    return false;\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { getLast, isPresentArray } from '@glimmer/util';\n\nimport type { AnyOptionalList, PresentList } from '../../../shared/list';\nimport type { NormalizationState } from '../context';\n\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { CALL_KEYWORDS } from '../keywords';\nimport { hasPath } from '../utils/is-node';\n\nexport class NormalizeExpressions {\n  visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode> {\n    switch (node.type) {\n      case 'Literal':\n        return Ok(this.Literal(node));\n      case 'Interpolate':\n        return this.Interpolate(node, state);\n      case 'Path':\n        return this.PathExpression(node);\n      case 'Call': {\n        let translated = CALL_KEYWORDS.translate(node, state);\n\n        if (translated !== null) {\n          return translated;\n        }\n\n        return this.CallExpression(node, state);\n      }\n      case 'DeprecatedCall':\n        return this.DeprecaedCallExpression(node, state);\n    }\n  }\n\n  visitList(\n    nodes: PresentArray<ASTv2.ExpressionNode>,\n    state: NormalizationState\n  ): Result<PresentList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>> {\n    return new ResultArray(nodes.map((e) => VISIT_EXPRS.visit(e, state))).toOptionalList();\n  }\n\n  /**\n   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.\n   *\n   * TODO since keywords don't support tails anyway, distinguish PathExpression from\n   * VariableReference in ASTv2.\n   */\n  PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode> {\n    let ref = this.VariableReference(path.ref);\n    let { tail } = path;\n\n    if (isPresentArray(tail)) {\n      let tailLoc = tail[0].loc.extend(getLast(tail).loc);\n      return Ok(\n        new mir.PathExpression({\n          loc: path.loc,\n          head: ref,\n          tail: new mir.Tail({ loc: tailLoc, members: tail }),\n        })\n      );\n    } else {\n      return Ok(ref);\n    }\n  }\n\n  VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference {\n    return ref;\n  }\n\n  Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression {\n    return literal;\n  }\n\n  Interpolate(\n    expr: ASTv2.InterpolateExpression,\n    state: NormalizationState\n  ): Result<mir.InterpolateExpression> {\n    let parts = expr.parts.map(convertPathToCallIfKeyword) as PresentArray<ASTv2.ExpressionNode>;\n\n    return VISIT_EXPRS.visitList(parts, state).mapOk(\n      (parts) => new mir.InterpolateExpression({ loc: expr.loc, parts: parts })\n    );\n  }\n\n  CallExpression(\n    expr: ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    if (!hasPath(expr)) {\n      throw new Error(`unimplemented subexpression at the head of a subexpression`);\n    } else {\n      return Result.all(\n        VISIT_EXPRS.visit(expr.callee, state),\n        VISIT_EXPRS.Args(expr.args, state)\n      ).mapOk(\n        ([callee, args]) =>\n          new mir.CallExpression({\n            loc: expr.loc,\n            callee,\n            args,\n          })\n      );\n    }\n  }\n\n  DeprecaedCallExpression(\n    { arg, callee, loc }: ASTv2.DeprecatedCallExpression,\n    _state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    return Ok(new mir.DeprecatedCallExpression({ loc, arg, callee }));\n  }\n\n  Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args> {\n    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(\n      ([positional, named]) =>\n        new mir.Args({\n          loc,\n          positional,\n          named,\n        })\n    );\n  }\n\n  Positional(\n    positional: ASTv2.PositionalArguments,\n    state: NormalizationState\n  ): Result<mir.Positional> {\n    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(\n      (list) =>\n        new mir.Positional({\n          loc: positional.loc,\n          list,\n        })\n    );\n  }\n\n  NamedArguments(\n    named: ASTv2.NamedArguments,\n    state: NormalizationState\n  ): Result<mir.NamedArguments> {\n    let pairs = named.entries.map((arg) => {\n      let value = convertPathToCallIfKeyword(arg.value);\n\n      return VISIT_EXPRS.visit(value, state).mapOk(\n        (value) =>\n          new mir.NamedArgument({\n            loc: arg.loc,\n            key: arg.name,\n            value,\n          })\n      );\n    });\n\n    return new ResultArray(pairs)\n      .toOptionalList()\n      .mapOk((pairs) => new mir.NamedArguments({ loc: named.loc, entries: pairs }));\n  }\n}\n\nexport function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode {\n  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {\n    return new ASTv2.CallExpression({\n      callee: path,\n      args: ASTv2.Args.empty(path.loc),\n      loc: path.loc,\n    });\n  }\n\n  return path;\n}\n\nexport const VISIT_EXPRS = new NormalizeExpressions();\n","import type { ASTv2, KeywordType } from '@glimmer/syntax';\nimport { generateSyntaxError, isKeyword, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { exhausted } from '@glimmer/util';\n\nimport type { Result } from '../../../shared/result';\nimport type { NormalizationState } from '../context';\n\nimport { Err } from '../../../shared/result';\n\nexport interface KeywordDelegate<Match extends KeywordMatch, V, Out> {\n  assert(options: Match, state: NormalizationState): Result<V>;\n  translate(options: { node: Match; state: NormalizationState }, param: V): Result<Out>;\n}\n\nexport interface Keyword<K extends KeywordType = KeywordType, Out = unknown> {\n  translate(node: KeywordCandidates[K], state: NormalizationState): Result<Out> | null;\n}\n\nexport interface BlockKeyword<Out = unknown> {\n  translate(node: ASTv2.InvokeBlock, state: NormalizationState): Result<Out> | null;\n}\n\nclass KeywordImpl<\n  K extends KeywordType,\n  S extends string = string,\n  Param = unknown,\n  Out = unknown,\n> {\n  protected types: Set<KeywordCandidates[K]['type']>;\n\n  constructor(\n    protected keyword: S,\n    type: KeywordType,\n    private delegate: KeywordDelegate<KeywordMatches[K], Param, Out>\n  ) {\n    let nodes = new Set<KeywordNode['type']>();\n    for (let nodeType of KEYWORD_NODES[type]) {\n      nodes.add(nodeType);\n    }\n\n    this.types = nodes;\n  }\n\n  protected match(node: KeywordCandidates[K]): node is KeywordMatches[K] {\n    if (!this.types.has(node.type)) {\n      return false;\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {\n      if (path.tail.length > 0) {\n        if (path.ref.resolution.serialize() === 'Loose') {\n          // cannot be a keyword reference, keywords do not allow paths (must be\n          // relying on implicit this fallback)\n          return false;\n        }\n      }\n\n      return path.ref.name === this.keyword;\n    } else {\n      return false;\n    }\n  }\n\n  translate(node: KeywordMatches[K], state: NormalizationState): Result<Out> | null {\n    if (this.match(node)) {\n      let path = getCalleeExpression(node);\n\n      if (path !== null && path.type === 'Path' && path.tail.length > 0) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${\n              this.keyword\n            }\\` keyword was used incorrectly. It was used as \\`${path.loc.asString()}\\`, but it cannot be used with additional path segments. \\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n\n      let param = this.delegate.assert(node, state);\n      return param.andThen((param) => this.delegate.translate({ node, state }, param));\n    } else {\n      return null;\n    }\n  }\n}\n\nexport type PossibleNode =\n  | ASTv2.PathExpression\n  | ASTv2.AppendContent\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock;\n\nexport const KEYWORD_NODES = {\n  Call: ['Call'],\n  Block: ['InvokeBlock'],\n  Append: ['AppendContent'],\n  Modifier: ['ElementModifier'],\n} as const;\n\nexport interface KeywordCandidates {\n  Call: ASTv2.ExpressionNode;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordCandidate = KeywordCandidates[keyof KeywordCandidates];\n\nexport interface KeywordMatches {\n  Call: ASTv2.CallExpression;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordMatch = KeywordMatches[keyof KeywordMatches];\n\n/**\n * A \"generic\" keyword is something like `has-block`, which makes sense in the context\n * of sub-expression or append\n */\nexport type GenericKeywordNode = ASTv2.AppendContent | ASTv2.CallExpression;\n\nexport type KeywordNode =\n  | GenericKeywordNode\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock\n  | ASTv2.ElementModifier;\n\nexport function keyword<\n  K extends KeywordType,\n  D extends KeywordDelegate<KeywordMatches[K], unknown, Out>,\n  Out = unknown,\n>(keyword: string, type: K, delegate: D): Keyword<K, Out> {\n  return new KeywordImpl(keyword, type, delegate as KeywordDelegate<KeywordMatch, unknown, Out>);\n}\n\nexport type PossibleKeyword = KeywordNode;\ntype OutFor<K extends Keyword | BlockKeyword> = K extends BlockKeyword<infer Out>\n  ? Out\n  : K extends Keyword<KeywordType, infer Out>\n    ? Out\n    : never;\n\nfunction getCalleeExpression(\n  node: KeywordNode | ASTv2.ExpressionNode\n): ASTv2.ExpressionNode | null {\n  switch (node.type) {\n    // This covers the inside of attributes and expressions, as well as the callee\n    // of call nodes\n    case 'Path':\n      return node;\n    case 'AppendContent':\n      return getCalleeExpression(node.value);\n    case 'Call':\n    case 'InvokeBlock':\n    case 'ElementModifier':\n      return node.callee;\n    default:\n      return null;\n  }\n}\n\nexport class Keywords<K extends KeywordType, KeywordList extends Keyword<K> = never>\n  implements Keyword<K, OutFor<KeywordList>>\n{\n  _keywords: Keyword[] = [];\n  _type: K;\n\n  constructor(type: K) {\n    this._type = type;\n  }\n\n  kw<S extends string = string, Out = unknown>(\n    name: S,\n    delegate: KeywordDelegate<KeywordMatches[K], unknown, Out>\n  ): Keywords<K, KeywordList | Keyword<K, Out>> {\n    this._keywords.push(keyword(name, this._type, delegate));\n\n    return this;\n  }\n\n  translate(\n    node: KeywordCandidates[K],\n    state: NormalizationState\n  ): Result<OutFor<KeywordList>> | null {\n    for (let keyword of this._keywords) {\n      let result = keyword.translate(node, state) as Result<OutFor<KeywordList>>;\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path && path.type === 'Path' && path.ref.type === 'Free' && isKeyword(path.ref.name)) {\n      let { name } = path.ref as { name: keyof typeof KEYWORDS_TYPES };\n\n      let usedType = this._type;\n      let validTypes: readonly KeywordType[] = KEYWORDS_TYPES[name];\n\n      if (!validTypes.includes(usedType)) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${name}\\` keyword was used incorrectly. It was used as ${\n              typesToReadableName[usedType]\n            }, but its valid usages are:\\n\\n${generateTypesMessage(\n              name,\n              validTypes\n            )}\\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    return null;\n  }\n}\n\nconst typesToReadableName = {\n  Append: 'an append statement',\n  Block: 'a block statement',\n  Call: 'a call expression',\n  Modifier: 'a modifier',\n};\n\nfunction generateTypesMessage(name: string, types: readonly KeywordType[]): string {\n  return types\n    .map((type) => {\n      switch (type) {\n        case 'Append':\n          return `- As an append statement, as in: {{${name}}}`;\n        case 'Block':\n          return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;\n        case 'Call':\n          return `- As an expression, as in: (${name})`;\n        case 'Modifier':\n          return `- As a modifier, as in: <div {{${name}}}></div>`;\n        default:\n          return exhausted(type);\n      }\n    })\n    .join('\\n\\n');\n}\n\n/**\n * This function builds keyword definitions for a particular type of AST node (`KeywordType`).\n *\n * You can build keyword definitions for:\n *\n * - `Expr`: A `SubExpression` or `PathExpression`\n * - `Block`: A `BlockStatement`\n *   - A `BlockStatement` is a keyword candidate if its head is a\n *     `PathExpression`\n * - `Append`: An `AppendStatement`\n *\n * A node is a keyword candidate if:\n *\n * - A `PathExpression` is a keyword candidate if it has no tail, and its\n *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is\n *   the keyword's name.\n * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword\n *   candidate if its head is a keyword candidate.\n *\n * The keyword infrastructure guarantees that:\n *\n * - If a node is not a keyword candidate, it is never passed to any keyword's\n *   `assert` method.\n * - If a node is not the `KeywordType` for a particular keyword, it will not\n *   be passed to the keyword's `assert` method.\n *\n * `Expr` keywords are used in expression positions and should return HIR\n * expressions. `Block` and `Append` keywords are used in statement\n * positions and should return HIR statements.\n *\n * A keyword definition has two parts:\n *\n * - `match`, which determines whether an AST node matches the keyword, and can\n *   optionally return some information extracted from the AST node.\n * - `translate`, which takes a matching AST node as well as the extracted\n *   information and returns an appropriate HIR instruction.\n *\n * # Example\n *\n * This keyword:\n *\n * - turns `(hello)` into `\"hello\"`\n *   - as long as `hello` is not in scope\n * - makes it an error to pass any arguments (such as `(hello world)`)\n *\n * ```ts\n * keywords('SubExpr').kw('hello', {\n *   assert(node: ExprKeywordNode): Result<void> | false {\n *     // we don't want to transform `hello` as a `PathExpression`\n *     if (node.type !== 'SubExpression') {\n *       return false;\n *     }\n *\n *     // node.head would be `LocalVarHead` if `hello` was in scope\n *     if (node.head.type !== 'FreeVarHead') {\n *       return false;\n *     }\n *\n *     if (node.params.length || node.hash) {\n *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);\n *     } else {\n *       return Ok();\n *     }\n *   },\n *\n *   translate(node: ASTv2.SubExpression): hir.Expression {\n *     return ASTv2.builders.literal(\"hello\", node.loc)\n *   }\n * })\n * ```\n *\n * The keyword infrastructure checks to make sure that the node is the right\n * type before calling `assert`, so you only need to consider `SubExpression`\n * and `PathExpression` here. It also checks to make sure that the node passed\n * to `assert` has the keyword name in the right place.\n *\n * Note the important difference between returning `false` from `assert`,\n * which just means that the node didn't match, and returning `Err`, which\n * means that the node matched, but there was a keyword-specific syntax\n * error.\n */\nexport function keywords<K extends KeywordType>(type: K): Keywords<K> {\n  return new Keywords(type);\n}\n","import type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport * as mir from '../../../2-encoding/mir';\n\nexport function toAppend<T>({\n  assert,\n  translate,\n}: KeywordDelegate<GenericKeywordNode, T, mir.ExpressionNode>): KeywordDelegate<\n  GenericKeywordNode,\n  T,\n  mir.AppendTextNode\n> {\n  return {\n    assert,\n    translate(\n      { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n      value: T\n    ): Result<mir.AppendTextNode> {\n      let result = translate({ node, state }, value);\n\n      return result.mapOk((text) => new mir.AppendTextNode({ text, loc: node.loc }));\n    },\n  };\n}\n","import type { CurriedType } from '@glimmer/interfaces';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nconst CurriedTypeToReadableType = {\n  [CurriedTypes.Component]: 'component',\n  [CurriedTypes.Helper]: 'helper',\n  [CurriedTypes.Modifier]: 'modifier',\n} as const;\n\nexport function assertCurryKeyword(curriedType: CurriedType) {\n  return (\n    node: ASTv2.AppendContent | ASTv2.InvokeBlock | ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<{\n    definition: ASTv2.ExpressionNode;\n    args: ASTv2.Args;\n  }> => {\n    let readableType = CurriedTypeToReadableType[curriedType];\n    let stringsAllowed = curriedType === CurriedTypes.Component;\n\n    let { args } = node;\n\n    let definition = args.nth(0);\n\n    if (definition === null) {\n      return Err(\n        generateSyntaxError(\n          `(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`,\n          args.loc\n        )\n      );\n    }\n\n    if (definition.type === 'Literal') {\n      if (stringsAllowed && state.isStrict) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values in strict mode templates`,\n            node.loc\n          )\n        );\n      } else if (!stringsAllowed) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    args = new ASTv2.Args({\n      positional: new ASTv2.PositionalArguments({\n        exprs: args.positional.exprs.slice(1),\n        loc: args.positional.loc,\n      }),\n      named: args.named,\n      loc: args.loc,\n    });\n\n    return Ok({ definition, args });\n  };\n}\n\nfunction translateCurryKeyword(curriedType: CurriedType) {\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n  ): Result<mir.Curry> => {\n    let definitionResult = VISIT_EXPRS.visit(definition, state);\n    let argsResult = VISIT_EXPRS.Args(args, state);\n\n    return Result.all(definitionResult, argsResult).mapOk(\n      ([definition, args]) =>\n        new mir.Curry({\n          loc: node.loc,\n          curriedType,\n          definition,\n          args,\n        })\n    );\n  };\n}\n\nexport function curryKeyword(\n  curriedType: CurriedType\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  { definition: ASTv2.ExpressionNode; args: ASTv2.Args },\n  mir.Curry\n> {\n  return {\n    assert: assertCurryKeyword(curriedType),\n    translate: translateCurryKeyword(curriedType),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertGetDynamicVarKeyword(node: GenericKeywordNode): Result<ASTv2.ExpressionNode> {\n  let call = node.type === 'AppendContent' ? node.value : node;\n\n  let named = call.type === 'Call' ? call.args.named : null;\n  let positionals = call.type === 'Call' ? call.args.positional : null;\n\n  if (named && !named.isEmpty()) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc)\n    );\n  }\n\n  let varName = positionals?.nth(0);\n\n  if (!varName) {\n    return Err(generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));\n  }\n\n  if (positionals && positionals.size > 1) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc)\n    );\n  }\n\n  return Ok(varName);\n}\n\nfunction translateGetDynamicVarKeyword(\n  { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n  name: ASTv2.ExpressionNode\n): Result<mir.GetDynamicVar> {\n  return VISIT_EXPRS.visit(name, state).mapOk(\n    (name) => new mir.GetDynamicVar({ name, loc: node.loc })\n  );\n}\n\nexport const getDynamicVarKeyword: KeywordDelegate<\n  GenericKeywordNode,\n  ASTv2.ExpressionNode,\n  mir.GetDynamicVar\n> = {\n  assert: assertGetDynamicVarKeyword,\n  translate: translateGetDynamicVarKeyword,\n};\n","import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\n\nfunction assertHasBlockKeyword(type: string) {\n  return (node: GenericKeywordNode): Result<SourceSlice> => {\n    let call = node.type === 'AppendContent' ? node.value : node;\n\n    let named = call.type === 'Call' ? call.args.named : null;\n    let positionals = call.type === 'Call' ? call.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));\n    }\n\n    if (!positionals || positionals.isEmpty()) {\n      return Ok(SourceSlice.synthetic('default'));\n    } else if (positionals.exprs.length === 1) {\n      let positional = positionals.exprs[0] as ASTv2.ExpressionNode;\n      if (ASTv2.isLiteral(positional, 'string')) {\n        return Ok(positional.toSlice());\n      } else {\n        return Err(\n          generateSyntaxError(\n            `(${type}) can only receive a string literal as its first argument`,\n            call.loc\n          )\n        );\n      }\n    } else {\n      return Err(\n        generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc)\n      );\n    }\n  };\n}\n\nfunction translateHasBlockKeyword(type: string) {\n  return (\n    { node, state: { scope } }: { node: ASTv2.CallExpression; state: NormalizationState },\n    target: SourceSlice\n  ): Result<mir.HasBlock | mir.HasBlockParams> => {\n    let block =\n      type === 'has-block'\n        ? new mir.HasBlock({ loc: node.loc, target, symbol: scope.allocateBlock(target.chars) })\n        : new mir.HasBlockParams({\n            loc: node.loc,\n            target,\n            symbol: scope.allocateBlock(target.chars),\n          });\n\n    return Ok(block);\n  };\n}\n\nexport function hasBlockKeyword(\n  type: string\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  SourceSlice,\n  mir.HasBlock | mir.HasBlockParams\n> {\n  return {\n    assert: assertHasBlockKeyword(type),\n    translate: translateHasBlockKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertIfUnlessInlineKeyword(type: string) {\n  return (\n    originalNode: ASTv2.AppendContent | ASTv2.ExpressionNode\n  ): Result<{\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  }> => {\n    let inverted = type === 'unless';\n\n    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;\n    let named = node.type === 'Call' ? node.args.named : null;\n    let positional = node.type === 'Call' ? node.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(\n        generateSyntaxError(\n          `(${type}) cannot receive named parameters, received ${named.entries\n            .map((e) => e.name.chars)\n            .join(', ')}`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let condition = positional?.nth(0);\n\n    if (!positional || !condition) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Did not receive any parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let truthy = positional.nth(1);\n    let falsy = positional.nth(2);\n\n    if (truthy === null) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Received only one parameter, the condition`,\n          originalNode.loc\n        )\n      );\n    }\n\n    if (positional.size > 3) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }, and 3. the value to return if the condition is ${\n            inverted ? 'true' : 'false'\n          }. Received ${positional?.size ?? 0} parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    return Ok({ condition, truthy, falsy });\n  };\n}\n\nfunction translateIfUnlessInlineKeyword(type: string) {\n  let inverted = type === 'unless';\n\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.AppendContent | ASTv2.ExpressionNode; state: NormalizationState },\n    {\n      condition,\n      truthy,\n      falsy,\n    }: {\n      condition: ASTv2.ExpressionNode;\n      truthy: ASTv2.ExpressionNode;\n      falsy: ASTv2.ExpressionNode | null;\n    }\n  ): Result<mir.IfInline> => {\n    let conditionResult = VISIT_EXPRS.visit(condition, state);\n    let truthyResult = VISIT_EXPRS.visit(truthy, state);\n    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);\n\n    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(\n      ([condition, truthy, falsy]) => {\n        if (inverted) {\n          condition = new mir.Not({ value: condition, loc: node.loc });\n        }\n\n        return new mir.IfInline({\n          loc: node.loc,\n          condition,\n          truthy,\n          falsy,\n        });\n      }\n    );\n  };\n}\n\nexport function ifUnlessInlineKeyword(type: string): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  {\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  },\n  mir.IfInline\n> {\n  return {\n    assert: assertIfUnlessInlineKeyword(type),\n    translate: translateIfUnlessInlineKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertLogKeyword(node: GenericKeywordNode): Result<ASTv2.PositionalArguments> {\n  let {\n    args: { named, positional },\n  } = node;\n\n  if (named && !named.isEmpty()) {\n    return Err(generateSyntaxError(`(log) does not take any named arguments`, node.loc));\n  }\n\n  return Ok(positional);\n}\n\nfunction translateLogKeyword(\n  { node, state }: { node: ASTv2.CallExpression; state: NormalizationState },\n  positional: ASTv2.PositionalArguments\n): Result<mir.Log> {\n  return VISIT_EXPRS.Positional(positional, state).mapOk(\n    (positional) => new mir.Log({ positional, loc: node.loc })\n  );\n}\n\nexport const logKeyword: KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  ASTv2.PositionalArguments,\n  mir.Log\n> = {\n  assert: assertLogKeyword,\n  translate: translateLogKeyword,\n};\n","import { ASTv2, generateSyntaxError, src } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { keywords } from './impl';\nimport { toAppend } from './utils/call-to-append';\nimport { assertCurryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const APPEND_KEYWORDS = keywords('Append')\n  .kw('has-block', toAppend(hasBlockKeyword('has-block')))\n  .kw('has-block-params', toAppend(hasBlockKeyword('has-block-params')))\n  .kw('-get-dynamic-var', toAppend(getDynamicVarKeyword))\n  .kw('log', toAppend(logKeyword))\n  .kw('if', toAppend(ifUnlessInlineKeyword('if')))\n  .kw('unless', toAppend(ifUnlessInlineKeyword('unless')))\n  .kw('yield', {\n    assert(node: ASTv2.AppendContent): Result<{\n      target: src.SourceSlice;\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (args.named.isEmpty()) {\n        return Ok({\n          target: src.SourceSpan.synthetic('default').toSlice(),\n          positional: args.positional,\n        });\n      } else {\n        let target = args.named.get('to');\n\n        if (args.named.size > 1 || target === null) {\n          return Err(\n            generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc)\n          );\n        }\n\n        if (ASTv2.isLiteral(target, 'string')) {\n          return Ok({ target: target.toSlice(), positional: args.positional });\n        } else {\n          return Err(\n            generateSyntaxError(`you can only yield to a literal string value`, target.loc)\n          );\n        }\n      }\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      {\n        target,\n        positional,\n      }: {\n        target: src.SourceSlice;\n        positional: ASTv2.PositionalArguments;\n      }\n    ): Result<mir.Statement> {\n      return VISIT_EXPRS.Positional(positional, state).mapOk(\n        (positional) =>\n          new mir.Yield({\n            loc: node.loc,\n            target,\n            to: state.scope.allocateBlock(target.chars),\n            positional,\n          })\n      );\n    },\n  })\n  .kw('debugger', {\n    assert(node: ASTv2.AppendContent): Result<void> {\n      let { args } = node;\n      let { positional } = args;\n\n      if (args.isEmpty()) {\n        return Ok(undefined);\n      } else {\n        if (positional.isEmpty()) {\n          return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));\n        } else {\n          return Err(\n            generateSyntaxError(`debugger does not take any positional arguments`, node.loc)\n          );\n        }\n      }\n    },\n\n    translate({\n      node,\n      state: { scope },\n    }: {\n      node: ASTv2.AppendContent;\n      state: NormalizationState;\n    }): Result<mir.Statement> {\n      scope.setHasDebugger();\n      return Ok(new mir.Debugger({ loc: node.loc, scope }));\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(\n        ([definition, args]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks: null,\n          })\n      );\n    },\n  })\n  .kw('helper', {\n    assert: assertCurryKeyword(CurriedTypes.Helper),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.AppendTextNode> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {\n        let text = new mir.CallExpression({ callee: definition, args, loc: node.loc });\n\n        return new mir.AppendTextNode({\n          loc: node.loc,\n          text,\n        });\n      });\n    },\n  });\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { VISIT_STMTS } from '../visitors/statements';\nimport { keywords } from './impl';\nimport { assertCurryKeyword } from './utils/curry';\n\nexport const BLOCK_KEYWORDS = keywords('Block')\n  .kw('in-element', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      insertBefore: ASTv2.ExpressionNode | null;\n      destination: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      let guid = args.get('guid');\n\n      if (guid) {\n        return Err(generateSyntaxError(`Cannot pass \\`guid\\` to \\`{{#in-element}}\\``, guid.loc));\n      }\n\n      let insertBefore = args.get('insertBefore');\n      let destination = args.nth(0);\n\n      if (destination === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#in-element}} requires a target element as its first positional parameter`,\n            args.loc\n          )\n        );\n      }\n\n      // TODO Better syntax checks\n\n      return Ok({ insertBefore, destination });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      {\n        insertBefore,\n        destination,\n      }: { insertBefore: ASTv2.ExpressionNode | null; destination: ASTv2.ExpressionNode }\n    ): Result<mir.InElement> {\n      let named = node.blocks.get('default');\n      let body = VISIT_STMTS.NamedBlock(named, state);\n      let destinationResult = VISIT_EXPRS.visit(destination, state);\n\n      return Result.all(body, destinationResult)\n        .andThen(\n          ([body, destination]): Result<{\n            body: mir.NamedBlock;\n            destination: mir.ExpressionNode;\n            insertBefore: mir.ExpressionNode;\n          }> => {\n            if (insertBefore) {\n              return VISIT_EXPRS.visit(insertBefore, state).mapOk((insertBefore) => ({\n                body,\n                destination,\n                insertBefore,\n              }));\n            } else {\n              return Ok({\n                body,\n                destination,\n                insertBefore: new mir.Missing({\n                  loc: node.callee.loc.collapse('end'),\n                }),\n              });\n            }\n          }\n        )\n        .mapOk(\n          ({ body, destination, insertBefore }) =>\n            new mir.InElement({\n              loc: node.loc,\n              block: body,\n              insertBefore,\n              guid: state.generateUniqueCursor(),\n              destination,\n            })\n        );\n    },\n  })\n  .kw('if', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('unless', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition: new mir.Not({ value: condition, loc: node.loc }),\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('each', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n      key: ASTv2.ExpressionNode | null;\n    }> {\n      let { args } = node;\n\n      if (!args.named.entries.every((e) => e.name.chars === 'key')) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive the 'key' named parameter, received ${args.named.entries\n              .filter((e) => e.name.chars !== 'key')\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n      let key = args.get('key');\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value, key });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value, key }: { value: ASTv2.ExpressionNode; key: ASTv2.ExpressionNode | null }\n    ): Result<mir.Each> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);\n\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(\n        ([value, key, block, inverse]) =>\n          new mir.Each({\n            loc: node.loc,\n            value,\n            key,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('with', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} can only receive one positional parameter. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} requires a value as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value }: { value: ASTv2.ExpressionNode }\n    ): Result<mir.With> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, blockResult, inverseResult).mapOk(\n        ([value, block, inverse]) =>\n          new mir.With({\n            loc: node.loc,\n            value,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('let', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size === 0) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      if (node.blocks.get('else')) {\n        return Err(\n          generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc)\n        );\n      }\n\n      return Ok({ positional: args.positional });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { positional }: { positional: ASTv2.PositionalArguments }\n    ): Result<mir.Let> {\n      let block = node.blocks.get('default');\n\n      let positionalResult = VISIT_EXPRS.Positional(positional, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(positionalResult, blockResult).mapOk(\n        ([positional, block]) =>\n          new mir.Let({\n            loc: node.loc,\n            positional,\n            block,\n          })\n      );\n    },\n  })\n  .kw('-with-dynamic-vars', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      named: ASTv2.NamedArguments;\n    }> {\n      return Ok({ named: node.args.named });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { named }: { named: ASTv2.NamedArguments }\n    ): Result<mir.WithDynamicVars> {\n      let block = node.blocks.get('default');\n\n      let namedResult = VISIT_EXPRS.NamedArguments(named, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(namedResult, blockResult).mapOk(\n        ([named, block]) =>\n          new mir.WithDynamicVars({\n            loc: node.loc,\n            named,\n            block,\n          })\n      );\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n      let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);\n\n      return Result.all(definitionResult, argsResult, blocksResult).mapOk(\n        ([definition, args, blocks]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks,\n          })\n      );\n    },\n  });\n","import { CurriedTypes } from '@glimmer/vm';\n\nimport { keywords } from './impl';\nimport { curryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const CALL_KEYWORDS = keywords('Call')\n  .kw('has-block', hasBlockKeyword('has-block'))\n  .kw('has-block-params', hasBlockKeyword('has-block-params'))\n  .kw('-get-dynamic-var', getDynamicVarKeyword)\n  .kw('log', logKeyword)\n  .kw('if', ifUnlessInlineKeyword('if'))\n  .kw('unless', ifUnlessInlineKeyword('unless'))\n  .kw('component', curryKeyword(CurriedTypes.Component))\n  .kw('helper', curryKeyword(CurriedTypes.Helper))\n  .kw('modifier', curryKeyword(CurriedTypes.Modifier));\n","import { keywords } from './impl';\n\nexport const MODIFIER_KEYWORDS = keywords('Modifier');\n","import type { Dict, WellKnownAttrName, WellKnownTagName } from '@glimmer/interfaces';\nimport { WellKnownAttrNames, WellKnownTagNames } from '@glimmer/wire-format';\n\n// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST: Dict<string | undefined> = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  xmlns: XMLNS,\n  'xmlns:xlink': XMLNS,\n};\n\nexport function getAttrNamespace(attrName: string): string | undefined {\n  return WHITELIST[attrName];\n}\n\nconst DEFLATE_TAG_TABLE: {\n  [tagName: string]: WellKnownTagName | undefined;\n} = {\n  div: WellKnownTagNames.div,\n  span: WellKnownTagNames.span,\n  p: WellKnownTagNames.p,\n  a: WellKnownTagNames.a,\n};\n\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function deflateTagName(tagName: string): string | WellKnownTagName {\n  return DEFLATE_TAG_TABLE[tagName] ?? tagName;\n}\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nconst DEFLATE_ATTR_TABLE: {\n  [tagName: string]: WellKnownAttrName | undefined;\n} = {\n  class: WellKnownAttrNames.class,\n  id: WellKnownAttrNames.id,\n  value: WellKnownAttrNames.value,\n  name: WellKnownAttrNames.name,\n  type: WellKnownAttrNames.type,\n  style: WellKnownAttrNames.style,\n  href: WellKnownAttrNames.href,\n};\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\n\nexport function deflateAttrName(attrName: string): string | WellKnownAttrName {\n  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n","import { ASTv2, maybeLoc, src } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\n\nimport { OptionalList } from '../../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../../shared/result';\nimport { getAttrNamespace } from '../../../../utils';\nimport * as mir from '../../../2-encoding/mir';\nimport { MODIFIER_KEYWORDS } from '../../keywords';\nimport { assertIsValidModifier, isHelperInvocation } from '../../utils/is-node';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\n\nexport type ValidAttr = mir.StaticAttr | mir.DynamicAttr | mir.SplatAttr;\n\ntype ProcessedAttributes = {\n  attrs: ValidAttr[];\n  args: mir.NamedArguments;\n};\n\nexport interface Classified {\n  readonly dynamicFeatures: boolean;\n\n  arg(attr: ASTv2.AttrNode, classified: ClassifiedElement): Result<mir.NamedArgument>;\n  toStatement(classified: ClassifiedElement, prepared: PreparedArgs): Result<mir.Statement>;\n}\n\nexport class ClassifiedElement {\n  readonly delegate: Classified;\n\n  constructor(\n    readonly element: ASTv2.ElementNode,\n    delegate: Classified,\n    readonly state: NormalizationState\n  ) {\n    this.delegate = delegate;\n  }\n\n  toStatement(): Result<mir.Statement> {\n    return this.prepare().andThen((prepared) => this.delegate.toStatement(this, prepared));\n  }\n\n  private attr(attr: ASTv2.HtmlAttr): Result<ValidAttr> {\n    let name = attr.name;\n    let rawValue = attr.value;\n    let namespace = getAttrNamespace(name.chars) || undefined;\n\n    if (ASTv2.isLiteral(rawValue, 'string')) {\n      return Ok(\n        new mir.StaticAttr({\n          loc: attr.loc,\n          name,\n          value: rawValue.toSlice(),\n          namespace,\n          kind: {\n            component: this.delegate.dynamicFeatures,\n          },\n        })\n      );\n    }\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk((value) => {\n      let isTrusting = attr.trusting;\n\n      return new mir.DynamicAttr({\n        loc: attr.loc,\n        name,\n        value: value,\n        namespace,\n        kind: {\n          trusting: isTrusting,\n          component: this.delegate.dynamicFeatures,\n        },\n      });\n    });\n  }\n\n  private modifier(modifier: ASTv2.ElementModifier): Result<mir.Modifier> {\n    if (isHelperInvocation(modifier)) {\n      assertIsValidModifier(modifier);\n    }\n\n    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(modifier.callee, this.state);\n    let args = VISIT_EXPRS.Args(modifier.args, this.state);\n\n    return Result.all(head, args).mapOk(\n      ([head, args]) =>\n        new mir.Modifier({\n          loc: modifier.loc,\n          callee: head,\n          args,\n        })\n    );\n  }\n\n  private attrs(): Result<ProcessedAttributes> {\n    let attrs = new ResultArray<ValidAttr>();\n    let args = new ResultArray<mir.NamedArgument>();\n\n    // Unlike most attributes, the `type` attribute can change how\n    // subsequent attributes are interpreted by the browser. To address\n    // this, in simple cases, we special case the `type` attribute to be set\n    // last. For elements with splattributes, where attribute order affects\n    // precedence, this re-ordering happens at runtime instead.\n    // See https://github.com/glimmerjs/glimmer-vm/pull/726\n    let typeAttr: ASTv2.AttrNode | null = null;\n    let simple = this.element.attrs.filter((attr) => attr.type === 'SplatAttr').length === 0;\n\n    for (let attr of this.element.attrs) {\n      if (attr.type === 'SplatAttr') {\n        attrs.add(\n          Ok(new mir.SplatAttr({ loc: attr.loc, symbol: this.state.scope.allocateBlock('attrs') }))\n        );\n      } else if (attr.name.chars === 'type' && simple) {\n        typeAttr = attr;\n      } else {\n        attrs.add(this.attr(attr));\n      }\n    }\n\n    for (let arg of this.element.componentArgs) {\n      args.add(this.delegate.arg(arg, this));\n    }\n\n    if (typeAttr) {\n      attrs.add(this.attr(typeAttr));\n    }\n\n    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({\n      attrs,\n      args: new mir.NamedArguments({\n        loc: maybeLoc(args, src.SourceSpan.NON_EXISTENT),\n        entries: OptionalList(args),\n      }),\n    }));\n  }\n\n  private prepare(): Result<PreparedArgs> {\n    let attrs = this.attrs();\n    let modifiers = new ResultArray(this.element.modifiers.map((m) => this.modifier(m))).toArray();\n\n    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {\n      let { attrs, args } = result;\n\n      let elementParams = [...attrs, ...modifiers];\n\n      let params = new mir.ElementParameters({\n        loc: maybeLoc(elementParams, src.SourceSpan.NON_EXISTENT),\n        body: OptionalList(elementParams),\n      });\n\n      return { args, params };\n    });\n  }\n}\n\nexport interface PreparedArgs {\n  args: mir.NamedArguments;\n  params: mir.ElementParameters;\n}\n\nexport function hasDynamicFeatures({\n  attrs,\n  modifiers,\n}: Pick<ASTv2.ElementNode, 'attrs' | 'modifiers'>): boolean {\n  // ElementModifier needs the special ComponentOperations\n  if (modifiers.length > 0) {\n    return true;\n  }\n\n  // Splattributes need the special ComponentOperations to merge into\n  return !!attrs.filter((attr) => attr.type === 'SplatAttr')[0];\n}\n","import type { ASTv2 } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport * as mir from '../../../2-encoding/mir';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedComponent implements Classified {\n  readonly dynamicFeatures = true;\n\n  constructor(\n    private tag: mir.ExpressionNode,\n    private element: ASTv2.InvokeComponent\n  ) {}\n\n  arg(attr: ASTv2.ComponentArg, { state }: ClassifiedElement): Result<mir.NamedArgument> {\n    let name = attr.name;\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(\n      (value) =>\n        new mir.NamedArgument({\n          loc: attr.loc,\n          key: name,\n          value,\n        })\n    );\n  }\n\n  toStatement(component: ClassifiedElement, { args, params }: PreparedArgs): Result<mir.Statement> {\n    let { element, state } = component;\n\n    return this.blocks(state).mapOk(\n      (blocks) =>\n        new mir.Component({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          args,\n          blocks,\n        })\n    );\n  }\n\n  private blocks(state: NormalizationState): Result<mir.NamedBlocks> {\n    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);\n  }\n}\n","import type { ASTv2, SourceSlice } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport { Err } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedSimpleElement implements Classified {\n  constructor(\n    private tag: SourceSlice,\n    private element: ASTv2.SimpleElement,\n    readonly dynamicFeatures: boolean\n  ) {}\n\n  readonly isComponent = false;\n\n  arg(attr: ASTv2.ComponentArg): Result<mir.NamedArgument> {\n    return Err(\n      generateSyntaxError(\n        `${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\\`${this.tag.chars}\\`) is a regular, non-component HTML element.`,\n        attr.loc\n      )\n    );\n  }\n\n  toStatement(classified: ClassifiedElement, { params }: PreparedArgs): Result<mir.Statement> {\n    let { state, element } = classified;\n\n    let body = VISIT_STMTS.visitList(this.element.body, state);\n\n    return body.mapOk(\n      (body) =>\n        new mir.SimpleElement({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          body: body.toArray(),\n          dynamicFeatures: this.dynamicFeatures,\n        })\n    );\n  }\n}\n","import { ASTv2 } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { OptionalList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { BLOCK_KEYWORDS } from '../keywords';\nimport { APPEND_KEYWORDS } from '../keywords/append';\nimport { ClassifiedElement, hasDynamicFeatures } from './element/classified';\nimport { ClassifiedComponent } from './element/component';\nimport { ClassifiedSimpleElement } from './element/simple-element';\nimport { VISIT_EXPRS } from './expressions';\n\nclass NormalizationStatements {\n  visitList(\n    nodes: readonly ASTv2.ContentNode[],\n    state: NormalizationState\n  ): Result<OptionalList<mir.Statement>> {\n    return new ResultArray(nodes.map((e) => VISIT_STMTS.visit(e, state)))\n      .toOptionalList()\n      .mapOk((list) => list.filter((s: mir.Statement | null): s is mir.Statement => s !== null));\n  }\n\n  visit(node: ASTv2.ContentNode, state: NormalizationState): Result<mir.Statement | null> {\n    switch (node.type) {\n      case 'GlimmerComment':\n        return Ok(null);\n      case 'AppendContent':\n        return this.AppendContent(node, state);\n      case 'HtmlText':\n        return Ok(this.TextNode(node));\n      case 'HtmlComment':\n        return Ok(this.HtmlComment(node));\n      case 'InvokeBlock':\n        return this.InvokeBlock(node, state);\n      case 'InvokeComponent':\n        return this.Component(node, state);\n      case 'SimpleElement':\n        return this.SimpleElement(node, state);\n    }\n  }\n\n  InvokeBlock(node: ASTv2.InvokeBlock, state: NormalizationState): Result<mir.Statement> {\n    let translated = BLOCK_KEYWORDS.translate(node, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(node.callee, state);\n    let args = VISIT_EXPRS.Args(node.args, state);\n\n    return Result.all(head, args).andThen(([head, args]) =>\n      this.NamedBlocks(node.blocks, state).mapOk(\n        (blocks) =>\n          new mir.InvokeBlock({\n            loc: node.loc,\n            head,\n            args,\n            blocks,\n          })\n      )\n    );\n  }\n\n  NamedBlocks(blocks: ASTv2.NamedBlocks, state: NormalizationState): Result<mir.NamedBlocks> {\n    let list = new ResultArray(blocks.blocks.map((b) => this.NamedBlock(b, state)));\n\n    return list\n      .toArray()\n      .mapOk((list) => new mir.NamedBlocks({ loc: blocks.loc, blocks: OptionalList(list) }));\n  }\n\n  NamedBlock(named: ASTv2.NamedBlock, state: NormalizationState): Result<mir.NamedBlock> {\n    let body = state.visitBlock(named.block);\n\n    return body.mapOk((body) => {\n      return new mir.NamedBlock({\n        loc: named.loc,\n        name: named.name,\n        body: body.toArray(),\n        scope: named.block.scope,\n      });\n    });\n  }\n\n  SimpleElement(element: ASTv2.SimpleElement, state: NormalizationState): Result<mir.Statement> {\n    return new ClassifiedElement(\n      element,\n      new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)),\n      state\n    ).toStatement();\n  }\n\n  Component(component: ASTv2.InvokeComponent, state: NormalizationState): Result<mir.Statement> {\n    return VISIT_EXPRS.visit(component.callee, state).andThen((callee) =>\n      new ClassifiedElement(\n        component,\n        new ClassifiedComponent(callee, component),\n        state\n      ).toStatement()\n    );\n  }\n\n  AppendContent(append: ASTv2.AppendContent, state: NormalizationState): Result<mir.Statement> {\n    let translated = APPEND_KEYWORDS.translate(append, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let value = VISIT_EXPRS.visit(append.value, state);\n\n    return value.mapOk((value) => {\n      if (append.trusting) {\n        return new mir.AppendTrustedHTML({\n          loc: append.loc,\n          html: value,\n        });\n      } else {\n        return new mir.AppendTextNode({\n          loc: append.loc,\n          text: value,\n        });\n      }\n    });\n  }\n\n  TextNode(text: ASTv2.HtmlText): mir.Statement {\n    return new mir.AppendTextNode({\n      loc: text.loc,\n      text: new ASTv2.LiteralExpression({ loc: text.loc, value: text.chars }),\n    });\n  }\n\n  HtmlComment(comment: ASTv2.HtmlComment): mir.Statement {\n    return new mir.AppendComment({\n      loc: comment.loc,\n      value: comment.text,\n    });\n  }\n}\n\nexport const VISIT_STMTS = new NormalizationStatements();\n","import type { ASTv2, SymbolTable } from '@glimmer/syntax';\n\nimport type { OptionalList } from '../../shared/list';\nimport type { Result } from '../../shared/result';\nimport type * as mir from '../2-encoding/mir';\n\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * This is the mutable state for this compiler pass.\n */\nexport class NormalizationState {\n  _currentScope: SymbolTable;\n  _cursorCount = 0;\n\n  constructor(\n    block: SymbolTable,\n    readonly isStrict: boolean\n  ) {\n    this._currentScope = block;\n  }\n\n  generateUniqueCursor(): string {\n    return `%cursor:${this._cursorCount++}%`;\n  }\n\n  get scope(): SymbolTable {\n    return this._currentScope;\n  }\n\n  visitBlock(block: ASTv2.Block): Result<OptionalList<mir.Statement>> {\n    let oldBlock = this._currentScope;\n    this._currentScope = block.scope;\n\n    try {\n      return VISIT_STMTS.visitList(block.body, this);\n    } finally {\n      this._currentScope = oldBlock;\n    }\n  }\n}\n","import type {\n  CurriedType,\n  Nullable,\n  SerializedInlineBlock,\n  SerializedTemplateBlock,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { dict, exhausted } from '@glimmer/util';\nimport { CurriedTypes } from '@glimmer/vm';\nimport { SexpOpcodes as Op } from '@glimmer/wire-format';\n\nimport { inflateAttrName, inflateTagName } from './utils';\n\nexport default class WireFormatDebugger {\n  private upvars: string[];\n  private symbols: string[];\n\n  constructor([_statements, symbols, _hasEval, upvars]: SerializedTemplateBlock) {\n    this.upvars = upvars;\n    this.symbols = symbols;\n  }\n\n  format(program: SerializedTemplateBlock): unknown {\n    let out = [];\n\n    for (let statement of program[0]) {\n      out.push(this.formatOpcode(statement));\n    }\n\n    return out;\n  }\n\n  formatOpcode(opcode: WireFormat.Syntax): unknown {\n    if (Array.isArray(opcode)) {\n      switch (opcode[0]) {\n        case Op.Append:\n          return ['append', this.formatOpcode(opcode[1])];\n        case Op.TrustingAppend:\n          return ['trusting-append', this.formatOpcode(opcode[1])];\n\n        case Op.Block:\n          return [\n            'block',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.InElement:\n          return [\n            'in-element',\n            opcode[1],\n            this.formatOpcode(opcode[2]),\n            opcode[3] ? this.formatOpcode(opcode[3]) : undefined,\n          ];\n\n        case Op.OpenElement:\n          return ['open-element', inflateTagName(opcode[1])];\n\n        case Op.OpenElementWithSplat:\n          return ['open-element-with-splat', inflateTagName(opcode[1])];\n\n        case Op.CloseElement:\n          return ['close-element'];\n\n        case Op.FlushElement:\n          return ['flush-element'];\n\n        case Op.StaticAttr:\n          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.StaticComponentAttr:\n          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.DynamicAttr:\n          return [\n            'dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.ComponentAttr:\n          return [\n            'component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.AttrSplat:\n          return ['attr-splat'];\n\n        case Op.Yield:\n          return ['yield', opcode[1], this.formatParams(opcode[2])];\n\n        case Op.DynamicArg:\n          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.StaticArg:\n          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.TrustingDynamicAttr:\n          return [\n            'trusting-dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.TrustingComponentAttr:\n          return [\n            'trusting-component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.Debugger:\n          return ['debugger', opcode[1]];\n\n        case Op.Comment:\n          return ['comment', opcode[1]];\n\n        case Op.Modifier:\n          return [\n            'modifier',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Component:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatElementParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.HasBlock:\n          return ['has-block', this.formatOpcode(opcode[1])];\n\n        case Op.HasBlockParams:\n          return ['has-block-params', this.formatOpcode(opcode[1])];\n\n        case Op.Curry:\n          return [\n            'curry',\n            this.formatOpcode(opcode[1]),\n            this.formatCurryType(opcode[2]),\n            this.formatParams(opcode[3]),\n            this.formatHash(opcode[4]),\n          ];\n\n        case Op.Undefined:\n          return ['undefined'];\n\n        case Op.Call:\n          return [\n            'call',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Concat:\n          return ['concat', this.formatParams(opcode[1] as WireFormat.Core.Params)];\n\n        case Op.GetStrictKeyword:\n          return ['get-strict-free', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentOrHelperHeadOrThisFallback:\n          return [\n            'GetFreeAsComponentOrHelperHeadOrThisFallback',\n            this.upvars[opcode[1]],\n            opcode[2],\n          ];\n\n        case Op.GetFreeAsComponentOrHelperHead:\n          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsHelperHeadOrThisFallback:\n          return ['GetFreeAsHelperHeadOrThisFallback', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsDeprecatedHelperHeadOrThisFallback:\n          return ['GetFreeAsDeprecatedHelperHeadOrThisFallback', this.upvars[opcode[1]]];\n\n        case Op.GetFreeAsHelperHead:\n          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentHead:\n          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsModifierHead:\n          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetSymbol: {\n          if (opcode[1] === 0) {\n            return ['get-symbol', 'this', opcode[2]];\n          } else {\n            return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];\n          }\n        }\n\n        case Op.GetLexicalSymbol: {\n          return ['get-template-symbol', opcode[1], opcode[2]];\n        }\n\n        case Op.If:\n          return [\n            'if',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.IfInline:\n          return ['if-inline'];\n\n        case Op.Not:\n          return ['not'];\n\n        case Op.Each:\n          return [\n            'each',\n            this.formatOpcode(opcode[1]),\n            opcode[2] ? this.formatOpcode(opcode[2]) : null,\n            this.formatBlock(opcode[3]),\n            opcode[4] ? this.formatBlock(opcode[4]) : null,\n          ];\n\n        case Op.With:\n          return [\n            'with',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.Let:\n          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.Log:\n          return ['log', this.formatParams(opcode[1])];\n\n        case Op.WithDynamicVars:\n          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.GetDynamicVar:\n          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];\n\n        case Op.InvokeComponent:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n      }\n    } else {\n      return opcode;\n    }\n  }\n\n  private formatCurryType(value: CurriedType) {\n    switch (value) {\n      case CurriedTypes.Component:\n        return 'component';\n      case CurriedTypes.Helper:\n        return 'helper';\n      case CurriedTypes.Modifier:\n        return 'modifier';\n      default:\n        throw exhausted(value);\n    }\n  }\n\n  private formatElementParams(\n    opcodes: Nullable<WireFormat.ElementParameter[]>\n  ): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatParams(opcodes: Nullable<WireFormat.Expression[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatHash(hash: WireFormat.Core.Hash): Nullable<object> {\n    if (hash === null) return null;\n\n    return hash[0].reduce((accum, key, index) => {\n      accum[key] = this.formatOpcode(hash[1][index]);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlocks(blocks: WireFormat.Core.Blocks): Nullable<object> {\n    if (blocks === null) return null;\n\n    return blocks[0].reduce((accum, key, index) => {\n      accum[key] = this.formatBlock(blocks[1][index] as SerializedInlineBlock);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlock(block: SerializedInlineBlock): object {\n    return {\n      statements: block[0].map((s) => this.formatOpcode(s)),\n      parameters: block[1],\n    };\n  }\n}\n","import type { PresentArray, WireFormat } from '@glimmer/interfaces';\nimport type { ASTv2 } from '@glimmer/syntax';\nimport { assertPresentArray, isPresentArray, mapPresentArray } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type * as mir from './mir';\n\nexport type HashPair = [string, WireFormat.Expression];\n\nexport class ExpressionEncoder {\n  expr(expr: mir.ExpressionNode): WireFormat.Expression {\n    switch (expr.type) {\n      case 'Missing':\n        return undefined;\n      case 'Literal':\n        return this.Literal(expr);\n      case 'CallExpression':\n        return this.CallExpression(expr);\n      case 'DeprecatedCallExpression':\n        return this.DeprecatedCallExpression(expr);\n      case 'PathExpression':\n        return this.PathExpression(expr);\n      case 'Arg':\n        return [SexpOpcodes.GetSymbol, expr.symbol];\n      case 'Local':\n        return this.Local(expr);\n      case 'This':\n        return [SexpOpcodes.GetSymbol, 0];\n      case 'Free':\n        return [expr.resolution.resolution(), expr.symbol];\n      case 'HasBlock':\n        return this.HasBlock(expr);\n      case 'HasBlockParams':\n        return this.HasBlockParams(expr);\n      case 'Curry':\n        return this.Curry(expr);\n      case 'Not':\n        return this.Not(expr);\n      case 'IfInline':\n        return this.IfInline(expr);\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expr);\n      case 'GetDynamicVar':\n        return this.GetDynamicVar(expr);\n      case 'Log':\n        return this.Log(expr);\n    }\n  }\n\n  Literal({\n    value,\n  }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined {\n    if (value === undefined) {\n      return [SexpOpcodes.Undefined];\n    } else {\n      return value;\n    }\n  }\n\n  Missing(): undefined {\n    return undefined;\n  }\n\n  HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock {\n    return [SexpOpcodes.HasBlock, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams {\n    return [SexpOpcodes.HasBlockParams, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry {\n    return [\n      SexpOpcodes.Curry,\n      EXPR.expr(definition),\n      curriedType,\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n    ];\n  }\n\n  Local({\n    isTemplateLocal,\n    symbol,\n  }: ASTv2.LocalVarReference):\n    | WireFormat.Expressions.GetSymbol\n    | WireFormat.Expressions.GetLexicalSymbol {\n    return [isTemplateLocal ? SexpOpcodes.GetLexicalSymbol : SexpOpcodes.GetSymbol, symbol];\n  }\n\n  GetWithResolver({ symbol }: mir.GetWithResolver): WireFormat.Expressions.GetContextualFree {\n    return [SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback, symbol];\n  }\n\n  PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath {\n    let getOp = EXPR.expr(head) as WireFormat.Expressions.GetVar;\n\n    return [...getOp, EXPR.Tail(tail)];\n  }\n\n  InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat {\n    return [SexpOpcodes.Concat, parts.map((e) => EXPR.expr(e)).toArray()];\n  }\n\n  CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper {\n    return [SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];\n  }\n\n  DeprecatedCallExpression({\n    arg,\n    callee,\n  }: mir.DeprecatedCallExpression): WireFormat.Expressions.GetPathFreeAsDeprecatedHelperHeadOrThisFallback {\n    return [SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback, callee.symbol, [arg.chars]];\n  }\n\n  Tail({ members }: mir.Tail): PresentArray<string> {\n    return mapPresentArray(members, (member) => member.chars);\n  }\n\n  Args({ positional, named }: mir.Args): WireFormat.Core.Args {\n    return [this.Positional(positional), this.NamedArguments(named)];\n  }\n\n  Positional({ list }: mir.Positional): WireFormat.Core.Params {\n    return list.map((l) => EXPR.expr(l)).toPresentArray();\n  }\n\n  NamedArgument({ key, value }: mir.NamedArgument): HashPair {\n    return [key.chars, EXPR.expr(value)];\n  }\n\n  NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash {\n    let list = pairs.toArray();\n\n    if (isPresentArray(list)) {\n      let names: string[] = [];\n      let values: WireFormat.Expression[] = [];\n\n      for (let pair of list) {\n        let [name, value] = EXPR.NamedArgument(pair);\n        names.push(name);\n        values.push(value);\n      }\n\n      assertPresentArray(names);\n      assertPresentArray(values);\n\n      return [names, values];\n    } else {\n      return null;\n    }\n  }\n\n  Not({ value }: mir.Not): WireFormat.Expressions.Not {\n    return [SexpOpcodes.Not, EXPR.expr(value)];\n  }\n\n  IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline {\n    let expr = [SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];\n\n    if (falsy) {\n      expr.push(EXPR.expr(falsy));\n    }\n\n    return expr as WireFormat.Expressions.IfInline;\n  }\n\n  GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar {\n    return [SexpOpcodes.GetDynamicVar, EXPR.expr(name)];\n  }\n\n  Log({ positional }: mir.Log): WireFormat.Expressions.Log {\n    return [SexpOpcodes.Log, this.Positional(positional)];\n  }\n}\n\nexport const EXPR = new ExpressionEncoder();\n","import type {\n  AttrOpcode,\n  ComponentAttrOpcode,\n  DynamicAttrOpcode,\n  StaticAttrOpcode,\n  StaticComponentAttrOpcode,\n  TrustingComponentAttrOpcode,\n  TrustingDynamicAttrOpcode,\n  WellKnownAttrName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { exhausted, LOCAL_LOGGER } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { OptionalList } from '../../shared/list';\nimport type * as mir from './mir';\n\nimport { deflateAttrName, deflateTagName } from '../../utils';\nimport { EXPR } from './expressions';\n\nclass WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {\n  constructor(private statements: readonly S[]) {}\n\n  toArray(): readonly S[] {\n    return this.statements;\n  }\n}\n\nexport class ContentEncoder {\n  list(statements: mir.Statement[]): WireFormat.Statement[] {\n    let out: WireFormat.Statement[] = [];\n\n    for (let statement of statements) {\n      let result = CONTENT.content(statement);\n\n      if (result && result instanceof WireStatements) {\n        out.push(...result.toArray());\n      } else {\n        out.push(result);\n      }\n    }\n\n    return out;\n  }\n\n  content(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    if (LOCAL_SHOULD_LOG) {\n      LOCAL_LOGGER.log(`encoding`, stmt);\n    }\n\n    return this.visitContent(stmt);\n  }\n\n  private visitContent(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    switch (stmt.type) {\n      case 'Debugger':\n        return [SexpOpcodes.Debugger, stmt.scope.getDebugInfo()];\n      case 'AppendComment':\n        return this.AppendComment(stmt);\n      case 'AppendTextNode':\n        return this.AppendTextNode(stmt);\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(stmt);\n      case 'Yield':\n        return this.Yield(stmt);\n      case 'Component':\n        return this.Component(stmt);\n      case 'SimpleElement':\n        return this.SimpleElement(stmt);\n      case 'InElement':\n        return this.InElement(stmt);\n      case 'InvokeBlock':\n        return this.InvokeBlock(stmt);\n      case 'If':\n        return this.If(stmt);\n      case 'Each':\n        return this.Each(stmt);\n      case 'With':\n        return this.With(stmt);\n      case 'Let':\n        return this.Let(stmt);\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(stmt);\n      case 'InvokeComponent':\n        return this.InvokeComponent(stmt);\n      default:\n        return exhausted(stmt);\n    }\n  }\n\n  Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield {\n    return [SexpOpcodes.Yield, to, EXPR.Positional(positional)];\n  }\n\n  InElement({\n    guid,\n    insertBefore,\n    destination,\n    block,\n  }: mir.InElement): WireFormat.Statements.InElement {\n    let wireBlock = CONTENT.NamedBlock(block)[1];\n    // let guid = args.guid;\n    let wireDestination = EXPR.expr(destination);\n    let wireInsertBefore = EXPR.expr(insertBefore);\n\n    if (wireInsertBefore === undefined) {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination];\n    } else {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];\n    }\n  }\n\n  InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block {\n    return [SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];\n  }\n\n  AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend {\n    return [SexpOpcodes.TrustingAppend, EXPR.expr(html)];\n  }\n\n  AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append {\n    return [SexpOpcodes.Append, EXPR.expr(text)];\n  }\n\n  AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment {\n    return [SexpOpcodes.Comment, value.chars];\n  }\n\n  SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements {\n    let op = dynamicFeatures ? SexpOpcodes.OpenElementWithSplat : SexpOpcodes.OpenElement;\n    return new WireStatements<WireFormat.Statement | WireFormat.ElementParameter>([\n      [op, deflateTagName(tag.chars)],\n      ...CONTENT.ElementParameters(params).toArray(),\n      [SexpOpcodes.FlushElement],\n      ...CONTENT.list(body),\n      [SexpOpcodes.CloseElement],\n    ]);\n  }\n\n  Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component {\n    let wireTag = EXPR.expr(tag);\n    let wirePositional = CONTENT.ElementParameters(params);\n    let wireNamed = EXPR.NamedArguments(args);\n\n    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);\n\n    return [\n      SexpOpcodes.Component,\n      wireTag,\n      wirePositional.toPresentArray(),\n      wireNamed,\n      wireNamedBlocks,\n    ];\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter> {\n    return body.map((p) => CONTENT.ElementParameter(p));\n  }\n\n  ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter {\n    switch (param.type) {\n      case 'SplatAttr':\n        return [SexpOpcodes.AttrSplat, param.symbol];\n      case 'DynamicAttr':\n        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];\n      case 'StaticAttr':\n        return [staticAttrOp(param.kind), ...staticAttr(param)];\n      case 'Modifier':\n        return [SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];\n    }\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks {\n    let names: string[] = [];\n    let serializedBlocks: WireFormat.SerializedInlineBlock[] = [];\n\n    for (let block of blocks.toArray()) {\n      let [name, serializedBlock] = CONTENT.NamedBlock(block);\n\n      names.push(name);\n      serializedBlocks.push(serializedBlock);\n    }\n\n    return names.length > 0 ? [names, serializedBlocks] : null;\n  }\n\n  NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock {\n    let nameChars = name.chars;\n    if (nameChars === 'inverse') {\n      nameChars = 'else';\n    }\n    return [nameChars, [CONTENT.list(body), scope.slots]];\n  }\n\n  If({ condition, block, inverse }: mir.If): WireFormat.Statements.If {\n    return [\n      SexpOpcodes.If,\n      EXPR.expr(condition),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each {\n    return [\n      SexpOpcodes.Each,\n      EXPR.expr(value),\n      key ? EXPR.expr(key) : null,\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  With({ value, block, inverse }: mir.With): WireFormat.Statements.With {\n    return [\n      SexpOpcodes.With,\n      EXPR.expr(value),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Let({ positional, block }: mir.Let): WireFormat.Statements.Let {\n    return [SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];\n  }\n\n  WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars {\n    return [SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];\n  }\n\n  InvokeComponent({\n    definition,\n    args,\n    blocks,\n  }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent {\n    return [\n      SexpOpcodes.InvokeComponent,\n      EXPR.expr(definition),\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n      blocks ? CONTENT.NamedBlocks(blocks) : null,\n    ];\n  }\n}\n\nexport const CONTENT = new ContentEncoder();\n\nexport type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];\n\nfunction staticAttr({ name, value, namespace }: mir.StaticAttr): StaticAttrArgs {\n  let out: StaticAttrArgs = [deflateAttrName(name.chars), value.chars];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nexport type DynamicAttrArgs = [\n  name: string | WellKnownAttrName,\n  value: WireFormat.Expression,\n  namespace?: string,\n];\n\nfunction dynamicAttr({ name, value, namespace }: mir.DynamicAttr): DynamicAttrArgs {\n  let out: DynamicAttrArgs = [deflateAttrName(name.chars), EXPR.expr(value)];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nfunction staticAttrOp(kind: { component: boolean }): StaticAttrOpcode | StaticComponentAttrOpcode;\nfunction staticAttrOp(kind: { component: boolean }): AttrOpcode {\n  if (kind.component) {\n    return SexpOpcodes.StaticComponentAttr;\n  } else {\n    return SexpOpcodes.StaticAttr;\n  }\n}\n\nfunction dynamicAttrOp(\n  kind: mir.AttrKind\n):\n  | TrustingComponentAttrOpcode\n  | TrustingDynamicAttrOpcode\n  | ComponentAttrOpcode\n  | DynamicAttrOpcode {\n  if (kind.component) {\n    return kind.trusting ? SexpOpcodes.TrustingComponentAttr : SexpOpcodes.ComponentAttr;\n  } else {\n    return kind.trusting ? SexpOpcodes.TrustingDynamicAttr : SexpOpcodes.DynamicAttr;\n  }\n}\n","import type {\n  Nullable,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  TemplateJavascript,\n} from '@glimmer/interfaces';\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n  TemplateIdFn,\n} from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { normalize, src } from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport pass0 from './passes/1-normalization/index';\nimport { visit as pass2 } from './passes/2-encoding/index';\n\ndeclare function require(id: 'crypto'): Crypto;\ndeclare function require(id: string): unknown;\n\ninterface Crypto {\n  createHash(alg: 'sha1'): {\n    update(src: string, encoding: 'utf8'): void;\n    digest(encoding: 'base64'): string;\n  };\n}\n\nexport const defaultId: TemplateIdFn = (() => {\n  const req: typeof require | undefined =\n    typeof module === 'object' && typeof module.require === 'function'\n      ? module.require\n      : globalThis.require;\n\n  if (req) {\n    try {\n      const crypto = req('crypto');\n\n      const idFn: TemplateIdFn = (src) => {\n        const hash = crypto.createHash('sha1');\n        hash.update(src, 'utf8');\n        // trim to 6 bytes of data (2^48 - 1)\n        return hash.digest('base64').substring(0, 8);\n      };\n\n      idFn('test');\n\n      return idFn;\n    } catch {\n      // do nothing\n    }\n  }\n\n  return function idFn() {\n    return null;\n  };\n})();\n\nconst defaultOptions: PrecompileOptions = {\n  id: defaultId,\n};\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompileJSON(\n  string: Nullable<string>,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): [block: SerializedTemplateBlock, usedLocals: string[]] {\n  const source = new src.Source(string ?? '', options.meta?.moduleName);\n  const [ast, locals] = normalize(source, { lexicalScope: () => false, ...options });\n  const block = pass0(source, ast, options.strictMode ?? false).mapOk((pass2In) => {\n    return pass2(pass2In);\n  });\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.log(`Template ->`, block);\n  }\n\n  if (block.isOk) {\n    return [block.value, locals];\n  } else {\n    throw block.reason;\n  }\n}\n\n// UUID used as a unique placeholder for placing a snippet of JS code into\n// the otherwise JSON stringified value below.\nconst SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompile(\n  source: string,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): TemplateJavascript {\n  const [block, usedLocals] = precompileJSON(source, options);\n\n  const moduleName = options.meta?.moduleName;\n  const idFn = options.id || defaultId;\n  const blockJSON = JSON.stringify(block);\n  const templateJSONObject: SerializedTemplateWithLazyBlock = {\n    id: idFn(JSON.stringify(options.meta) + blockJSON),\n    block: blockJSON,\n    moduleName: moduleName ?? '(unknown template module)',\n    // lying to the type checker here because we're going to\n    // replace it just below, after stringification\n    scope: SCOPE_PLACEHOLDER as unknown as null,\n    isStrictMode: options.strictMode ?? false,\n  };\n\n  if (usedLocals.length === 0) {\n    delete templateJSONObject.scope;\n  }\n\n  // JSON is javascript\n  let stringified = JSON.stringify(templateJSONObject);\n\n  if (usedLocals.length > 0) {\n    const scopeFn = `()=>[${usedLocals.join(',')}]`;\n\n    stringified = stringified.replace(`\"${SCOPE_PLACEHOLDER}\"`, scopeFn);\n  }\n\n  return stringified;\n}\n\nexport type { PrecompileOptions };\n","import type { ASTv2, src } from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type { Result } from '../../shared/result';\n\nimport * as mir from '../2-encoding/mir';\nimport { NormalizationState } from './context';\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special\n * instructions for keywords like `{{yield}}`, `(has-block)` and\n * `{{#in-element}}`.\n *\n * Most importantly, it also classifies HTML element syntax into:\n *\n * 1. simple HTML element (with optional splattributes)\n * 2. component invocation\n *\n * Because the @glimmer/syntax AST gives us a string for an element's tag,\n * this pass also normalizes that string into an expression.\n *\n * ```\n * // normalized into a path expression whose head is `this` and tail is\n * // `[\"x\"]`\n * <this.x />\n *\n * {{#let expr as |t|}}\n *   // `\"t\"` is normalized into a variable lookup.\n *   <t />\n *\n *   // normalized into a path expression whose head is the variable lookup\n *   // `t` and tail is `[\"input\"]`.\n *   <t.input />\n * {{/let}}\n *\n * // normalized into a free variable lookup for `SomeComponent` (with the\n * // context `ComponentHead`).\n * <SomeComponent />\n *\n * // normalized into a path expression whose head is the free variable\n * // `notInScope` (with the context `Expression`), and whose tail is\n * // `[\"SomeComponent\"]`. In resolver mode, this path will be rejected later,\n * // since it cannot serve as an input to the resolver.\n * <notInScope.SomeComponent />\n * ```\n */\nexport default function normalize(\n  source: src.Source,\n  root: ASTv2.Template,\n  isStrict: boolean\n): Result<mir.Template> {\n  // create a new context for the normalization pass\n  let state = new NormalizationState(root.table, isStrict);\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);\n    LOCAL_LOGGER.log('symbols', root.table);\n    LOCAL_LOGGER.log('source', source);\n    LOCAL_LOGGER.groupEnd();\n  }\n\n  let body = VISIT_STMTS.visitList(root.body, state);\n\n  if (LOCAL_SHOULD_LOG) {\n    if (body.isOk) {\n      LOCAL_LOGGER.log('-> pass0: out', body.value);\n    } else {\n      LOCAL_LOGGER.log('-> pass0: error', body.reason);\n    }\n  }\n\n  return body.mapOk(\n    (body) => new mir.Template({ loc: root.loc, scope: root.table, body: body.toArray() })\n  );\n}\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type * as mir from './mir';\n\nimport WireFormatDebugger from '../../wire-format-debug';\nimport { CONTENT } from './content';\n\nexport function visit(template: mir.Template): WireFormat.SerializedTemplateBlock {\n  let statements = CONTENT.list(template.body);\n  let scope = template.scope;\n  let block: WireFormat.SerializedTemplateBlock = [\n    statements,\n    scope.symbols,\n    scope.hasEval,\n    scope.upvars,\n  ];\n\n  if (LOCAL_SHOULD_LOG) {\n    let debug = new WireFormatDebugger(block);\n    LOCAL_LOGGER.log(\n      `-> `,\n      statements.map((s) => debug.formatOpcode(s))\n    );\n  }\n\n  return block;\n}\n"],"names":["HeadKind","VariableKind","normalizeStatement","statement","Array","isArray","name","Builder","Literal","Get","Concat","HasBlock","HasBlockParams","statementIsExpression","normalizeAppendExpression","isSugaryArrayStatement","params","hash","length","normalizeParams","normalizeHash","kind","Call","head","normalizeCallHead","trusted","path","blocks","blockParams","normalizeBuilderBlockStatement","Block","slice","Keyword","attrs","dict","block","normalizeAttrs","normalizeBlock","Element","expect","extractElement","Error","JSON","stringify","normalizeSugaryArrayStatement","value","Append","Modifier","DynamicComponent","expr","normalizeExpression","Comment","normalizeVerboseStatement","normalizeAppendHead","normalizeDottedPath","assertNever","type","ExpressionKind","GetPath","AppendPath","AppendExpr","extractBlockHead","result","exec","normalizePath","tail","pathHead","normalizePathHead","isPresentArray","GetVar","variable","whole","rest","split","mode","test","This","Free","Arg","Local","normalizeBlocks","normalizeBlockHash","out","callback","Object","keys","forEach","key","entries","default","mapObject","map","s","a","attr","Splat","normalizeAttr","object","mapper","k","input","match","expression","forceTrusted","isBuilderCallExpression","normalizeCallExpression","ProgramSymbols","_freeVariables","_symbols","top","this","toSymbols","toUpvars","freeVar","addString","symbol","arg","local","hasLocal","_name","child","locals","LocalSymbols","constructor","parent","paramSymbols","values","array","item","index","indexOf","push","unimpl","message","buildStatements","statements","symbols","buildStatement","buildNormalizedStatements","normalized","Op","TrustingAppend","buildGetPath","buildExpression","builtParams","buildParams","builtHash","buildHash","builtExpr","buildCallHead","VariableResolutionContext","AmbiguousInvoke","AmbiguousAppendInvoke","buildBlock","buildBlocks","ResolveAsComponentHead","buildKeyword","hasSplat","OpenElementWithSplat","OpenElement","args","AttrSplat","buildAttributeValue","extractNamespace","buildElementParams","assert","FlushElement","CloseElement","buildElement","arr","interpolated","reduce","string","i","String","c","unicode","charCode","fromCharCode","parseInt","NEWLINE","childSymbols","inverse","With","If","keyExpr","Each","some","NS_XMLNS","NS_XLINK","NS_XML","namespace","val","StaticAttr","undefined","DynamicAttr","varContext","context","bare","buildVar","buildConcat","Strict","Undefined","callHead","sym","op","GetSymbol","GetStrictKeyword","GetFreeAsComponentOrHelperHeadOrThisFallback","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHeadOrThisFallback","GetFreeAsHelperHead","AmbiguousAppend","ResolveAsCallHead","ResolveAsModifierHead","GetFreeAsModifierHead","GetFreeAsComponentHead","exhausted","expressionContextOp","getSymbolForVar","exprs","e","LOCAL_SHOULD_LOG","window","location","search","Template","node","fields","InElement","Not","IfInline","Let","WithDynamicVars","GetDynamicVar","Log","InvokeComponent","NamedBlocks","NamedBlock","AppendTrustedHTML","AppendTextNode","AppendComment","Component","SimpleElement","ElementParameters","Yield","Debugger","CallExpression","DeprecatedCallExpression","InvokeBlock","SplatAttr","PathExpression","Missing","InterpolateExpression","Curry","Positional","NamedArguments","NamedArgument","Args","Tail","PresentList","list","toArray","mapPresentArray","filter","predicate","OptionalList","toPresentArray","into","ifPresent","EmptyList","_callback","_predicate","ifEmpty","ResultImpl","all","results","isErr","cast","Ok","Result","OkImpl","isOk","super","_message","ifOk","andThen","mapOk","ifErr","mapErr","ErrImpl","reason","Err","ResultArray","items","add","err","toOptionalList","hasPath","callee","assertIsValidModifier","helper","ref","ASTv2","isStrictResolution","resolution","parts","isSimplePath","generateSyntaxError","printPath","loc","printedPath","printPathHead","t","chars","join","unreachable","convertPathToCallIfKeyword","KEYWORDS_TYPES","empty","VISIT_EXPRS","visit","state","Interpolate","translated","CALL_KEYWORDS","translate","DeprecaedCallExpression","visitList","nodes","VariableReference","tailLoc","extend","getLast","mir","members","literal","_state","positional","named","pairs","KeywordImpl","types","keyword","delegate","Set","nodeType","KEYWORD_NODES","has","getCalleeExpression","serialize","asString","param","Keywords","_keywords","_type","kw","isKeyword","usedType","validTypes","includes","typesToReadableName","generateTypesMessage","keywords","toAppend","text","CurriedTypeToReadableType","CurriedTypes","Helper","assertCurryKeyword","curriedType","readableType","stringsAllowed","definition","nth","isStrict","PositionalArguments","translateCurryKeyword","definitionResult","argsResult","curryKeyword","getDynamicVarKeyword","call","positionals","isEmpty","varName","size","assertHasBlockKeyword","SourceSlice","synthetic","isLiteral","toSlice","translateHasBlockKeyword","scope","target","allocateBlock","hasBlockKeyword","assertIfUnlessInlineKeyword","originalNode","inverted","condition","truthy","falsy","translateIfUnlessInlineKeyword","conditionResult","truthyResult","falsyResult","ifUnlessInlineKeyword","logKeyword","APPEND_KEYWORDS","src","SourceSpan","get","to","setHasDebugger","BLOCK_KEYWORDS","guid","insertBefore","destination","body","VISIT_STMTS","destinationResult","collapse","generateUniqueCursor","blockResult","inverseResult","every","valueResult","keyResult","positionalResult","namedResult","blocksResult","MODIFIER_KEYWORDS","XLINK","XML","XMLNS","WHITELIST","xmlns","DEFLATE_TAG_TABLE","div","WellKnownTagNames","span","p","INFLATE_TAG_TABLE","inflateTagName","tagName","DEFLATE_ATTR_TABLE","class","WellKnownAttrNames","id","style","href","INFLATE_ATTR_TABLE","deflateAttrName","attrName","inflateAttrName","ClassifiedElement","element","toStatement","prepare","prepared","rawValue","component","dynamicFeatures","isTrusting","trusting","modifier","isHelperInvocation","typeAttr","simple","componentArgs","maybeLoc","NON_EXISTENT","modifiers","m","elementParams","ClassifiedComponent","tag","ClassifiedSimpleElement","isComponent","classified","AppendContent","TextNode","HtmlComment","b","visitBlock","hasDynamicFeatures","append","html","LiteralExpression","comment","NormalizationState","_currentScope","_cursorCount","oldBlock","WireFormatDebugger","upvars","_statements","_hasEval","format","program","formatOpcode","opcode","formatParams","formatHash","formatBlocks","StaticComponentAttr","ComponentAttr","DynamicArg","StaticArg","TrustingDynamicAttr","TrustingComponentAttr","formatElementParams","formatCurryType","GetFreeAsDeprecatedHelperHeadOrThisFallback","GetLexicalSymbol","formatBlock","opcodes","o","accum","parameters","EXPR","SexpOpcodes","isTemplateLocal","GetWithResolver","member","l","names","pair","assertPresentArray","WireStatements","CONTENT","content","stmt","LOCAL_LOGGER","log","visitContent","getDebugInfo","wireBlock","wireDestination","wireInsertBefore","wireTag","wirePositional","wireNamed","wireNamedBlocks","ElementParameter","dynamicAttrOp","dynamicAttr","staticAttrOp","staticAttr","serializedBlocks","serializedBlock","nameChars","slots","defaultId","req","module","require","globalThis","crypto","idFn","createHash","update","digest","substring","defaultOptions","precompileJSON","options","source","Source","meta","moduleName","ast","normalize","lexicalScope","root","table","groupCollapsed","groupEnd","pass0","strictMode","pass2In","template","hasEval","debug","pass2","SCOPE_PLACEHOLDER","precompile","usedLocals","blockJSON","templateJSONObject","isStrictMode","stringified","scopeFn","replace"],"mappings":"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"}