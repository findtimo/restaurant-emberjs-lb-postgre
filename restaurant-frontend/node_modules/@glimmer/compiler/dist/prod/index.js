import{assertNever as e,dict as t,expect as r,isPresentArray as n,values as a,assert as s,NS_XMLNS as l,NS_XML as o,NS_XLINK as i,exhausted as c,mapPresentArray as u,unreachable as p,getLast as m,LOCAL_LOGGER as d,assertPresentArray as h}from"@glimmer/util";import{VariableResolutionContext as f,SexpOpcodes as k,WellKnownTagNames as y,WellKnownAttrNames as g}from"@glimmer/wire-format";import{node as w,generateSyntaxError as v,ASTv2 as A,KEYWORDS_TYPES as b,isKeyword as x,SourceSlice as C,src as E,maybeLoc as B,normalize as O}from"@glimmer/syntax";import{CurriedTypes as H}from"@glimmer/vm";let S=function(e){return e.Block="Block",e.Call="Call",e.Element="Element",e.AppendPath="AppendPath",e.AppendExpr="AppendExpr",e.Literal="Literal",e.Modifier="Modifier",e.DynamicComponent="DynamicComponent",e.Comment="Comment",e.Splat="Splat",e.Keyword="Keyword",e}({}),P=function(e){return e.Local="Local",e.Free="Free",e.Arg="Arg",e.Block="Block",e.This="This",e}({});function L(n){if(Array.isArray(n))return function(e){if(!Array.isArray(e))return!1;const t=e[0];if("number"==typeof t)switch(t){case z.Literal:case z.Get:case z.Concat:case z.HasBlock:case z.HasBlockParams:return!0;default:return!1}if("("===t[0])return!0;return!1}(n)?U(n):function(e){if(Array.isArray(e)&&"string"==typeof e[0])switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(n)?function(e){const n=e[0];switch(n[0]){case"(":{let t=null,r=null;return 3===e.length?(t=Y(e[1]),r=X(e[2])):2===e.length&&(Array.isArray(e[1])?t=Y(e[1]):r=X(e[1])),{kind:S.Call,head:G(n),params:t,hash:r,trusted:!1}}case"#":{const{head:t,params:r,hash:n,blocks:a,blockParams:s}=D(e);return{kind:S.Block,head:t,params:r,hash:n,blocks:a,blockParams:s}}case"!":{const t=e[0].slice(1),{params:r,hash:n,blocks:a,blockParams:s}=D(e);return{kind:S.Keyword,name:t,params:r,hash:n,blocks:a,blockParams:s}}case"<":{let a=t(),s=[];return 3===e.length?(a=W(e[1]),s=_(e[2])):2===e.length&&(Array.isArray(e[1])?s=_(e[1]):a=W(e[1])),{kind:S.Element,name:r(q(n),`BUG: expected ${n} to look like a tag name`),attrs:a,block:s}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(n):function(e){switch(e[0]){case z.Literal:return{kind:S.Literal,value:e[1]};case z.Append:return U(e[1],e[2]);case z.Modifier:return{kind:S.Modifier,params:Y(e[1]),hash:X(e[2])};case z.DynamicComponent:return{kind:S.DynamicComponent,expr:J(e[1]),hash:X(e[2]),block:_(e[3])};case z.Comment:return{kind:S.Comment,value:e[1]}}}(n);if("string"==typeof n)return N(I(n),!1);throw e(n)}function N(e,t){return e.type===R.GetPath?{kind:S.AppendPath,path:e,trusted:t}:{kind:S.AppendExpr,expr:e,trusted:t}}function T(e){const t=/^(#|!)(.*)$/u.exec(e);if(null===t)throw new Error("Unexpected missing # in block head");return I(t[2])}function G(e){const t=/^\((.*)\)$/u.exec(e);if(null===t)throw new Error("Unexpected missing () in call head");return I(t[1])}function $(e,t=[]){const r=F(e);return n(t)?{type:R.GetPath,path:{head:r,tail:t}}:{type:R.GetVar,variable:r}}function I(e){const{kind:t,name:r}=F(e),[a,...s]=r.split("."),l={kind:t,name:a,mode:"loose"};return n(s)?{type:R.GetPath,path:{head:l,tail:s}}:{type:R.GetVar,variable:l}}function F(e){let t,r;if(/^this(?:\.|$)/u.test(e))return{kind:P.This,name:e,mode:"loose"};switch(e[0]){case"^":t=P.Free,r=e.slice(1);break;case"@":t=P.Arg,r=e.slice(1);break;case"&":t=P.Block,r=e.slice(1);break;default:t=P.Local,r=e}return{kind:t,name:r,mode:"loose"}}function D(e){const r=e[0];let n=t(),a=null,s=null,l=null;return 2===e.length?n=V(e[1]):3===e.length?(Array.isArray(e[1])?a=Y(e[1]):({hash:s,blockParams:l}=M(e[1])),n=V(e[2])):4===e.length&&(a=Y(e[1]),({hash:s,blockParams:l}=M(e[2])),n=V(e[3])),{head:T(r),params:a,hash:s,blockParams:l,blocks:n}}function M(e){if(null===e)return{hash:null,blockParams:null};let r=null,n=null;return function(e,t){Object.keys(e).forEach((r=>{const n=e[r];t(r,n)}))}(e,((e,a)=>{"as"===e?n=Array.isArray(a)?a:[a]:(r=r||t(),r[e]=J(a))})),{hash:r,blockParams:n}}function V(e){return Array.isArray(e)?{default:_(e)}:j(e,_)}function _(e){return e.map((e=>L(e)))}function W(e){return j(e,(e=>function(e){if("splat"===e)return{expr:S.Splat,trusted:!1};return{expr:J(e),trusted:!1}}(e).expr))}function j(e,r){const n=t();return Object.keys(e).forEach((t=>{n[t]=r(e[t],t)})),n}function q(e){const t=/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(e);return t?.[1]??null}let z=function(e){return e[e.Literal=0]="Literal",e[e.Comment=1]="Comment",e[e.Append=2]="Append",e[e.Modifier=3]="Modifier",e[e.DynamicComponent=4]="DynamicComponent",e[e.Get=5]="Get",e[e.Concat=6]="Concat",e[e.HasBlock=7]="HasBlock",e[e.HasBlockParams=8]="HasBlockParams",e}({}),R=function(e){return e.Literal="Literal",e.Call="Call",e.GetPath="GetPath",e.GetVar="GetVar",e.Concat="Concat",e.HasBlock="HasBlock",e.HasBlockParams="HasBlockParams",e}({});function U(t,r=!1){if(null==t)return{expr:{type:R.Literal,value:t},kind:S.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case z.Literal:return{expr:{type:R.Literal,value:t[1]},kind:S.AppendExpr,trusted:!1};case z.Get:return N($(t[1],t[2]),r);case z.Concat:return{expr:{type:R.Concat,params:Y(t.slice(1))},kind:S.AppendExpr,trusted:r};case z.HasBlock:return{expr:{type:R.HasBlock,name:t[1]},kind:S.AppendExpr,trusted:r};case z.HasBlockParams:return{expr:{type:R.HasBlockParams,name:t[1]},kind:S.AppendExpr,trusted:r};default:if(K(t))return{expr:Z(t),kind:S.AppendExpr,trusted:r};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return N(I(t),r);case"boolean":case"number":return{expr:{type:R.Literal,value:t},kind:S.AppendExpr,trusted:!0};default:throw e(t)}}}function J(t){if(null==t)return{type:R.Literal,value:t};if(Array.isArray(t))switch(t[0]){case z.Literal:return{type:R.Literal,value:t[1]};case z.Get:return $(t[1],t[2]);case z.Concat:return{type:R.Concat,params:Y(t.slice(1))};case z.HasBlock:return{type:R.HasBlock,name:t[1]};case z.HasBlockParams:return{type:R.HasBlockParams,name:t[1]};default:if(K(t))return Z(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return I(t);case"boolean":case"number":return{type:R.Literal,value:t};default:throw e(t)}}}function K(e){return"string"==typeof e[0]&&"("===e[0][0]}function Y(e){return e.map(J)}function X(e){return null===e?null:j(e,J)}function Z(e){switch(e.length){case 1:return{type:R.Call,head:G(e[0]),params:null,hash:null};case 2:return Array.isArray(e[1])?{type:R.Call,head:G(e[0]),params:Y(e[1]),hash:null}:{type:R.Call,head:G(e[0]),params:null,hash:X(e[1])};case 3:return{type:R.Call,head:G(e[0]),params:Y(e[1]),hash:X(e[2])}}}class Q{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return te(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return te(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return te(this._symbols,e)}child(e){return new ee(this,e)}}class ee{locals=t();constructor(e,t){this.parent=e;for(let r of t)this.locals[r]=e.top.symbol(r)}get paramSymbols(){return a(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new ee(this,e)}}function te(e,t){let r=e.indexOf(t);return-1===r?(r=e.length,e.push(t),r):r}function re(e){return new Error(`unimplemented ${e}`)}function ne(e,t){let r=[];return e.forEach((e=>r.push(...se(L(e),t)))),r}function ae(e,t){let r=[];return e.forEach((e=>r.push(...se(e,t)))),r}function se(t,r=new Q){switch(t.kind){case S.AppendPath:return[[t.trusted?k.TrustingAppend:k.Append,ye(t.path,r)]];case S.AppendExpr:return[[t.trusted?k.TrustingAppend:k.Append,fe(t.expr,t.trusted?"TrustedAppend":"Append",r)]];case S.Call:{let{head:e,params:n,hash:a,trusted:s}=t,l=n?we(n,r):null,o=a?Ae(a,r):null,i=ke(e,s?f.AmbiguousInvoke:f.AmbiguousAppendInvoke,r);return[[s?k.TrustingAppend:k.Append,[k.Call,i,l,o]]]}case S.Literal:return[[k.Append,t.value]];case S.Comment:return[[k.Comment,t.value]];case S.Block:{let e=function(e,t,r){let n=[],a=[];for(const[s,l]of Object.entries(e))if(n.push(s),"default"===s){let e=r.child(t||[]);a.push(be(l,e,e.paramSymbols))}else a.push(be(l,r,[]));return[n,a]}(t.blocks,t.blockParams,r),n=Ae(t.hash,r),a=we(t.params,r),s=ke(t.head,f.ResolveAsComponentHead,r);return[[k.Block,s,a,n,e]]}case S.Keyword:return[ue(t,r)];case S.Element:return function({name:t,attrs:r,block:a},l){let o=[pe(r)?[k.OpenElementWithSplat,t]:[k.OpenElement,t]];if(r){let{params:e,args:t}=function(e,t){let r=[],a=[],s=[];for(const[n,l]of Object.entries(e))l===S.Splat?r.push([k.AttrSplat,t.block("&attrs")]):"@"===n[0]?(a.push(n),s.push(fe(l,"Strict",t))):r.push(...de(n,l,me(n),t));return{params:r,args:n(a)&&n(s)?[a,s]:null}}(r,l);o.push(...e),s(null===t,"Can't pass args to a simple element")}if(o.push([k.FlushElement]),Array.isArray(a))a.forEach((e=>o.push(...se(e,l))));else if(null!==a)throw e(a);return o.push([k.CloseElement]),o}(t,r);case S.Modifier:throw re("modifier");case S.DynamicComponent:throw re("dynamic component");default:throw e(t)}}function le(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[z.Literal,r]}function oe(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[z.Comment,r]}function ie(e){return String.fromCharCode(parseInt(e,16))}const ce="\n";function ue(e,t){let{name:n}=e,a=we(e.params,t),s=t.child(e.blockParams||[]),l=be(e.blocks.default,s,s.paramSymbols),o=e.blocks.else?be(e.blocks.else,t,[]):null;switch(n){case"with":return[k.With,r(a,"with requires params")[0],l,o];case"if":return[k.If,r(a,"if requires params")[0],l,o];case"each":{let n=e.hash?e.hash.key:null,s=n?fe(n,"Strict",t):null;return[k.Each,r(a,"if requires params")[0],s,l,o]}default:throw new Error("unimplemented keyword")}}function pe(e){return null!==e&&Object.keys(e).some((t=>e[t]===S.Splat))}function me(e){if("xmlns"===e)return l;let t=/^([^:]*):([^:]*)$/u.exec(e);if(null===t)return null;switch(t[1]){case"xlink":return i;case"xml":return o;case"xmlns":return l}return null}function de(e,t,r,n){if(t.type===R.Literal){let n=t.value;if(!1===n)return[];if(!0===n)return[[k.StaticAttr,e,"",r??void 0]];if("string"==typeof n)return[[k.StaticAttr,e,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[k.DynamicAttr,e,fe(t,"AttrValue",n),r??void 0]]}function he(e,t){switch(e){case"Append":return t?"AppendBare":"AppendInvoke";case"TrustedAppend":return t?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return t?"AttrValueBare":"AttrValueInvoke";default:return e}}function fe(t,r,n){switch(t.type){case R.GetPath:return ye(t,n);case R.GetVar:return ge(t.variable,he(r,!0),n);case R.Concat:return[k.Concat,ve(t.params,n)];case R.Call:{let e=we(t.params,n),a=Ae(t.hash,n),s=ke(t.head,"Strict"===r?"SubExpression":he(r,!1),n);return[k.Call,s,e,a]}case R.HasBlock:return[k.HasBlock,ge({kind:P.Block,name:t.name,mode:"loose"},f.Strict,n)];case R.HasBlockParams:return[k.HasBlockParams,ge({kind:P.Block,name:t.name,mode:"loose"},f.Strict,n)];case R.Literal:return void 0===t.value?[k.Undefined]:t.value;default:e(t)}}function ke(e,t,r){return e.type===R.GetVar?ge(e.variable,t,r):ye(e,r)}function ye(e,t){return ge(e.path.head,f.Strict,t,e.path.tail)}function ge(e,t,r,n){let a,s=k.GetSymbol;if(e.kind===P.Free)s="Strict"===t?k.GetStrictKeyword:"AppendBare"===t?k.GetFreeAsComponentOrHelperHeadOrThisFallback:"AppendInvoke"===t?k.GetFreeAsComponentOrHelperHead:"TrustedAppendBare"===t?k.GetFreeAsHelperHeadOrThisFallback:"TrustedAppendInvoke"===t?k.GetFreeAsHelperHead:"AttrValueBare"===t?k.GetFreeAsHelperHeadOrThisFallback:"AttrValueInvoke"===t||"SubExpression"===t?k.GetFreeAsHelperHead:function(e){switch(e){case f.Strict:return k.GetStrictKeyword;case f.AmbiguousAppend:return k.GetFreeAsComponentOrHelperHeadOrThisFallback;case f.AmbiguousAppendInvoke:return k.GetFreeAsComponentOrHelperHead;case f.AmbiguousInvoke:return k.GetFreeAsHelperHeadOrThisFallback;case f.ResolveAsCallHead:return k.GetFreeAsHelperHead;case f.ResolveAsModifierHead:return k.GetFreeAsModifierHead;case f.ResolveAsComponentHead:return k.GetFreeAsComponentHead;default:return c(e)}}(t),a=r.freeVar(e.name);else s=k.GetSymbol,a=function(e,t,r){switch(e){case P.Arg:return t.arg(r);case P.Block:return t.block(r);case P.Local:return t.local(r);case P.This:return t.this();default:return c(e)}}(e.kind,r,e.name);return void 0===n||0===n.length?[s,a]:[s,a,n]}function we(e,t){return null!==e&&n(e)?e.map((e=>fe(e,"Strict",t))):null}function ve(e,t){return e.map((e=>fe(e,"AttrValue",t)))}function Ae(e,t){if(null===e)return null;let r=[[],[]];for(const[n,a]of Object.entries(e))r[0].push(n),r[1].push(fe(a,"Strict",t));return r}function be(e,t,r=[]){return[ae(e,t),r]}const xe=!("undefined"==typeof window||!window.location||!/[&?]enable_local_should_log/u.test(window.location.search));class Ce extends(w("Template").fields()){}class Ee extends(w("InElement").fields()){}class Be extends(w("Not").fields()){}class Oe extends(w("If").fields()){}class He extends(w("IfInline").fields()){}class Se extends(w("Each").fields()){}class Pe extends(w("With").fields()){}class Le extends(w("Let").fields()){}class Ne extends(w("WithDynamicVars").fields()){}class Te extends(w("GetDynamicVar").fields()){}class Ge extends(w("Log").fields()){}class $e extends(w("InvokeComponent").fields()){}class Ie extends(w("NamedBlocks").fields()){}class Fe extends(w("NamedBlock").fields()){}w("EndBlock").fields();class De extends(w("AppendTrustedHTML").fields()){}class Me extends(w("AppendTextNode").fields()){}class Ve extends(w("AppendComment").fields()){}class _e extends(w("Component").fields()){}class We extends(w("StaticAttr").fields()){}class je extends(w("DynamicAttr").fields()){}class qe extends(w("SimpleElement").fields()){}class ze extends(w("ElementParameters").fields()){}class Re extends(w("Yield").fields()){}class Ue extends(w("Debugger").fields()){}class Je extends(w("CallExpression").fields()){}class Ke extends(w("DeprecatedCallExpression").fields()){}class Ye extends(w("Modifier").fields()){}class Xe extends(w("InvokeBlock").fields()){}class Ze extends(w("SplatAttr").fields()){}class Qe extends(w("PathExpression").fields()){}w("GetWithResolver").fields();w("GetSymbol").fields();w("GetFreeWithContext").fields();w("GetFree").fields();class et extends(w("Missing").fields()){}class tt extends(w("InterpolateExpression").fields()){}class rt extends(w("HasBlock").fields()){}class nt extends(w("HasBlockParams").fields()){}class at extends(w("Curry").fields()){}class st extends(w("Positional").fields()){}class lt extends(w("NamedArguments").fields()){}class ot extends(w("NamedArgument").fields()){}class it extends(w("Args").fields()){}class ct extends(w("Tail").fields()){}class ut{constructor(e){this.list=e}toArray(){return this.list}map(e){let t=u(this.list,e);return new ut(t)}filter(e){let t=[];for(let r of this.list)e(r)&&t.push(r);return mt(t)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class pt{list=[];map(e){return new pt}filter(e){return new pt}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function mt(e){return n(e)?new ut(e):new pt}class dt{static all(...e){let t=[];for(let r of e){if(r.isErr)return r.cast();t.push(r.value)}return yt(t)}}const ht=dt;class ft extends dt{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return yt(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class kt extends dt{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return gt(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function yt(e){return new ft(e)}function gt(e){return new kt(e)}class wt{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter((e=>e instanceof kt))[0];return void 0!==e?e.cast():yt(this.items.map((e=>e.value)))}toOptionalList(){return this.toArray().mapOk((e=>mt(e)))}}function vt(e){return"Path"===e.callee.type}function At(e){var t;if("Path"===(t=e).callee.type&&"Free"===t.callee.ref.type&&!A.isStrictResolution(t.callee.ref.resolution)&&!function(e){if("Path"===e.type){let{ref:t,tail:r}=e;return"Free"===t.type&&!A.isStrictResolution(t.resolution)&&0===r.length}return!1}(e.callee))throw v(`\`${bt(e.callee)}\` is not a valid name for a modifier`,e.loc)}function bt(e){switch(e.type){case"Literal":return JSON.stringify(e.value);case"Path":{let t=[xt(e.ref)];return t.push(...e.tail.map((e=>e.chars))),t.join(".")}case"Call":return`(${bt(e.callee)} ...)`;case"DeprecatedCall":return`${e.callee.name}`;case"Interpolate":throw p("a concat statement cannot appear as the head of an expression")}}function xt(e){switch(e.type){case"Arg":return e.name.chars;case"Free":case"Local":return e.name;case"This":return"this"}}function Ct(e){return"Path"===e.type&&"Free"===e.ref.type&&e.ref.name in b?new A.CallExpression({callee:e,args:A.Args.empty(e.loc),loc:e.loc}):e}const Et=new class{visit(e,t){switch(e.type){case"Literal":return yt(this.Literal(e));case"Interpolate":return this.Interpolate(e,t);case"Path":return this.PathExpression(e);case"Call":{let r=Ut.translate(e,t);return null!==r?r:this.CallExpression(e,t)}case"DeprecatedCall":return this.DeprecaedCallExpression(e,t)}}visitList(e,t){return new wt(e.map((e=>Et.visit(e,t)))).toOptionalList()}PathExpression(e){let t=this.VariableReference(e.ref),{tail:r}=e;if(n(r)){let n=r[0].loc.extend(m(r).loc);return yt(new Qe({loc:e.loc,head:t,tail:new ct({loc:n,members:r})}))}return yt(t)}VariableReference(e){return e}Literal(e){return e}Interpolate(e,t){let r=e.parts.map(Ct);return Et.visitList(r,t).mapOk((t=>new tt({loc:e.loc,parts:t})))}CallExpression(e,t){if(vt(e))return ht.all(Et.visit(e.callee,t),Et.Args(e.args,t)).mapOk((([t,r])=>new Je({loc:e.loc,callee:t,args:r})));throw new Error("unimplemented subexpression at the head of a subexpression")}DeprecaedCallExpression({arg:e,callee:t,loc:r},n){return yt(new Ke({loc:r,arg:e,callee:t}))}Args({positional:e,named:t,loc:r},n){return ht.all(this.Positional(e,n),this.NamedArguments(t,n)).mapOk((([e,t])=>new it({loc:r,positional:e,named:t})))}Positional(e,t){return Et.visitList(e.exprs,t).mapOk((t=>new st({loc:e.loc,list:t})))}NamedArguments(e,t){let r=e.entries.map((e=>{let r=Ct(e.value);return Et.visit(r,t).mapOk((t=>new ot({loc:e.loc,key:e.name,value:t})))}));return new wt(r).toOptionalList().mapOk((t=>new lt({loc:e.loc,entries:t})))}};class Bt{types;constructor(e,t,r){this.keyword=e,this.delegate=r;let n=new Set;for(let e of Ot[t])n.add(e);this.types=n}match(e){if(!this.types.has(e.type))return!1;let t=Ht(e);return null!==t&&"Path"===t.type&&"Free"===t.ref.type&&(!(t.tail.length>0&&"Loose"===t.ref.resolution.serialize())&&t.ref.name===this.keyword)}translate(e,t){if(this.match(e)){let r=Ht(e);return null!==r&&"Path"===r.type&&r.tail.length>0?gt(v(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${r.loc.asString()}\`, but it cannot be used with additional path segments. \n\nError caused by`,e.loc)):this.delegate.assert(e,t).andThen((r=>this.delegate.translate({node:e,state:t},r)))}return null}}const Ot={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function Ht(e){switch(e.type){case"Path":return e;case"AppendContent":return Ht(e.value);case"Call":case"InvokeBlock":case"ElementModifier":return e.callee;default:return null}}class St{_keywords=[];_type;constructor(e){this._type=e}kw(e,t){return this._keywords.push(function(e,t,r){return new Bt(e,t,r)}(e,this._type,t)),this}translate(e,t){for(let r of this._keywords){let n=r.translate(e,t);if(null!==n)return n}let r=Ht(e);if(r&&"Path"===r.type&&"Free"===r.ref.type&&x(r.ref.name)){let{name:t}=r.ref,n=this._type,a=b[t];if(!a.includes(n))return gt(v(`The \`${t}\` keyword was used incorrectly. It was used as ${Pt[n]}, but its valid usages are:\n\n${function(e,t){return t.map((t=>{switch(t){case"Append":return`- As an append statement, as in: {{${e}}}`;case"Block":return`- As a block statement, as in: {{#${e}}}{{/${e}}}`;case"Call":return`- As an expression, as in: (${e})`;case"Modifier":return`- As a modifier, as in: <div {{${e}}}></div>`;default:return c(t)}})).join("\n\n")}(t,a)}\n\nError caused by`,e.loc))}return null}}const Pt={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function Lt(e){return new St(e)}function Nt({assert:e,translate:t}){return{assert:e,translate:({node:e,state:r},n)=>t({node:e,state:r},n).mapOk((t=>new Me({text:t,loc:e.loc})))}}const Tt={[H.Component]:"component",[H.Helper]:"helper",[H.Modifier]:"modifier"};function Gt(e){return(t,r)=>{let n=Tt[e],a=e===H.Component,{args:s}=t,l=s.nth(0);if(null===l)return gt(v(`(${n}) requires a ${n} definition or identifier as its first positional parameter, did not receive any parameters.`,s.loc));if("Literal"===l.type){if(a&&r.isStrict)return gt(v(`(${n}) cannot resolve string values in strict mode templates`,t.loc));if(!a)return gt(v(`(${n}) cannot resolve string values, you must pass a ${n} definition directly`,t.loc))}return s=new A.Args({positional:new A.PositionalArguments({exprs:s.positional.exprs.slice(1),loc:s.positional.loc}),named:s.named,loc:s.loc}),yt({definition:l,args:s})}}function $t(e){return({node:t,state:r},{definition:n,args:a})=>{let s=Et.visit(n,r),l=Et.Args(a,r);return ht.all(s,l).mapOk((([r,n])=>new at({loc:t.loc,curriedType:e,definition:r,args:n})))}}function It(e){return{assert:Gt(e),translate:$t(e)}}const Ft={assert:function(e){let t="AppendContent"===e.type?e.value:e,r="Call"===t.type?t.args.named:null,n="Call"===t.type?t.args.positional:null;if(r&&!r.isEmpty())return gt(v("(-get-dynamic-vars) does not take any named arguments",e.loc));let a=n?.nth(0);return a?n&&n.size>1?gt(v("(-get-dynamic-vars) only receives one positional arg",e.loc)):yt(a):gt(v("(-get-dynamic-vars) requires a var name to get",e.loc))},translate:function({node:e,state:t},r){return Et.visit(r,t).mapOk((t=>new Te({name:t,loc:e.loc})))}};function Dt(e){return t=>{let r="AppendContent"===t.type?t.value:t,n="Call"===r.type?r.args.named:null,a="Call"===r.type?r.args.positional:null;if(n&&!n.isEmpty())return gt(v(`(${e}) does not take any named arguments`,r.loc));if(!a||a.isEmpty())return yt(C.synthetic("default"));if(1===a.exprs.length){let t=a.exprs[0];return A.isLiteral(t,"string")?yt(t.toSlice()):gt(v(`(${e}) can only receive a string literal as its first argument`,r.loc))}return gt(v(`(${e}) only takes a single positional argument`,r.loc))}}function Mt(e){return({node:t,state:{scope:r}},n)=>yt("has-block"===e?new rt({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}):new nt({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}))}function Vt(e){return{assert:Dt(e),translate:Mt(e)}}function _t(e){return t=>{let r="unless"===e,n="AppendContent"===t.type?t.value:t,a="Call"===n.type?n.args.named:null,s="Call"===n.type?n.args.positional:null;if(a&&!a.isEmpty())return gt(v(`(${e}) cannot receive named parameters, received ${a.entries.map((e=>e.name.chars)).join(", ")}`,t.loc));let l=s?.nth(0);if(!s||!l)return gt(v(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,t.loc));let o=s.nth(1),i=s.nth(2);return null===o?gt(v(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,t.loc)):s.size>3?gt(v(`When used inline, (${e}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${e}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${s?.size??0} parameters`,t.loc)):yt({condition:l,truthy:o,falsy:i})}}function Wt(e){let t="unless"===e;return({node:e,state:r},{condition:n,truthy:a,falsy:s})=>{let l=Et.visit(n,r),o=Et.visit(a,r),i=s?Et.visit(s,r):yt(null);return ht.all(l,o,i).mapOk((([r,n,a])=>(t&&(r=new Be({value:r,loc:e.loc})),new He({loc:e.loc,condition:r,truthy:n,falsy:a}))))}}function jt(e){return{assert:_t(e),translate:Wt(e)}}const qt={assert:function(e){let{args:{named:t,positional:r}}=e;return t&&!t.isEmpty()?gt(v("(log) does not take any named arguments",e.loc)):yt(r)},translate:function({node:e,state:t},r){return Et.Positional(r,t).mapOk((t=>new Ge({positional:t,loc:e.loc})))}},zt=Lt("Append").kw("has-block",Nt(Vt("has-block"))).kw("has-block-params",Nt(Vt("has-block-params"))).kw("-get-dynamic-var",Nt(Ft)).kw("log",Nt(qt)).kw("if",Nt(jt("if"))).kw("unless",Nt(jt("unless"))).kw("yield",{assert(e){let{args:t}=e;if(t.named.isEmpty())return yt({target:E.SourceSpan.synthetic("default").toSlice(),positional:t.positional});{let e=t.named.get("to");return t.named.size>1||null===e?gt(v("yield only takes a single named argument: 'to'",t.named.loc)):A.isLiteral(e,"string")?yt({target:e.toSlice(),positional:t.positional}):gt(v("you can only yield to a literal string value",e.loc))}},translate:({node:e,state:t},{target:r,positional:n})=>Et.Positional(n,t).mapOk((n=>new Re({loc:e.loc,target:r,to:t.scope.allocateBlock(r.chars),positional:n})))}).kw("debugger",{assert(e){let{args:t}=e,{positional:r}=t;return t.isEmpty()?yt(void 0):r.isEmpty()?gt(v("debugger does not take any named arguments",e.loc)):gt(v("debugger does not take any positional arguments",e.loc))},translate:({node:e,state:{scope:t}})=>(t.setHasDebugger(),yt(new Ue({loc:e.loc,scope:t})))}).kw("component",{assert:Gt(H.Component),translate({node:e,state:t},{definition:r,args:n}){let a=Et.visit(r,t),s=Et.Args(n,t);return ht.all(a,s).mapOk((([t,r])=>new $e({loc:e.loc,definition:t,args:r,blocks:null})))}}).kw("helper",{assert:Gt(H.Helper),translate({node:e,state:t},{definition:r,args:n}){let a=Et.visit(r,t),s=Et.Args(n,t);return ht.all(a,s).mapOk((([t,r])=>{let n=new Je({callee:t,args:r,loc:e.loc});return new Me({loc:e.loc,text:n})}))}}),Rt=Lt("Block").kw("in-element",{assert(e){let{args:t}=e,r=t.get("guid");if(r)return gt(v("Cannot pass `guid` to `{{#in-element}}`",r.loc));let n=t.get("insertBefore"),a=t.nth(0);return null===a?gt(v("{{#in-element}} requires a target element as its first positional parameter",t.loc)):yt({insertBefore:n,destination:a})},translate({node:e,state:t},{insertBefore:r,destination:n}){let a=e.blocks.get("default"),s=cr.NamedBlock(a,t),l=Et.visit(n,t);return ht.all(s,l).andThen((([n,a])=>r?Et.visit(r,t).mapOk((e=>({body:n,destination:a,insertBefore:e}))):yt({body:n,destination:a,insertBefore:new et({loc:e.callee.loc.collapse("end")})}))).mapOk((({body:r,destination:n,insertBefore:a})=>new Ee({loc:e.loc,block:r,insertBefore:a,guid:t.generateUniqueCursor(),destination:n})))}}).kw("if",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(v(`{{#if}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return gt(v(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?gt(v("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):yt({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),a=e.blocks.get("else"),s=Et.visit(r,t),l=cr.NamedBlock(n,t),o=a?cr.NamedBlock(a,t):yt(null);return ht.all(s,l,o).mapOk((([t,r,n])=>new Oe({loc:e.loc,condition:t,block:r,inverse:n})))}}).kw("unless",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(v(`{{#unless}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return gt(v(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?gt(v("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):yt({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),a=e.blocks.get("else"),s=Et.visit(r,t),l=cr.NamedBlock(n,t),o=a?cr.NamedBlock(a,t):yt(null);return ht.all(s,l,o).mapOk((([t,r,n])=>new Oe({loc:e.loc,condition:new Be({value:t,loc:e.loc}),block:r,inverse:n})))}}).kw("each",{assert(e){let{args:t}=e;if(!t.named.entries.every((e=>"key"===e.name.chars)))return gt(v(`{{#each}} can only receive the 'key' named parameter, received ${t.named.entries.filter((e=>"key"!==e.name.chars)).map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return gt(v(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0),n=t.get("key");return null===r?gt(v("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",t.loc)):yt({value:r,key:n})},translate({node:e,state:t},{value:r,key:n}){let a=e.blocks.get("default"),s=e.blocks.get("else"),l=Et.visit(r,t),o=n?Et.visit(n,t):yt(null),i=cr.NamedBlock(a,t),c=s?cr.NamedBlock(s,t):yt(null);return ht.all(l,o,i,c).mapOk((([t,r,n,a])=>new Se({loc:e.loc,value:t,key:r,block:n,inverse:a})))}}).kw("with",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(v(`{{#with}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return gt(v(`{{#with}} can only receive one positional parameter. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0);return null===r?gt(v("{{#with}} requires a value as its first positional parameter, did not receive any parameters",t.loc)):yt({value:r})},translate({node:e,state:t},{value:r}){let n=e.blocks.get("default"),a=e.blocks.get("else"),s=Et.visit(r,t),l=cr.NamedBlock(n,t),o=a?cr.NamedBlock(a,t):yt(null);return ht.all(s,l,o).mapOk((([t,r,n])=>new Pe({loc:e.loc,value:t,block:r,inverse:n})))}}).kw("let",{assert(e){let{args:t}=e;return t.named.isEmpty()?0===t.positional.size?gt(v("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",t.positional.loc)):e.blocks.get("else")?gt(v("{{#let}} cannot receive an {{else}} block",t.positional.loc)):yt({positional:t.positional}):gt(v(`{{#let}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc))},translate({node:e,state:t},{positional:r}){let n=e.blocks.get("default"),a=Et.Positional(r,t),s=cr.NamedBlock(n,t);return ht.all(a,s).mapOk((([t,r])=>new Le({loc:e.loc,positional:t,block:r})))}}).kw("-with-dynamic-vars",{assert:e=>yt({named:e.args.named}),translate({node:e,state:t},{named:r}){let n=e.blocks.get("default"),a=Et.NamedArguments(r,t),s=cr.NamedBlock(n,t);return ht.all(a,s).mapOk((([t,r])=>new Ne({loc:e.loc,named:t,block:r})))}}).kw("component",{assert:Gt(H.Component),translate({node:e,state:t},{definition:r,args:n}){let a=Et.visit(r,t),s=Et.Args(n,t),l=cr.NamedBlocks(e.blocks,t);return ht.all(a,s,l).mapOk((([t,r,n])=>new $e({loc:e.loc,definition:t,args:r,blocks:n})))}}),Ut=Lt("Call").kw("has-block",Vt("has-block")).kw("has-block-params",Vt("has-block-params")).kw("-get-dynamic-var",Ft).kw("log",qt).kw("if",jt("if")).kw("unless",jt("unless")).kw("component",It(H.Component)).kw("helper",It(H.Helper)).kw("modifier",It(H.Modifier)),Jt=Lt("Modifier"),Kt="http://www.w3.org/1999/xlink",Yt="http://www.w3.org/XML/1998/namespace",Xt="http://www.w3.org/2000/xmlns/",Zt={"xlink:actuate":Kt,"xlink:arcrole":Kt,"xlink:href":Kt,"xlink:role":Kt,"xlink:show":Kt,"xlink:title":Kt,"xlink:type":Kt,"xml:base":Yt,"xml:lang":Yt,"xml:space":Yt,xmlns:Xt,"xmlns:xlink":Xt};const Qt={div:y.div,span:y.span,p:y.p,a:y.a},er=["div","span","p","a"];function tr(e){return"string"==typeof e?e:er[e]}const rr={class:g.class,id:g.id,value:g.value,name:g.name,type:g.type,style:g.style,href:g.href},nr=["class","id","value","name","type","style","href"];function ar(e){return rr[e]??e}function sr(e){return"string"==typeof e?e:nr[e]}class lr{delegate;constructor(e,t,r){this.element=e,this.state=r,this.delegate=t}toStatement(){return this.prepare().andThen((e=>this.delegate.toStatement(this,e)))}attr(e){let t=e.name,r=e.value,n=(a=t.chars,Zt[a]||void 0);var a;return A.isLiteral(r,"string")?yt(new We({loc:e.loc,name:t,value:r.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):Et.visit(Ct(r),this.state).mapOk((r=>{let a=e.trusting;return new je({loc:e.loc,name:t,value:r,namespace:n,kind:{trusting:a,component:this.delegate.dynamicFeatures}})}))}modifier(e){(function(e){return!!vt(e)&&!e.args.isEmpty()})(e)&&At(e);let t=Jt.translate(e,this.state);if(null!==t)return t;let r=Et.visit(e.callee,this.state),n=Et.Args(e.args,this.state);return ht.all(r,n).mapOk((([t,r])=>new Ye({loc:e.loc,callee:t,args:r})))}attrs(){let e=new wt,t=new wt,r=null,n=0===this.element.attrs.filter((e=>"SplatAttr"===e.type)).length;for(let t of this.element.attrs)"SplatAttr"===t.type?e.add(yt(new Ze({loc:t.loc,symbol:this.state.scope.allocateBlock("attrs")}))):"type"===t.name.chars&&n?r=t:e.add(this.attr(t));for(let e of this.element.componentArgs)t.add(this.delegate.arg(e,this));return r&&e.add(this.attr(r)),ht.all(t.toArray(),e.toArray()).mapOk((([e,t])=>({attrs:t,args:new lt({loc:B(e,E.SourceSpan.NON_EXISTENT),entries:mt(e)})})))}prepare(){let e=this.attrs(),t=new wt(this.element.modifiers.map((e=>this.modifier(e)))).toArray();return ht.all(e,t).mapOk((([e,t])=>{let{attrs:r,args:n}=e,a=[...r,...t];return{args:n,params:new ze({loc:B(a,E.SourceSpan.NON_EXISTENT),body:mt(a)})}}))}}class or{dynamicFeatures=!0;constructor(e,t){this.tag=e,this.element=t}arg(e,{state:t}){let r=e.name;return Et.visit(Ct(e.value),t).mapOk((t=>new ot({loc:e.loc,key:r,value:t})))}toStatement(e,{args:t,params:r}){let{element:n,state:a}=e;return this.blocks(a).mapOk((e=>new _e({loc:n.loc,tag:this.tag,params:r,args:t,blocks:e})))}blocks(e){return cr.NamedBlocks(this.element.blocks,e)}}class ir{constructor(e,t,r){this.tag=e,this.element=t,this.dynamicFeatures=r}isComponent=!1;arg(e){return gt(v(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:t}){let{state:r,element:n}=e;return cr.visitList(this.element.body,r).mapOk((e=>new qe({loc:n.loc,tag:this.tag,params:t,body:e.toArray(),dynamicFeatures:this.dynamicFeatures})))}}const cr=new class{visitList(e,t){return new wt(e.map((e=>cr.visit(e,t)))).toOptionalList().mapOk((e=>e.filter((e=>null!==e))))}visit(e,t){switch(e.type){case"GlimmerComment":return yt(null);case"AppendContent":return this.AppendContent(e,t);case"HtmlText":return yt(this.TextNode(e));case"HtmlComment":return yt(this.HtmlComment(e));case"InvokeBlock":return this.InvokeBlock(e,t);case"InvokeComponent":return this.Component(e,t);case"SimpleElement":return this.SimpleElement(e,t)}}InvokeBlock(e,t){let r=Rt.translate(e,t);if(null!==r)return r;let n=Et.visit(e.callee,t),a=Et.Args(e.args,t);return ht.all(n,a).andThen((([r,n])=>this.NamedBlocks(e.blocks,t).mapOk((t=>new Xe({loc:e.loc,head:r,args:n,blocks:t})))))}NamedBlocks(e,t){return new wt(e.blocks.map((e=>this.NamedBlock(e,t)))).toArray().mapOk((t=>new Ie({loc:e.loc,blocks:mt(t)})))}NamedBlock(e,t){return t.visitBlock(e.block).mapOk((t=>new Fe({loc:e.loc,name:e.name,body:t.toArray(),scope:e.block.scope})))}SimpleElement(e,t){return new lr(e,new ir(e.tag,e,function({attrs:e,modifiers:t}){return t.length>0||!!e.filter((e=>"SplatAttr"===e.type))[0]}(e)),t).toStatement()}Component(e,t){return Et.visit(e.callee,t).andThen((r=>new lr(e,new or(r,e),t).toStatement()))}AppendContent(e,t){let r=zt.translate(e,t);return null!==r?r:Et.visit(e.value,t).mapOk((t=>e.trusting?new De({loc:e.loc,html:t}):new Me({loc:e.loc,text:t})))}TextNode(e){return new Me({loc:e.loc,text:new A.LiteralExpression({loc:e.loc,value:e.chars})})}HtmlComment(e){return new Ve({loc:e.loc,value:e.text})}};class ur{_currentScope;_cursorCount=0;constructor(e,t){this.isStrict=t,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let t=this._currentScope;this._currentScope=e.scope;try{return cr.visitList(e.body,this)}finally{this._currentScope=t}}}class pr{upvars;symbols;constructor([e,t,r,n]){this.upvars=n,this.symbols=t}format(e){let t=[];for(let r of e[0])t.push(this.formatOpcode(r));return t}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case k.Append:return["append",this.formatOpcode(e[1])];case k.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case k.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case k.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case k.OpenElement:return["open-element",tr(e[1])];case k.OpenElementWithSplat:return["open-element-with-splat",tr(e[1])];case k.CloseElement:return["close-element"];case k.FlushElement:return["flush-element"];case k.StaticAttr:return["static-attr",sr(e[1]),e[2],e[3]];case k.StaticComponentAttr:return["static-component-attr",sr(e[1]),e[2],e[3]];case k.DynamicAttr:return["dynamic-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.ComponentAttr:return["component-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.AttrSplat:return["attr-splat"];case k.Yield:return["yield",e[1],this.formatParams(e[2])];case k.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case k.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case k.TrustingDynamicAttr:return["trusting-dynamic-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.TrustingComponentAttr:return["trusting-component-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.Debugger:return["debugger",e[1]];case k.Comment:return["comment",e[1]];case k.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case k.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case k.HasBlock:return["has-block",this.formatOpcode(e[1])];case k.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case k.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case k.Undefined:return["undefined"];case k.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case k.Concat:return["concat",this.formatParams(e[1])];case k.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentOrHelperHeadOrThisFallback:return["GetFreeAsComponentOrHelperHeadOrThisFallback",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case k.GetFreeAsHelperHeadOrThisFallback:return["GetFreeAsHelperHeadOrThisFallback",this.upvars[e[1]],e[2]];case k.GetFreeAsDeprecatedHelperHeadOrThisFallback:return["GetFreeAsDeprecatedHelperHeadOrThisFallback",this.upvars[e[1]]];case k.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case k.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case k.GetSymbol:return 0===e[1]?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case k.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case k.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case k.IfInline:return["if-inline"];case k.Not:return["not"];case k.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case k.With:return["with",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case k.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case k.Log:return["log",this.formatParams(e[1])];case k.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case k.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case k.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case H.Component:return"component";case H.Helper:return"helper";case H.Modifier:return"modifier";default:throw c(e)}}formatElementParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatHash(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatOpcode(e[1][n]),t)),t())}formatBlocks(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatBlock(e[1][n]),t)),t())}formatBlock(e){return{statements:e[0].map((e=>this.formatOpcode(e))),parameters:e[1]}}}const mr=new class{expr(e){switch(e.type){case"Missing":return;case"Literal":return this.Literal(e);case"CallExpression":return this.CallExpression(e);case"DeprecatedCallExpression":return this.DeprecatedCallExpression(e);case"PathExpression":return this.PathExpression(e);case"Arg":return[k.GetSymbol,e.symbol];case"Local":return this.Local(e);case"This":return[k.GetSymbol,0];case"Free":return[e.resolution.resolution(),e.symbol];case"HasBlock":return this.HasBlock(e);case"HasBlockParams":return this.HasBlockParams(e);case"Curry":return this.Curry(e);case"Not":return this.Not(e);case"IfInline":return this.IfInline(e);case"InterpolateExpression":return this.InterpolateExpression(e);case"GetDynamicVar":return this.GetDynamicVar(e);case"Log":return this.Log(e)}}Literal({value:e}){return void 0===e?[k.Undefined]:e}Missing(){}HasBlock({symbol:e}){return[k.HasBlock,[k.GetSymbol,e]]}HasBlockParams({symbol:e}){return[k.HasBlockParams,[k.GetSymbol,e]]}Curry({definition:e,curriedType:t,args:r}){return[k.Curry,mr.expr(e),t,mr.Positional(r.positional),mr.NamedArguments(r.named)]}Local({isTemplateLocal:e,symbol:t}){return[e?k.GetLexicalSymbol:k.GetSymbol,t]}GetWithResolver({symbol:e}){return[k.GetFreeAsComponentOrHelperHeadOrThisFallback,e]}PathExpression({head:e,tail:t}){return[...mr.expr(e),mr.Tail(t)]}InterpolateExpression({parts:e}){return[k.Concat,e.map((e=>mr.expr(e))).toArray()]}CallExpression({callee:e,args:t}){return[k.Call,mr.expr(e),...mr.Args(t)]}DeprecatedCallExpression({arg:e,callee:t}){return[k.GetFreeAsDeprecatedHelperHeadOrThisFallback,t.symbol,[e.chars]]}Tail({members:e}){return u(e,(e=>e.chars))}Args({positional:e,named:t}){return[this.Positional(e),this.NamedArguments(t)]}Positional({list:e}){return e.map((e=>mr.expr(e))).toPresentArray()}NamedArgument({key:e,value:t}){return[e.chars,mr.expr(t)]}NamedArguments({entries:e}){let t=e.toArray();if(n(t)){let e=[],r=[];for(let n of t){let[t,a]=mr.NamedArgument(n);e.push(t),r.push(a)}return h(e),h(r),[e,r]}return null}Not({value:e}){return[k.Not,mr.expr(e)]}IfInline({condition:e,truthy:t,falsy:r}){let n=[k.IfInline,mr.expr(e),mr.expr(t)];return r&&n.push(mr.expr(r)),n}GetDynamicVar({name:e}){return[k.GetDynamicVar,mr.expr(e)]}Log({positional:e}){return[k.Log,this.Positional(e)]}};class dr{constructor(e){this.statements=e}toArray(){return this.statements}}const hr=new class{list(e){let t=[];for(let r of e){let e=hr.content(r);e&&e instanceof dr?t.push(...e.toArray()):t.push(e)}return t}content(e){return xe&&d.log("encoding",e),this.visitContent(e)}visitContent(e){switch(e.type){case"Debugger":return[k.Debugger,e.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(e);case"AppendTextNode":return this.AppendTextNode(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"Yield":return this.Yield(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InElement":return this.InElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"With":return this.With(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e);default:return c(e)}}Yield({to:e,positional:t}){return[k.Yield,e,mr.Positional(t)]}InElement({guid:e,insertBefore:t,destination:r,block:n}){let a=hr.NamedBlock(n)[1],s=mr.expr(r),l=mr.expr(t);return void 0===l?[k.InElement,a,e,s]:[k.InElement,a,e,s,l]}InvokeBlock({head:e,args:t,blocks:r}){return[k.Block,mr.expr(e),...mr.Args(t),hr.NamedBlocks(r)]}AppendTrustedHTML({html:e}){return[k.TrustingAppend,mr.expr(e)]}AppendTextNode({text:e}){return[k.Append,mr.expr(e)]}AppendComment({value:e}){return[k.Comment,e.chars]}SimpleElement({tag:e,params:t,body:r,dynamicFeatures:n}){let a=n?k.OpenElementWithSplat:k.OpenElement;return new dr([[a,(s=e.chars,Qt[s]??s)],...hr.ElementParameters(t).toArray(),[k.FlushElement],...hr.list(r),[k.CloseElement]]);var s}Component({tag:e,params:t,args:r,blocks:n}){let a=mr.expr(e),s=hr.ElementParameters(t),l=mr.NamedArguments(r),o=hr.NamedBlocks(n);return[k.Component,a,s.toPresentArray(),l,o]}ElementParameters({body:e}){return e.map((e=>hr.ElementParameter(e)))}ElementParameter(e){switch(e.type){case"SplatAttr":return[k.AttrSplat,e.symbol];case"DynamicAttr":return[gr(e.kind),...kr(e)];case"StaticAttr":return[yr(e.kind),...fr(e)];case"Modifier":return[k.Modifier,mr.expr(e.callee),...mr.Args(e.args)]}}NamedBlocks({blocks:e}){let t=[],r=[];for(let n of e.toArray()){let[e,a]=hr.NamedBlock(n);t.push(e),r.push(a)}return t.length>0?[t,r]:null}NamedBlock({name:e,body:t,scope:r}){let n=e.chars;return"inverse"===n&&(n="else"),[n,[hr.list(t),r.slots]]}If({condition:e,block:t,inverse:r}){return[k.If,mr.expr(e),hr.NamedBlock(t)[1],r?hr.NamedBlock(r)[1]:null]}Each({value:e,key:t,block:r,inverse:n}){return[k.Each,mr.expr(e),t?mr.expr(t):null,hr.NamedBlock(r)[1],n?hr.NamedBlock(n)[1]:null]}With({value:e,block:t,inverse:r}){return[k.With,mr.expr(e),hr.NamedBlock(t)[1],r?hr.NamedBlock(r)[1]:null]}Let({positional:e,block:t}){return[k.Let,mr.Positional(e),hr.NamedBlock(t)[1]]}WithDynamicVars({named:e,block:t}){return[k.WithDynamicVars,mr.NamedArguments(e),hr.NamedBlock(t)[1]]}InvokeComponent({definition:e,args:t,blocks:r}){return[k.InvokeComponent,mr.expr(e),mr.Positional(t.positional),mr.NamedArguments(t.named),r?hr.NamedBlocks(r):null]}};function fr({name:e,value:t,namespace:r}){let n=[ar(e.chars),t.chars];return r&&n.push(r),n}function kr({name:e,value:t,namespace:r}){let n=[ar(e.chars),mr.expr(t)];return r&&n.push(r),n}function yr(e){return e.component?k.StaticComponentAttr:k.StaticAttr}function gr(e){return e.component?e.trusting?k.TrustingComponentAttr:k.ComponentAttr:e.trusting?k.TrustingDynamicAttr:k.DynamicAttr}const wr=(()=>{const e="object"==typeof module&&"function"==typeof module.require?module.require:globalThis.require;if(e)try{const t=e("crypto"),r=e=>{const r=t.createHash("sha1");return r.update(e,"utf8"),r.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),vr={id:wr};function Ar(e,t=vr){const r=new E.Source(e??"",t.meta?.moduleName),[n,a]=O(r,{lexicalScope:()=>!1,...t}),s=function(e,t,r){let n=new ur(t.table,r);xe&&(d.groupCollapsed("pass0: visiting"),d.log("symbols",t.table),d.log("source",e),d.groupEnd());let a=cr.visitList(t.body,n);return xe&&(a.isOk?d.log("-> pass0: out",a.value):d.log("-> pass0: error",a.reason)),a.mapOk((e=>new Ce({loc:t.loc,scope:t.table,body:e.toArray()})))}(r,n,t.strictMode??!1).mapOk((e=>function(e){let t=hr.list(e.body),r=e.scope,n=[t,r.symbols,r.hasEval,r.upvars];if(xe){let e=new pr(n);d.log("-> ",t.map((t=>e.formatOpcode(t))))}return n}(e)));if(xe&&d.log("Template ->",s),s.isOk)return[s.value,a];throw s.reason}const br="796d24e6-2450-4fb0-8cdf-b65638b5ef70";function xr(e,t=vr){const[r,n]=Ar(e,t),a=t.meta?.moduleName,s=t.id||wr,l=JSON.stringify(r),o={id:s(JSON.stringify(t.meta)+l),block:l,moduleName:a??"(unknown template module)",scope:br,isStrictMode:t.strictMode??!1};0===n.length&&delete o.scope;let i=JSON.stringify(o);if(n.length>0){const e=`()=>[${n.join(",")}]`;i=i.replace(`"${br}"`,e)}return i}export{z as Builder,ce as NEWLINE,Q as ProgramSymbols,pr as WireFormatDebugger,se as buildStatement,ne as buildStatements,oe as c,wr as defaultId,xr as precompile,Ar as precompileJSON,le as s,ie as unicode};
//# sourceMappingURL=index.js.map
