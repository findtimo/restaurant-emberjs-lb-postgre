import Owner from "@ember/owner";
import { ElementFor, ArgsFor, DefaultSignature, PositionalArgs, NamedArgs, EmptyObject } from "./-private/signature.js";
// Type-only utilities used for representing the type of a Modifier in a way
// that (a) has no runtime overhead and (b) makes no public API commitment: by
// extending it with an interface representing the modifier, its internals
// become literally invisible. The private field for the "brand" is not visible
// when interacting with an interface which extends this, but it makes the type
// non-substitutable with an empty object. This is borrowed from, and basically
// identical to, the same time used internally in Ember's types.
declare const Brand: unique symbol;
declare class _Opaque<T> {
    private readonly [Brand];
}
// This provides a signature whose only purpose here is to represent the runtime
// type of a function-based modifier: an opaque item. The fact that it's an
// empty interface is actually the point: it makes the private `[Brand]` above
// is not visible to end users. By exporting only this interface, we also ensure
// we don't *ourselves* try to treat it as a class in the rest of the package.
// eslint-disable-next-line @typescript-eslint/no-empty-interface
interface Opaque<T> extends _Opaque<T> {
}
// Preserve the signature on a class-based modifier so it can be plucked off
// later (by e.g. Glint), using interface merging with an opaque item to
// preserve it in the type system. The fact that it's an empty interface is
// actually the point: it *only* hooks the type parameter into the opaque
// (nominal) type. Note that this is distinct from the function-based modifier
// type intentionally, because it is actually the static class side of a
// class-based modifier which corresponds to the result of calling `modifier()`
// with a callback defining a function-based modifier.
// eslint-disable-next-line @typescript-eslint/no-empty-interface
interface ClassBasedModifier<S = DefaultSignature> extends Opaque<S> {
}
/**
 * A base class for modifiers which need more capabilities than function-based
 * modifiers. Useful if, for example:
 *
 * 1. You need to inject services and access them
 * 2. You need fine-grained control of updates, either for performance or
 *    convenience reasons, and don't want to teardown the state of your modifier
 *    every time only to set it up again.
 * 3. You need to store some local state within your modifier.
 *
 * The lifecycle hooks of class modifiers are tracked. When they run, they any
 * values they access will be added to the modifier, and the modifier will
 * update if any of those values change.
 */
declare class ClassBasedModifier<S = DefaultSignature> {
    // `args` is passed here for the sake of subclasses to have access to args in
    // their constructors while having constructors which are properly asssignable
    // for the superclass.
    /**
     *
     * @param owner An instance of an Owner (for service injection etc.).
     * @param args The positional and named arguments passed to the modifier.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(owner: Owner, args: ArgsFor<S>);
    /**
     * Called when the modifier is installed and any time any tracked state used
     * in the modifier changes.
     *
     * If you need to do first-time-only setup, create a class field representing
     * the initialization state and check it when running the hook. That is also
     * where and when you should use `registerDestructor` for any teardown you
     * need to do. For example:
     *
     * ```js
     * function disconnect(instance) {
     *  instance.observer?.disconnect();
     * }
     *
     * class IntersectionObserver extends Modifier {
     *   observer;
     *
     *   constructor(owner, args) {
     *     super(owner, args);
     *     registerDestructor(this, disconnect);
     *   }
     *
     *   modify(element, callback, options) {
     *     disconnect(this);
     *
     *     this.observer = new IntersectionObserver(callback, options);
     *     this.observer.observe(element);
     *   }
     * }
     * ```
     *
     * @param element The element to which the modifier is applied.
     * @param positional The positional arguments to the modifier.
     * @param named The named arguments to the modifier.
     */
    modify(/* eslint-disable @typescript-eslint/no-unused-vars */
    element: ElementFor<S>, positional: PositionalArgs<S>, named: NamedArgs<S>): void;
}
declare module ClassBasedModifierWrapper {
    export { ClassBasedModifier };
}
import Modifier = ClassBasedModifierWrapper.ClassBasedModifier;
// This type exists to provide a non-user-constructible, non-subclassable
// type representing the conceptual "instance type" of a function modifier.
// The abstract field of type `never` prevents subclassing in userspace of
// the value returned from `modifier()`. By extending `Modifier<S>`, any
// augmentations of the `Modifier` type performed by tools like Glint will
// also apply to function-based modifiers as well.
declare abstract class FunctionBasedModifierInstance<S> extends Modifier<S> {
    protected abstract __concrete__: never;
}
// This provides a type whose only purpose here is to represent the runtime
// type of a function-based modifier: a virtually opaque item. The fact that it's
// a bare constructor type allows `modifier()` to preserve type parameters from
// a generic function it's passed, and by making it abstract and impossible to
// subclass (see above) we prevent users from attempting to instantiate the return
// value from a `modifier()` call.
type FunctionBasedModifier<S> = abstract new () => FunctionBasedModifierInstance<S>;
/**
 * The (optional) return type for a modifier which needs to perform some kind of
 * cleanup or teardown -- for example, removing an event listener from an
 * element besides the one passed into the modifier.
 */
type Teardown = () => unknown;
/**
 * An API for writing simple modifiers.
 *
 * This function runs the first time when the element the modifier was applied
 * to is inserted into the DOM, and it *autotracks* while running. Any values
 * that it accesses will be tracked, including any of its arguments that it
 * accesses, and if any of them changes, the function will run again.
 *
 * **Note:** this will *not* automatically rerun because an argument changes. It
 * will only rerun if it is *using* that argument (the same as with auto-tracked
 * state in general).
 *
 * The modifier can also optionally return a *destructor*. The destructor
 * function will be run just before the next update, and when the element is
 * being removed entirely. It should generally clean up the changes that the
 * modifier made in the first place.
 *
 * @param fn The function which defines the modifier.
 */
// This overload allows users to write types directly on the callback passed to
// the `modifier` function and infer the resulting type correctly.
declare function modifier<E extends Element, P extends unknown[], N = EmptyObject>(fn: (element: E, positional: P, named: N) => void | Teardown): FunctionBasedModifier<{
    Args: {
        Positional: P;
        Named: N;
    };
    Element: E;
}>;
/**
 * An API for writing simple modifiers.
 *
 * This function runs the first time when the element the modifier was applied
 * to is inserted into the DOM, and it *autotracks* while running. Any values
 * that it accesses will be tracked, including any of its arguments that it
 * accesses, and if any of them changes, the function will run again.
 *
 * **Note:** this will *not* automatically rerun because an argument changes. It
 * will only rerun if it is *using* that argument (the same as with auto-tracked
 * state in general).
 *
 * The modifier can also optionally return a *destructor*. The destructor
 * function will be run just before the next update, and when the element is
 * being removed entirely. It should generally clean up the changes that the
 * modifier made in the first place.
 *
 * @param fn The function which defines the modifier.
 */
// This overload allows users to provide a `Signature` type explicitly at the
// modifier definition site, e.g. `modifier<Sig>((el, pos, named) => {...})`.
// **Note:** this overload must appear second, since TS' inference engine will
// not correctly infer the type of `S` here from the types on the supplied
// callback.
declare function modifier<S>(fn: (element: ElementFor<S>, positional: PositionalArgs<S>, named: NamedArgs<S>) => void | Teardown): FunctionBasedModifier<{
    Element: ElementFor<S>;
    Args: {
        Named: NamedArgs<S>;
        Positional: PositionalArgs<S>;
    };
}>;
export { ClassBasedModifier as default, modifier };
export type { FunctionBasedModifier };
export type { ArgsFor, NamedArgs, PositionalArgs } from "./-private/signature.js";
