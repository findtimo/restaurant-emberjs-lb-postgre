{"version":3,"file":"index.js","sources":["../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/-private/class-based/modifier-manager.ts","../src/-private/class-based/modifier.ts","../src/-private/function-based/modifier-manager.ts","../src/-private/function-based/modifier.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import { capabilities } from '@ember/modifier';\nimport { destroy } from '@ember/destroyable';\nimport { dependencySatisfies } from '@embroider/macros';\nimport type Owner from '@ember/owner';\n\nimport ClassBasedModifier from './modifier';\nimport { ArgsFor, ElementFor } from '../signature';\n\n/**\n * The state bucket used throughout the life-cycle of the modifier. Basically a\n * state *machine*, where the framework calls us with the version we hand back\n * to it at each phase. The two states are the two `extends` versions of this\n * below.\n *\n * @internal\n */\ninterface State<S> {\n  instance: ClassBasedModifier<S>;\n}\n\n/**\n * The `State` after calling `createModifier`, and therefore the state available\n * at the start of `InstallModifier`.\n * @internal\n */\ninterface CreatedState<S> extends State<S> {\n  element: null;\n}\n\n/**\n * The `State` after calling `installModifier`, and therefore the state\n * available in all `updateModifier` calls and in `destroyModifier`.\n * @internal\n */\ninterface InstalledState<S> extends State<S> {\n  element: ElementFor<S>;\n}\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement<S>(\n  state: CreatedState<S>,\n  element: ElementFor<S>\n): InstalledState<S> {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state as State<S> as InstalledState<S>;\n  installedState.element = element;\n  return installedState;\n}\n\nexport default class ClassBasedModifierManager<S> {\n  capabilities = capabilities(\n    dependencySatisfies('ember-source', '>=3.22.0') ? '3.22' : '3.13'\n  );\n\n  constructor(private owner: Owner) {}\n\n  createModifier(\n    modifierClass: typeof ClassBasedModifier,\n    args: ArgsFor<S>\n  ): CreatedState<S> {\n    const instance = new modifierClass(this.owner, args);\n    return { instance, element: null };\n  }\n\n  installModifier(\n    createdState: CreatedState<S>,\n    element: ElementFor<S>,\n    args: ArgsFor<S>\n  ): void {\n    const state = installElement(createdState, element);\n    state.instance.modify(element, args.positional, args.named);\n  }\n\n  updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void {\n    state.instance.modify(state.element, args.positional, args.named);\n  }\n\n  destroyModifier({ instance }: InstalledState<S>): void {\n    destroy(instance);\n  }\n}\n","import { setOwner } from '@ember/application';\nimport { setModifierManager } from '@ember/modifier';\nimport type Owner from '@ember/owner';\nimport Manager from './modifier-manager';\nimport {\n  ElementFor,\n  ArgsFor,\n  DefaultSignature,\n  PositionalArgs,\n  NamedArgs,\n} from '../signature';\nimport Opaque from '../opaque';\n\n// Preserve the signature on a class-based modifier so it can be plucked off\n// later (by e.g. Glint), using interface merging with an opaque item to\n// preserve it in the type system. The fact that it's an empty interface is\n// actually the point: it *only* hooks the type parameter into the opaque\n// (nominal) type. Note that this is distinct from the function-based modifier\n// type intentionally, because it is actually the static class side of a\n// class-based modifier which corresponds to the result of calling `modifier()`\n// with a callback defining a function-based modifier.\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport default interface ClassBasedModifier<S = DefaultSignature>\n  extends Opaque<S> {}\n\n/**\n * A base class for modifiers which need more capabilities than function-based\n * modifiers. Useful if, for example:\n *\n * 1. You need to inject services and access them\n * 2. You need fine-grained control of updates, either for performance or\n *    convenience reasons, and don't want to teardown the state of your modifier\n *    every time only to set it up again.\n * 3. You need to store some local state within your modifier.\n *\n * The lifecycle hooks of class modifiers are tracked. When they run, they any\n * values they access will be added to the modifier, and the modifier will\n * update if any of those values change.\n */\nexport default class ClassBasedModifier<S = DefaultSignature> {\n  // `args` is passed here for the sake of subclasses to have access to args in\n  // their constructors while having constructors which are properly asssignable\n  // for the superclass.\n  /**\n   *\n   * @param owner An instance of an Owner (for service injection etc.).\n   * @param args The positional and named arguments passed to the modifier.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(owner: Owner, args: ArgsFor<S>) {\n    setOwner(this, owner);\n  }\n\n  /**\n   * Called when the modifier is installed and any time any tracked state used\n   * in the modifier changes.\n   *\n   * If you need to do first-time-only setup, create a class field representing\n   * the initialization state and check it when running the hook. That is also\n   * where and when you should use `registerDestructor` for any teardown you\n   * need to do. For example:\n   *\n   * ```js\n   * function disconnect(instance) {\n   *  instance.observer?.disconnect();\n   * }\n   *\n   * class IntersectionObserver extends Modifier {\n   *   observer;\n   *\n   *   constructor(owner, args) {\n   *     super(owner, args);\n   *     registerDestructor(this, disconnect);\n   *   }\n   *\n   *   modify(element, callback, options) {\n   *     disconnect(this);\n   *\n   *     this.observer = new IntersectionObserver(callback, options);\n   *     this.observer.observe(element);\n   *   }\n   * }\n   * ```\n   *\n   * @param element The element to which the modifier is applied.\n   * @param positional The positional arguments to the modifier.\n   * @param named The named arguments to the modifier.\n   */\n  modify(\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    element: ElementFor<S>,\n    positional: PositionalArgs<S>,\n    named: NamedArgs<S>\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): void {\n    /* no op, for subclassing */\n  }\n}\n\nsetModifierManager((owner) => new Manager(owner), ClassBasedModifier);\n","import { capabilities } from '@ember/modifier';\nimport { dependencySatisfies } from '@embroider/macros';\nimport type { FunctionBasedModifierDefinition, Teardown } from './modifier';\nimport type { ArgsFor, ElementFor } from '../signature';\n\ninterface State<S> {\n  instance: FunctionBasedModifierDefinition<S>;\n}\n\ninterface CreatedState<S> extends State<S> {\n  element: null;\n}\n\ninterface InstalledState<S> extends State<S> {\n  element: ElementFor<S>;\n  teardown?: Teardown;\n}\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement<S>(\n  state: CreatedState<S>,\n  element: ElementFor<S>\n): InstalledState<S> {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state as State<S> as InstalledState<S>;\n  installedState.element = element;\n  return installedState;\n}\n\nexport default class FunctionBasedModifierManager<S> {\n  capabilities = capabilities(\n    dependencySatisfies('ember-source', '>=3.22.0') ? '3.22' : '3.13'\n  );\n\n  createModifier(\n    instance: FunctionBasedModifierDefinition<S>\n  ): CreatedState<S> {\n    return { element: null, instance };\n  }\n\n  installModifier(\n    createdState: CreatedState<S>,\n    element: ElementFor<S>,\n    args: ArgsFor<S>\n  ): void {\n    const state = installElement(createdState, element);\n\n    const { positional, named } = args;\n    const teardown = createdState.instance(element, positional, named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n\n  updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n\n    const teardown = state.instance(state.element, args.positional, args.named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n\n  destroyModifier(state: InstalledState<S>): void {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n  }\n}\n","import { setModifierManager } from '@ember/modifier';\nimport {\n  ElementFor,\n  EmptyObject,\n  NamedArgs,\n  PositionalArgs,\n} from '../signature';\nimport Modifier from '../class-based/modifier';\nimport FunctionBasedModifierManager from './modifier-manager';\n\n// Provide a singleton manager.\nconst MANAGER = new FunctionBasedModifierManager();\n\n// This type exists to provide a non-user-constructible, non-subclassable\n// type representing the conceptual \"instance type\" of a function modifier.\n// The abstract field of type `never` prevents subclassing in userspace of\n// the value returned from `modifier()`. By extending `Modifier<S>`, any\n// augmentations of the `Modifier` type performed by tools like Glint will\n// also apply to function-based modifiers as well.\nexport declare abstract class FunctionBasedModifierInstance<\n  S\n> extends Modifier<S> {\n  protected abstract __concrete__: never;\n}\n\n// This provides a type whose only purpose here is to represent the runtime\n// type of a function-based modifier: a virtually opaque item. The fact that it's\n// a bare constructor type allows `modifier()` to preserve type parameters from\n// a generic function it's passed, and by making it abstract and impossible to\n// subclass (see above) we prevent users from attempting to instantiate the return\n// value from a `modifier()` call.\nexport type FunctionBasedModifier<S> =\n  abstract new () => FunctionBasedModifierInstance<S>;\n\n/**\n * The (optional) return type for a modifier which needs to perform some kind of\n * cleanup or teardown -- for example, removing an event listener from an\n * element besides the one passed into the modifier.\n */\nexport type Teardown = () => unknown;\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to write types directly on the callback passed to\n// the `modifier` function and infer the resulting type correctly.\nexport default function modifier<\n  E extends Element,\n  P extends unknown[],\n  N = EmptyObject\n>(\n  fn: (element: E, positional: P, named: N) => void | Teardown\n): FunctionBasedModifier<{\n  Args: {\n    Positional: P;\n    Named: N;\n  };\n  Element: E;\n}>;\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to provide a `Signature` type explicitly at the\n// modifier definition site, e.g. `modifier<Sig>((el, pos, named) => {...})`.\n// **Note:** this overload must appear second, since TS' inference engine will\n// not correctly infer the type of `S` here from the types on the supplied\n// callback.\nexport default function modifier<S>(\n  fn: (\n    element: ElementFor<S>,\n    positional: PositionalArgs<S>,\n    named: NamedArgs<S>\n  ) => void | Teardown\n): FunctionBasedModifier<{\n  Element: ElementFor<S>;\n  Args: {\n    Named: NamedArgs<S>;\n    Positional: PositionalArgs<S>;\n  };\n}>;\n\n// This is the runtime signature; it performs no inference whatsover and just\n// uses the simplest version of the invocation possible since, for the case of\n// setting it on the modifier manager, we don't *need* any of that info, and\n// the two previous overloads capture all invocations from a type perspective.\nexport default function modifier(\n  fn: (\n    element: Element,\n    positional: unknown[],\n    named: object\n  ) => void | Teardown\n): FunctionBasedModifier<{\n  Element: Element;\n  Args: {\n    Named: object;\n    Positional: unknown[];\n  };\n}> {\n  // SAFETY: the cast here is a *lie*, but it is a useful one. The actual return\n  // type of `setModifierManager` today is `void`; we pretend it actually\n  // returns an opaque `Modifier` type so that we can provide a result from this\n  // type which is useful to TS-aware tooling (e.g. Glint).\n  return setModifierManager(\n    () => MANAGER,\n    fn\n  ) as unknown as FunctionBasedModifier<{\n    Element: Element;\n    Args: {\n      Named: object;\n      Positional: unknown[];\n    };\n  }>;\n}\n\n/**\n * @internal\n */\nexport type FunctionBasedModifierDefinition<S> = (\n  element: ElementFor<S>,\n  positional: PositionalArgs<S>,\n  named: NamedArgs<S>\n) => void | Teardown;\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","installElement","state","element","installedState","ClassBasedModifierManager","constructor","owner","capabilities","dependencySatisfies","createModifier","modifierClass","args","instance","installModifier","createdState","modify","positional","named","updateModifier","destroyModifier","destroy","ClassBasedModifier","setOwner","setModifierManager","Manager","FunctionBasedModifierManager","teardown","MANAGER","modifier","fn"],"mappings":"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"}