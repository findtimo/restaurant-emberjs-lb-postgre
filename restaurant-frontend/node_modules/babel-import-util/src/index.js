"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportUtil = void 0;
class ImportUtil {
    constructor(t, program) {
        this.t = t;
        this.program = program;
    }
    // remove one imported binding. If this is the last thing imported from the
    // given moduleSpecifier, the whole statement will also be removed.
    removeImport(moduleSpecifier, exportedName) {
        for (let topLevelPath of this.program.get('body')) {
            if (!matchModule(topLevelPath, moduleSpecifier)) {
                continue;
            }
            let importSpecifierPath = topLevelPath
                .get('specifiers')
                .find((specifierPath) => matchSpecifier(specifierPath, exportedName));
            if (importSpecifierPath) {
                if (topLevelPath.node.specifiers.length === 1) {
                    topLevelPath.remove();
                }
                else {
                    importSpecifierPath.remove();
                }
            }
        }
    }
    // remove all imports from the given moduleSpecifier
    removeAllImports(moduleSpecifier) {
        for (let topLevelPath of this.program.get('body')) {
            if (matchModule(topLevelPath, moduleSpecifier)) {
                topLevelPath.remove();
            }
        }
    }
    // Import the given value (if needed) and return an Identifier representing
    // it.
    import(
    // the spot at which you will insert the Identifier we return to you
    target, 
    // the path to the module you're importing from
    moduleSpecifier, 
    // the name you're importing from that module. Use "default" for the default
    // export. Use "*" for the namespace.
    exportedName, 
    // Optional hint for helping us pick a name for the imported binding
    nameHint) {
        var _a;
        let isNamespaceImport = exportedName === '*';
        let isDefaultImport = exportedName === 'default';
        let isNamedImport = !isDefaultImport && !isNamespaceImport;
        let declaration = this.findImportFrom(moduleSpecifier);
        let hasNamespaceSpecifier = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportNamespaceSpecifier');
        let hasNamedSpecifiers = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportSpecifier');
        /**
         * the file has a preexisting non-namespace import and a transform tries to add a namespace import, so they don't get combined
         * the file has a preexisting namespace import and a transform tries to add a non-namespace import, so they don't get combined
         * the file has a preexisting namespace import and a transform tries to add a namespace import, so they don't get combined
         */
        let cannotUseExistingDeclaration = (hasNamedSpecifiers && isNamespaceImport) ||
            (hasNamespaceSpecifier && isNamedImport) ||
            (hasNamespaceSpecifier && isNamespaceImport);
        if (!cannotUseExistingDeclaration && declaration) {
            let specifier = declaration
                .get('specifiers')
                .find((spec) => matchSpecifier(spec, exportedName));
            if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === 'module') {
                return this.t.identifier(specifier.node.local.name);
            }
            else {
                return this.addSpecifier(target, declaration, exportedName, nameHint);
            }
        }
        else {
            let declaration = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
            return this.addSpecifier(target, declaration, exportedName, nameHint);
        }
    }
    importForSideEffect(moduleSpecifier) {
        let declaration = this.findImportFrom(moduleSpecifier);
        if (!declaration) {
            this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
        }
    }
    addSpecifier(target, declaration, exportedName, nameHint) {
        let local = this.t.identifier(unusedNameLike(target, desiredName(nameHint, exportedName, target)));
        let specifier = this.buildSpecifier(exportedName, local);
        if (specifier.type === 'ImportDefaultSpecifier') {
            declaration.node.specifiers.unshift(specifier);
        }
        else {
            declaration.node.specifiers.push(specifier);
        }
        declaration.scope.registerBinding('module', declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`));
        return local;
    }
    buildSpecifier(exportedName, localName) {
        switch (exportedName) {
            case 'default':
                return this.t.importDefaultSpecifier(localName);
            case '*':
                return this.t.importNamespaceSpecifier(localName);
            default:
                return this.t.importSpecifier(localName, this.t.identifier(exportedName));
        }
    }
    findImportFrom(moduleSpecifier) {
        for (let path of this.program.get('body')) {
            if (path.isImportDeclaration() && path.node.source.value === moduleSpecifier) {
                return path;
            }
        }
        return undefined;
    }
    insertAfterExistingImports(statement) {
        let lastIndex;
        for (let [index, node] of this.program.node.body.entries()) {
            if (node.type === 'ImportDeclaration') {
                lastIndex = index;
            }
        }
        if (lastIndex == null) {
            // we are intentionally not using babel's container-aware methods, because
            // while in theory it's nice that they schedule other plugins to run on
            // our nodes, in practice those nodes might get mutated or removed by some
            // other plugin in the intervening time causing failures.
            this.program.node.body.unshift(statement);
            return this.program.get('body.0');
        }
        else {
            this.program.node.body.splice(lastIndex + 1, 0, statement);
            return this.program.get(`body.${lastIndex + 1}`);
        }
    }
}
exports.ImportUtil = ImportUtil;
function unusedNameLike(path, name) {
    let candidate = name;
    let counter = 0;
    while (path.scope.hasBinding(candidate)) {
        candidate = `${name}${counter++}`;
    }
    return candidate;
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
function desiredName(nameHint, exportedName, target) {
    if (nameHint) {
        // first we opportunistically do camelization when an illegal character is
        // followed by a lowercase letter, in an effort to aid readability of the
        // output.
        let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());
        // then we unliterally strip all remaining illegal characters.
        cleaned = cleaned.replace(/[^a-zA-Z_]/g, '');
        return cleaned;
    }
    if (exportedName === 'default' || exportedName === '*') {
        if (target.isIdentifier()) {
            return target.node.name;
        }
        else {
            return target.scope.generateUidIdentifierBasedOnNode(target.node).name;
        }
    }
    else {
        return exportedName;
    }
}
function matchSpecifier(spec, exportedName) {
    switch (exportedName) {
        case 'default':
            return spec.isImportDefaultSpecifier();
        case '*':
            return spec.isImportNamespaceSpecifier();
        default:
            return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;
    }
}
function matchModule(path, moduleSpecifier) {
    return path.isImportDeclaration() && path.get('source').node.value === moduleSpecifier;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFLQSxNQUFhLFVBQVU7SUFDckIsWUFBb0IsQ0FBYSxFQUFVLE9BQTRCO1FBQW5ELE1BQUMsR0FBRCxDQUFDLENBQVk7UUFBVSxZQUFPLEdBQVAsT0FBTyxDQUFxQjtJQUFHLENBQUM7SUFFM0UsMkVBQTJFO0lBQzNFLG1FQUFtRTtJQUNuRSxZQUFZLENBQUMsZUFBdUIsRUFBRSxZQUFvQjtRQUN4RCxLQUFLLElBQUksWUFBWSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLGVBQWUsQ0FBQyxFQUFFO2dCQUMvQyxTQUFTO2FBQ1Y7WUFFRCxJQUFJLG1CQUFtQixHQUFHLFlBQVk7aUJBQ25DLEdBQUcsQ0FBQyxZQUFZLENBQUM7aUJBQ2pCLElBQUksQ0FBQyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ3hFLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3ZCLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDN0MsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUN2QjtxQkFBTTtvQkFDTCxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDOUI7YUFDRjtTQUNGO0lBQ0gsQ0FBQztJQUVELG9EQUFvRDtJQUNwRCxnQkFBZ0IsQ0FBQyxlQUF1QjtRQUN0QyxLQUFLLElBQUksWUFBWSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pELElBQUksV0FBVyxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsRUFBRTtnQkFDOUMsWUFBWSxDQUFDLE1BQU0s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TSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztTQUN4RTtLQUNGO1NBQU07UUFDTCxPQUFPLFlBQVksQ0FBQztLQUNyQjtBQUNILENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxJQUFtQixFQUFFLFlBQW9CO0lBQy9ELFFBQVEsWUFBWSxFQUFFO1FBQ3BCLEtBQUssU0FBUztZQUNaLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDekMsS0FBSyxHQUFHO1lBQ04sT0FBTyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztRQUMzQztZQUNFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxDQUFDO0tBQ2hGO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUNsQixJQUFtQixFQUNuQixlQUF1QjtJQUV2QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxlQUFlLENBQUM7QUFDekYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHR5cGUgKiBhcyB0IGZyb20gJ0BiYWJlbC90eXBlcyc7XG5cbnR5cGUgQmFiZWxUeXBlcyA9IHR5cGVvZiB0O1xuXG5leHBvcnQgY2xhc3MgSW1wb3J0VXRpbCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdDogQmFiZWxUeXBlcywgcHJpdmF0ZSBwcm9ncmFtOiBOb2RlUGF0aDx0LlByb2dyYW0+KSB7fVxuXG4gIC8vIHJlbW92ZSBvbmUgaW1wb3J0ZWQgYmluZGluZy4gSWYgdGhpcyBpcyB0aGUgbGFzdCB0aGluZyBpbXBvcnRlZCBmcm9tIHRoZVxuICAvLyBnaXZlbiBtb2R1bGVTcGVjaWZpZXIsIHRoZSB3aG9sZSBzdGF0ZW1lbnQgd2lsbCBhbHNvIGJlIHJlbW92ZWQuXG4gIHJlbW92ZUltcG9ydChtb2R1bGVTcGVjaWZpZXI6IHN0cmluZywgZXhwb3J0ZWROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmb3IgKGxldCB0b3BMZXZlbFBhdGggb2YgdGhpcy5wcm9ncmFtLmdldCgnYm9keScpKSB7XG4gICAgICBpZiAoIW1hdGNoTW9kdWxlKHRvcExldmVsUGF0aCwgbW9kdWxlU3BlY2lmaWVyKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGltcG9ydFNwZWNpZmllclBhdGggPSB0b3BMZXZlbFBhdGhcbiAgICAgICAgLmdldCgnc3BlY2lmaWVycycpXG4gICAgICAgIC5maW5kKChzcGVjaWZpZXJQYXRoKSA9PiBtYXRjaFNwZWNpZmllcihzcGVjaWZpZXJQYXRoLCBleHBvcnRlZE5hbWUpKTtcbiAgICAgIGlmIChpbXBvcnRTcGVjaWZpZXJQYXRoKSB7XG4gICAgICAgIGlmICh0b3BMZXZlbFBhdGgubm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRvcExldmVsUGF0aC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBvcnRTcGVjaWZpZXJQYXRoLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGFsbCBpbXBvcnRzIGZyb20gdGhlIGdpdmVuIG1vZHVsZVNwZWNpZmllclxuICByZW1vdmVBbGxJbXBvcnRzKG1vZHVsZVNwZWNpZmllcjogc3RyaW5nKTogdm9pZCB7XG4gICAgZm9yIChsZXQgdG9wTGV2ZWxQYXRoIG9mIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgaWYgKG1hdGNoTW9kdWxlKHRvcExldmVsUGF0aCwgbW9kdWxlU3BlY2lmaWVyKSkge1xuICAgICAgICB0b3BMZXZlbFBhdGgucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSW1wb3J0IHRoZSBnaXZlbiB2YWx1ZSAoaWYgbmVlZGVkKSBhbmQgcmV0dXJuIGFuIElkZW50aWZpZXIgcmVwcmVzZW50aW5nXG4gIC8vIGl0LlxuICBpbXBvcnQoXG4gICAgLy8gdGhlIHNwb3QgYXQgd2hpY2ggeW91IHdpbGwgaW5zZXJ0IHRoZSBJZGVudGlmaWVyIHdlIHJldHVybiB0byB5b3VcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG5cbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyBPcHRpb25hbCBoaW50IGZvciBoZWxwaW5nIHVzIHBpY2sgYSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgYmluZGluZ1xuICAgIG5hbWVIaW50Pzogc3RyaW5nXG4gICk6IHQuSWRlbnRpZmllciB7XG4gICAgbGV0IGlzTmFtZXNwYWNlSW1wb3J0ID0gZXhwb3J0ZWROYW1lID09PSAnKic7XG4gICAgbGV0IGlzRGVmYXVsdEltcG9ydCA9IGV4cG9ydGVkTmFtZSA9PT0gJ2RlZmF1bHQnO1xuICAgIGxldCBpc05hbWVkSW1wb3J0ID0gIWlzRGVmYXVsdEltcG9ydCAmJiAhaXNOYW1lc3BhY2VJbXBvcnQ7XG4gICAgbGV0IGRlY2xhcmF0aW9uID0gdGhpcy5maW5kSW1wb3J0RnJvbShtb2R1bGVTcGVjaWZpZXIpO1xuICAgIGxldCBoYXNOYW1lc3BhY2VTcGVjaWZpZXIgPSBkZWNsYXJhdGlvbj8ubm9kZS5zcGVjaWZpZXJzLmZpbmQoXG4gICAgICAocykgPT4gcy50eXBlID09PSAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJ1xuICAgICk7XG4gICAgbGV0IGhhc05hbWVkU3BlY2lmaWVycyA9IGRlY2xhcmF0aW9uPy5ub2RlLnNwZWNpZmllcnMuZmluZCgocykgPT4gcy50eXBlID09PSAnSW1wb3J0U3BlY2lmaWVyJyk7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgZmlsZSBoYXMgYSBwcmVleGlzdGluZyBub24tbmFtZXNwYWNlIGltcG9ydCBhbmQgYSB0cmFuc2Zvcm0gdHJpZXMgdG8gYWRkIGEgbmFtZXNwYWNlIGltcG9ydCwgc28gdGhleSBkb24ndCBnZXQgY29tYmluZWRcbiAgICAgKiB0aGUgZmlsZSBoYXMgYSBwcmVleGlzdGluZyBuYW1lc3BhY2UgaW1wb3J0IGFuZCBhIHRyYW5zZm9ybSB0cmllcyB0byBhZGQgYSBub24tbmFtZXNwYWNlIGltcG9ydCwgc28gdGhleSBkb24ndCBnZXQgY29tYmluZWRcbiAgICAgKiB0aGUgZmlsZSBoYXMgYSBwcmVleGlzdGluZyBuYW1lc3BhY2UgaW1wb3J0IGFuZCBhIHRyYW5zZm9ybSB0cmllcyB0byBhZGQgYSBuYW1lc3BhY2UgaW1wb3J0LCBzbyB0aGV5IGRvbid0IGdldCBjb21iaW5lZFxuICAgICAqL1xuICAgIGxldCBjYW5ub3RVc2VFeGlzdGluZ0RlY2xhcmF0aW9uID1cbiAgICAgIChoYXNOYW1lZFNwZWNpZmllcnMgJiYgaXNOYW1lc3BhY2VJbXBvcnQpIHx8XG4gICAgICAoaGFzTmFtZXNwYWNlU3BlY2lmaWVyICYmIGlzTmFtZWRJbXBvcnQpIHx8XG4gICAgICAoaGFzTmFtZXNwYWNlU3BlY2lmaWVyICYmIGlzTmFtZXNwYWNlSW1wb3J0KTtcblxuICAgIGlmICghY2Fubm90VXNlRXhpc3RpbmdEZWNsYXJhdGlvbiAmJiBkZWNsYXJhdGlvbikge1xuICAgICAgbGV0IHNwZWNpZmllciA9IGRlY2xhcmF0aW9uXG4gICAgICAgIC5nZXQoJ3NwZWNpZmllcnMnKVxuICAgICAgICAuZmluZCgoc3BlYykgPT4gbWF0Y2hTcGVjaWZpZXIoc3BlYywgZXhwb3J0ZWROYW1lKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyICYmIHRhcmdldC5zY29wZS5nZXRCaW5kaW5nKHNwZWNpZmllci5ub2RlLmxvY2FsLm5hbWUpPy5raW5kID09PSAnbW9kdWxlJykge1xuICAgICAgICByZXR1cm4gdGhpcy50LmlkZW50aWZpZXIoc3BlY2lmaWVyLm5vZGUubG9jYWwubmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTcGVjaWZpZXIodGFyZ2V0LCBkZWNsYXJhdGlvbiwgZXhwb3J0ZWROYW1lLCBuYW1lSGludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZWNsYXJhdGlvbiA9IHRoaXMuaW5zZXJ0QWZ0ZXJFeGlzdGluZ0ltcG9ydHMoXG4gICAgICAgIHRoaXMudC5pbXBvcnREZWNsYXJhdGlvbihbXSwgdGhpcy50LnN0cmluZ0xpdGVyYWwobW9kdWxlU3BlY2lmaWVyKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRTcGVjaWZpZXIodGFyZ2V0LCBkZWNsYXJhdGlvbiwgZXhwb3J0ZWROYW1lLCBuYW1lSGludCk7XG4gICAgfVxuICB9XG5cbiAgaW1wb3J0Rm9yU2lkZUVmZmVjdChtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkZWNsYXJhdGlvbiA9IHRoaXMuZmluZEltcG9ydEZyb20obW9kdWxlU3BlY2lmaWVyKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWRkU3BlY2lmaWVyKFxuICAgIHRhcmdldDogTm9kZVBhdGg8dC5Ob2RlPixcbiAgICBkZWNsYXJhdGlvbjogTm9kZVBhdGg8dC5JbXBvcnREZWNsYXJhdGlvbj4sXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG4gICAgbmFtZUhpbnQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiB0LklkZW50aWZpZXIge1xuICAgIGxldCBsb2NhbCA9IHRoaXMudC5pZGVudGlmaWVyKFxuICAgICAgdW51c2VkTmFtZUxpa2UodGFyZ2V0LCBkZXNpcmVkTmFtZShuYW1lSGludCwgZXhwb3J0ZWROYW1lLCB0YXJnZXQpKVxuICAgICk7XG4gICAgbGV0IHNwZWNpZmllciA9IHRoaXMuYnVpbGRTcGVjaWZpZXIoZXhwb3J0ZWROYW1lLCBsb2NhbCk7XG4gICAgaWYgKHNwZWNpZmllci50eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicpIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy51bnNoaWZ0KHNwZWNpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5wdXNoKHNwZWNpZmllcik7XG4gICAgfVxuICAgIGRlY2xhcmF0aW9uLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcbiAgICAgICdtb2R1bGUnLFxuICAgICAgZGVjbGFyYXRpb24uZ2V0KGBzcGVjaWZpZXJzLiR7ZGVjbGFyYXRpb24ubm9kZS5zcGVjaWZpZXJzLmxlbmd0aCAtIDF9YCkgYXMgTm9kZVBhdGhcbiAgICApO1xuICAgIHJldHVybiBsb2NhbDtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRTcGVjaWZpZXIoZXhwb3J0ZWROYW1lOiBzdHJpbmcsIGxvY2FsTmFtZTogdC5JZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChleHBvcnRlZE5hbWUpIHtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gdGhpcy50LmltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWxOYW1lKTtcbiAgICAgIGNhc2UgJyonOlxuICAgICAgICByZXR1cm4gdGhpcy50LmltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbE5hbWUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnRTcGVjaWZpZXIobG9jYWxOYW1lLCB0aGlzLnQuaWRlbnRpZmllcihleHBvcnRlZE5hbWUpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpbmRJbXBvcnRGcm9tKG1vZHVsZVNwZWNpZmllcjogc3RyaW5nKTogTm9kZVBhdGg8dC5JbXBvcnREZWNsYXJhdGlvbj4gfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IHBhdGggb2YgdGhpcy5wcm9ncmFtLmdldCgnYm9keScpKSB7XG4gICAgICBpZiAocGF0aC5pc0ltcG9ydERlY2xhcmF0aW9uKCkgJiYgcGF0aC5ub2RlLnNvdXJjZS52YWx1ZSA9PT0gbW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnNlcnRBZnRlckV4aXN0aW5nSW1wb3J0czxTIGV4dGVuZHMgdC5TdGF0ZW1lbnQ+KHN0YXRlbWVudDogUyk6IE5vZGVQYXRoPFM+IHtcbiAgICBsZXQgbGFzdEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgW2luZGV4LCBub2RlXSBvZiB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LmVudHJpZXMoKSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJykge1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA9PSBudWxsKSB7XG4gICAgICAvLyB3ZSBhcmUgaW50ZW50aW9uYWxseSBub3QgdXNpbmcgYmFiZWwncyBjb250YWluZXItYXdhcmUgbWV0aG9kcywgYmVjYXVzZVxuICAgICAgLy8gd2hpbGUgaW4gdGhlb3J5IGl0J3MgbmljZSB0aGF0IHRoZXkgc2NoZWR1bGUgb3RoZXIgcGx1Z2lucyB0byBydW4gb25cbiAgICAgIC8vIG91ciBub2RlcywgaW4gcHJhY3RpY2UgdGhvc2Ugbm9kZXMgbWlnaHQgZ2V0IG11dGF0ZWQgb3IgcmVtb3ZlZCBieSBzb21lXG4gICAgICAvLyBvdGhlciBwbHVnaW4gaW4gdGhlIGludGVydmVuaW5nIHRpbWUgY2F1c2luZyBmYWlsdXJlcy5cbiAgICAgIHRoaXMucHJvZ3JhbS5ub2RlLmJvZHkudW5zaGlmdChzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHkuMCcpIGFzIE5vZGVQYXRoPFM+O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LnNwbGljZShsYXN0SW5kZXggKyAxLCAwLCBzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoYGJvZHkuJHtsYXN0SW5kZXggKyAxfWApIGFzIE5vZGVQYXRoPFM+O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bnVzZWROYW1lTGlrZShwYXRoOiBOb2RlUGF0aDx0Lk5vZGU+LCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgY2FuZGlkYXRlID0gbmFtZTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICB3aGlsZSAocGF0aC5zY29wZS5oYXNCaW5kaW5nKGNhbmRpZGF0ZSkpIHtcbiAgICBjYW5kaWRhdGUgPSBgJHtuYW1lfSR7Y291bnRlcisrfWA7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2lyZWROYW1lKG5hbWVIaW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV4cG9ydGVkTmFtZTogc3RyaW5nLCB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4pIHtcbiAgaWYgKG5hbWVIaW50KSB7XG4gICAgLy8gZmlyc3Qgd2Ugb3Bwb3J0dW5pc3RpY2FsbHkgZG8gY2FtZWxpemF0aW9uIHdoZW4gYW4gaWxsZWdhbCBjaGFyYWN0ZXIgaXNcbiAgICAvLyBmb2xsb3dlZCBieSBhIGxvd2VyY2FzZSBsZXR0ZXIsIGluIGFuIGVmZm9ydCB0byBhaWQgcmVhZGFiaWxpdHkgb2YgdGhlXG4gICAgLy8gb3V0cHV0LlxuICAgIGxldCBjbGVhbmVkID0gbmFtZUhpbnQucmVwbGFjZSgvW15hLXpBLVpfXShbYS16XSkvZywgKF9tLCBsZXR0ZXIpID0+IGxldHRlci50b1VwcGVyQ2FzZSgpKTtcbiAgICAvLyB0aGVuIHdlIHVubGl0ZXJhbGx5IHN0cmlwIGFsbCByZW1haW5pbmcgaWxsZWdhbCBjaGFyYWN0ZXJzLlxuICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoL1teYS16QS1aX10vZywgJycpO1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGlmIChleHBvcnRlZE5hbWUgPT09ICdkZWZhdWx0JyB8fCBleHBvcnRlZE5hbWUgPT09ICcqJykge1xuICAgIGlmICh0YXJnZXQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQubm9kZS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllckJhc2VkT25Ob2RlKHRhcmdldC5ub2RlKS5uYW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwb3J0ZWROYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3BlY2lmaWVyKHNwZWM6IE5vZGVQYXRoPGFueT4sIGV4cG9ydGVkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICByZXR1cm4gc3BlYy5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgICBjYXNlICcqJzpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0U3BlY2lmaWVyKCkgJiYgbmFtZShzcGVjLm5vZGUuaW1wb3J0ZWQpID09PSBleHBvcnRlZE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hNb2R1bGUoXG4gIHBhdGg6IE5vZGVQYXRoPGFueT4sXG4gIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nXG4pOiBwYXRoIGlzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHtcbiAgcmV0dXJuIHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpICYmIHBhdGguZ2V0KCdzb3VyY2UnKS5ub2RlLnZhbHVlID09PSBtb2R1bGVTcGVjaWZpZXI7XG59XG4iXX0=