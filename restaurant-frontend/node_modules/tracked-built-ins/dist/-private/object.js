import { _ as _classPrivateFieldGet } from '../classPrivateFieldGet-0e0d6742.js';
import { createStorage, getValue, setValue } from 'ember-tracked-storage-polyfill';

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
var _storages = /*#__PURE__*/new WeakMap();
var _collection = /*#__PURE__*/new WeakMap();
var _readStorageFor = /*#__PURE__*/new WeakSet();
var _dirtyStorageFor = /*#__PURE__*/new WeakSet();
var _dirtyCollection = /*#__PURE__*/new WeakSet();
class TrackedObject {
  static fromEntries(entries) {
    return new TrackedObject(Object.fromEntries(entries));
  }
  constructor(obj = {}) {
    _classPrivateMethodInitSpec(this, _dirtyCollection);
    _classPrivateMethodInitSpec(this, _dirtyStorageFor);
    _classPrivateMethodInitSpec(this, _readStorageFor);
    _classPrivateFieldInitSpec(this, _storages, {
      writable: true,
      value: new Map()
    });
    _classPrivateFieldInitSpec(this, _collection, {
      writable: true,
      value: createStorage(null, () => false)
    });
    let proto = Object.getPrototypeOf(obj);
    let descs = Object.getOwnPropertyDescriptors(obj);
    let clone = Object.create(proto);
    for (let prop in descs) {
      Object.defineProperty(clone, prop, descs[prop]);
    }

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let self = this;
    return new Proxy(clone, {
      get(target, prop) {
        _classPrivateMethodGet(self, _readStorageFor, _readStorageFor2).call(self, prop);
        return target[prop];
      },
      has(target, prop) {
        _classPrivateMethodGet(self, _readStorageFor, _readStorageFor2).call(self, prop);
        return prop in target;
      },
      ownKeys(target) {
        getValue(_classPrivateFieldGet(self, _collection));
        return Reflect.ownKeys(target);
      },
      set(target, prop, value) {
        target[prop] = value;
        _classPrivateMethodGet(self, _dirtyStorageFor, _dirtyStorageFor2).call(self, prop);
        _classPrivateMethodGet(self, _dirtyCollection, _dirtyCollection2).call(self);
        return true;
      },
      deleteProperty(target, prop) {
        if (prop in target) {
          delete target[prop];
          _classPrivateMethodGet(self, _dirtyStorageFor, _dirtyStorageFor2).call(self, prop);
          _classPrivateMethodGet(self, _dirtyCollection, _dirtyCollection2).call(self);
        }
        return true;
      },
      getPrototypeOf() {
        return TrackedObject.prototype;
      }
    });
  }
}
function _readStorageFor2(key) {
  let storage = _classPrivateFieldGet(this, _storages).get(key);
  if (storage === undefined) {
    storage = createStorage(null, () => false);
    _classPrivateFieldGet(this, _storages).set(key, storage);
  }
  getValue(storage);
}
function _dirtyStorageFor2(key) {
  const storage = _classPrivateFieldGet(this, _storages).get(key);
  if (storage) {
    setValue(storage, null);
  }
}
function _dirtyCollection2() {
  setValue(_classPrivateFieldGet(this, _collection), null);
}

export { TrackedObject as default };
//# sourceMappingURL=object.js.map
