{"version":3,"file":"cache-handler-XLbbNJdo.js","sources":["../src/-private/utils/coerce-id.ts","../src/-private/utils/normalize-model-name.ts","../src/-private/utils/uuid-polyfill.ts","../src/-private/caches/resource-utils.ts","../src/-private/caches/identifier-cache.ts","../src/-private/legacy-model-support/record-reference.ts","../src/-private/managers/cache-capabilities-manager.ts","../src/-private/caches/cache-utils.ts","../src/-private/caches/instance-cache.ts","../src/-private/legacy-model-support/shim-model-class.ts","../../../node_modules/.pnpm/@babel+runtime@7.23.9/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js","../../../node_modules/.pnpm/@babel+runtime@7.23.9/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js","../src/-private/managers/cache-manager.ts","../src/-private/managers/notification-manager.ts","../../../node_modules/.pnpm/@babel+runtime@7.23.9/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js","../src/-private/record-arrays/identifier-array.ts","../src/-private/managers/record-array-manager.ts","../src/-private/network/request-cache.ts","../src/-private/utils/is-non-empty-string.ts","../src/-private/utils/construct-resource.ts","../src/-private/store-service.ts","../src/-private/document.ts","../src/-private/cache-handler.ts"],"sourcesContent":["/**\n  @module @ember-data/store\n*/\n\nimport { assert, deprecate } from '@ember/debug';\n\nimport { DEPRECATE_NON_STRICT_ID } from '@ember-data/deprecations';\n\n// Used by the store to normalize IDs entering the store.  Despite the fact\n// that developers may provide IDs as numbers (e.g., `store.findRecord('person', 1)`),\n// it is important that internally we use strings, since IDs may be serialized\n// and lose type information.  For example, Ember's router may put a record's\n// ID into the URL, and if we later try to deserialize that URL and find the\n// corresponding record, we will not know if it is a string or a number.\ntype Coercable = string | number | boolean | null | undefined | symbol;\n\nfunction coerceId(id: Coercable): string | null {\n  if (DEPRECATE_NON_STRICT_ID) {\n    let normalized: string | null;\n    if (id === null || id === undefined || id === '') {\n      normalized = null;\n    } else {\n      normalized = String(id);\n    }\n\n    deprecate(\n      `The resource id '<${typeof id}> ${String(\n        id\n      )} ' is not normalized. Update your application code to use '${JSON.stringify(normalized)}' instead.`,\n      normalized === id,\n      {\n        id: 'ember-data:deprecate-non-strict-id',\n        until: '6.0',\n        for: 'ember-data',\n        since: {\n          available: '5.3',\n          enabled: '5.3',\n        },\n      }\n    );\n\n    return normalized;\n  }\n\n  assert(\n    `Resource IDs must be a non-empty string or null. Received '${String(id)}'.`,\n    id === null || (typeof id === 'string' && id.length > 0)\n  );\n\n  return id;\n}\n\nexport function ensureStringId(id: Coercable): string {\n  let normalized: string | null = null;\n  if (typeof id === 'string') {\n    normalized = id.length > 0 ? id : null;\n  } else if (typeof id === 'number' && !isNaN(id)) {\n    normalized = String(id);\n  }\n\n  assert(`Expected id to be a string or number, received ${String(id)}`, normalized !== null);\n\n  return normalized;\n}\n\nexport default coerceId;\n","import { deprecate } from '@ember/debug';\nimport { dasherize } from '@ember/string';\n\nimport { DEPRECATE_NON_STRICT_TYPES } from '@ember-data/deprecations';\n\nexport default function normalizeModelName(type: string): string {\n  if (DEPRECATE_NON_STRICT_TYPES) {\n    const result = dasherize(type);\n\n    deprecate(\n      `The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,\n      result === type,\n      {\n        id: 'ember-data:deprecate-non-strict-types',\n        until: '6.0',\n        for: 'ember-data',\n        since: {\n          available: '5.3',\n          enabled: '5.3',\n        },\n      }\n    );\n\n    return result;\n  }\n\n  return type;\n}\n","/**\n  @module @ember-data/store\n*/\ninterface FastbootCrypto {\n  randomFillSync(v: Uint8Array): Uint8Array;\n}\n\ntype UUIDv4 = `${string}-${string}-${string}-${string}-${string}`;\n\nexport default function installPolyfill() {\n  const isFastBoot = typeof FastBoot !== 'undefined';\n  const CRYPTO: Crypto = isFastBoot ? (FastBoot.require('crypto') as Crypto) : window.crypto;\n\n  if (!CRYPTO.randomUUID) {\n    // we might be able to optimize this by requesting more bytes than we need at a time\n    const rng = function (): Uint8Array {\n      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n      const rnds8 = new Uint8Array(16);\n\n      if (!CRYPTO.getRandomValues && !isFastBoot) {\n        throw new Error(`Unable to generate bytes for UUID`);\n      }\n\n      return CRYPTO.getRandomValues\n        ? CRYPTO.getRandomValues(rnds8)\n        : (CRYPTO as unknown as FastbootCrypto).randomFillSync(rnds8);\n    };\n\n    /*\n     * Convert array of 16 byte values to UUID string format of the form:\n     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n     */\n    const byteToHex: string[] = [];\n    for (let i = 0; i < 256; ++i) {\n      byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    }\n\n    const bytesToUuid = function (buf: Uint8Array): UUIDv4 {\n      const bth = byteToHex;\n      // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n      return [\n        bth[buf[0]],\n        bth[buf[1]],\n        bth[buf[2]],\n        bth[buf[3]],\n        '-',\n        bth[buf[4]],\n        bth[buf[5]],\n        '-',\n        bth[buf[6]],\n        bth[buf[7]],\n        '-',\n        bth[buf[8]],\n        bth[buf[9]],\n        '-',\n        bth[buf[10]],\n        bth[buf[11]],\n        bth[buf[12]],\n        bth[buf[13]],\n        bth[buf[14]],\n        bth[buf[15]],\n      ].join('') as UUIDv4;\n    };\n\n    CRYPTO.randomUUID = function uuidv4(): UUIDv4 {\n      const rnds = rng();\n\n      // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n      rnds[6] = (rnds[6] & 0x0f) | 0x40;\n      rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n      return bytesToUuid(rnds);\n    };\n  }\n}\n","function isResource(resource: unknown): resource is Record<string, unknown> {\n  return Boolean(resource && typeof resource === 'object');\n}\n\nfunction hasProp<T extends string, K extends { [J in T]: string }>(resource: unknown, prop: T): resource is K {\n  return Boolean(\n    isResource(resource) && prop in resource && typeof resource[prop] === 'string' && (resource[prop] as string).length\n  );\n}\n\nexport function hasLid(resource: unknown): resource is { lid: string } {\n  return hasProp(resource, 'lid');\n}\n\nexport function hasId(resource: unknown): resource is { id: string } {\n  return (\n    hasProp(resource, 'id') || Boolean(isResource(resource) && 'id' in resource && typeof resource.id === 'number')\n  );\n}\n\nexport function hasType(resource: unknown): resource is { type: string } {\n  return hasProp(resource, 'type');\n}\n","/**\n  @module @ember-data/store\n*/\nimport { assert, warn } from '@ember/debug';\n\nimport { getOwnConfig, macroCondition } from '@embroider/macros';\n\nimport { LOG_IDENTIFIERS } from '@ember-data/debugging';\nimport { DEBUG } from '@ember-data/env';\nimport {\n  CACHE_OWNER,\n  DEBUG_CLIENT_ORIGINATED,\n  DEBUG_IDENTIFIER_BUCKET,\n  DEBUG_STALE_CACHE_OWNER,\n  type Identifier,\n  type IdentifierBucket,\n  type RecordIdentifier,\n  type StableDocumentIdentifier,\n  type StableIdentifier,\n  type StableRecordIdentifier,\n} from '@warp-drive/core-types/identifier';\nimport type { ImmutableRequestInfo } from '@warp-drive/core-types/request';\nimport type { ExistingResourceObject, ResourceIdentifierObject } from '@warp-drive/core-types/spec/raw';\n\nimport type {\n  ForgetMethod,\n  GenerationMethod,\n  ResetMethod,\n  ResourceData,\n  UpdateMethod,\n} from '../../-types/q/identifier';\nimport coerceId from '../utils/coerce-id';\nimport normalizeModelName from '../utils/normalize-model-name';\nimport installPolyfill from '../utils/uuid-polyfill';\nimport { hasId, hasLid, hasType } from './resource-utils';\n\nconst IDENTIFIERS = new Set();\nconst DOCUMENTS = new Set();\n\nexport function isStableIdentifier(identifier: unknown): identifier is StableRecordIdentifier {\n  return (identifier as StableRecordIdentifier)[CACHE_OWNER] !== undefined || IDENTIFIERS.has(identifier);\n}\n\nexport function isDocumentIdentifier(identifier: unknown): identifier is StableDocumentIdentifier {\n  return DOCUMENTS.has(identifier);\n}\n\nconst isFastBoot = typeof FastBoot !== 'undefined';\nconst _crypto: Crypto = isFastBoot ? (FastBoot.require('crypto') as Crypto) : window.crypto;\n\nif (macroCondition(getOwnConfig<{ polyfillUUID: boolean }>().polyfillUUID)) {\n  installPolyfill();\n}\n\nfunction uuidv4(): string {\n  assert(\n    'crypto.randomUUID needs to be avaliable. Some browsers incorrectly disallow it in insecure contexts. You maybe want to enable the polyfill: https://github.com/emberjs/data#randomuuid-polyfill',\n    typeof _crypto.randomUUID === 'function'\n  );\n  return _crypto.randomUUID();\n}\n\nfunction freeze<T>(obj: T): T {\n  if (typeof Object.freeze === 'function') {\n    return Object.freeze(obj);\n  }\n  return obj;\n}\n\ninterface KeyOptions {\n  lid: IdentifierMap;\n  id: IdentifierMap;\n}\ntype TypeMap = { [key: string]: KeyOptions };\n\n// type IdentifierTypeLookup = { all: Set<StableRecordIdentifier>; id: Map<string, StableRecordIdentifier> };\n// type IdentifiersByType = Map<string, IdentifierTypeLookup>;\ntype IdentifierMap = Map<string, StableRecordIdentifier>;\ntype KeyInfo = {\n  id: string | null;\n  type: string;\n};\ntype StableCache = {\n  resources: IdentifierMap;\n  documents: Map<string, StableDocumentIdentifier>;\n  resourcesByType: TypeMap;\n  polymorphicLidBackMap: Map<string, string[]>;\n};\n\nexport type KeyInfoMethod = (resource: unknown, known: StableRecordIdentifier | null) => KeyInfo;\n\nexport type MergeMethod = (\n  targetIdentifier: StableRecordIdentifier,\n  matchedIdentifier: StableRecordIdentifier,\n  resourceData: unknown\n) => StableRecordIdentifier;\n\nlet configuredForgetMethod: ForgetMethod | null;\nlet configuredGenerationMethod: GenerationMethod | null;\nlet configuredResetMethod: ResetMethod | null;\nlet configuredUpdateMethod: UpdateMethod | null;\nlet configuredKeyInfoMethod: KeyInfoMethod | null;\n\nexport function setIdentifierGenerationMethod(method: GenerationMethod | null): void {\n  configuredGenerationMethod = method;\n}\n\nexport function setIdentifierUpdateMethod(method: UpdateMethod | null): void {\n  configuredUpdateMethod = method;\n}\n\nexport function setIdentifierForgetMethod(method: ForgetMethod | null): void {\n  configuredForgetMethod = method;\n}\n\nexport function setIdentifierResetMethod(method: ResetMethod | null): void {\n  configuredResetMethod = method;\n}\n\nexport function setKeyInfoForResource(method: KeyInfoMethod | null): void {\n  configuredKeyInfoMethod = method;\n}\n\nfunction assertIsRequest(request: unknown): asserts request is ImmutableRequestInfo {\n  return;\n}\n\n// Map<type, Map<id, lid>>\ntype TypeIdMap = Map<string, Map<string, string>>;\nconst NEW_IDENTIFIERS: TypeIdMap = new Map();\nlet IDENTIFIER_CACHE_ID = 0;\n\nfunction updateTypeIdMapping(typeMap: TypeIdMap, identifier: StableRecordIdentifier, id: string): void {\n  let idMap = typeMap.get(identifier.type);\n  if (!idMap) {\n    idMap = new Map();\n    typeMap.set(identifier.type, idMap);\n  }\n  idMap.set(id, identifier.lid);\n}\n\nfunction defaultUpdateMethod(identifier: StableRecordIdentifier, data: unknown, bucket: 'record'): void;\nfunction defaultUpdateMethod(identifier: StableIdentifier, newData: unknown, bucket: never): void;\nfunction defaultUpdateMethod(\n  identifier: StableIdentifier | StableRecordIdentifier,\n  data: unknown,\n  bucket: 'record'\n): void {\n  if (bucket === 'record') {\n    assert(`Expected identifier to be a StableRecordIdentifier`, isStableIdentifier(identifier));\n    if (!identifier.id && hasId(data)) {\n      updateTypeIdMapping(NEW_IDENTIFIERS, identifier, data.id);\n    }\n  }\n}\n\nfunction defaultKeyInfoMethod(resource: unknown, known: StableRecordIdentifier | null): KeyInfo {\n  // TODO RFC something to make this configurable\n  const id = hasId(resource) ? coerceId(resource.id) : null;\n  const type = hasType(resource) ? normalizeModelName(resource.type) : known ? known.type : null;\n\n  assert(`Expected keyInfoForResource to provide a type for the resource`, type);\n\n  return { type, id };\n}\n\nfunction defaultGenerationMethod(data: ImmutableRequestInfo, bucket: 'document'): string | null;\nfunction defaultGenerationMethod(data: ResourceData | { type: string }, bucket: 'record'): string;\nfunction defaultGenerationMethod(\n  data: ImmutableRequestInfo | ResourceData | { type: string },\n  bucket: IdentifierBucket\n): string | null {\n  if (bucket === 'record') {\n    if (hasLid(data)) {\n      return data.lid;\n    }\n\n    assert(`Cannot generate an identifier for a resource without a type`, hasType(data));\n\n    if (hasId(data)) {\n      const type = normalizeModelName(data.type);\n      const lid = NEW_IDENTIFIERS.get(type)?.get(data.id);\n\n      return lid || `@lid:${type}-${data.id}`;\n    }\n\n    return uuidv4();\n  } else if (bucket === 'document') {\n    assertIsRequest(data);\n    if (!data.url) {\n      return null;\n    }\n    if (!data.method || data.method.toUpperCase() === 'GET') {\n      return data.url;\n    }\n    return null;\n  }\n  assert(`Unknown bucket ${bucket as string}`, false);\n}\n\nfunction defaultEmptyCallback(...args: unknown[]): void {}\nfunction defaultMergeMethod(\n  a: StableRecordIdentifier,\n  _b: StableRecordIdentifier,\n  _c: unknown\n): StableRecordIdentifier {\n  return a;\n}\n\nlet DEBUG_MAP: WeakMap<StableRecordIdentifier, StableRecordIdentifier>;\nif (DEBUG) {\n  DEBUG_MAP = new WeakMap<StableRecordIdentifier, StableRecordIdentifier>();\n}\n\n/**\n * Each instance of {Store} receives a unique instance of a IdentifierCache.\n *\n * This cache is responsible for assigning or retrieving the unique identify\n * for arbitrary resource data encountered by the store. Data representing\n * a unique resource or record should always be represented by the same\n * identifier.\n *\n * It can be configured by consuming applications.\n *\n * @class IdentifierCache\n   @public\n */\nexport class IdentifierCache {\n  declare _cache: StableCache;\n  declare _generate: GenerationMethod;\n  declare _update: UpdateMethod;\n  declare _forget: ForgetMethod;\n  declare _reset: ResetMethod;\n  declare _merge: MergeMethod;\n  declare _keyInfoForResource: KeyInfoMethod;\n  declare _isDefaultConfig: boolean;\n  declare _id: number;\n\n  constructor() {\n    // we cache the user configuredGenerationMethod at init because it must\n    // be configured prior and is not allowed to be changed\n    this._generate = configuredGenerationMethod || (defaultGenerationMethod as GenerationMethod);\n    this._update = configuredUpdateMethod || defaultUpdateMethod;\n    this._forget = configuredForgetMethod || defaultEmptyCallback;\n    this._reset = configuredResetMethod || defaultEmptyCallback;\n    this._merge = defaultMergeMethod;\n    this._keyInfoForResource = configuredKeyInfoMethod || defaultKeyInfoMethod;\n    this._isDefaultConfig = !configuredGenerationMethod;\n    this._id = IDENTIFIER_CACHE_ID++;\n\n    this._cache = {\n      resources: new Map<string, StableRecordIdentifier>(),\n      resourcesByType: Object.create(null) as TypeMap,\n      documents: new Map<string, StableDocumentIdentifier>(),\n      polymorphicLidBackMap: new Map<string, string[]>(),\n    };\n  }\n\n  /**\n   * Internal hook to allow management of merge conflicts with identifiers.\n   *\n   * we allow late binding of this private internal merge so that\n   * the cache can insert itself here to handle elimination of duplicates\n   *\n   * @method __configureMerge\n   * @private\n   */\n  __configureMerge(method: MergeMethod | null) {\n    this._merge = method || defaultMergeMethod;\n  }\n\n  upgradeIdentifier(resource: { type: string; id: string | null; lid?: string }): StableRecordIdentifier {\n    return this._getRecordIdentifier(resource, 2);\n  }\n\n  /**\n   * @method _getRecordIdentifier\n   * @private\n   */\n  _getRecordIdentifier(\n    resource: { type: string; id: string | null; lid?: string },\n    shouldGenerate: 2\n  ): StableRecordIdentifier;\n  _getRecordIdentifier(resource: unknown, shouldGenerate: 1): StableRecordIdentifier;\n  _getRecordIdentifier(resource: unknown, shouldGenerate: 0): StableRecordIdentifier | undefined;\n  _getRecordIdentifier(resource: unknown, shouldGenerate: 0 | 1 | 2): StableRecordIdentifier | undefined {\n    if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed(`Identifiers: ${shouldGenerate ? 'Generating' : 'Peeking'} Identifier`, resource);\n    }\n    // short circuit if we're already the stable version\n    if (isStableIdentifier(resource)) {\n      if (DEBUG) {\n        // TODO should we instead just treat this case as a new generation skipping the short circuit?\n        if (!this._cache.resources.has(resource.lid) || this._cache.resources.get(resource.lid) !== resource) {\n          throw new Error(`The supplied identifier ${JSON.stringify(resource)} does not belong to this store instance`);\n        }\n      }\n      if (LOG_IDENTIFIERS) {\n        // eslint-disable-next-line no-console\n        console.log(`Identifiers: cache HIT - Stable ${resource.lid}`);\n        // eslint-disable-next-line no-console\n        console.groupEnd();\n      }\n      return resource;\n    }\n\n    // the resource is unknown, ask the application to identify this data for us\n    const lid = this._generate(resource, 'record');\n    if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.log(`Identifiers: ${lid ? 'no ' : ''}lid ${lid ? lid + ' ' : ''}determined for resource`, resource);\n    }\n\n    let identifier: StableRecordIdentifier | null = /*#__NOINLINE__*/ getIdentifierFromLid(this._cache, lid, resource);\n    if (identifier !== null) {\n      if (LOG_IDENTIFIERS) {\n        // eslint-disable-next-line no-console\n        console.groupEnd();\n      }\n      return identifier;\n    }\n\n    if (shouldGenerate === 0) {\n      if (LOG_IDENTIFIERS) {\n        // eslint-disable-next-line no-console\n        console.groupEnd();\n      }\n      return;\n    }\n\n    // if we still don't have an identifier, time to generate one\n    if (shouldGenerate === 2) {\n      (resource as StableRecordIdentifier).lid = lid;\n      (resource as StableRecordIdentifier)[CACHE_OWNER] = this._id;\n      identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(resource as StableRecordIdentifier, 'record', false);\n    } else {\n      // we lie a bit here as a memory optimization\n      const keyInfo = this._keyInfoForResource(resource, null) as StableRecordIdentifier;\n      keyInfo.lid = lid;\n      keyInfo[CACHE_OWNER] = this._id;\n      identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(keyInfo, 'record', false);\n    }\n\n    addResourceToCache(this._cache, identifier);\n\n    if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.groupEnd();\n    }\n\n    return identifier;\n  }\n\n  /**\n   * allows us to peek without generating when needed\n   * useful for the \"create\" case when we need to see if\n   * we are accidentally overwritting something\n   *\n   * @method peekRecordIdentifier\n   * @param resource\n   * @return {StableRecordIdentifier | undefined}\n   * @private\n   */\n  peekRecordIdentifier(resource: ResourceIdentifierObject | Identifier): StableRecordIdentifier | undefined {\n    return this._getRecordIdentifier(resource, 0);\n  }\n\n  /**\n    Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.\n    Returns `null` if the request does not have a `cacheKey` or `url`.\n\n    @method getOrCreateDocumentIdentifier\n    @param request\n    @return {StableDocumentIdentifier | null}\n    @public\n  */\n  getOrCreateDocumentIdentifier(request: ImmutableRequestInfo): StableDocumentIdentifier | null {\n    let cacheKey: string | null | undefined = request.cacheOptions?.key;\n\n    if (!cacheKey) {\n      cacheKey = this._generate(request, 'document');\n    }\n\n    if (!cacheKey) {\n      return null;\n    }\n\n    let identifier = this._cache.documents.get(cacheKey);\n\n    if (identifier === undefined) {\n      identifier = { lid: cacheKey };\n      if (DEBUG) {\n        Object.freeze(identifier);\n      }\n      DOCUMENTS.add(identifier);\n      this._cache.documents.set(cacheKey, identifier);\n    }\n\n    return identifier;\n  }\n\n  /**\n    Returns the Identifier for the given Resource, creates one if it does not yet exist.\n\n    Specifically this means that we:\n\n    - validate the `id` `type` and `lid` combo against known identifiers\n    - return an object with an `lid` that is stable (repeated calls with the same\n      `id` + `type` or `lid` will return the same `lid` value)\n    - this referential stability of the object itself is guaranteed\n\n    @method getOrCreateRecordIdentifier\n    @param resource\n    @return {StableRecordIdentifier}\n    @public\n  */\n  getOrCreateRecordIdentifier(resource: unknown): StableRecordIdentifier {\n    return this._getRecordIdentifier(resource, 1);\n  }\n\n  /**\n   Returns a new Identifier for the supplied data. Call this method to generate\n   an identifier when a new resource is being created local to the client and\n   potentially does not have an `id`.\n\n   Delegates generation to the user supplied `GenerateMethod` if one has been provided\n   with the signature `generateMethod({ type }, 'record')`.\n\n   @method createIdentifierForNewRecord\n   @param data\n   @return {StableRecordIdentifier}\n   @public\n  */\n  createIdentifierForNewRecord(data: { type: string; id?: string | null }): StableRecordIdentifier {\n    const newLid = this._generate(data, 'record');\n    const identifier = /*#__NOINLINE__*/ makeStableRecordIdentifier(\n      { id: data.id || null, type: data.type, lid: newLid, [CACHE_OWNER]: this._id },\n      'record',\n      true\n    );\n\n    // populate our unique table\n    if (DEBUG) {\n      if (this._cache.resources.has(identifier.lid)) {\n        throw new Error(`The lid generated for the new record is not unique as it matches an existing identifier`);\n      }\n    }\n\n    /*#__NOINLINE__*/ addResourceToCache(this._cache, identifier);\n\n    if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.log(`Identifiers: created identifier ${String(identifier)} for newly generated resource`, data);\n    }\n\n    return identifier;\n  }\n\n  /**\n   Provides the opportunity to update secondary lookup tables for existing identifiers\n   Called after an identifier created with `createIdentifierForNewRecord` has been\n   committed.\n\n   Assigned `id` to an `Identifier` if `id` has not previously existed; however,\n   attempting to change the `id` or calling update without providing an `id` when\n   one is missing will throw an error.\n\n    - sets `id` (if `id` was previously `null`)\n    - `lid` and `type` MUST NOT be altered post creation\n\n    If a merge occurs, it is possible the returned identifier does not match the originally\n    provided identifier. In this case the abandoned identifier will go through the usual\n    `forgetRecordIdentifier` codepaths.\n\n    @method updateRecordIdentifier\n    @param identifierObject\n    @param data\n    @return {StableRecordIdentifier}\n    @public\n  */\n  updateRecordIdentifier(identifierObject: RecordIdentifier, data: unknown): StableRecordIdentifier {\n    let identifier = this.getOrCreateRecordIdentifier(identifierObject);\n\n    const keyInfo = this._keyInfoForResource(data, identifier);\n    let existingIdentifier = /*#__NOINLINE__*/ detectMerge(this._cache, keyInfo, identifier, data);\n    const hadLid = hasLid(data);\n\n    if (!existingIdentifier) {\n      // If the incoming type does not match the identifier type, we need to create an identifier for the incoming\n      // data so we can merge the incoming data with the existing identifier, see #7325 and #7363\n      if (identifier.type !== keyInfo.type) {\n        if (hadLid) {\n          // Strip the lid to ensure we force a new identifier creation\n          delete (data as { lid?: string }).lid;\n        }\n        existingIdentifier = this.getOrCreateRecordIdentifier(data);\n      }\n    }\n\n    if (existingIdentifier) {\n      const generatedIdentifier = identifier;\n      identifier = this._mergeRecordIdentifiers(keyInfo, generatedIdentifier, existingIdentifier, data);\n\n      // make sure that the `lid` on the data we are processing matches the lid we kept\n      if (hadLid) {\n        data.lid = identifier.lid;\n      }\n\n      if (LOG_IDENTIFIERS) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Identifiers: merged identifiers ${generatedIdentifier.lid} and ${existingIdentifier.lid} for resource into ${identifier.lid}`,\n          data\n        );\n      }\n    }\n\n    const id = identifier.id;\n    /*#__NOINLINE__*/ performRecordIdentifierUpdate(identifier, keyInfo, data, this._update);\n    const newId = identifier.id;\n\n    // add to our own secondary lookup table\n    if (id !== newId && newId !== null) {\n      if (LOG_IDENTIFIERS) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Identifiers: updated id for identifier ${identifier.lid} from '${String(id)}' to '${String(\n            newId\n          )}' for resource`,\n          data\n        );\n      }\n\n      const typeSet = this._cache.resourcesByType[identifier.type];\n      assert(`Expected to find a typeSet for ${identifier.type}`, typeSet);\n      typeSet.id.set(newId, identifier);\n\n      if (id !== null) {\n        typeSet.id.delete(id);\n      }\n    } else if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.log(`Identifiers: updated identifier ${identifier.lid} resource`, data);\n    }\n\n    return identifier;\n  }\n\n  /**\n   * @method _mergeRecordIdentifiers\n   * @private\n   */\n  _mergeRecordIdentifiers(\n    keyInfo: KeyInfo,\n    identifier: StableRecordIdentifier,\n    existingIdentifier: StableRecordIdentifier,\n    data: unknown\n  ): StableRecordIdentifier {\n    assert(`Expected keyInfo to contain an id`, hasId(keyInfo));\n    // delegate determining which identifier to keep to the configured MergeMethod\n    const kept = this._merge(identifier, existingIdentifier, data);\n    const abandoned = kept === identifier ? existingIdentifier : identifier;\n\n    // get any backreferences before forgetting this identifier, as it will be removed from the cache\n    // and we will no longer be able to find them\n    const abandonedBackReferences = this._cache.polymorphicLidBackMap.get(abandoned.lid);\n    // delete the backreferences for the abandoned identifier so that forgetRecordIdentifier\n    // does not try to remove them.\n    if (abandonedBackReferences) this._cache.polymorphicLidBackMap.delete(abandoned.lid);\n\n    // cleanup the identifier we no longer need\n    this.forgetRecordIdentifier(abandoned);\n\n    // ensure a secondary cache entry for the original lid for the abandoned identifier\n    this._cache.resources.set(abandoned.lid, kept);\n\n    // backReferences let us know which other identifiers are pointing at this identifier\n    // so we can delete them later if we forget this identifier\n    const keptBackReferences = this._cache.polymorphicLidBackMap.get(kept.lid) ?? [];\n    keptBackReferences.push(abandoned.lid);\n\n    // update the backreferences from the abandoned identifier to be for the kept identifier\n    if (abandonedBackReferences) {\n      abandonedBackReferences.forEach((lid) => {\n        keptBackReferences.push(lid);\n        this._cache.resources.set(lid, kept);\n      });\n    }\n\n    this._cache.polymorphicLidBackMap.set(kept.lid, keptBackReferences);\n    return kept;\n  }\n\n  /**\n   Provides the opportunity to eliminate an identifier from secondary lookup tables\n   as well as eliminates it from ember-data's own lookup tables and book keeping.\n\n   Useful when a record has been deleted and the deletion has been persisted and\n   we do not care about the record anymore. Especially useful when an `id` of a\n   deleted record might be reused later for a new record.\n\n   @method forgetRecordIdentifier\n   @param identifierObject\n   @public\n  */\n  forgetRecordIdentifier(identifierObject: RecordIdentifier): void {\n    const identifier = this.getOrCreateRecordIdentifier(identifierObject);\n    const typeSet = this._cache.resourcesByType[identifier.type];\n    assert(`Expected to find a typeSet for ${identifier.type}`, typeSet);\n\n    if (identifier.id !== null) {\n      typeSet.id.delete(identifier.id);\n    }\n    this._cache.resources.delete(identifier.lid);\n    typeSet.lid.delete(identifier.lid);\n\n    const backReferences = this._cache.polymorphicLidBackMap.get(identifier.lid);\n    if (backReferences) {\n      backReferences.forEach((lid) => {\n        this._cache.resources.delete(lid);\n      });\n      this._cache.polymorphicLidBackMap.delete(identifier.lid);\n    }\n\n    if (DEBUG) {\n      identifier[DEBUG_STALE_CACHE_OWNER] = identifier[CACHE_OWNER];\n    }\n    identifier[CACHE_OWNER] = undefined;\n    IDENTIFIERS.delete(identifier);\n    this._forget(identifier, 'record');\n    if (LOG_IDENTIFIERS) {\n      // eslint-disable-next-line no-console\n      console.log(`Identifiers: released identifier ${identifierObject.lid}`);\n    }\n  }\n\n  destroy() {\n    NEW_IDENTIFIERS.clear();\n    this._cache.documents.forEach((identifier) => {\n      DOCUMENTS.delete(identifier);\n    });\n    this._reset();\n  }\n}\n\nfunction makeStableRecordIdentifier(\n  recordIdentifier: {\n    type: string;\n    id: string | null;\n    lid: string;\n    [CACHE_OWNER]: number | undefined;\n  },\n  bucket: IdentifierBucket,\n  clientOriginated: boolean\n): StableRecordIdentifier {\n  IDENTIFIERS.add(recordIdentifier);\n\n  if (DEBUG) {\n    // we enforce immutability in dev\n    //  but preserve our ability to do controlled updates to the reference\n    let wrapper: StableRecordIdentifier = {\n      get lid() {\n        return recordIdentifier.lid;\n      },\n      get id() {\n        return recordIdentifier.id;\n      },\n      get type() {\n        return recordIdentifier.type;\n      },\n      get [CACHE_OWNER](): number | undefined {\n        return recordIdentifier[CACHE_OWNER];\n      },\n      set [CACHE_OWNER](value: number) {\n        recordIdentifier[CACHE_OWNER] = value;\n      },\n      get [DEBUG_STALE_CACHE_OWNER](): number | undefined {\n        return (recordIdentifier as StableRecordIdentifier)[DEBUG_STALE_CACHE_OWNER];\n      },\n      set [DEBUG_STALE_CACHE_OWNER](value: number | undefined) {\n        (recordIdentifier as StableRecordIdentifier)[DEBUG_STALE_CACHE_OWNER] = value;\n      },\n    };\n    Object.defineProperty(wrapper, 'toString', {\n      enumerable: false,\n      value: () => {\n        const { type, id, lid } = recordIdentifier;\n        return `${clientOriginated ? '[CLIENT_ORIGINATED] ' : ''}${String(type)}:${String(id)} (${lid})`;\n      },\n    });\n    Object.defineProperty(wrapper, 'toJSON', {\n      enumerable: false,\n      value: () => {\n        const { type, id, lid } = recordIdentifier;\n        return { type, id, lid };\n      },\n    });\n    wrapper[DEBUG_CLIENT_ORIGINATED] = clientOriginated;\n    wrapper[DEBUG_IDENTIFIER_BUCKET] = bucket;\n    IDENTIFIERS.add(wrapper);\n    DEBUG_MAP.set(wrapper, recordIdentifier);\n    wrapper = freeze(wrapper);\n    return wrapper;\n  }\n\n  return recordIdentifier;\n}\n\nfunction performRecordIdentifierUpdate(\n  identifier: StableRecordIdentifier,\n  keyInfo: KeyInfo,\n  data: unknown,\n  updateFn: UpdateMethod\n) {\n  if (DEBUG) {\n    const { id, type } = keyInfo;\n\n    // get the mutable instance behind our proxy wrapper\n    const wrapper = identifier;\n    identifier = DEBUG_MAP.get(wrapper)!;\n\n    if (hasLid(data)) {\n      const lid = data.lid;\n      if (lid !== identifier.lid) {\n        throw new Error(\n          `The 'lid' for a RecordIdentifier cannot be updated once it has been created. Attempted to set lid for '${wrapper.lid}' to '${lid}'.`\n        );\n      }\n    }\n\n    if (id && identifier.id !== null && identifier.id !== id) {\n      // here we warn and ignore, as this may be a mistake, but we allow the user\n      // to have multiple cache-keys pointing at a single lid so we cannot error\n      warn(\n        `The 'id' for a RecordIdentifier should not be updated once it has been set. Attempted to set id for '${wrapper.lid}' to '${id}'.`,\n        false,\n        { id: 'ember-data:multiple-ids-for-identifier' }\n      );\n    }\n\n    // TODO consider just ignoring here to allow flexible polymorphic support\n    if (type && type !== identifier.type) {\n      throw new Error(\n        `The 'type' for a RecordIdentifier cannot be updated once it has been set. Attempted to set type for '${wrapper.lid}' to '${type}'.`\n      );\n    }\n\n    updateFn(wrapper, data, 'record');\n  } else {\n    updateFn(identifier, data, 'record');\n  }\n\n  // upgrade the ID, this is a \"one time only\" ability\n  // for the multiple-cache-key scenario we \"could\"\n  // use a heuristic to guess the best id for display\n  // (usually when `data.id` is available and `data.attributes` is not)\n  if ((data as ExistingResourceObject).id !== undefined) {\n    identifier.id = coerceId((data as ExistingResourceObject).id);\n  }\n}\n\nfunction detectMerge(\n  cache: StableCache,\n  keyInfo: KeyInfo,\n  identifier: StableRecordIdentifier,\n  data: unknown\n): StableRecordIdentifier | false {\n  const newId = keyInfo.id;\n  const { id, type, lid } = identifier;\n  const typeSet = cache.resourcesByType[identifier.type];\n\n  // if the IDs are present but do not match\n  // then check if we have an existing identifier\n  // for the newer ID.\n  if (id !== null && id !== newId && newId !== null) {\n    const existingIdentifier = typeSet && typeSet.id.get(newId);\n\n    return existingIdentifier !== undefined ? existingIdentifier : false;\n  } else {\n    const newType = keyInfo.type;\n\n    // If the ids and type are the same but lid is not the same, we should trigger a merge of the identifiers\n    // we trigger a merge of the identifiers\n    // though probably we should just throw an error here\n    if (id !== null && id === newId && newType === type && hasLid(data) && data.lid !== lid) {\n      return getIdentifierFromLid(cache, data.lid, data) || false;\n\n      // If the lids are the same, and ids are the same, but types are different we should trigger a merge of the identifiers\n    } else if (id !== null && id === newId && newType && newType !== type && hasLid(data) && data.lid === lid) {\n      const newTypeSet = cache.resourcesByType[newType];\n      const existingIdentifier = newTypeSet && newTypeSet.id.get(newId);\n\n      return existingIdentifier !== undefined ? existingIdentifier : false;\n    }\n  }\n\n  return false;\n}\n\nfunction getIdentifierFromLid(cache: StableCache, lid: string, resource: unknown): StableRecordIdentifier | null {\n  const identifier = cache.resources.get(lid);\n  if (LOG_IDENTIFIERS) {\n    // eslint-disable-next-line no-console\n    console.log(`Identifiers: cache ${identifier ? 'HIT' : 'MISS'} - Non-Stable ${lid}`, resource);\n  }\n  return identifier || null;\n}\n\nfunction addResourceToCache(cache: StableCache, identifier: StableRecordIdentifier): void {\n  cache.resources.set(identifier.lid, identifier);\n  let typeSet = cache.resourcesByType[identifier.type];\n\n  if (!typeSet) {\n    typeSet = { lid: new Map(), id: new Map() };\n    cache.resourcesByType[identifier.type] = typeSet;\n  }\n\n  typeSet.lid.set(identifier.lid, identifier);\n  if (identifier.id) {\n    typeSet.id.set(identifier.id, identifier);\n  }\n}\n","import { assert } from '@ember/debug';\n\nimport { defineSignal } from '@ember-data/tracking/-private';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';\n/**\n  @module @ember-data/store\n*/\nimport type { SingleResourceDocument } from '@warp-drive/core-types/spec/raw';\n\nimport type { RecordInstance } from '../../-types/q/record-instance';\nimport type { NotificationType } from '../managers/notification-manager';\nimport type Store from '../store-service';\n\n/**\n  @module @ember-data/store\n*/\n\n/**\n   A `RecordReference` is a low-level API that allows users and\n   addon authors to perform meta-operations on a record.\n\n   @class RecordReference\n   @public\n*/\nexport default class RecordReference {\n  declare store: Store;\n  // unsubscribe token given to us by the notification manager\n  ___token!: object;\n  ___identifier: StableRecordIdentifier;\n\n  declare _ref: number;\n\n  constructor(store: Store, identifier: StableRecordIdentifier) {\n    this.store = store;\n    this.___identifier = identifier;\n    this.___token = store.notifications.subscribe(\n      identifier,\n      (_: StableRecordIdentifier, bucket: NotificationType, notifiedKey?: string) => {\n        if (bucket === 'identity' || (bucket === 'attributes' && notifiedKey === 'id')) {\n          this._ref++;\n        }\n      }\n    );\n  }\n\n  destroy() {\n    this.store.notifications.unsubscribe(this.___token);\n  }\n\n  get type(): string {\n    return this.identifier().type;\n  }\n\n  /**\n     The `id` of the record that this reference refers to.\n\n     Together, the `type` and `id` properties form a composite key for\n     the identity map.\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     userRef.id(); // '1'\n     ```\n\n     @method id\n    @public\n     @return {String} The id of the record.\n  */\n  id() {\n    this._ref; // consume the tracked prop\n    return this.___identifier.id;\n  }\n\n  /**\n     The `identifier` of the record that this reference refers to.\n\n     Together, the `type` and `id` properties form a composite key for\n     the identity map.\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     userRef.identifier(); // '1'\n     ```\n\n     @method identifier\n    @public\n     @return {String} The identifier of the record.\n  */\n  identifier(): StableRecordIdentifier {\n    return this.___identifier;\n  }\n\n  /**\n     How the reference will be looked up when it is loaded. Currently\n     this always returns `identity` to signify that a record will be\n     loaded by its `type` and `id`.\n\n     Example\n\n     ```javascript\n     const userRef = store.getReference('user', 1);\n\n     userRef.remoteType(); // 'identity'\n     ```\n\n     @method remoteType\n     @public\n     @return {String} 'identity'\n  */\n  remoteType(): 'identity' {\n    return 'identity';\n  }\n\n  /**\n    This API allows you to provide a reference with new data. The\n    simplest usage of this API is similar to `store.push`: you provide a\n    normalized hash of data and the object represented by the reference\n    will update.\n\n    If you pass a promise to `push`, Ember Data will not ask the adapter\n    for the data if another attempt to fetch it is made in the\n    interim. When the promise resolves, the underlying object is updated\n    with the new data, and the promise returned by *this function* is resolved\n    with that object.\n\n    For example, `recordReference.push(promise)` will be resolved with a\n    record.\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     // provide data for reference\n     userRef.push({\n       data: {\n         id: \"1\",\n         type: \"user\",\n         attributes: {\n           username: \"@user\"\n         }\n       }\n     }).then(function(user) {\n       userRef.value() === user;\n     });\n     ```\n\n    @method push\n    @public\n    @param objectOrPromise a JSON:API ResourceDocument or a promise resolving to one\n    @return a promise for the value (record or relationship)\n  */\n  push(objectOrPromise: SingleResourceDocument | Promise<SingleResourceDocument>): Promise<RecordInstance> {\n    // TODO @deprecate pushing unresolved payloads\n    return Promise.resolve(objectOrPromise).then((data) => {\n      return this.store.push(data);\n    });\n  }\n\n  /**\n    If the entity referred to by the reference is already loaded, it is\n    present as `reference.value`. Otherwise the value returned by this function\n    is `null`.\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     userRef.value(); // user\n     ```\n\n     @method value\n    @public\n     @return {Model} the record for this RecordReference\n  */\n  value(): RecordInstance | null {\n    return this.store.peekRecord(this.___identifier);\n  }\n\n  /**\n     Triggers a fetch for the backing entity based on its `remoteType`\n     (see `remoteType` definitions per reference type).\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     // load user (via store.find)\n     userRef.load().then(...)\n     ```\n\n     @method load\n    @public\n     @return {Promise<record>} the record for this RecordReference\n  */\n  load() {\n    const id = this.id();\n    if (id !== null) {\n      return this.store.findRecord(this.type, id);\n    }\n    assert(`Unable to fetch record of type ${this.type} without an id`);\n  }\n\n  /**\n     Reloads the record if it is already loaded. If the record is not\n     loaded it will load the record via `store.findRecord`\n\n     Example\n\n     ```javascript\n     let userRef = store.getReference('user', 1);\n\n     // or trigger a reload\n     userRef.reload().then(...)\n     ```\n\n     @method reload\n    @public\n     @return {Promise<record>} the record for this RecordReference\n  */\n  reload() {\n    const id = this.id();\n    if (id !== null) {\n      return this.store.findRecord(this.type, id, { reload: true });\n    }\n    assert(`Unable to fetch record of type ${this.type} without an id`);\n  }\n}\n\ndefineSignal(RecordReference.prototype, '_ref');\n","import { assert } from '@ember/debug';\n\nimport type { StableDocumentIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\n\nimport type { CacheCapabilitiesManager as StoreWrapper } from '../../-types/q/cache-store-wrapper';\nimport type { SchemaService } from '../../-types/q/schema-service';\nimport type { IdentifierCache } from '../caches/identifier-cache';\nimport { isDocumentIdentifier, isStableIdentifier } from '../caches/identifier-cache';\nimport type Store from '../store-service';\nimport type { NotificationType } from './notification-manager';\n\n/**\n  @module @ember-data/store\n*/\n\nexport class CacheCapabilitiesManager implements StoreWrapper {\n  declare _willNotify: boolean;\n  declare _pendingNotifies: Map<StableRecordIdentifier, Set<string>>;\n  declare _store: Store;\n\n  constructor(_store: Store) {\n    this._store = _store;\n    this._willNotify = false;\n    this._pendingNotifies = new Map();\n  }\n\n  get identifierCache(): IdentifierCache {\n    return this._store.identifierCache;\n  }\n\n  _scheduleNotification(identifier: StableRecordIdentifier, key: string) {\n    let pending = this._pendingNotifies.get(identifier);\n\n    if (!pending) {\n      pending = new Set();\n      this._pendingNotifies.set(identifier, pending);\n    }\n    pending.add(key);\n\n    if (this._willNotify === true) {\n      return;\n    }\n\n    this._willNotify = true;\n    // it's possible a cache adhoc notifies us,\n    // in which case we sync flush\n    if (this._store._cbs) {\n      this._store._schedule('notify', () => this._flushNotifications());\n    } else {\n      // TODO @runspired determine if relationship mutations should schedule\n      // into join/run vs immediate flush\n      this._flushNotifications();\n    }\n  }\n\n  _flushNotifications(): void {\n    if (this._willNotify === false) {\n      return;\n    }\n\n    const pending = this._pendingNotifies;\n    this._pendingNotifies = new Map();\n    this._willNotify = false;\n\n    pending.forEach((set, identifier) => {\n      set.forEach((key) => {\n        this._store.notifications.notify(identifier, 'relationships', key);\n      });\n    });\n  }\n\n  notifyChange(identifier: StableRecordIdentifier, namespace: 'added' | 'removed'): void;\n  notifyChange(identifier: StableDocumentIdentifier, namespace: 'added' | 'updated' | 'removed'): void;\n  notifyChange(identifier: StableRecordIdentifier, namespace: NotificationType, key?: string): void;\n  notifyChange(\n    identifier: StableRecordIdentifier | StableDocumentIdentifier,\n    namespace: NotificationType | 'added' | 'removed' | 'updated',\n    key?: string\n  ): void {\n    assert(`Expected a stable identifier`, isStableIdentifier(identifier) || isDocumentIdentifier(identifier));\n\n    // TODO do we still get value from this?\n    if (namespace === 'relationships' && key) {\n      this._scheduleNotification(identifier as StableRecordIdentifier, key);\n      return;\n    }\n\n    // @ts-expect-error\n    this._store.notifications.notify(identifier, namespace, key);\n  }\n\n  getSchemaDefinitionService(): SchemaService {\n    return this._store.getSchemaDefinitionService();\n  }\n\n  get schema() {\n    return this._store.schema;\n  }\n\n  setRecordId(identifier: StableRecordIdentifier, id: string) {\n    assert(`Expected a stable identifier`, isStableIdentifier(identifier));\n    this._store._instanceCache.setRecordId(identifier, id);\n  }\n\n  hasRecord(identifier: StableRecordIdentifier): boolean {\n    return Boolean(this._store._instanceCache.peek(identifier));\n  }\n\n  disconnectRecord(identifier: StableRecordIdentifier): void {\n    assert(`Expected a stable identifier`, isStableIdentifier(identifier));\n    this._store._instanceCache.disconnect(identifier);\n    this._pendingNotifies.delete(identifier);\n  }\n}\n","import { assert } from '@ember/debug';\n\nimport type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';\n\nimport type { Cache } from '../../-types/q/cache';\nimport type { RecordInstance } from '../../-types/q/record-instance';\n\n/*\n * Returns the Cache instance associated with a given\n * Model or Identifier\n */\n\nexport const CacheForIdentifierCache = new Map<StableRecordIdentifier | RecordInstance, Cache>();\n\nexport function setCacheFor(identifier: StableRecordIdentifier | RecordInstance, cache: Cache): void {\n  assert(\n    `Illegal set of identifier`,\n    !CacheForIdentifierCache.has(identifier) || CacheForIdentifierCache.get(identifier) === cache\n  );\n  CacheForIdentifierCache.set(identifier, cache);\n}\n\nexport function removeRecordDataFor(identifier: StableRecordIdentifier | RecordInstance): void {\n  CacheForIdentifierCache.delete(identifier);\n}\n\nexport default function peekCache(instance: StableRecordIdentifier): Cache | null;\nexport default function peekCache(instance: RecordInstance): Cache;\nexport default function peekCache(instance: StableRecordIdentifier | RecordInstance): Cache | null {\n  if (CacheForIdentifierCache.has(instance as StableRecordIdentifier)) {\n    return CacheForIdentifierCache.get(instance as StableRecordIdentifier) as Cache;\n  }\n\n  return null;\n}\n","import { assert, warn } from '@ember/debug';\n\nimport { LOG_INSTANCE_CACHE } from '@ember-data/debugging';\nimport { DEBUG } from '@ember-data/env';\nimport type { RecordIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { Value } from '@warp-drive/core-types/json/raw';\nimport type { RelationshipSchema } from '@warp-drive/core-types/schema';\nimport type { ExistingResourceIdentifierObject, NewResourceIdentifierObject } from '@warp-drive/core-types/spec/raw';\n\nimport type { Cache } from '../../-types/q/cache';\nimport type { JsonApiRelationship, JsonApiResource } from '../../-types/q/record-data-json-api';\nimport type { RecordInstance } from '../../-types/q/record-instance';\nimport RecordReference from '../legacy-model-support/record-reference';\nimport { CacheCapabilitiesManager } from '../managers/cache-capabilities-manager';\nimport type { CacheManager } from '../managers/cache-manager';\nimport type { CreateRecordProperties } from '../store-service';\nimport type Store from '../store-service';\nimport { ensureStringId } from '../utils/coerce-id';\nimport { CacheForIdentifierCache, removeRecordDataFor, setCacheFor } from './cache-utils';\n\ntype Destroyable = {\n  isDestroyed: boolean;\n  isDestroying: boolean;\n  destroy(): void;\n};\n\nfunction isDestroyable(record: RecordInstance): record is Destroyable {\n  return Boolean(record && typeof record === 'object' && typeof (record as Destroyable).destroy === 'function');\n}\n\n/**\n  @module @ember-data/store\n*/\n\nconst RecordCache = new Map<RecordInstance, StableRecordIdentifier>();\n\nexport function peekRecordIdentifier(record: RecordInstance): StableRecordIdentifier | undefined {\n  return RecordCache.get(record);\n}\n\n/**\n  Retrieves the unique referentially-stable [RecordIdentifier](/ember-data/release/classes/StableRecordIdentifier)\n  assigned to the given record instance.\n  ```js\n  import { recordIdentifierFor } from \"@ember-data/store\";\n  // ... gain access to a record, for instance with peekRecord or findRecord\n  const record = store.peekRecord(\"user\", \"1\");\n  // get the identifier for the record (see docs for StableRecordIdentifier)\n  const identifier = recordIdentifierFor(record);\n  // access the identifier's properties.\n  const { id, type, lid } = identifier;\n  ```\n  @method recordIdentifierFor\n  @public\n  @static\n  @for @ember-data/store\n  @param {Object} record a record instance previously obstained from the store.\n  @return {StableRecordIdentifier}\n */\nexport function recordIdentifierFor(record: RecordInstance): StableRecordIdentifier {\n  assert(`${String(record)} is not a record instantiated by @ember-data/store`, RecordCache.has(record));\n  return RecordCache.get(record)!;\n}\n\nexport function setRecordIdentifier(record: RecordInstance, identifier: StableRecordIdentifier): void {\n  if (DEBUG) {\n    if (RecordCache.has(record) && RecordCache.get(record) !== identifier) {\n      throw new Error(`${String(record)} was already assigned an identifier`);\n    }\n  }\n\n  /*\n  It would be nice to do a reverse check here that an identifier has not\n  previously been assigned a record; however, unload + rematerialization\n  prevents us from having a great way of doing so when CustomRecordClasses\n  don't necessarily give us access to a `isDestroyed` for dematerialized\n  instance.\n  */\n\n  RecordCache.set(record, identifier);\n}\n\nexport const StoreMap = new Map<RecordInstance, Store>();\n\nexport function storeFor(record: RecordInstance): Store | undefined {\n  const store = StoreMap.get(record);\n\n  assert(\n    `A record in a disconnected state cannot utilize the store. This typically means the record has been destroyed, most commonly by unloading it.`,\n    store\n  );\n  return store;\n}\n\ntype Caches = {\n  record: Map<StableRecordIdentifier, RecordInstance>;\n  reference: WeakMap<StableRecordIdentifier, RecordReference>;\n};\n\nexport class InstanceCache {\n  declare store: Store;\n  declare cache: Cache;\n  declare _storeWrapper: CacheCapabilitiesManager;\n  declare __cacheFor: (resource: RecordIdentifier) => Cache;\n\n  declare __cacheManager: CacheManager;\n  __instances: Caches = {\n    record: new Map<StableRecordIdentifier, RecordInstance>(),\n    reference: new WeakMap<StableRecordIdentifier, RecordReference>(),\n  };\n\n  constructor(store: Store) {\n    this.store = store;\n\n    this._storeWrapper = new CacheCapabilitiesManager(this.store);\n\n    store.identifierCache.__configureMerge(\n      (identifier: StableRecordIdentifier, matchedIdentifier: StableRecordIdentifier, resourceData: unknown) => {\n        let keptIdentifier = identifier;\n        if (identifier.id !== matchedIdentifier.id) {\n          // @ts-expect-error TODO this needs to be fixed\n          keptIdentifier = 'id' in resourceData && identifier.id === resourceData.id ? identifier : matchedIdentifier;\n        } else if (identifier.type !== matchedIdentifier.type) {\n          keptIdentifier = // @ts-expect-error TODO this needs to be fixed\n            'type' in resourceData && identifier.type === resourceData.type ? identifier : matchedIdentifier;\n        }\n        const staleIdentifier = identifier === keptIdentifier ? matchedIdentifier : identifier;\n\n        // check for duplicate entities\n        const keptHasRecord = this.__instances.record.has(keptIdentifier);\n        const staleHasRecord = this.__instances.record.has(staleIdentifier);\n\n        // we cannot merge entities when both have records\n        // (this may not be strictly true, we could probably swap the cache data the record points at)\n        if (keptHasRecord && staleHasRecord) {\n          // TODO we probably don't need to throw these errors anymore\n          // we can probably just \"swap\" what data source the abandoned\n          // record points at so long as\n          // it itself is not retained by the store in any way.\n          // @ts-expect-error TODO this needs to be fixed\n          if ('id' in resourceData) {\n            throw new Error(\n              `Failed to update the 'id' for the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${\n                identifier.lid\n              })' to '${String(resourceData.id)}', because that id is already in use by '${\n                matchedIdentifier.type\n              }:${String(matchedIdentifier.id)} (${matchedIdentifier.lid})'`\n            );\n          }\n\n          assert(\n            `Failed to update the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${\n              identifier.lid\n            })' to merge with the detected duplicate identifier '${matchedIdentifier.type}:${String(\n              matchedIdentifier.id\n            )} (${String(matchedIdentifier.lid)})'`\n          );\n        }\n\n        this.store.cache.patch({\n          op: 'mergeIdentifiers',\n          record: staleIdentifier,\n          value: keptIdentifier,\n        });\n\n        /*\n      TODO @runspired consider adding this to make polymorphism even nicer\n      if (identifier.type !== matchedIdentifier.type) {\n        this.store._graph?.registerPolymorphicType(identifier.type, matchedIdentifier.type);\n      }\n      */\n\n        this.unloadRecord(staleIdentifier);\n        return keptIdentifier;\n      }\n    );\n  }\n  peek(identifier: StableRecordIdentifier): Cache | RecordInstance | undefined {\n    return this.__instances.record.get(identifier);\n  }\n\n  getRecord(identifier: StableRecordIdentifier, properties?: CreateRecordProperties): RecordInstance {\n    let record = this.__instances.record.get(identifier);\n\n    if (!record) {\n      assert(\n        `Cannot create a new record instance while the store is being destroyed`,\n        !this.store.isDestroying && !this.store.isDestroyed\n      );\n      const cache = this.store.cache;\n      setCacheFor(identifier, cache);\n\n      record = this.store.instantiateRecord(identifier, properties || {});\n\n      setRecordIdentifier(record, identifier);\n      setCacheFor(record, cache);\n      StoreMap.set(record, this.store);\n      this.__instances.record.set(identifier, record);\n\n      if (LOG_INSTANCE_CACHE) {\n        // eslint-disable-next-line no-console\n        console.log(`InstanceCache: created Record for ${String(identifier)}`, properties);\n      }\n    }\n\n    return record;\n  }\n\n  getReference(identifier: StableRecordIdentifier) {\n    const cache = this.__instances.reference;\n    let reference = cache.get(identifier);\n\n    if (!reference) {\n      reference = new RecordReference(this.store, identifier);\n      cache.set(identifier, reference);\n    }\n    return reference;\n  }\n\n  recordIsLoaded(identifier: StableRecordIdentifier, filterDeleted = false) {\n    const cache = this.cache;\n    if (!cache) {\n      return false;\n    }\n    const isNew = cache.isNew(identifier);\n    const isEmpty = cache.isEmpty(identifier);\n\n    // if we are new we must consider ourselves loaded\n    if (isNew) {\n      return !cache.isDeleted(identifier);\n    }\n    // even if we have a past request, if we are now empty we are not loaded\n    // typically this is true after an unloadRecord call\n\n    // if we are not empty, not new && we have a fulfilled request then we are loaded\n    // we should consider allowing for something to be loaded that is simply \"not empty\".\n    // which is how RecordState currently handles this case; however, RecordState is buggy\n    // in that it does not account for unloading.\n    return filterDeleted && cache.isDeletionCommitted(identifier) ? false : !isEmpty;\n  }\n\n  disconnect(identifier: StableRecordIdentifier) {\n    const record = this.__instances.record.get(identifier);\n    assert(\n      'Cannot destroy record while it is still materialized',\n      !isDestroyable(record) || record.isDestroyed || record.isDestroying\n    );\n\n    this.store._graph?.remove(identifier);\n\n    this.store.identifierCache.forgetRecordIdentifier(identifier);\n    removeRecordDataFor(identifier);\n    this.store._requestCache._clearEntries(identifier);\n    if (LOG_INSTANCE_CACHE) {\n      // eslint-disable-next-line no-console\n      console.log(`InstanceCache: disconnected ${String(identifier)}`);\n    }\n  }\n\n  unloadRecord(identifier: StableRecordIdentifier) {\n    if (DEBUG) {\n      const requests = this.store.getRequestStateService().getPendingRequestsForRecord(identifier);\n      if (\n        requests.some((req) => {\n          return req.type === 'mutation';\n        })\n      ) {\n        assert(`You can only unload a record which is not inFlight. '${String(identifier)}'`);\n      }\n    }\n    if (LOG_INSTANCE_CACHE) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed(`InstanceCache: unloading record for ${String(identifier)}`);\n    }\n\n    // TODO is this join still necessary?\n    this.store._join(() => {\n      const record = this.__instances.record.get(identifier);\n      const cache = this.cache;\n\n      if (record) {\n        this.store.teardownRecord(record);\n        this.__instances.record.delete(identifier);\n        StoreMap.delete(record);\n        RecordCache.delete(record);\n        removeRecordDataFor(record);\n\n        if (LOG_INSTANCE_CACHE) {\n          // eslint-disable-next-line no-console\n          console.log(`InstanceCache: destroyed record for ${String(identifier)}`);\n        }\n      }\n\n      if (cache) {\n        cache.unloadRecord(identifier);\n        removeRecordDataFor(identifier);\n        if (LOG_INSTANCE_CACHE) {\n          // eslint-disable-next-line no-console\n          console.log(`InstanceCache: destroyed cache for ${String(identifier)}`);\n        }\n      } else {\n        this.disconnect(identifier);\n      }\n\n      this.store._requestCache._clearEntries(identifier);\n      if (LOG_INSTANCE_CACHE) {\n        // eslint-disable-next-line no-console\n        console.log(`InstanceCache: unloaded RecordData for ${String(identifier)}`);\n        // eslint-disable-next-line no-console\n        console.groupEnd();\n      }\n    });\n  }\n\n  clear(type?: string) {\n    const cache = this.store.identifierCache._cache;\n    if (type === undefined) {\n      // it would be cool if we could just de-ref cache here\n      // but probably would require WeakRef models to do so.\n      cache.resources.forEach((identifier) => {\n        this.unloadRecord(identifier);\n      });\n    } else {\n      const typeCache = cache.resourcesByType;\n      const identifiers = typeCache[type]?.lid;\n      if (identifiers) {\n        identifiers.forEach((identifier) => {\n          // if (rds.has(identifier)) {\n          this.unloadRecord(identifier);\n          // }\n          // TODO we don't remove the identifier, should we?\n        });\n      }\n    }\n  }\n\n  // TODO this should move into something coordinating operations\n  setRecordId(identifier: StableRecordIdentifier, id: string) {\n    const { type, lid } = identifier;\n    const oldId = identifier.id;\n\n    // ID absolutely can't be missing if the oldID is empty (missing Id in response for a new record)\n    assert(\n      `'${type}' was saved to the server, but the response does not have an id and your record does not either.`,\n      !(id === null && oldId === null)\n    );\n\n    // ID absolutely can't be different than oldID if oldID is not null\n    // TODO this assertion and restriction may not strictly be needed in the identifiers world\n    assert(\n      `Cannot update the id for '${type}:${lid}' from '${String(oldId)}' to '${id}'.`,\n      !(oldId !== null && id !== oldId)\n    );\n\n    // ID can be null if oldID is not null (altered ID in response for a record)\n    // however, this is more than likely a developer error.\n    if (oldId !== null && id === null) {\n      warn(\n        `Your ${type} record was saved to the server, but the response does not have an id.`,\n        !(oldId !== null && id === null)\n      );\n      return;\n    }\n\n    if (LOG_INSTANCE_CACHE) {\n      // eslint-disable-next-line no-console\n      console.log(`InstanceCache: updating id to '${id}' for record ${String(identifier)}`);\n    }\n\n    const existingIdentifier = this.store.identifierCache.peekRecordIdentifier({ type, id });\n    assert(\n      `'${type}' was saved to the server, but the response returned the new id '${id}', which has already been used with another record.'`,\n      !existingIdentifier || existingIdentifier === identifier\n    );\n\n    if (identifier.id === null) {\n      // TODO potentially this needs to handle merged result\n      this.store.identifierCache.updateRecordIdentifier(identifier, { type, id });\n    }\n\n    // TODO update resource cache if needed ?\n    // TODO handle consequences of identifier merge for notifications\n    this.store.notifications.notify(identifier, 'identity');\n  }\n}\n\nfunction _resourceIsFullDeleted(identifier: StableRecordIdentifier, cache: Cache): boolean {\n  return cache.isDeletionCommitted(identifier) || (cache.isNew(identifier) && cache.isDeleted(identifier));\n}\n\nexport function resourceIsFullyDeleted(instanceCache: InstanceCache, identifier: StableRecordIdentifier): boolean {\n  const cache = instanceCache.cache;\n  return !cache || _resourceIsFullDeleted(identifier, cache);\n}\n\n/*\n    When a find request is triggered on the store, the user can optionally pass in\n    attributes and relationships to be preloaded. These are meant to behave as if they\n    came back from the server, except the user obtained them out of band and is informing\n    the store of their existence. The most common use case is for supporting client side\n    nested URLs, such as `/posts/1/comments/2` so the user can do\n    `store.findRecord('comment', 2, { preload: { post: 1 } })` without having to fetch the post.\n\n    Preloaded data can be attributes and relationships passed in either as IDs or as actual\n    models.\n  */\ntype PreloadRelationshipValue = RecordInstance | string;\nexport function preloadData(store: Store, identifier: StableRecordIdentifier, preload: Record<string, Value>) {\n  const jsonPayload: JsonApiResource = {};\n  //TODO(Igor) consider the polymorphic case\n  const schemas = store.getSchemaDefinitionService();\n  const relationships = schemas.relationshipsDefinitionFor(identifier);\n  Object.keys(preload).forEach((key) => {\n    const preloadValue = preload[key];\n\n    const relationshipMeta = relationships[key];\n    if (relationshipMeta) {\n      if (!jsonPayload.relationships) {\n        jsonPayload.relationships = {};\n      }\n      jsonPayload.relationships[key] = preloadRelationship(relationshipMeta, preloadValue);\n    } else {\n      if (!jsonPayload.attributes) {\n        jsonPayload.attributes = {};\n      }\n      jsonPayload.attributes[key] = preloadValue;\n    }\n  });\n  const cache = store.cache;\n  const hasRecord = Boolean(store._instanceCache.peek(identifier));\n  cache.upsert(identifier, jsonPayload, hasRecord);\n}\n\nfunction preloadRelationship(\n  schema: RelationshipSchema,\n  preloadValue: PreloadRelationshipValue | null | Array<PreloadRelationshipValue>\n): JsonApiRelationship {\n  const relatedType = schema.type;\n\n  if (schema.kind === 'hasMany') {\n    assert('You need to pass in an array to set a hasMany property on a record', Array.isArray(preloadValue));\n    return { data: preloadValue.map((value) => _convertPreloadRelationshipToJSON(value, relatedType)) };\n  }\n\n  assert('You should not pass in an array to set a belongsTo property on a record', !Array.isArray(preloadValue));\n  return { data: preloadValue ? _convertPreloadRelationshipToJSON(preloadValue, relatedType) : null };\n}\n\n/*\n  findRecord('user', '1', { preload: { friends: ['1'] }});\n  findRecord('user', '1', { preload: { friends: [record] }});\n*/\nfunction _convertPreloadRelationshipToJSON(\n  value: RecordInstance | string,\n  type: string\n): ExistingResourceIdentifierObject | NewResourceIdentifierObject {\n  if (typeof value === 'string' || typeof value === 'number') {\n    return { type, id: ensureStringId(value) };\n  }\n  // TODO if not a record instance assert it's an identifier\n  // and allow identifiers to be used\n  return recordIdentifierFor(value);\n}\n\nexport function _clearCaches() {\n  RecordCache.clear();\n  StoreMap.clear();\n  CacheForIdentifierCache.clear();\n}\n","import type { AttributeSchema, RelationshipSchema } from '@warp-drive/core-types/schema';\n\nimport type { ModelSchema } from '../../-types/q/ds-model';\nimport type Store from '../store-service';\n\ntype GenericRecord = Record<string, unknown>;\n\n// if modelFor turns out to be a bottleneck we should replace with a Map\n// and clear it during store teardown.\nconst AvailableShims = new WeakMap<Store, Record<string, ShimModelClass<GenericRecord>>>();\n\nexport function getShimClass(store: Store, modelName: string): ShimModelClass<GenericRecord> {\n  let shims = AvailableShims.get(store);\n\n  if (!shims) {\n    shims = Object.create(null) as Record<string, ShimModelClass<GenericRecord>>;\n    AvailableShims.set(store, shims);\n  }\n\n  let shim = shims[modelName];\n  if (shim === undefined) {\n    shim = shims[modelName] = new ShimModelClass(store, modelName);\n  }\n\n  return shim;\n}\n\nfunction mapFromHash<K extends string, T>(hash: Record<K, T>): Map<K, T> {\n  const map: Map<K, T> = new Map();\n  for (const i in hash) {\n    if (Object.prototype.hasOwnProperty.call(hash, i)) {\n      map.set(i, hash[i]);\n    }\n  }\n  return map;\n}\n\n// Mimics the static apis of @ember-data/model\nexport default class ShimModelClass<T extends object> implements ModelSchema<T> {\n  declare __store: Store;\n  declare modelName: string;\n  constructor(store: Store, modelName: string) {\n    this.__store = store;\n    this.modelName = modelName;\n  }\n\n  get fields(): Map<keyof T & string, 'attribute' | 'belongsTo' | 'hasMany'> {\n    const attrs = this.__store.getSchemaDefinitionService().attributesDefinitionFor({ type: this.modelName });\n    const relationships = this.__store\n      .getSchemaDefinitionService()\n      .relationshipsDefinitionFor({ type: this.modelName });\n    const fields = new Map<keyof T & string, 'attribute' | 'belongsTo' | 'hasMany'>();\n    Object.keys(attrs).forEach((key) => fields.set(key as keyof T & string, 'attribute'));\n    Object.keys(relationships).forEach((key) => fields.set(key as keyof T & string, relationships[key]!.kind));\n    return fields;\n  }\n\n  get attributes(): Map<keyof T & string, AttributeSchema> {\n    const attrs = this.__store.getSchemaDefinitionService().attributesDefinitionFor({ type: this.modelName });\n    return mapFromHash(attrs as Record<keyof T & string, AttributeSchema>);\n  }\n\n  get relationshipsByName(): Map<keyof T & string, RelationshipSchema> {\n    const relationships = this.__store\n      .getSchemaDefinitionService()\n      .relationshipsDefinitionFor({ type: this.modelName });\n    return mapFromHash(relationships as Record<keyof T & string, RelationshipSchema>);\n  }\n\n  eachAttribute<K extends keyof T & string>(callback: (key: K, attribute: AttributeSchema) => void, binding?: T) {\n    const attrDefs = this.__store.getSchemaDefinitionService().attributesDefinitionFor({ type: this.modelName });\n    Object.keys(attrDefs).forEach((key) => {\n      callback.call(binding, key as K, attrDefs[key]);\n    });\n  }\n\n  eachRelationship<K extends keyof T & string>(\n    callback: (key: K, relationship: RelationshipSchema) => void,\n    binding?: T\n  ) {\n    const relationshipDefs = this.__store\n      .getSchemaDefinitionService()\n      .relationshipsDefinitionFor({ type: this.modelName });\n    Object.keys(relationshipDefs).forEach((key) => {\n      callback.call(binding, key as K, relationshipDefs[key]);\n    });\n  }\n\n  eachTransformedAttribute<K extends keyof T & string>(callback: (key: K, type: string | null) => void, binding?: T) {\n    const attrDefs = this.__store.getSchemaDefinitionService().attributesDefinitionFor({ type: this.modelName });\n    Object.keys(attrDefs).forEach((key) => {\n      if (attrDefs[key]!.type) {\n        callback.call(binding, key as K, attrDefs[key].type);\n      }\n    });\n  }\n}\n","export default function _classPrivateFieldBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}","var id = 0;\nexport default function _classPrivateFieldKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}","import type { Cache, ChangedAttributesHash, RelationshipDiff } from '@warp-drive/core-types/cache';\nimport type { Change } from '@warp-drive/core-types/cache/change';\nimport type { CollectionRelationship, ResourceRelationship } from '@warp-drive/core-types/cache/relationship';\nimport type { LocalRelationshipOperation } from '@warp-drive/core-types/graph';\nimport type { StableDocumentIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { Value } from '@warp-drive/core-types/json/raw';\nimport type { StructuredDataDocument, StructuredDocument } from '@warp-drive/core-types/request';\nimport type { ResourceDocument, SingleResourceDataDocument } from '@warp-drive/core-types/spec/document';\nimport type { ApiError } from '@warp-drive/core-types/spec/error';\n\nimport type { MergeOperation } from '../../-types/q/cache';\nimport type { JsonApiResource } from '../../-types/q/record-data-json-api';\nimport type { StoreRequestContext } from '../cache-handler';\n\n/**\n * The CacheManager wraps a Cache enforcing that only\n * the public API surface area is exposed.\n *\n * Hence, it is the value of `Store.cache`, wrapping\n * the cache instance returned by `Store.createCache`.\n *\n * It handles translating between cache versions when\n * necessary, for instance when a Store is configured\n * to use both a v1 and a v2 cache depending on some\n * heuristic.\n *\n * Starting with the v2 spec, the cache is designed such\n * that it must be implemented as a singleton.\n *\n * @class CacheManager\n * @public\n */\nexport class CacheManager implements Cache {\n  version = '2' as const;\n\n  #cache: Cache;\n\n  constructor(cache: Cache) {\n    this.#cache = cache;\n  }\n\n  // Cache Management\n  // ================\n\n  /**\n   * Cache the response to a request\n   *\n   * Unlike `store.push` which has UPSERT\n   * semantics, `put` has `replace` semantics similar to\n   * the `http` method `PUT`\n   *\n   * the individually cacheable\n   * e resource data it may contain\n   * should upsert, but the document data surrounding it should\n   * fully replace any existing information\n   *\n   * Note that in order to support inserting arbitrary data\n   * to the cache that did not originate from a request `put`\n   * should expect to sometimes encounter a document with only\n   * a `content` member and therefor must not assume the existence\n   * of `request` and `response` on the document.\n   *\n   * @method put\n   * @param {StructuredDocument} doc\n   * @return {ResourceDocument}\n   * @public\n   */\n  put<T>(doc: StructuredDocument<T> | { content: T }): ResourceDocument {\n    return this.#cache.put(doc);\n  }\n\n  /**\n   * Perform an operation on the cache to update the remote state.\n   *\n   * Note: currently the only valid operation is a MergeOperation\n   * which occurs when a collision of identifiers is detected.\n   *\n   * @method patch\n   * @public\n   * @param op the operation to perform\n   * @return {void}\n   */\n  patch(op: MergeOperation): void {\n    this.#cache.patch(op);\n  }\n\n  /**\n   * Update resource data with a local mutation. Currently supports operations\n   * on relationships only.\n   *\n   * @method mutate\n   * @public\n   * @param mutation\n   */\n  mutate(mutation: LocalRelationshipOperation): void {\n    this.#cache.mutate(mutation);\n  }\n\n  /**\n   * Peek resource data from the Cache.\n   *\n   * In development, if the return value\n   * is JSON the return value\n   * will be deep-cloned and deep-frozen\n   * to prevent mutation thereby enforcing cache\n   * Immutability.\n   *\n   * This form of peek is useful for implementations\n   * that want to feed raw-data from cache to the UI\n   * or which want to interact with a blob of data\n   * directly from the presentation cache.\n   *\n   * An implementation might want to do this because\n   * de-referencing records which read from their own\n   * blob is generally safer because the record does\n   * not require retaining connections to the Store\n   * and Cache to present data on a per-field basis.\n   *\n   * This generally takes the place of `getAttr` as\n   * an API and may even take the place of `getRelationship`\n   * depending on implementation specifics, though this\n   * latter usage is less recommended due to the advantages\n   * of the Graph handling necessary entanglements and\n   * notifications for relational data.\n   *\n   * @method peek\n   * @public\n   * @param {StableRecordIdentifier | StableDocumentIdentifier} identifier\n   * @return {ResourceDocument | ResourceBlob | null} the known resource data\n   */\n  peek(identifier: StableRecordIdentifier): unknown;\n  peek(identifier: StableDocumentIdentifier): ResourceDocument | null;\n  peek(identifier: StableRecordIdentifier | StableDocumentIdentifier): unknown {\n    return this.#cache.peek(identifier);\n  }\n\n  /**\n   * Peek the Cache for the existing request data associated with\n   * a cacheable request\n   *\n   * @method peekRequest\n   * @param {StableDocumentIdentifier}\n   * @return {StableDocumentIdentifier | null}\n   * @public\n   */\n  peekRequest(identifier: StableDocumentIdentifier): StructuredDocument<ResourceDocument> | null {\n    return this.#cache.peekRequest(identifier);\n  }\n\n  /**\n   * Push resource data from a remote source into the cache for this identifier\n   *\n   * @method upsert\n   * @public\n   * @param identifier\n   * @param data\n   * @param hasRecord\n   * @return {void | string[]} if `hasRecord` is true then calculated key changes should be returned\n   */\n  upsert(identifier: StableRecordIdentifier, data: JsonApiResource, hasRecord: boolean): void | string[] {\n    return this.#cache.upsert(identifier, data, hasRecord);\n  }\n\n  // Cache Forking Support\n  // =====================\n\n  /**\n   * Create a fork of the cache from the current state.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to fork at the Store level, which will\n   * utilize this method to fork the cache.\n   *\n   * @method fork\n   * @public\n   * @return Promise<Cache>\n   */\n  fork(): Promise<Cache> {\n    return this.#cache.fork();\n  }\n\n  /**\n   * Merge a fork back into a parent Cache.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to merge at the Store level, which will\n   * utilize this method to merge the caches.\n   *\n   * @method merge\n   * @param {Cache} cache\n   * @public\n   * @return Promise<void>\n   */\n  merge(cache: Cache): Promise<void> {\n    return this.#cache.merge(cache);\n  }\n\n  /**\n   * Generate the list of changes applied to all\n   * record in the store.\n   *\n   * Each individual resource or document that has\n   * been mutated should be described as an individual\n   * `Change` entry in the returned array.\n   *\n   * A `Change` is described by an object containing up to\n   * three properties: (1) the `identifier` of the entity that\n   * changed; (2) the `op` code of that change being one of\n   * `upsert` or `remove`, and if the op is `upsert` a `patch`\n   * containing the data to merge into the cache for the given\n   * entity.\n   *\n   * This `patch` is opaque to the Store but should be understood\n   * by the Cache and may expect to be utilized by an Adapter\n   * when generating data during a `save` operation.\n   *\n   * It is generally recommended that the `patch` contain only\n   * the updated state, ignoring fields that are unchanged\n   *\n   * ```ts\n   * interface Change {\n   *  identifier: StableRecordIdentifier | StableDocumentIdentifier;\n   *  op: 'upsert' | 'remove';\n   *  patch?: unknown;\n   * }\n   * ```\n   *\n   * @method diff\n   * @public\n   */\n  diff(): Promise<Change[]> {\n    return this.#cache.diff();\n  }\n\n  // SSR Support\n  // ===========\n\n  /**\n   * Serialize the entire contents of the Cache into a Stream\n   * which may be fed back into a new instance of the same Cache\n   * via `cache.hydrate`.\n   *\n   * @method dump\n   * @return {Promise<ReadableStream>}\n   * @public\n   */\n  dump(): Promise<ReadableStream<unknown>> {\n    return this.#cache.dump();\n  }\n\n  /**\n   * hydrate a Cache from a Stream with content previously serialized\n   * from another instance of the same Cache, resolving when hydration\n   * is complete.\n   *\n   * This method should expect to be called both in the context of restoring\n   * the Cache during application rehydration after SSR **AND** at unknown\n   * times during the lifetime of an already booted application when it is\n   * desired to bulk-load additional information into the cache. This latter\n   * behavior supports optimizing pre/fetching of data for route transitions\n   * via data-only SSR modes.\n   *\n   * @method hydrate\n   * @param {ReadableStream} stream\n   * @return {Promise<void>}\n   * @public\n   */\n  hydrate(stream: ReadableStream<unknown>): Promise<void> {\n    return this.#cache.hydrate(stream);\n  }\n\n  // Cache\n  // =====\n\n  // Resource Support\n  // ================\n\n  /**\n   * [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n   *\n   * It returns properties from options that should be set on the record during the create\n   * process. This return value behavior is deprecated.\n   *\n   * @method clientDidCreate\n   * @public\n   * @param identifier\n   * @param options\n   */\n  clientDidCreate(identifier: StableRecordIdentifier, options?: Record<string, unknown>): Record<string, unknown> {\n    return this.#cache.clientDidCreate(identifier, options);\n  }\n\n  /**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * will be part of a save transaction.\n   *\n   * @method willCommit\n   * @public\n   * @param identifier\n   */\n  willCommit(identifier: StableRecordIdentifier, context: StoreRequestContext): void {\n    this.#cache.willCommit(identifier, context);\n  }\n\n  /**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was successfully updated as part of a save transaction.\n   *\n   * @method didCommit\n   * @public\n   * @param identifier\n   * @param data\n   */\n  didCommit(identifier: StableRecordIdentifier, result: StructuredDataDocument<unknown>): SingleResourceDataDocument {\n    return this.#cache.didCommit(identifier, result);\n  }\n\n  /**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was update via a save transaction failed.\n   *\n   * @method commitWasRejected\n   * @public\n   * @param identifier\n   * @param errors\n   */\n  commitWasRejected(identifier: StableRecordIdentifier, errors?: ApiError[]): void {\n    this.#cache.commitWasRejected(identifier, errors);\n  }\n\n  /**\n   * [LIFECYCLE] Signals to the cache that all data for a resource\n   * should be cleared.\n   *\n   * @method unloadRecord\n   * @public\n   * @param identifier\n   */\n  unloadRecord(identifier: StableRecordIdentifier): void {\n    this.#cache.unloadRecord(identifier);\n  }\n\n  // Granular Resource Data APIs\n  // ===========================\n\n  /**\n   * Retrieve the data for an attribute from the cache\n   *\n   * @method getAttr\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return {unknown}\n   */\n  getAttr(identifier: StableRecordIdentifier, propertyName: string): Value | undefined {\n    return this.#cache.getAttr(identifier, propertyName);\n  }\n\n  /**\n   * Mutate the data for an attribute in the cache\n   *\n   * @method setAttr\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @param value\n   */\n  setAttr(identifier: StableRecordIdentifier, propertyName: string, value: Value): void {\n    this.#cache.setAttr(identifier, propertyName, value);\n  }\n\n  /**\n   * Query the cache for the changed attributes of a resource.\n   *\n   * @method changedAttrs\n   * @public\n   * @param identifier\n   * @return\n   */\n  changedAttrs(identifier: StableRecordIdentifier): ChangedAttributesHash {\n    return this.#cache.changedAttrs(identifier);\n  }\n\n  /**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @method hasChangedAttrs\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */\n  hasChangedAttrs(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.hasChangedAttrs(identifier);\n  }\n\n  /**\n   * Tell the cache to discard any uncommitted mutations to attributes\n   *\n   * @method rollbackAttrs\n   * @public\n   * @param identifier\n   * @return the names of attributes that were restored\n   */\n  rollbackAttrs(identifier: StableRecordIdentifier): string[] {\n    return this.#cache.rollbackAttrs(identifier);\n  }\n\n  // Relationships\n  // =============\n\n  /**\n   * Query the cache for the changes to relationships of a resource.\n   *\n   * Returns a map of relationship names to RelationshipDiff objects.\n   *\n   * ```ts\n   * type RelationshipDiff =\n  | {\n      kind: 'collection';\n      remoteState: StableRecordIdentifier[];\n      additions: Set<StableRecordIdentifier>;\n      removals: Set<StableRecordIdentifier>;\n      localState: StableRecordIdentifier[];\n      reordered: boolean;\n    }\n  | {\n      kind: 'resource';\n      remoteState: StableRecordIdentifier | null;\n      localState: StableRecordIdentifier | null;\n    };\n    ```\n   *\n   * @method changedRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {Map<string, RelationshipDiff>}\n   */\n  changedRelationships(identifier: StableRecordIdentifier): Map<string, RelationshipDiff> {\n    return this.#cache.changedRelationships(identifier);\n  }\n\n  /**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @method hasChangedRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {boolean}\n   */\n  hasChangedRelationships(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.hasChangedRelationships(identifier);\n  }\n\n  /**\n   * Tell the cache to discard any uncommitted mutations to relationships.\n   *\n   * This will also discard the change on any appropriate inverses.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method rollbackRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {string[]} the names of relationships that were restored\n   */\n  rollbackRelationships(identifier: StableRecordIdentifier): string[] {\n    return this.#cache.rollbackRelationships(identifier);\n  }\n\n  /**\n   * Query the cache for the current state of a relationship property\n   *\n   * @method getRelationship\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return resource relationship object\n   */\n  getRelationship(\n    identifier: StableRecordIdentifier,\n    propertyName: string\n  ): ResourceRelationship | CollectionRelationship {\n    return this.#cache.getRelationship(identifier, propertyName);\n  }\n\n  // Resource State\n  // ===============\n\n  /**\n   * Update the cache state for the given resource to be marked as locally deleted,\n   * or remove such a mark.\n   *\n   * @method setIsDeleted\n   * @public\n   * @param identifier\n   * @param isDeleted\n   */\n  setIsDeleted(identifier: StableRecordIdentifier, isDeleted: boolean): void {\n    this.#cache.setIsDeleted(identifier, isDeleted);\n  }\n\n  /**\n   * Query the cache for any validation errors applicable to the given resource.\n   *\n   * @method getErrors\n   * @public\n   * @param identifier\n   * @return\n   */\n  getErrors(identifier: StableRecordIdentifier): ApiError[] {\n    return this.#cache.getErrors(identifier);\n  }\n\n  /**\n   * Query the cache for whether a given resource has any available data\n   *\n   * @method isEmpty\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */\n  isEmpty(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.isEmpty(identifier);\n  }\n\n  /**\n   * Query the cache for whether a given resource was created locally and not\n   * yet persisted.\n   *\n   * @method isNew\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */\n  isNew(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.isNew(identifier);\n  }\n\n  /**\n   * Query the cache for whether a given resource is marked as deleted (but not\n   * necessarily persisted yet).\n   *\n   * @method isDeleted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */\n  isDeleted(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.isDeleted(identifier);\n  }\n\n  /**\n   * Query the cache for whether a given resource has been deleted and that deletion\n   * has also been persisted.\n   *\n   * @method isDeletionCommitted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */\n  isDeletionCommitted(identifier: StableRecordIdentifier): boolean {\n    return this.#cache.isDeletionCommitted(identifier);\n  }\n}\n","/**\n * @module @ember-data/store\n */\nimport { assert } from '@ember/debug';\n// eslint-disable-next-line no-restricted-imports\nimport { _backburner } from '@ember/runloop';\n\nimport { LOG_NOTIFICATIONS } from '@ember-data/debugging';\nimport { DEBUG } from '@ember-data/env';\nimport type { StableDocumentIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\n\nimport { isDocumentIdentifier, isStableIdentifier } from '../caches/identifier-cache';\nimport type Store from '../store-service';\n\nexport type UnsubscribeToken = object;\nlet tokenId = 0;\n\nconst CacheOperations = new Set(['added', 'removed', 'state', 'updated']);\nexport type CacheOperation = 'added' | 'removed' | 'updated' | 'state';\n\nfunction isCacheOperationValue(value: NotificationType | CacheOperation): value is CacheOperation {\n  return CacheOperations.has(value);\n}\n\nfunction runLoopIsFlushing(): boolean {\n  //@ts-expect-error\n  return !!_backburner.currentInstance && _backburner._autorun !== true;\n}\n\nexport type NotificationType = 'attributes' | 'relationships' | 'identity' | 'errors' | 'meta' | 'state';\n\nexport interface NotificationCallback {\n  (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;\n  (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;\n  (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;\n}\n\nexport interface ResourceOperationCallback {\n  // resource updates\n  (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;\n}\n\nexport interface DocumentOperationCallback {\n  // document updates\n  (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;\n}\n\nfunction _unsubscribe(\n  tokens: Map<UnsubscribeToken, StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'>,\n  token: UnsubscribeToken,\n  cache: Map<\n    'resource' | 'document' | StableDocumentIdentifier | StableRecordIdentifier,\n    Map<UnsubscribeToken, NotificationCallback | ResourceOperationCallback | DocumentOperationCallback>\n  >\n) {\n  const identifier = tokens.get(token);\n  if (LOG_NOTIFICATIONS) {\n    if (!identifier) {\n      // eslint-disable-next-line no-console\n      console.log('Passed unknown unsubscribe token to unsubscribe', identifier);\n    }\n  }\n  if (identifier) {\n    tokens.delete(token);\n    const map = cache.get(identifier);\n    map?.delete(token);\n  }\n}\n\n/**\n * The NotificationManager provides the ability to subscribe to\n * changes to Cache state.\n *\n * This Feature is what allows EmberData to create subscriptions that\n * work with any framework or change-notification system.\n *\n * @class NotificationManager\n * @public\n */\nexport default class NotificationManager {\n  declare store: Store;\n  declare isDestroyed: boolean;\n  declare _buffered: Map<StableDocumentIdentifier | StableRecordIdentifier, [string, string | undefined][]>;\n  declare _cache: Map<\n    StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document',\n    Map<UnsubscribeToken, NotificationCallback | ResourceOperationCallback | DocumentOperationCallback>\n  >;\n  declare _tokens: Map<UnsubscribeToken, StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'>;\n  declare _hasFlush: boolean;\n  declare _onFlushCB?: () => void;\n\n  constructor(store: Store) {\n    this.store = store;\n    this.isDestroyed = false;\n    this._buffered = new Map();\n    this._hasFlush = false;\n    this._cache = new Map();\n    this._tokens = new Map();\n  }\n\n  /**\n   * Subscribe to changes for a given resource identifier, resource addition/removal, or document addition/removal.\n   *\n   * ```ts\n   * export type CacheOperation = 'added' | 'removed' | 'updated' | 'state';\n   *\n   * export interface NotificationCallback {\n   *   (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;\n   *   (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;\n   *   (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;\n   * }\n   * export interface ResourceOperationCallback {\n   *   // resource updates\n   *   (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;\n   * }\n   * export interface DocumentOperationCallback {\n   *   // document updates\n   *   (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;\n   * }\n   * ```\n   *\n   * @method subscribe\n   * @public\n   * @param {StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'} identifier\n   * @param {NotificationCallback | ResourceOperationCallback | DocumentOperationCallback} callback\n   * @return {UnsubscribeToken} an opaque token to be used with unsubscribe\n   */\n  subscribe(identifier: StableRecordIdentifier, callback: NotificationCallback): UnsubscribeToken;\n  subscribe(identifier: 'resource', callback: ResourceOperationCallback): UnsubscribeToken;\n  subscribe(identifier: StableDocumentIdentifier, callback: DocumentOperationCallback): UnsubscribeToken;\n  subscribe(identifier: 'document', callback: DocumentOperationCallback): UnsubscribeToken;\n  subscribe(\n    identifier: StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document',\n    callback: NotificationCallback | ResourceOperationCallback | DocumentOperationCallback\n  ): UnsubscribeToken {\n    assert(\n      `Expected to receive a stable Identifier to subscribe to`,\n      identifier === 'resource' ||\n        identifier === 'document' ||\n        isStableIdentifier(identifier) ||\n        isDocumentIdentifier(identifier)\n    );\n    let map = this._cache.get(identifier);\n\n    if (!map) {\n      map = new Map();\n      this._cache.set(identifier, map);\n    }\n\n    const unsubToken = DEBUG ? { _tokenRef: tokenId++ } : {};\n    map.set(unsubToken, callback);\n    this._tokens.set(unsubToken, identifier);\n    return unsubToken;\n  }\n\n  /**\n   * remove a previous subscription\n   *\n   * @method unsubscribe\n   * @public\n   * @param {UnsubscribeToken} token\n   */\n  unsubscribe(token: UnsubscribeToken) {\n    if (!this.isDestroyed) {\n      _unsubscribe(this._tokens, token, this._cache);\n    }\n  }\n\n  /**\n   * Custom Caches and Application Code should not call this method directly.\n   *\n   * @method notify\n   * @param identifier\n   * @param value\n   * @param key\n   * @return {Boolean} whether a notification was delivered to any subscribers\n   * @private\n   */\n  notify(identifier: StableRecordIdentifier, value: 'attributes' | 'relationships', key?: string): boolean;\n  notify(identifier: StableRecordIdentifier, value: 'errors' | 'meta' | 'identity' | 'state'): boolean;\n  notify(identifier: StableRecordIdentifier | StableDocumentIdentifier, value: CacheOperation): boolean;\n  notify(\n    identifier: StableRecordIdentifier | StableDocumentIdentifier,\n    value: NotificationType | CacheOperation,\n    key?: string\n  ): boolean {\n    assert(\n      `Notify does not accept a key argument for the namespace '${value}'. Received key '${key || ''}'.`,\n      !key || value === 'attributes' || value === 'relationships'\n    );\n    if (!isStableIdentifier(identifier) && !isDocumentIdentifier(identifier)) {\n      if (LOG_NOTIFICATIONS) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Notifying: Expected to receive a stable Identifier to notify '${value}' '${key || ''}' with, but ${String(\n            identifier\n          )} is not in the cache`,\n          identifier\n        );\n      }\n      return false;\n    }\n\n    if (LOG_NOTIFICATIONS) {\n      // eslint-disable-next-line no-console\n      console.log(`Buffering Notify: ${String(identifier.lid)}\\t${value}\\t${key || ''}`);\n    }\n\n    const hasSubscribers = Boolean(this._cache.get(identifier)?.size);\n\n    if (isCacheOperationValue(value) || hasSubscribers) {\n      let buffer = this._buffered.get(identifier);\n      if (!buffer) {\n        buffer = [];\n        this._buffered.set(identifier, buffer);\n      }\n      buffer.push([value, key]);\n\n      this._scheduleNotify();\n    }\n\n    return hasSubscribers;\n  }\n\n  _onNextFlush(cb: () => void) {\n    this._onFlushCB = cb;\n  }\n\n  _scheduleNotify() {\n    const asyncFlush = this.store._enableAsyncFlush;\n\n    if (this._hasFlush) {\n      if (asyncFlush !== false && !runLoopIsFlushing()) {\n        return;\n      }\n    }\n\n    if (asyncFlush && !runLoopIsFlushing()) {\n      this._hasFlush = true;\n      return;\n    }\n\n    this._flush();\n  }\n\n  _flush() {\n    if (this._buffered.size) {\n      this._buffered.forEach((states, identifier) => {\n        states.forEach((args) => {\n          // @ts-expect-error\n          this._flushNotification(identifier, args[0], args[1]);\n        });\n      });\n      this._buffered = new Map();\n    }\n\n    this._hasFlush = false;\n    this._onFlushCB?.();\n    this._onFlushCB = undefined;\n  }\n\n  _flushNotification(identifier: StableRecordIdentifier, value: 'attributes' | 'relationships', key?: string): boolean;\n  _flushNotification(identifier: StableRecordIdentifier, value: 'errors' | 'meta' | 'identity' | 'state'): boolean;\n  _flushNotification(identifier: StableRecordIdentifier | StableDocumentIdentifier, value: CacheOperation): boolean;\n  _flushNotification(\n    identifier: StableRecordIdentifier | StableDocumentIdentifier,\n    value: NotificationType | CacheOperation,\n    key?: string\n  ): boolean {\n    if (LOG_NOTIFICATIONS) {\n      // eslint-disable-next-line no-console\n      console.log(`Notifying: ${String(identifier)}\\t${value}\\t${key || ''}`);\n    }\n\n    // TODO for documents this will need to switch based on Identifier kind\n    if (isCacheOperationValue(value)) {\n      const callbackMap = this._cache.get(isDocumentIdentifier(identifier) ? 'document' : 'resource') as Map<\n        UnsubscribeToken,\n        ResourceOperationCallback | DocumentOperationCallback\n      >;\n\n      if (callbackMap) {\n        callbackMap.forEach((cb: ResourceOperationCallback | DocumentOperationCallback) => {\n          cb(identifier as StableRecordIdentifier, value);\n        });\n      }\n    }\n\n    const callbackMap = this._cache.get(identifier);\n    if (!callbackMap || !callbackMap.size) {\n      return false;\n    }\n    callbackMap.forEach((cb) => {\n      // @ts-expect-error overload doesn't narrow within body\n      cb(identifier, value, key);\n    });\n    return true;\n  }\n\n  destroy() {\n    this.isDestroyed = true;\n    this._tokens.clear();\n    this._cache.clear();\n  }\n}\n","export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n  return desc;\n}","/**\n  @module @ember-data/store\n*/\nimport { assert } from '@ember/debug';\n\nimport { compat } from '@ember-data/tracking';\nimport type { Signal } from '@ember-data/tracking/-private';\nimport {\n  addToTransaction,\n  createArrayTags,\n  createSignal,\n  defineSignal,\n  subscribe,\n} from '@ember-data/tracking/-private';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { ImmutableRequestInfo } from '@warp-drive/core-types/request';\nimport type { Links, PaginationLinks } from '@warp-drive/core-types/spec/raw';\n\nimport type { RecordInstance } from '../../-types/q/record-instance';\nimport { isStableIdentifier } from '../caches/identifier-cache';\nimport { recordIdentifierFor } from '../caches/instance-cache';\nimport type RecordArrayManager from '../managers/record-array-manager';\nimport type Store from '../store-service';\n\ntype KeyType = string | symbol | number;\nconst ARRAY_GETTER_METHODS = new Set<KeyType>([\n  Symbol.iterator,\n  'concat',\n  'entries',\n  'every',\n  'fill',\n  'filter',\n  'find',\n  'findIndex',\n  'flat',\n  'flatMap',\n  'forEach',\n  'includes',\n  'indexOf',\n  'join',\n  'keys',\n  'lastIndexOf',\n  'map',\n  'reduce',\n  'reduceRight',\n  'slice',\n  'some',\n  'values',\n]);\nconst ARRAY_SETTER_METHODS = new Set<KeyType>(['push', 'pop', 'unshift', 'shift', 'splice', 'sort']);\nconst SYNC_PROPS = new Set<KeyType>(['[]', 'length', 'links', 'meta']);\nfunction isArrayGetter<T>(prop: KeyType): prop is keyof Array<T> {\n  return ARRAY_GETTER_METHODS.has(prop);\n}\nfunction isArraySetter<T>(prop: KeyType): prop is keyof Array<T> {\n  return ARRAY_SETTER_METHODS.has(prop);\n}\nfunction isSelfProp<T extends object>(self: T, prop: KeyType): prop is keyof T {\n  return prop in self;\n}\n\nexport const ARRAY_SIGNAL = Symbol('#signal');\nexport const SOURCE = Symbol('#source');\nexport const MUTATE = Symbol('#update');\nexport const NOTIFY = Symbol('#notify');\nconst IS_COLLECTION = Symbol.for('Collection');\n\nexport function notifyArray(arr: IdentifierArray) {\n  addToTransaction(arr[ARRAY_SIGNAL]);\n}\n\nfunction convertToInt(prop: KeyType): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\ntype ProxiedMethod = (...args: unknown[]) => unknown;\ndeclare global {\n  interface ProxyConstructor {\n    new <TSource extends object, TTarget extends object>(target: TSource, handler: ProxyHandler<TSource>): TTarget;\n  }\n}\n\nexport type IdentifierArrayCreateOptions = {\n  identifiers: StableRecordIdentifier[];\n  type?: string;\n  store: Store;\n  allowMutation: boolean;\n  manager: RecordArrayManager;\n  links?: Links | PaginationLinks | null;\n  meta?: Record<string, unknown> | null;\n};\n\ninterface PrivateState {\n  links: Links | PaginationLinks | null;\n  meta: Record<string, unknown> | null;\n}\ntype ForEachCB = (record: RecordInstance, index: number, context: typeof Proxy<StableRecordIdentifier[]>) => void;\nfunction safeForEach(\n  instance: typeof Proxy<StableRecordIdentifier[]>,\n  arr: StableRecordIdentifier[],\n  store: Store,\n  callback: ForEachCB,\n  target: unknown\n) {\n  if (target === undefined) {\n    target = null;\n  }\n  // clone to prevent mutation\n  arr = arr.slice();\n  assert('`forEach` expects a function as first argument.', typeof callback === 'function');\n\n  // because we retrieveLatest above we need not worry if array is mutated during iteration\n  // by unloadRecord/rollbackAttributes\n  // push/add/removeObject may still be problematic\n  // but this is a more traditionally expected forEach bug.\n  const length = arr.length; // we need to access length to ensure we are consumed\n\n  for (let index = 0; index < length; index++) {\n    callback.call(target, store._instanceCache.getRecord(arr[index]), index, instance);\n  }\n\n  return instance;\n}\n\n/**\n  A record array is an array that contains records of a certain type (or modelName).\n  The record array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  `RecordArray` or its subclasses will be returned by your application's store\n  in response to queries.\n\n  This class should not be imported and instantiated by consuming applications.\n\n  @class RecordArray\n  @public\n*/\ninterface IdentifierArray extends Omit<Array<RecordInstance>, '[]'> {\n  [MUTATE]?(\n    target: StableRecordIdentifier[],\n    receiver: typeof Proxy<StableRecordIdentifier[]>,\n    prop: string,\n    args: unknown[],\n    _SIGNAL: Signal\n  ): unknown;\n}\nclass IdentifierArray {\n  declare DEPRECATED_CLASS_NAME: string;\n  /**\n    The flag to signal a `RecordArray` is currently loading data.\n    Example\n    ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n    people.update();\n    people.isUpdating; // true\n    ```\n    @property isUpdating\n    @public\n    @type Boolean\n  */\n  declare isUpdating: boolean;\n  isLoaded = true;\n  isDestroying = false;\n  isDestroyed = false;\n  _updatingPromise: Promise<IdentifierArray> | null = null;\n\n  [IS_COLLECTION] = true;\n  declare [ARRAY_SIGNAL]: Signal;\n  [SOURCE]: StableRecordIdentifier[];\n  [NOTIFY]() {\n    notifyArray(this);\n  }\n\n  declare links: Links | PaginationLinks | null;\n  declare meta: Record<string, unknown> | null;\n  declare modelName?: string;\n  /**\n    The store that created this record array.\n\n    @property store\n    @private\n    @type Store\n    */\n  declare store: Store;\n  declare _manager: RecordArrayManager;\n\n  destroy(clear: boolean) {\n    this.isDestroying = !clear;\n    // changing the reference breaks the Proxy\n    // this[SOURCE] = [];\n    this[SOURCE].length = 0;\n    this[NOTIFY]();\n    this.isDestroyed = !clear;\n  }\n\n  // length must be on self for proxied methods to work properly\n  @compat\n  get length() {\n    return this[SOURCE].length;\n  }\n  set length(value) {\n    this[SOURCE].length = value;\n  }\n\n  constructor(options: IdentifierArrayCreateOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.modelName = options.type;\n    this.store = options.store;\n    this._manager = options.manager;\n    this[SOURCE] = options.identifiers;\n    this[ARRAY_SIGNAL] = createSignal(this, 'length');\n    const store = options.store;\n    const boundFns = new Map<KeyType, ProxiedMethod>();\n    const _SIGNAL = this[ARRAY_SIGNAL];\n    const PrivateState: PrivateState = {\n      links: options.links || null,\n      meta: options.meta || null,\n    };\n    let transaction = false;\n\n    // when a mutation occurs\n    // we track all mutations within the call\n    // and forward them as one\n\n    const proxy = new Proxy<StableRecordIdentifier[], RecordInstance[]>(this[SOURCE], {\n      get<R extends typeof Proxy<StableRecordIdentifier[]>>(\n        target: StableRecordIdentifier[],\n        prop: keyof R,\n        receiver: R\n      ): unknown {\n        const index = convertToInt(prop);\n        if (_SIGNAL.shouldReset && (index !== null || SYNC_PROPS.has(prop) || isArrayGetter(prop))) {\n          options.manager._syncArray(receiver as unknown as IdentifierArray);\n          _SIGNAL.t = false;\n          _SIGNAL.shouldReset = false;\n        }\n\n        if (index !== null) {\n          const identifier = target[index];\n          if (!transaction) {\n            subscribe(_SIGNAL);\n          }\n          return identifier && store._instanceCache.getRecord(identifier);\n        }\n\n        if (prop === 'meta') return subscribe(_SIGNAL), PrivateState.meta;\n        if (prop === 'links') return subscribe(_SIGNAL), PrivateState.links;\n        if (prop === '[]') return subscribe(_SIGNAL), receiver;\n\n        if (isArrayGetter(prop)) {\n          let fn = boundFns.get(prop);\n\n          if (fn === undefined) {\n            if (prop === 'forEach') {\n              fn = function () {\n                subscribe(_SIGNAL);\n                transaction = true;\n                const result = safeForEach(receiver, target, store, arguments[0] as ForEachCB, arguments[1]);\n                transaction = false;\n                return result;\n              };\n            } else {\n              fn = function () {\n                subscribe(_SIGNAL);\n                // array functions must run through Reflect to work properly\n                // binding via other means will not work.\n                transaction = true;\n                const result = Reflect.apply(target[prop] as ProxiedMethod, receiver, arguments) as unknown;\n                transaction = false;\n                return result;\n              };\n            }\n\n            boundFns.set(prop, fn);\n          }\n\n          return fn;\n        }\n\n        if (isArraySetter(prop)) {\n          let fn = boundFns.get(prop);\n\n          if (fn === undefined) {\n            fn = function () {\n              // array functions must run through Reflect to work properly\n              // binding via other means will not work.\n              if (!options.allowMutation) {\n                assert(`Mutating this array of records via ${String(prop)} is not allowed.`, options.allowMutation);\n                return;\n              }\n              const args: unknown[] = Array.prototype.slice.call(arguments);\n              assert(`Cannot start a new array transaction while a previous transaction is underway`, !transaction);\n              transaction = true;\n              const result = self[MUTATE]!(target, receiver, prop as string, args, _SIGNAL);\n              transaction = false;\n              return result;\n            };\n\n            boundFns.set(prop, fn);\n          }\n\n          return fn;\n        }\n\n        if (isSelfProp(self, prop)) {\n          if (prop === NOTIFY || prop === ARRAY_SIGNAL || prop === SOURCE) {\n            return self[prop];\n          }\n\n          let fn = boundFns.get(prop);\n          if (fn) return fn;\n\n          const outcome: unknown = self[prop];\n\n          if (typeof outcome === 'function') {\n            fn = function () {\n              subscribe(_SIGNAL);\n              // array functions must run through Reflect to work properly\n              // binding via other means will not work.\n              return Reflect.apply(outcome as ProxiedMethod, receiver, arguments) as unknown;\n            };\n\n            boundFns.set(prop, fn);\n            return fn;\n          }\n\n          return subscribe(_SIGNAL), outcome;\n        }\n\n        return target[prop as keyof StableRecordIdentifier[]];\n      },\n\n      // FIXME: Should this get a generic like get above?\n      set(\n        target: StableRecordIdentifier[],\n        prop: KeyType,\n        value: unknown,\n        receiver: typeof Proxy<StableRecordIdentifier[]>\n      ): boolean {\n        if (prop === 'length') {\n          if (!transaction && value === 0) {\n            transaction = true;\n            self[MUTATE]!(target, receiver, 'length 0', [], _SIGNAL);\n            transaction = false;\n            return true;\n          } else if (transaction) {\n            return Reflect.set(target, prop, value);\n          } else {\n            assert(`unexpected length set`);\n          }\n        }\n        if (prop === 'links') {\n          PrivateState.links = (value || null) as PaginationLinks | Links | null;\n          return true;\n        }\n        if (prop === 'meta') {\n          PrivateState.meta = (value || null) as Record<string, unknown> | null;\n          return true;\n        }\n        const index = convertToInt(prop);\n\n        // we do not allow \"holey\" arrays and so if the index is\n        // greater than length then we will disallow setting it.\n        // however, there is a special case for \"unshift\" with more than\n        // one item being inserted since current items will be moved to the\n        // new indices first.\n        // we \"loosely\" detect this by just checking whether we are in\n        // a transaction.\n        if (index === null || index > target.length) {\n          if (index !== null && transaction) {\n            const identifier = recordIdentifierFor(value);\n            assert(`Cannot set index ${index} past the end of the array.`, isStableIdentifier(identifier));\n            target[index] = identifier;\n            return true;\n          } else if (isSelfProp(self, prop)) {\n            self[prop] = value;\n            return true;\n          }\n          return false;\n        }\n\n        if (!options.allowMutation) {\n          assert(`Mutating ${String(prop)} on this RecordArray is not allowed.`, options.allowMutation);\n          return false;\n        }\n\n        const original: StableRecordIdentifier | undefined = target[index];\n        const newIdentifier = extractIdentifierFromRecord(value);\n        (target as unknown as Record<KeyType, unknown>)[index] = newIdentifier;\n        assert(`Expected a record`, isStableIdentifier(newIdentifier));\n        // We generate \"transactions\" whenever a setter method on the array\n        // is called and might bulk update multiple array cells. Fundamentally,\n        // all array operations decompose into individual cell replacements.\n        // e.g. a push is really a \"replace cell at next index with new value\"\n        // or a splice is \"shift all values left/right by X and set out of new\n        // bounds cells to undefined\"\n        //\n        // so, if we are in a transaction, then this is not a user generated change\n        // but one generated by a setter method. In this case we want to only apply\n        // the change to the target array and not call the MUTATE method.\n        // If there is no transaction though, then this means the user themselves has\n        // directly changed the value of a specific index and we need to thus generate\n        // a mutation for that change.\n        // e.g. \"arr.push(newVal)\" is handled by a \"addToRelatedRecords\" mutation within\n        // a transaction.\n        // while \"arr[arr.length] = newVal;\" is handled by this replace cell code path.\n        if (!transaction) {\n          self[MUTATE]!(target, receiver, 'replace cell', [index, original, newIdentifier], _SIGNAL);\n        } else {\n          target[index] = newIdentifier;\n        }\n\n        return true;\n      },\n\n      deleteProperty(target: StableRecordIdentifier[], prop: string | symbol): boolean {\n        assert(`Deleting keys on managed arrays is disallowed`, transaction);\n        if (!transaction) {\n          return false;\n        }\n        return Reflect.deleteProperty(target, prop);\n      },\n\n      getPrototypeOf() {\n        return IdentifierArray.prototype;\n      },\n    }) as IdentifierArray;\n\n    createArrayTags(proxy, _SIGNAL);\n\n    this[NOTIFY] = this[NOTIFY].bind(proxy);\n\n    return proxy;\n  }\n\n  /**\n    Used to get the latest version of all of the records in this array\n    from the adapter.\n\n    Example\n\n    ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n\n    people.update().then(function() {\n      people.isUpdating; // false\n    });\n\n    people.isUpdating; // true\n    ```\n\n    @method update\n    @public\n  */\n  update(): Promise<IdentifierArray> {\n    if (this.isUpdating) {\n      return this._updatingPromise!;\n    }\n\n    this.isUpdating = true;\n\n    const updatingPromise = this._update();\n    void updatingPromise.finally(() => {\n      this._updatingPromise = null;\n      if (this.isDestroying || this.isDestroyed) {\n        return;\n      }\n      this.isUpdating = false;\n    });\n\n    this._updatingPromise = updatingPromise;\n\n    return updatingPromise;\n  }\n\n  /*\n    Update this RecordArray and return a promise which resolves once the update\n    is finished.\n   */\n  _update(): Promise<IdentifierArray> {\n    assert(`_update cannot be used with this array`, this.modelName);\n    return this.store.findAll(this.modelName, { reload: true });\n  }\n\n  // TODO deprecate\n  /**\n    Saves all of the records in the `RecordArray`.\n\n    Example\n\n    ```javascript\n    let messages = store.peekAll('message');\n    messages.forEach(function(message) {\n      message.hasBeenSeen = true;\n    });\n    messages.save();\n    ```\n\n    @method save\n    @public\n    @return {Promise<IdentifierArray>} promise\n  */\n  save(): Promise<IdentifierArray> {\n    const promise = Promise.all(this.map((record) => this.store.saveRecord(record))).then(() => this);\n\n    return promise;\n  }\n}\n\n// this will error if someone tries to call\n// A(identifierArray) since it is not configurable\n// which is preferable to the `meta` override we used\n// before which required importing all of Ember\nconst desc = {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return this;\n  },\n};\ncompat(desc);\nObject.defineProperty(IdentifierArray.prototype, '[]', desc);\n\ndefineSignal(IdentifierArray.prototype, 'isUpdating', false);\n\nexport default IdentifierArray;\n\nexport type CollectionCreateOptions = IdentifierArrayCreateOptions & {\n  query: ImmutableRequestInfo | Record<string, unknown> | null;\n  isLoaded: boolean;\n};\n\nexport class Collection extends IdentifierArray {\n  query: ImmutableRequestInfo | Record<string, unknown> | null = null;\n\n  constructor(options: CollectionCreateOptions) {\n    super(options as IdentifierArrayCreateOptions);\n    this.query = options.query || null;\n    this.isLoaded = options.isLoaded || false;\n  }\n\n  _update(): Promise<Collection> {\n    const { store, query } = this;\n\n    // TODO save options from initial request?\n    assert(`update cannot be used with this array`, this.modelName);\n    assert(`update cannot be used with no query`, query);\n    const promise = store.query(this.modelName, query as Record<string, unknown>, { _recordArray: this });\n\n    return promise;\n  }\n\n  destroy(clear: boolean) {\n    super.destroy(clear);\n    this._manager._managed.delete(this);\n    this._manager._pending.delete(this);\n  }\n}\n// trick the proxy \"in\" check\nCollection.prototype.query = null;\n\n// Ensure instanceof works correctly\n// Object.setPrototypeOf(IdentifierArray.prototype, Array.prototype);\n\ntype PromiseProxyRecord = { then(): void; content: RecordInstance | null | undefined };\n\nfunction assertRecordPassedToHasMany(record: RecordInstance | PromiseProxyRecord) {\n  assert(\n    `All elements of a hasMany relationship must be instances of Model, you passed $${typeof record}`,\n    (function () {\n      try {\n        recordIdentifierFor(record);\n        return true;\n      } catch {\n        return false;\n      }\n    })()\n  );\n}\n\nfunction extractIdentifierFromRecord(record: PromiseProxyRecord | RecordInstance | null) {\n  if (!record) {\n    return null;\n  }\n\n  assertRecordPassedToHasMany(record);\n  return recordIdentifierFor(record);\n}\n","/**\n  @module @ember-data/store\n*/\nimport { addTransactionCB } from '@ember-data/tracking/-private';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { ImmutableRequestInfo } from '@warp-drive/core-types/request';\nimport type { CollectionResourceDocument } from '@warp-drive/core-types/spec/raw';\n\nimport type { CollectionCreateOptions } from '../record-arrays/identifier-array';\nimport IdentifierArray, {\n  ARRAY_SIGNAL,\n  Collection,\n  NOTIFY,\n  notifyArray,\n  SOURCE,\n} from '../record-arrays/identifier-array';\nimport type Store from '../store-service';\nimport type { CacheOperation, UnsubscribeToken } from './notification-manager';\n\nconst FAKE_ARR = {};\nconst SLICE_BATCH_SIZE = 1200;\n/**\n * This is a clever optimization.\n *\n * clever optimizations rarely stand the test of time, so if you're\n * ever curious or think something better is possible please benchmark\n * and discuss. The benchmark for this at the time of writing is in\n * `scripts/benchmark-push.js`\n *\n * This approach turns out to be 150x faster in Chrome and node than\n * simply using push or concat. It's highly susceptible to the specifics\n * of the batch size, and may require tuning.\n *\n * Clever optimizations should always come with a `why`. This optimization\n * exists for two reasons.\n *\n * 1) array.push(...objects) and Array.prototype.push.apply(arr, objects)\n *   are susceptible to stack overflows. The size of objects at which this\n *   occurs varies by environment, browser, and current stack depth and memory\n *   pressure; however, it occurs in all browsers in fairly pristine conditions\n *   somewhere around 125k to 200k elements. Since EmberData regularly encounters\n *   arrays larger than this in size, we cannot use push.\n *\n * 2) `array.concat` or simply setting the array to a new reference is often an\n *   easier approach; however, native Proxy to an array cannot swap it's target array\n *   and attempts at juggling multiple array sources have proven to be victim to a number\n *   of browser implementation bugs. Should these bugs be addressed then we could\n *   simplify to using `concat`, however, do note this is currently 150x faster\n *   than concat, and due to the overloaded signature of concat will likely always\n *   be faster.\n *\n * Sincerely,\n *   - runspired (Chris Thoburn) 08/21/2022\n *\n * @function fastPush\n * @internal\n * @param target the array to push into\n * @param source the items to push into target\n */\nexport function fastPush<T>(target: T[], source: T[]) {\n  let startLength = 0;\n  const newLength = source.length;\n  while (newLength - startLength > SLICE_BATCH_SIZE) {\n    // eslint-disable-next-line prefer-spread\n    target.push.apply(target, source.slice(startLength, startLength + SLICE_BATCH_SIZE));\n    startLength += SLICE_BATCH_SIZE;\n  }\n  // eslint-disable-next-line prefer-spread\n  target.push.apply(target, source.slice(startLength));\n}\n\ntype ChangeSet = Map<StableRecordIdentifier, 'add' | 'del'>;\n\n/**\n  @class RecordArrayManager\n  @internal\n*/\nclass RecordArrayManager {\n  declare store: Store;\n  declare isDestroying: boolean;\n  declare isDestroyed: boolean;\n  declare _set: Map<IdentifierArray, Set<StableRecordIdentifier>>;\n  declare _live: Map<string, IdentifierArray>;\n  declare _managed: Set<IdentifierArray>;\n  declare _pending: Map<IdentifierArray, ChangeSet>;\n  declare _identifiers: Map<StableRecordIdentifier, Set<Collection>>;\n  declare _staged: Map<string, ChangeSet>;\n  declare _subscription: UnsubscribeToken;\n  declare _keyedArrays: Map<string, Collection>;\n  declare _visibilitySet: Map<StableRecordIdentifier, boolean>;\n\n  constructor(options: { store: Store }) {\n    this.store = options.store;\n    this.isDestroying = false;\n    this.isDestroyed = false;\n    this._live = new Map();\n    this._managed = new Set();\n    this._pending = new Map();\n    this._staged = new Map();\n    this._keyedArrays = new Map();\n    this._identifiers = new Map();\n    this._set = new Map();\n    this._visibilitySet = new Map();\n\n    this._subscription = this.store.notifications.subscribe(\n      'resource',\n      (identifier: StableRecordIdentifier, type: CacheOperation) => {\n        if (type === 'added') {\n          this._visibilitySet.set(identifier, true);\n          this.identifierAdded(identifier);\n        } else if (type === 'removed') {\n          this._visibilitySet.set(identifier, false);\n          this.identifierRemoved(identifier);\n        } else if (type === 'state') {\n          this.identifierChanged(identifier);\n        }\n      }\n    );\n  }\n\n  _syncArray(array: IdentifierArray) {\n    const pending = this._pending.get(array);\n\n    if (!pending || this.isDestroying || this.isDestroyed) {\n      return;\n    }\n\n    sync(array, pending, this._set.get(array)!);\n    this._pending.delete(array);\n  }\n\n  /**\n    Get the `RecordArray` for a modelName, which contains all loaded records of\n    given modelName.\n\n    @method liveArrayFor\n    @internal\n    @param {String} modelName\n    @return {RecordArray}\n  */\n  liveArrayFor(type: string): IdentifierArray {\n    let array = this._live.get(type);\n    const identifiers: StableRecordIdentifier[] = [];\n    const staged = this._staged.get(type);\n    if (staged) {\n      staged.forEach((value, key) => {\n        if (value === 'add') {\n          identifiers.push(key);\n        }\n      });\n      this._staged.delete(type);\n    }\n\n    if (!array) {\n      array = new IdentifierArray({\n        type,\n        identifiers,\n        store: this.store,\n        allowMutation: false,\n        manager: this,\n      });\n      this._live.set(type, array);\n      this._set.set(array, new Set(identifiers));\n    }\n\n    return array;\n  }\n\n  createArray(config: {\n    type?: string;\n    query?: ImmutableRequestInfo | Record<string, unknown>;\n    identifiers?: StableRecordIdentifier[];\n    doc?: CollectionResourceDocument;\n  }): Collection {\n    const options: CollectionCreateOptions = {\n      type: config.type,\n      links: config.doc?.links || null,\n      meta: config.doc?.meta || null,\n      query: config.query || null,\n      identifiers: config.identifiers || [],\n      isLoaded: !!config.identifiers?.length,\n      allowMutation: false,\n      store: this.store,\n      manager: this,\n    };\n    const array = new Collection(options);\n    this._managed.add(array);\n    this._set.set(array, new Set(options.identifiers || []));\n    if (config.identifiers) {\n      associate(this._identifiers, array, config.identifiers);\n    }\n\n    return array;\n  }\n\n  dirtyArray(array: IdentifierArray, delta: number): void {\n    if (array === FAKE_ARR) {\n      return;\n    }\n    const tag = array[ARRAY_SIGNAL];\n    if (!tag.shouldReset) {\n      tag.shouldReset = true;\n      addTransactionCB(array[NOTIFY]);\n    } else if (delta > 0 && !tag.t) {\n      addTransactionCB(array[NOTIFY]);\n    }\n  }\n\n  _getPendingFor(\n    identifier: StableRecordIdentifier,\n    includeManaged: boolean,\n    isRemove?: boolean\n  ): Map<IdentifierArray, ChangeSet> | void {\n    if (this.isDestroying || this.isDestroyed) {\n      return;\n    }\n\n    const liveArray = this._live.get(identifier.type);\n    const allPending = this._pending;\n    const pending: Map<IdentifierArray, ChangeSet> = new Map();\n\n    if (includeManaged) {\n      const managed = this._identifiers.get(identifier);\n      if (managed) {\n        managed.forEach((arr) => {\n          let changes = allPending.get(arr);\n          if (!changes) {\n            changes = new Map();\n            allPending.set(arr, changes);\n          }\n          pending.set(arr, changes);\n        });\n      }\n    }\n\n    // during unloadAll we can ignore removes since we've already\n    // cleared the array.\n    if (liveArray && liveArray[SOURCE].length === 0 && isRemove) {\n      const pendingLive = allPending.get(liveArray);\n      if (!pendingLive || pendingLive.size === 0) {\n        return pending;\n      }\n    }\n\n    if (!liveArray) {\n      // start building a changeset for when we eventually\n      // do have a live array\n      let changes = this._staged.get(identifier.type);\n      if (!changes) {\n        changes = new Map();\n        this._staged.set(identifier.type, changes);\n      }\n      pending.set(FAKE_ARR as IdentifierArray, changes);\n    } else {\n      let changes = allPending.get(liveArray);\n      if (!changes) {\n        changes = new Map();\n        allPending.set(liveArray, changes);\n      }\n      pending.set(liveArray, changes);\n    }\n\n    return pending;\n  }\n\n  populateManagedArray(array: Collection, identifiers: StableRecordIdentifier[], payload: CollectionResourceDocument) {\n    this._pending.delete(array);\n    const source = array[SOURCE];\n    const old = source.slice();\n    source.length = 0;\n    fastPush(source, identifiers);\n    this._set.set(array, new Set(identifiers));\n\n    notifyArray(array);\n    array.meta = payload.meta || null;\n    array.links = payload.links || null;\n    array.isLoaded = true;\n\n    disassociate(this._identifiers, array, old);\n    associate(this._identifiers, array, identifiers);\n  }\n\n  identifierAdded(identifier: StableRecordIdentifier): void {\n    const changeSets = this._getPendingFor(identifier, false);\n    if (changeSets) {\n      changeSets.forEach((changes, array) => {\n        const existing = changes.get(identifier);\n        if (existing === 'del') {\n          changes.delete(identifier);\n        } else {\n          changes.set(identifier, 'add');\n\n          this.dirtyArray(array, changes.size);\n        }\n      });\n    }\n  }\n\n  identifierRemoved(identifier: StableRecordIdentifier): void {\n    const changeSets = this._getPendingFor(identifier, true, true);\n    if (changeSets) {\n      changeSets.forEach((changes, array) => {\n        const existing = changes.get(identifier);\n        if (existing === 'add') {\n          changes.delete(identifier);\n        } else {\n          changes.set(identifier, 'del');\n\n          this.dirtyArray(array, changes.size);\n        }\n      });\n    }\n  }\n\n  identifierChanged(identifier: StableRecordIdentifier): void {\n    const newState = this.store._instanceCache.recordIsLoaded(identifier, true);\n\n    // if the change matches the most recent direct added/removed\n    // state, then we can ignore it\n    if (this._visibilitySet.get(identifier) === newState) {\n      return;\n    }\n\n    if (newState) {\n      this.identifierAdded(identifier);\n    } else {\n      this.identifierRemoved(identifier);\n    }\n  }\n\n  clear(isClear = true) {\n    this._live.forEach((array) => array.destroy(isClear));\n    this._managed.forEach((array) => array.destroy(isClear));\n    this._managed.clear();\n    this._identifiers.clear();\n    this._pending.clear();\n    this._set.forEach((set) => set.clear());\n    this._visibilitySet.clear();\n  }\n\n  destroy() {\n    this.isDestroying = true;\n    this.clear(false);\n    this._live.clear();\n    this.isDestroyed = true;\n    this.store.notifications.unsubscribe(this._subscription);\n  }\n}\n\nfunction associate(\n  ArraysCache: Map<StableRecordIdentifier, Set<Collection>>,\n  array: Collection,\n  identifiers: StableRecordIdentifier[]\n) {\n  for (let i = 0; i < identifiers.length; i++) {\n    const identifier = identifiers[i];\n    let cache = ArraysCache.get(identifier);\n    if (!cache) {\n      cache = new Set();\n      ArraysCache.set(identifier, cache);\n    }\n    cache.add(array);\n  }\n}\n\nfunction disassociate(\n  ArraysCache: Map<StableRecordIdentifier, Set<Collection>>,\n  array: Collection,\n  identifiers: StableRecordIdentifier[]\n) {\n  for (let i = 0; i < identifiers.length; i++) {\n    disassociateIdentifier(ArraysCache, array, identifiers[i]);\n  }\n}\n\nexport function disassociateIdentifier(\n  ArraysCache: Map<StableRecordIdentifier, Set<Collection>>,\n  array: Collection,\n  identifier: StableRecordIdentifier\n) {\n  const cache = ArraysCache.get(identifier);\n  if (cache) {\n    cache.delete(array);\n  }\n}\n\nfunction sync(\n  array: IdentifierArray,\n  changes: Map<StableRecordIdentifier, 'add' | 'del'>,\n  arraySet: Set<StableRecordIdentifier>\n) {\n  const state = array[SOURCE];\n  const adds: StableRecordIdentifier[] = [];\n  const removes: StableRecordIdentifier[] = [];\n  changes.forEach((value, key) => {\n    if (value === 'add') {\n      // likely we want to keep a Set along-side\n      if (arraySet.has(key)) {\n        return;\n      }\n      adds.push(key);\n      arraySet.add(key);\n    } else {\n      if (arraySet.has(key)) {\n        removes.push(key);\n        arraySet.delete(key);\n      }\n    }\n  });\n  if (removes.length) {\n    if (removes.length === state.length) {\n      state.length = 0;\n      // changing the reference breaks the Proxy\n      // state = array[SOURCE] = [];\n    } else {\n      removes.forEach((i) => {\n        const index = state.indexOf(i);\n        if (index !== -1) {\n          state.splice(index, 1);\n          arraySet.delete(i);\n        }\n      });\n    }\n  }\n\n  if (adds.length) {\n    fastPush(state, adds);\n    // changing the reference breaks the Proxy\n    // else we could do this\n    /*\n    if (state.length === 0) {\n      array[SOURCE] = adds;\n    } else {\n      array[SOURCE] = state.concat(adds);\n    }\n    */\n  }\n}\n\nexport default RecordArrayManager;\n","/**\n * @module @ember-data/store\n */\nimport { assert } from '@ember/debug';\n\nimport { DEBUG } from '@ember-data/env';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';\n\nimport type { FindOptions } from '../../-types/q/store';\nimport type Store from '../store-service';\n\nconst Touching: unique symbol = Symbol('touching');\nexport const RequestPromise: unique symbol = Symbol('promise');\nconst EMPTY_ARR: RequestState[] = DEBUG ? (Object.freeze([]) as unknown as RequestState[]) : [];\n\nexport interface Operation {\n  op: string;\n  options: FindOptions | undefined;\n  recordIdentifier: StableRecordIdentifier;\n}\n\nexport interface FindRecordQuery extends Operation {\n  op: 'findRecord';\n}\n\nexport interface SaveRecordMutation extends Operation {\n  op: 'saveRecord';\n}\n\nexport interface Request {\n  data: Operation[];\n  options?: Record<string, unknown>;\n}\n\nexport type RequestStates = 'pending' | 'fulfilled' | 'rejected';\n\nexport interface RequestState {\n  state: RequestStates;\n  type: 'query' | 'mutation';\n  request: Request;\n  response?: Response;\n}\n\nexport interface Response {\n  // rawData: unknown;\n  data: unknown;\n}\n\ninterface InternalRequest extends RequestState {\n  [Touching]: StableRecordIdentifier[];\n  [RequestPromise]?: Promise<unknown>;\n}\n\ntype RecordOperation = FindRecordQuery | SaveRecordMutation;\nexport type RequestSubscription = (requestState: RequestState) => void;\n\nfunction hasRecordIdentifier(op: Operation): op is RecordOperation {\n  return 'recordIdentifier' in op;\n}\n\n/**\n * The RequestStateService is used to track the state of requests\n * for fetching or updating known resource identifies that are inflight.\n *\n * @class RequestStateService\n * @public\n */\nexport default class RequestStateService {\n  _pending: Map<StableRecordIdentifier, InternalRequest[]> = new Map();\n  _done: Map<StableRecordIdentifier, InternalRequest[]> = new Map();\n  _subscriptions: Map<StableRecordIdentifier, RequestSubscription[]> = new Map();\n  _toFlush: InternalRequest[] = [];\n  _store: Store;\n\n  constructor(store: Store) {\n    this._store = store;\n  }\n\n  _clearEntries(identifier: StableRecordIdentifier) {\n    this._done.delete(identifier);\n  }\n\n  _enqueue<T>(promise: Promise<T>, queryRequest: Request): Promise<T> {\n    const query = queryRequest.data[0];\n    if (hasRecordIdentifier(query)) {\n      const identifier = query.recordIdentifier;\n      const type = query.op === 'saveRecord' ? ('mutation' as const) : ('query' as const);\n      if (!this._pending.has(identifier)) {\n        this._pending.set(identifier, []);\n      }\n      const request: InternalRequest = {\n        state: 'pending',\n        request: queryRequest,\n        type,\n      } as InternalRequest;\n      request[Touching] = [query.recordIdentifier];\n      request[RequestPromise] = promise;\n      this._pending.get(identifier)!.push(request);\n      this._triggerSubscriptions(request);\n      return promise.then(\n        (result) => {\n          this._dequeue(identifier, request);\n          const finalizedRequest = {\n            state: 'fulfilled',\n            request: queryRequest,\n            type,\n            response: { data: result },\n          } as InternalRequest;\n          finalizedRequest[Touching] = request[Touching];\n          this._addDone(finalizedRequest);\n          this._triggerSubscriptions(finalizedRequest);\n          return result;\n        },\n        (error) => {\n          this._dequeue(identifier, request);\n          const finalizedRequest = {\n            state: 'rejected',\n            request: queryRequest,\n            type,\n            response: { data: error },\n          } as InternalRequest;\n          finalizedRequest[Touching] = request[Touching];\n          this._addDone(finalizedRequest);\n          this._triggerSubscriptions(finalizedRequest);\n          throw error;\n        }\n      );\n    }\n    assert(`Expected a well formed  query`);\n  }\n\n  _triggerSubscriptions(req: InternalRequest): void {\n    if (req.state === 'pending') {\n      this._flushRequest(req);\n      return;\n    }\n    this._toFlush.push(req);\n\n    if (this._toFlush.length === 1) {\n      this._store.notifications._onNextFlush(() => {\n        this._flush();\n      });\n    }\n  }\n\n  _flush(): void {\n    this._toFlush.forEach((req) => {\n      this._flushRequest(req);\n    });\n    this._toFlush = [];\n  }\n\n  _flushRequest(req: InternalRequest): void {\n    req[Touching].forEach((identifier: StableRecordIdentifier) => {\n      const subscriptions = this._subscriptions.get(identifier);\n      if (subscriptions) {\n        subscriptions.forEach((callback) => callback(req));\n      }\n    });\n  }\n\n  _dequeue(identifier: StableRecordIdentifier, request: InternalRequest) {\n    const pending = this._pending.get(identifier)!;\n    this._pending.set(\n      identifier,\n      pending.filter((req) => req !== request)\n    );\n  }\n\n  _addDone(request: InternalRequest) {\n    request[Touching].forEach((identifier) => {\n      // TODO add support for multiple\n      const requestDataOp = request.request.data[0].op;\n      let requests = this._done.get(identifier);\n\n      if (requests) {\n        requests = requests.filter((req) => {\n          // TODO add support for multiple\n          let data: Operation;\n          if (Array.isArray(req.request.data)) {\n            data = req.request.data[0];\n          } else {\n            data = req.request.data;\n          }\n          return data.op !== requestDataOp;\n        });\n      }\n      requests = requests || [];\n      requests.push(request);\n      this._done.set(identifier, requests);\n    });\n  }\n\n  /**\n   * Subscribe to requests for a given resource identity.\n   *\n   * The callback will receive the current state of the request.\n   *\n   * ```ts\n   * interface RequestState {\n   *   state: 'pending' | 'fulfilled' | 'rejected';\n   *   type: 'query' | 'mutation';\n   *   request: Request;\n   *   response?: { data: unknown };\n   * }\n   * ```\n   *\n   * Note: It should be considered dangerous to use this API for more than simple\n   * state derivation or debugging. The `request` and `response` properties are poorly\n   * spec'd and may change unexpectedly when shifting what Handlers are in use or how\n   * requests are issued from the Store.\n   *\n   * We expect to revisit this API in the near future as we continue to refine the\n   * RequestManager ergonomics, as a simpler but more powerful direct integration\n   * with the RequestManager for these purposes is likely to be a better long-term\n   * design.\n   *\n   * @method subscribeForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @param {(state: RequestState) => void} callback\n   */\n  subscribeForRecord(identifier: StableRecordIdentifier, callback: RequestSubscription) {\n    let subscriptions = this._subscriptions.get(identifier);\n    if (!subscriptions) {\n      subscriptions = [];\n      this._subscriptions.set(identifier, subscriptions);\n    }\n    subscriptions.push(callback);\n  }\n\n  /**\n   * Retrieve all active requests for a given resource identity.\n   *\n   * @method getPendingRequestsForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestState[]} an array of request states for any pending requests for the given identifier\n   */\n  getPendingRequestsForRecord(identifier: StableRecordIdentifier): RequestState[] {\n    return this._pending.get(identifier) || EMPTY_ARR;\n  }\n\n  /**\n   * Retrieve the last completed request for a given resource identity.\n   *\n   * @method getLastRequestForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestState | null} the state of the most recent request for the given identifier\n   */\n  getLastRequestForRecord(identifier: StableRecordIdentifier): RequestState | null {\n    const requests = this._done.get(identifier);\n    if (requests) {\n      return requests[requests.length - 1];\n    }\n    return null;\n  }\n}\n","export default function isNonEmptyString(str: unknown): str is string {\n  return Boolean(str && typeof str === 'string');\n}\n","import { assert } from '@ember/debug';\n\nimport type { ExistingResourceIdentifierObject, ResourceIdentifierObject } from '@warp-drive/core-types/spec/raw';\n\nimport { isStableIdentifier } from '../caches/identifier-cache';\nimport coerceId from './coerce-id';\nimport isNonEmptyString from './is-non-empty-string';\n\nfunction constructResource(type: ResourceIdentifierObject): ResourceIdentifierObject;\nfunction constructResource(type: string, id: string, lid: string): ExistingResourceIdentifierObject;\nfunction constructResource(\n  type: string | undefined,\n  id: null | undefined,\n  lid: string\n): ExistingResourceIdentifierObject;\nfunction constructResource(type: string, id: string, lid?: string | null): ExistingResourceIdentifierObject;\nfunction constructResource(type: string, id?: string | number | null, lid?: string | null): ResourceIdentifierObject;\nfunction constructResource(\n  type: string | ResourceIdentifierObject | undefined,\n  id?: string | number | null,\n  lid?: string | null\n): ResourceIdentifierObject | ExistingResourceIdentifierObject {\n  if (typeof type === 'object' && type !== null) {\n    const resource = type;\n    if (isStableIdentifier(resource)) {\n      return resource;\n    }\n    if ('id' in resource) {\n      resource.id = coerceId(resource.id);\n    }\n\n    assert(\n      'Expected either id or lid to be a valid string',\n      ('id' in resource && isNonEmptyString(resource.id)) || isNonEmptyString(resource.lid)\n    );\n    assert('if id is present, the type must be a string', !('id' in resource) || typeof resource.type === 'string');\n\n    return resource;\n  } else {\n    const trueId = coerceId(id);\n    if (!isNonEmptyString(trueId)) {\n      if (isNonEmptyString(lid)) {\n        return { lid };\n      }\n      throw new Error('Expected either id or lid to be a valid string');\n    }\n\n    assert('type must be a string', typeof type === 'string');\n\n    if (isNonEmptyString(lid)) {\n      return { type, id: trueId, lid };\n    }\n\n    return { type, id: trueId };\n  }\n}\n\nexport default constructResource;\n","/**\n  @module @ember-data/store\n */\n// this import location is deprecated but breaks in 4.8 and older\nimport { assert } from '@ember/debug';\nimport EmberObject from '@ember/object';\n\nimport { LOG_PAYLOADS, LOG_REQUESTS } from '@ember-data/debugging';\nimport { DEBUG, TESTING } from '@ember-data/env';\nimport type RequestManager from '@ember-data/request';\nimport type { Future } from '@ember-data/request/-private/types';\nimport type { Graph } from '@warp-drive/core-types/graph';\nimport type {\n  StableDocumentIdentifier,\n  StableExistingRecordIdentifier,\n  StableRecordIdentifier,\n} from '@warp-drive/core-types/identifier';\nimport { EnableHydration, SkipCache } from '@warp-drive/core-types/request';\nimport type { ResourceDocument } from '@warp-drive/core-types/spec/document';\nimport type {\n  CollectionResourceDocument,\n  EmptyResourceDocument,\n  JsonApiDocument,\n  ResourceIdentifierObject,\n  SingleResourceDocument,\n} from '@warp-drive/core-types/spec/raw';\n\nimport type { Cache, CacheV1 } from '../-types/q/cache';\nimport type { CacheCapabilitiesManager } from '../-types/q/cache-store-wrapper';\nimport type { ModelSchema } from '../-types/q/ds-model';\nimport type { RecordInstance } from '../-types/q/record-instance';\nimport type { SchemaService } from '../-types/q/schema-service';\nimport type { FindOptions, QueryOptions } from '../-types/q/store';\nimport type { LifetimesService, StoreRequestContext, StoreRequestInput } from './cache-handler';\nimport { IdentifierCache } from './caches/identifier-cache';\nimport {\n  InstanceCache,\n  peekRecordIdentifier,\n  preloadData,\n  recordIdentifierFor,\n  resourceIsFullyDeleted,\n  storeFor,\n} from './caches/instance-cache';\nimport type { Document } from './document';\nimport type RecordReference from './legacy-model-support/record-reference';\nimport { getShimClass } from './legacy-model-support/shim-model-class';\nimport { CacheManager } from './managers/cache-manager';\nimport NotificationManager from './managers/notification-manager';\nimport RecordArrayManager from './managers/record-array-manager';\nimport RequestStateService, { RequestPromise } from './network/request-cache';\nimport type { Collection } from './record-arrays/identifier-array';\nimport type IdentifierArray from './record-arrays/identifier-array';\nimport coerceId, { ensureStringId } from './utils/coerce-id';\nimport constructResource from './utils/construct-resource';\nimport normalizeModelName from './utils/normalize-model-name';\n\nexport { storeFor };\n\ntype CompatStore = Store & {\n  adapterFor?: (\n    type: string,\n    _allowMissing?: boolean\n  ) => undefined | { generateIdForRecord?(store: Store, type: string, properties: object): string };\n};\nfunction upgradeStore(store: Store): asserts store is CompatStore {}\n\nexport interface CreateRecordProperties {\n  id?: string | null;\n  [key: string]: unknown;\n}\n\n/**\n * A Store coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\n * and sources of data (such as your API or a local persistence layer)\n * accessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n *\n * ```app/services/store.js\n * import Store from '@ember-data/store';\n *\n * export default class extends Store {}\n * ```\n *\n * Most Ember applications will only have a single `Store` configured as a Service\n * in this manner. However, setting up multiple stores is possible, including using\n * each as a unique service.\n *\n\n  @class Store\n  @public\n*/\n\n// @ts-expect-error\ninterface Store {\n  createRecordDataFor?(identifier: StableRecordIdentifier, wrapper: CacheCapabilitiesManager): Cache | CacheV1;\n\n  createCache(storeWrapper: CacheCapabilitiesManager): Cache;\n\n  instantiateRecord(identifier: StableRecordIdentifier, createRecordArgs: { [key: string]: unknown }): RecordInstance;\n\n  teardownRecord(record: RecordInstance): void;\n}\n\nclass Store extends EmberObject {\n  declare recordArrayManager: RecordArrayManager;\n\n  /**\n   * Provides access to the NotificationManager associated\n   * with this Store instance.\n   *\n   * The NotificationManager can be used to subscribe to\n   * changes to the cache.\n   *\n   * @property {NotificationManager} notifications\n   * @public\n   */\n  declare notifications: NotificationManager;\n\n  /**\n   * Provides access to the SchemaService instance\n   * for this Store instance.\n   *\n   * The SchemaService can be used to query for\n   * information about the schema of a resource.\n   *\n   * @property {SchemaService} schema\n   * @public\n   */\n  get schema(): SchemaService {\n    return this.getSchemaDefinitionService();\n  }\n  declare _schema: SchemaService;\n\n  /**\n   * Provides access to the IdentifierCache instance\n   * for this store.\n   *\n   * The IdentifierCache can be used to generate or\n   * retrieve a stable unique identifier for any resource.\n   *\n   * @property {IdentifierCache} identifierCache\n   * @public\n   */\n  declare identifierCache: IdentifierCache;\n  /**\n   * Provides access to the requestManager instance associated\n   * with this Store instance.\n   *\n   * When using `ember-data` this property is automatically\n   * set to an instance of `RequestManager`. When not using `ember-data`\n   * you must configure this property yourself, either by declaring\n   * it as a service or by initializing it.\n   *\n   * ```ts\n   * import Store, { CacheHandler } from '@ember-data/store';\n   * import RequestManager from '@ember-data/request';\n   * import Fetch from '@ember/data/request/fetch';\n   *\n   * class extends Store {\n   *   constructor() {\n   *     super(...arguments);\n   *     this.requestManager = new RequestManager();\n   *     this.requestManager.use([Fetch]);\n   *     this.requestManager.useCache(CacheHandler);\n   *   }\n   * }\n   * ```\n   *\n   * @public\n   * @property {RequestManager} requestManager\n   */\n  declare requestManager: RequestManager;\n\n  /**\n   * A Property which an App may set to provide a Lifetimes Service\n   * to control when a cached request becomes stale.\n   *\n   * Note, when defined, these methods will only be invoked if a\n   * cache key exists for the request, either because the request\n   * contains `cacheOptions.key` or because the [IdentifierCache](/ember-data/release/classes/IdentifierCache)\n   * was able to generate a key for the request using the configured\n   * [generation method](/ember-data/release/functions/@ember-data%2Fstore/setIdentifierGenerationMethod).\n   *\n   * `isSoftExpired` will only be invoked if `isHardExpired` returns `false`.\n   *\n   * ```ts\n   * store.lifetimes = {\n   *   // make the request and ignore the current cache state\n   *   isHardExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   *\n   *   // make the request in the background if true, return cache state\n   *   isSoftExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   * }\n   * ```\n   *\n   * @public\n   * @property {LivetimesService|undefined} lifetimes\n   */\n  declare lifetimes?: LifetimesService;\n\n  // Private\n  declare _graph?: Graph;\n  declare _requestCache: RequestStateService;\n  declare _instanceCache: InstanceCache;\n  declare _documentCache: Map<StableDocumentIdentifier, Document<RecordInstance | RecordInstance[] | null | undefined>>;\n\n  declare _cbs: { coalesce?: () => void; sync?: () => void; notify?: () => void } | null;\n  declare _forceShim: boolean;\n  declare _enableAsyncFlush: boolean | null;\n\n  // DEBUG-only properties\n  declare DISABLE_WAITER?: boolean;\n\n  declare _isDestroying: boolean;\n  declare _isDestroyed: boolean;\n\n  get isDestroying(): boolean {\n    return this._isDestroying;\n  }\n  set isDestroying(value: boolean) {\n    this._isDestroying = value;\n  }\n  get isDestroyed(): boolean {\n    return this._isDestroyed;\n  }\n  set isDestroyed(value: boolean) {\n    this._isDestroyed = value;\n  }\n\n  /**\n    @method init\n    @private\n  */\n  constructor(createArgs?: unknown) {\n    // @ts-expect-error ember-source types improperly expect createArgs to be `Owner`\n    super(createArgs);\n    Object.assign(this, createArgs);\n\n    this.identifierCache = new IdentifierCache();\n\n    this.notifications = new NotificationManager(this);\n\n    // private but maybe useful to be here, somewhat intimate\n    this.recordArrayManager = new RecordArrayManager({ store: this });\n\n    // private\n    this._requestCache = new RequestStateService(this);\n    this._instanceCache = new InstanceCache(this);\n    this._documentCache = new Map();\n\n    this.isDestroying = false;\n    this.isDestroyed = false;\n  }\n\n  _run(cb: () => void) {\n    assert(`EmberData should never encounter a nested run`, !this._cbs);\n    const _cbs: { coalesce?: () => void; sync?: () => void; notify?: () => void } = (this._cbs = {});\n    if (DEBUG) {\n      try {\n        cb();\n        if (_cbs.coalesce) {\n          _cbs.coalesce();\n        }\n        if (_cbs.sync) {\n          _cbs.sync();\n        }\n        if (_cbs.notify) {\n          _cbs.notify();\n        }\n      } finally {\n        this._cbs = null;\n      }\n    } else {\n      cb();\n      if (_cbs.coalesce) {\n        _cbs.coalesce();\n      }\n      if (_cbs.sync) {\n        _cbs.sync();\n      }\n      if (_cbs.notify) {\n        _cbs.notify();\n      }\n      this._cbs = null;\n    }\n  }\n  _join(cb: () => void): void {\n    if (this._cbs) {\n      cb();\n    } else {\n      this._run(cb);\n    }\n  }\n\n  _schedule(name: 'coalesce' | 'sync' | 'notify', cb: () => void): void {\n    assert(`EmberData expects to schedule only when there is an active run`, !!this._cbs);\n    assert(`EmberData expects only one flush per queue name, cannot schedule ${name}`, !this._cbs[name]);\n\n    this._cbs[name] = cb;\n  }\n\n  /**\n   * Retrieve the RequestStateService instance\n   * associated with this Store.\n   *\n   * This can be used to query the status of requests\n   * that have been initiated for a given identifier.\n   *\n   * @method getRequestStateService\n   * @return {RequestStateService}\n   * @public\n   */\n  getRequestStateService(): RequestStateService {\n    return this._requestCache;\n  }\n\n  _getAllPending(): (Promise<unknown[]> & { length: number }) | void {\n    if (TESTING) {\n      const all: Promise<unknown>[] = [];\n      const pending = this._requestCache._pending;\n\n      pending.forEach((requests) => {\n        all.push(...requests.map((v) => v[RequestPromise]!));\n      });\n      this.requestManager._pending.forEach((v) => all.push(v));\n      const promise: Promise<unknown[]> & { length: number } = Promise.allSettled(all) as Promise<unknown[]> & {\n        length: number;\n      };\n      promise.length = all.length;\n      return promise;\n    }\n  }\n\n  /**\n   * Issue a request via the configured RequestManager,\n   * inserting the response into the cache and handing\n   * back a Future which resolves to a ResponseDocument\n   *\n   * ## Cache Keys\n   *\n   * Only GET requests with a url or requests with an explicit\n   * cache key (`cacheOptions.key`) will have the request result\n   * and document cached.\n   *\n   * The cache key used is `requestConfig.cacheOptions.key`\n   * if present, falling back to `requestconfig.url`.\n   *\n   * Params are not serialized as part of the cache-key, so\n   * either ensure they are already in the url or utilize\n   * `requestConfig.cacheOptions.key`. For queries issued\n   * via the `POST` method `requestConfig.cacheOptions.key`\n   * MUST be supplied for the document to be cached.\n   *\n   * ## Requesting Without a Cache Key\n   *\n   * Resource data within the request is always updated in the cache,\n   * regardless of whether a cache key is present for the request.\n   *\n   * ## Fulfilling From Cache\n   *\n   * When a cache-key is determined, the request may fulfill\n   * from cache provided the cache is not stale.\n   *\n   * Cache staleness is determined by the configured LifetimesService\n   * with priority given to the `cacheOptions.reload` and\n   * `cacheOptions.backgroundReload` on the request if present.\n   *\n   * If the cache data has soft expired or the request asks for a background\n   * reload, the request will fulfill from cache if possible and\n   * make a non-blocking request in the background to update the cache.\n   *\n   * If the cache data has hard expired or the request asks for a reload,\n   * the request will not fulfill from cache and will make a blocking\n   * request to update the cache.\n   *\n   * ## The Response\n   *\n   * The primary difference between `requestManager.request` and `store.request`\n   * is that `store.request` will attempt to hydrate the response content into\n   * a response Document containing RecordInstances.\n   *\n   * @method request\n   * @param {StoreRequestInput} requestConfig\n   * @return {Future}\n   * @public\n   */\n  request<T>(requestConfig: StoreRequestInput): Future<T> {\n    // we lazily set the cache handler when we issue the first request\n    // because constructor doesn't allow for this to run after\n    // the user has had the chance to set the prop.\n    const opts: {\n      store: Store;\n      disableTestWaiter?: boolean;\n      [EnableHydration]: true;\n      records?: StableRecordIdentifier[];\n    } = {\n      store: this,\n      [EnableHydration]: true,\n    };\n\n    if (requestConfig.records) {\n      const identifierCache = this.identifierCache;\n      opts.records = requestConfig.records.map((r) => identifierCache.getOrCreateRecordIdentifier(r));\n    }\n\n    if (TESTING) {\n      if (this.DISABLE_WAITER) {\n        opts.disableTestWaiter =\n          typeof requestConfig.disableTestWaiter === 'boolean' ? requestConfig.disableTestWaiter : true;\n      }\n    }\n\n    if (LOG_REQUESTS) {\n      let options: unknown;\n      try {\n        options = JSON.parse(JSON.stringify(requestConfig));\n      } catch {\n        options = requestConfig;\n      }\n      // eslint-disable-next-line no-console\n      console.log(\n        `request: [[START]] ${requestConfig.op && !requestConfig.url ? '(LEGACY) ' : ''}${\n          requestConfig.op || '<unknown operation>'\n        } ${requestConfig.url || '<empty url>'}  ${requestConfig.method || '<empty method>'}`,\n        options\n      );\n    }\n\n    const future = this.requestManager.request<T>(Object.assign(requestConfig, opts));\n\n    future.onFinalize(() => {\n      if (LOG_REQUESTS) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `request: [[FINALIZE]] ${requestConfig.op && !requestConfig.url ? '(LEGACY) ' : ''}${\n            requestConfig.op || '<unknown operation>'\n          } ${requestConfig.url || '<empty url>'}  ${requestConfig.method || '<empty method>'}`\n        );\n      }\n      // skip flush for legacy belongsTo\n      if (requestConfig.op === 'findBelongsTo' && !requestConfig.url) {\n        return;\n      }\n      this.notifications._flush();\n    });\n\n    return future;\n  }\n\n  /**\n   * A hook which an app or addon may implement. Called when\n   * the Store is attempting to create a Record Instance for\n   * a resource.\n   *\n   * This hook can be used to select or instantiate any desired\n   * mechanism of presentating cache data to the ui for access\n   * mutation, and interaction.\n   *\n   * @method instantiateRecord (hook)\n   * @param identifier\n   * @param createRecordArgs\n   * @param recordDataFor deprecated use this.cache\n   * @param notificationManager deprecated use this.notifications\n   * @return A record instance\n   * @public\n   */\n\n  /**\n   * A hook which an app or addon may implement. Called when\n   * the Store is destroying a Record Instance. This hook should\n   * be used to teardown any custom record instances instantiated\n   * with `instantiateRecord`.\n   *\n   * @method teardownRecord (hook)\n   * @public\n   * @param record\n   */\n\n  /**\n   * Provides access to the SchemaDefinitionService instance\n   * for this Store instance.\n   *\n   * The SchemaDefinitionService can be used to query for\n   * information about the schema of a resource.\n   *\n   * @method getSchemaDefinitionService\n   * @public\n   */\n  getSchemaDefinitionService(): SchemaService {\n    assert(`You must registerSchemaDefinitionService with the store to use custom model classes`, this._schema);\n    return this._schema;\n  }\n\n  /**\n   * DEPRECATED - Use `registerSchema` instead.\n   *\n   * Allows an app to register a custom SchemaService\n   * for use when information about a resource's schema needs\n   * to be queried.\n   *\n   * This method can only be called more than once, but only one schema\n   * definition service may exist. Therefore if you wish to chain services\n   * you must lookup the existing service and close over it with the new\n   * service by accessing `store.schema` prior to registration.\n   *\n   * For Example:\n   *\n   * ```ts\n   * import Store from '@ember-data/store';\n   *\n   * class SchemaDelegator {\n   *   constructor(schema) {\n   *     this._schema = schema;\n   *   }\n   *\n   *   doesTypeExist(type: string): boolean {\n   *     if (AbstractSchemas.has(type)) {\n   *       return true;\n   *     }\n   *     return this._schema.doesTypeExist(type);\n   *   }\n   *\n   *   attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesSchema {\n   *     return this._schema.attributesDefinitionFor(identifier);\n   *   }\n   *\n   *   relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsSchema {\n   *     const schema = AbstractSchemas.get(identifier.type);\n   *     return schema || this._schema.relationshipsDefinitionFor(identifier);\n   *   }\n   * }\n   *\n   * export default class extends Store {\n   *   constructor(...args) {\n   *     super(...args);\n   *\n   *     const schema = this.schema;\n   *     this.registerSchemaDefinitionService(new SchemaDelegator(schema));\n   *   }\n   * }\n   * ```\n   *\n   * @method registerSchemaDefinitionService\n   * @param {SchemaService} schema\n   * @deprecated\n   * @public\n   */\n  registerSchemaDefinitionService(schema: SchemaService) {\n    this._schema = schema;\n  }\n  /**\n   * Allows an app to register a custom SchemaService\n   * for use when information about a resource's schema needs\n   * to be queried.\n   *\n   * This method can only be called more than once, but only one schema\n   * definition service may exist. Therefore if you wish to chain services\n   * you must lookup the existing service and close over it with the new\n   * service by accessing `store.schema` prior to registration.\n   *\n   * For Example:\n   *\n   * ```ts\n   * import Store from '@ember-data/store';\n   *\n   * class SchemaDelegator {\n   *   constructor(schema) {\n   *     this._schema = schema;\n   *   }\n   *\n   *   doesTypeExist(type: string): boolean {\n   *     if (AbstractSchemas.has(type)) {\n   *       return true;\n   *     }\n   *     return this._schema.doesTypeExist(type);\n   *   }\n   *\n   *   attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesSchema {\n   *     return this._schema.attributesDefinitionFor(identifier);\n   *   }\n   *\n   *   relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsSchema {\n   *     const schema = AbstractSchemas.get(identifier.type);\n   *     return schema || this._schema.relationshipsDefinitionFor(identifier);\n   *   }\n   * }\n   *\n   * export default class extends Store {\n   *   constructor(...args) {\n   *     super(...args);\n   *\n   *     const schema = this.schema;\n   *     this.registerSchema(new SchemaDelegator(schema));\n   *   }\n   * }\n   * ```\n   *\n   * @method registerSchema\n   * @param {SchemaService} schema\n   * @public\n   */\n  registerSchema(schema: SchemaService) {\n    this._schema = schema;\n  }\n\n  /**\n    Returns the schema for a particular `modelName`.\n\n    When used with Model from @ember-data/model the return is the model class,\n    but this is not guaranteed.\n\n    If looking to query attribute or relationship information it is\n    recommended to use `getSchemaDefinitionService` instead. This method\n    should be considered legacy and exists primarily to continue to support\n    Adapter/Serializer APIs which expect it's return value in their method\n    signatures.\n\n    The class of a model might be useful if you want to get a list of all the\n    relationship names of the model, see\n    [`relationshipNames`](/ember-data/release/classes/Model?anchor=relationshipNames)\n    for example.\n\n    @method modelFor\n    @public\n    @param {String} type\n    @return {ModelSchema}\n    */\n  // TODO @deprecate in favor of schema APIs, requires adapter/serializer overhaul or replacement\n\n  modelFor(type: string): ModelSchema {\n    if (DEBUG) {\n      assertDestroyedStoreOnly(this, 'modelFor');\n    }\n    assert(`You need to pass <type> to the store's modelFor method`, typeof type === 'string' && type.length);\n    assert(\n      `No model was found for '${type}' and no schema handles the type`,\n      this.getSchemaDefinitionService().doesTypeExist(type)\n    );\n\n    return getShimClass(this, type);\n  }\n\n  /**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n\n    To create a new instance of a `Post`:\n\n    ```js\n    store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n    ```\n\n    To create a new instance of a `Post` that has a relationship with a `User` record:\n\n    ```js\n    let user = this.store.peekRecord('user', 1);\n    store.createRecord('post', {\n      title: 'Ember is awesome!',\n      user: user\n    });\n    ```\n\n    @method createRecord\n    @public\n    @param {String} modelName\n    @param {Object} inputProperties a hash of properties to set on the\n      newly created record.\n    @return {Model} record\n  */\n  createRecord(modelName: string, inputProperties: CreateRecordProperties): RecordInstance {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'createRecord');\n    }\n    assert(`You need to pass a model name to the store's createRecord method`, modelName);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${modelName}`,\n      typeof modelName === 'string'\n    );\n\n    // This is wrapped in a `run.join` so that in test environments users do not need to manually wrap\n    //   calls to `createRecord`. The run loop usage here is because we batch the joining and updating\n    //   of record-arrays via ember's run loop, not our own.\n    //\n    //   to remove this, we would need to move to a new `async` API.\n    let record!: RecordInstance;\n    this._join(() => {\n      const normalizedModelName = normalizeModelName(modelName);\n      const properties = { ...inputProperties };\n\n      // If the passed properties do not include a primary key,\n      // give the adapter an opportunity to generate one. Typically,\n      // client-side ID generators will use something like uuid.js\n      // to avoid conflicts.\n\n      if (properties.id === null || properties.id === undefined) {\n        upgradeStore(this);\n        const adapter = this.adapterFor?.(modelName, true);\n\n        if (adapter && adapter.generateIdForRecord) {\n          properties.id = adapter.generateIdForRecord(this, modelName, properties);\n        } else {\n          properties.id = null;\n        }\n      }\n\n      // Coerce ID to a string\n      properties.id = coerceId(properties.id);\n      const resource = { type: normalizedModelName, id: properties.id };\n\n      if (resource.id) {\n        const identifier = this.identifierCache.peekRecordIdentifier(resource as ResourceIdentifierObject);\n\n        assert(\n          `The id ${String(properties.id)} has already been used with another '${normalizedModelName}' record.`,\n          !identifier\n        );\n      }\n\n      const identifier = this.identifierCache.createIdentifierForNewRecord(resource);\n      const cache = this.cache;\n\n      const createOptions = normalizeProperties(this, identifier, properties);\n      const resultProps = cache.clientDidCreate(identifier, createOptions);\n\n      record = this._instanceCache.getRecord(identifier, resultProps);\n    });\n    return record;\n  }\n\n  /**\n    For symmetry, a record can be deleted via the store.\n\n    Example\n\n    ```javascript\n    let post = store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n\n    store.deleteRecord(post);\n    ```\n\n    @method deleteRecord\n    @public\n    @param {Model} record\n  */\n  deleteRecord(record: RecordInstance): void {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'deleteRecord');\n    }\n\n    const identifier = peekRecordIdentifier(record);\n    const cache = this.cache;\n    assert(`expected the record to be connected to a cache`, identifier);\n    this._join(() => {\n      cache.setIsDeleted(identifier, true);\n\n      if (cache.isNew(identifier)) {\n        this._instanceCache.unloadRecord(identifier);\n      }\n    });\n  }\n\n  /**\n    For symmetry, a record can be unloaded via the store.\n    This will cause the record to be destroyed and freed up for garbage collection.\n\n    Example\n\n    ```javascript\n    store.findRecord('post', 1).then(function(post) {\n      store.unloadRecord(post);\n    });\n    ```\n\n    @method unloadRecord\n    @public\n    @param {Model} record\n  */\n  unloadRecord(record: RecordInstance): void {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'unloadRecord');\n    }\n    const identifier = peekRecordIdentifier(record);\n    if (identifier) {\n      this._instanceCache.unloadRecord(identifier);\n    }\n  }\n\n  /**\n    This method returns a record for a given identifier or type and id combination.\n\n    The `findRecord` method will always resolve its promise with the same\n    object for a given identifier or type and `id`.\n\n    The `findRecord` method will always return a **promise** that will be\n    resolved with the record.\n\n    **Example 1**\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model({ post_id }) {\n        return this.store.findRecord('post', post_id);\n      }\n    }\n    ```\n\n    **Example 2**\n\n    `findRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model({ post_id: id }) {\n        return this.store.findRecord({ type: 'post', id });\n      }\n    }\n    ```\n\n    **Example 3**\n\n    If you have previously received an lid via an Identifier for this record, and the record\n    has already been assigned an id, you can find the record again using just the lid.\n\n    ```app/routes/post.js\n    store.findRecord({ lid });\n    ```\n\n    If the record is not yet available, the store will ask the adapter's `findRecord`\n    method to retrieve and supply the necessary data. If the record is already present\n    in the store, it depends on the reload behavior _when_ the returned promise\n    resolves.\n\n    ### Preloading\n\n    You can optionally `preload` specific attributes and relationships that you know of\n    by passing them via the passed `options`.\n\n    For example, if your Ember route looks like `/posts/1/comments/2` and your API route\n    for the comment also looks like `/posts/1/comments/2` if you want to fetch the comment\n    without also fetching the post you can pass in the post to the `findRecord` call:\n\n    ```app/routes/post-comments.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { preload: { post: post_id }} });\n      }\n    }\n    ```\n\n    In your adapter you can then access this id without triggering a network request via the\n    snapshot:\n\n    ```app/adapters/application.js\n    export default class Adapter {\n\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n\n        if (type === 'comment')\n          let postId = snapshot.belongsTo('post', { id: true });\n\n          return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n\n      static create() {\n        return new this();\n      }\n    }\n    ```\n\n    This could also be achieved by supplying the post id to the adapter via the adapterOptions\n    property on the options hash.\n\n    ```app/routes/post-comments.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { adapterOptions: { post: post_id }} });\n      }\n    }\n    ```\n\n    ```app/adapters/application.js\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n\n        if (type === 'comment')\n          let postId = snapshot.adapterOptions.post;\n\n          return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n\n      static create() {\n        return new this();\n      }\n    }\n    ```\n\n    If you have access to the post model you can also pass the model itself to preload:\n\n    ```javascript\n    let post = await store.findRecord('post', 1);\n    let comment = await store.findRecord('comment', 2, { post: myPostModel });\n    ```\n\n    ### Reloading\n\n    The reload behavior is configured either via the passed `options` hash or\n    the result of the adapter's `shouldReloadRecord`.\n\n    If `{ reload: true }` is passed or `adapter.shouldReloadRecord` evaluates\n    to `true`, then the returned promise resolves once the adapter returns\n    data, regardless if the requested record is already in the store:\n\n    ```js\n    store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n\n    // adapter#findRecord resolves with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n    store.findRecord('post', 1, { reload: true }).then(function(post) {\n      post.revision; // 2\n    });\n    ```\n\n    If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with the cached version in the store.\n\n    ### Background Reloading\n\n    Optionally, if `adapter.shouldBackgroundReloadRecord` evaluates to `true`,\n    then a background reload is started, which updates the records' data, once\n    it is available:\n\n    ```js\n    // app/adapters/post.js\n    import ApplicationAdapter from \"./application\";\n\n    export default class PostAdapter extends ApplicationAdapter {\n      shouldReloadRecord(store, snapshot) {\n        return false;\n      },\n\n      shouldBackgroundReloadRecord(store, snapshot) {\n        return true;\n      }\n    });\n\n    // ...\n\n    store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n\n    let blogPost = store.findRecord('post', 1).then(function(post) {\n      post.revision; // 1\n    });\n\n    // later, once adapter#findRecord resolved with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n\n    blogPost.revision; // 2\n    ```\n\n    If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findRecord`.\n\n    ```app/routes/post/edit.js\n    import Route from '@ember/routing/route';\n\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { backgroundReload: false });\n      }\n    }\n    ```\n\n    If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to your adapter via the snapshot\n\n    ```app/routes/post/edit.js\n    import Route from '@ember/routing/route';\n\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n\n    ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n\n    export default class PostAdapter extends MyCustomAdapter {\n      findRecord(store, type, id, snapshot) {\n        if (snapshot.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n\n    See [peekRecord](../methods/peekRecord?anchor=peekRecord) to get the cached version of a record.\n\n    ### Retrieving Related Model Records\n\n    If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findRecord()` or `findAll()` to automatically retrieve additional records related to\n    the one you request by supplying an `include` parameter in the `options` object.\n\n    For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve a specific post we can have the server also return that post's\n    comments in the same request:\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: 'comments' });\n      }\n    }\n    ```\n\n    ```app/adapters/application.js\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n\n        if (type === 'post')\n          let includes = snapshot.adapterOptions.include;\n\n          return fetch(`./posts/${postId}?include=${includes}`)\n            .then(response => response.json())\n        }\n      }\n\n      static create() {\n        return new this();\n      }\n    }\n    ```\n\n    In this case, the post's comments would then be available in your template as\n    `model.comments`.\n\n    Multiple relationships can be requested using an `include` parameter consisting of a\n    comma-separated list (without white-space) while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the post's\n    comments and the authors of those comments the request would look like this:\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: 'comments,comments.author' });\n      }\n    }\n    ```\n\n    ### Retrieving Specific Fields by Type\n\n    If your server endpoint supports the use of a ['fields' query parameter](https://jsonapi.org/format/#fetching-sparse-fieldsets),\n    you can use pass those fields through to your server.  At this point in time, this requires a few manual steps on your part.\n\n    1. Implement `buildQuery` in your adapter.\n\n    ```app/adapters/application.js\n    buildQuery(snapshot) {\n      let query = super.buildQuery(...arguments);\n\n      let { fields } = snapshot.adapterOptions;\n\n      if (fields) {\n        query.fields = fields;\n      }\n\n      return query;\n    }\n    ```\n\n    2. Then pass through the applicable fields to your `findRecord` request.\n\n    Given a `post` model with attributes body, title, publishDate and meta, you can retrieve a filtered list of attributes.\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n    export default Route.extend({\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title' } });\n      }\n    });\n    ```\n\n    Moreover, you can filter attributes on related models as well. If a `post` has a `belongsTo` relationship to a user,\n    just include the relationship key and attributes.\n\n    ```app/routes/post.js\n    import Route from '@ember/routing/route';\n    export default Route.extend({\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title', user: 'name,email' } });\n      }\n    });\n    ```\n\n    @since 1.13.0\n    @method findRecord\n    @public\n    @param {String|object} modelName - either a string representing the modelName or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {(String|Integer|Object)} id - optional object with options for the request only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved\n    @param {Object} [options] - if the first param is a string this will be the optional options for the request. See examples for available options.\n    @return {Promise} promise\n  */\n  findRecord(resource: string, id: string | number, options?: FindOptions): Promise<RecordInstance>;\n  findRecord(resource: ResourceIdentifierObject, id?: FindOptions): Promise<RecordInstance>;\n  findRecord(\n    resource: string | ResourceIdentifierObject,\n    id?: string | number | FindOptions,\n    options?: FindOptions\n  ): Promise<RecordInstance> {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'findRecord');\n    }\n\n    assert(\n      `You need to pass a modelName or resource identifier as the first argument to the store's findRecord method`,\n      resource\n    );\n    if (isMaybeIdentifier(resource)) {\n      options = id as FindOptions | undefined;\n    } else {\n      assert(\n        `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${resource}`,\n        typeof resource === 'string'\n      );\n      const type = normalizeModelName(resource);\n      const normalizedId = ensureStringId(id as string | number);\n      resource = constructResource(type, normalizedId);\n    }\n\n    const identifier = this.identifierCache.getOrCreateRecordIdentifier(resource);\n    options = options || {};\n\n    if (options.preload) {\n      // force reload if we preload to ensure we don't resolve the promise\n      // until we are complete, else we will end up background-reloading\n      // even for initial load.\n      if (!this._instanceCache.recordIsLoaded(identifier)) {\n        options.reload = true;\n      }\n      this._join(() => {\n        preloadData(this, identifier, options!.preload!);\n      });\n    }\n\n    const promise = this.request<RecordInstance>({\n      op: 'findRecord',\n      data: {\n        record: identifier,\n        options,\n      },\n      cacheOptions: { [SkipCache as symbol]: true },\n    });\n\n    return promise.then((document) => {\n      return document.content;\n    });\n  }\n\n  /**\n    Get the reference for the specified record.\n\n    Example\n\n    ```javascript\n    let userRef = store.getReference('user', 1);\n\n    // check if the user is loaded\n    let isLoaded = userRef.value() !== null;\n\n    // get the record of the reference (null if not yet available)\n    let user = userRef.value();\n\n    // get the identifier of the reference\n    if (userRef.remoteType() === 'id') {\n    let id = userRef.id();\n    }\n\n    // load user (via store.find)\n    userRef.load().then(...)\n\n    // or trigger a reload\n    userRef.reload().then(...)\n\n    // provide data for reference\n    userRef.push({ id: 1, username: '@user' }).then(function(user) {\n      userRef.value() === user;\n    });\n    ```\n\n    @method getReference\n    @public\n    @param {String|object} resource - modelName (string) or Identifier (object)\n    @param {String|Integer} id\n    @since 2.5.0\n    @return {RecordReference}\n  */\n  // TODO @deprecate getReference (and references generally)\n  getReference(resource: string | ResourceIdentifierObject, id: string | number): RecordReference {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'getReference');\n    }\n\n    let resourceIdentifier: ResourceIdentifierObject;\n    if (arguments.length === 1 && isMaybeIdentifier(resource)) {\n      resourceIdentifier = resource;\n    } else {\n      const type = normalizeModelName(resource as string);\n      const normalizedId = ensureStringId(id);\n      resourceIdentifier = constructResource(type, normalizedId);\n    }\n\n    assert(\n      'getReference expected to receive either a resource identifier or type and id as arguments',\n      isMaybeIdentifier(resourceIdentifier)\n    );\n\n    const identifier: StableRecordIdentifier = this.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);\n\n    return this._instanceCache.getReference(identifier);\n  }\n\n  /**\n    Get a record by a given type and ID without triggering a fetch.\n\n    This method will synchronously return the record if it is available in the store,\n    otherwise it will return `null`. A record is available if it has been fetched earlier, or\n    pushed manually into the store.\n\n    See [findRecord](../methods/findRecord?anchor=findRecord) if you would like to request this record from the backend.\n\n    _Note: This is a synchronous method and does not return a promise._\n\n    **Example 1**\n\n    ```js\n    let post = store.peekRecord('post', 1);\n\n    post.id; // 1\n    ```\n\n    `peekRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n\n    **Example 2**\n\n    ```js\n    let post = store.peekRecord({ type: 'post', id });\n    post.id; // 1\n    ```\n\n    If you have previously received an lid from an Identifier for this record, you can lookup the record again using\n    just the lid.\n\n    **Example 3**\n\n    ```js\n    let post = store.peekRecord({ lid });\n    post.id; // 1\n    ```\n\n\n    @since 1.13.0\n    @method peekRecord\n    @public\n    @param {String|object} modelName - either a string representing the modelName or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {String|Integer} id - optional only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved.\n    @return {Model|null} record\n  */\n  peekRecord<T = RecordInstance>(identifier: string, id: string | number): T | null;\n  peekRecord<T = RecordInstance>(identifier: ResourceIdentifierObject): T | null;\n  peekRecord<T = RecordInstance>(identifier: ResourceIdentifierObject | string, id?: string | number): T | null {\n    if (arguments.length === 1 && isMaybeIdentifier(identifier)) {\n      const stableIdentifier = this.identifierCache.peekRecordIdentifier(identifier);\n      const isLoaded = stableIdentifier && this._instanceCache.recordIsLoaded(stableIdentifier);\n      // TODO come up with a better mechanism for determining if we have data and could peek.\n      // this is basically an \"are we not empty\" query.\n      return isLoaded ? (this._instanceCache.getRecord(stableIdentifier) as T) : null;\n    }\n\n    if (DEBUG) {\n      assertDestroyingStore(this, 'peekRecord');\n    }\n\n    assert(`You need to pass a model name to the store's peekRecord method`, identifier);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(\n        identifier\n      )}`,\n      typeof identifier === 'string'\n    );\n\n    const type = normalizeModelName(identifier);\n    const normalizedId = ensureStringId(id);\n    const resource = { type, id: normalizedId };\n    const stableIdentifier = this.identifierCache.peekRecordIdentifier(resource);\n    const isLoaded = stableIdentifier && this._instanceCache.recordIsLoaded(stableIdentifier);\n\n    return isLoaded ? (this._instanceCache.getRecord(stableIdentifier) as T) : null;\n  }\n\n  /**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n\n    Each time this method is called a new request is made through the adapter.\n\n    Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n\n    ---\n\n    If you do something like this:\n\n    ```javascript\n    store.query('person', { page: 1 });\n    ```\n\n    The request made to the server will look something like this:\n\n    ```\n    GET \"/api/v1/person?page=1\"\n    ```\n\n    ---\n\n    If you do something like this:\n\n    ```javascript\n    store.query('person', { ids: [1, 2, 3] });\n    ```\n\n    The request made to the server will look something like this:\n\n    ```\n    GET \"/api/v1/person?ids%5B%5D=1&ids%5B%5D=2&ids%5B%5D=3\"\n    decoded: \"/api/v1/person?ids[]=1&ids[]=2&ids[]=3\"\n    ```\n\n    This method returns a promise, which is resolved with a\n    [`Collection`](/ember-data/release/classes/Collection)\n    once the server returns.\n\n    @since 1.13.0\n    @method query\n    @public\n    @param {String} modelName\n    @param {any} query an opaque query to be used by the adapter\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter.query\n    @return {Promise} promise\n  */\n  query(\n    modelName: string,\n    query: Record<string, unknown>,\n    options: { [key: string]: unknown; adapterOptions?: Record<string, unknown> }\n  ): Promise<Collection> {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'query');\n    }\n    assert(`You need to pass a model name to the store's query method`, modelName);\n    assert(`You need to pass a query hash to the store's query method`, query);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${modelName}`,\n      typeof modelName === 'string'\n    );\n\n    const promise = this.request<Collection>({\n      op: 'query',\n      data: {\n        type: normalizeModelName(modelName),\n        query,\n        options: options || {},\n      },\n      cacheOptions: { [SkipCache as symbol]: true },\n    });\n\n    return promise.then((document) => document.content);\n  }\n\n  /**\n    This method makes a request for one record, where the `id` is not known\n    beforehand (if the `id` is known, use [`findRecord`](../methods/findRecord?anchor=findRecord)\n    instead).\n\n    This method can be used when it is certain that the server will return a\n    single object for the primary data.\n\n    Each time this method is called a new request is made through the adapter.\n\n    Let's assume our API provides an endpoint for the currently logged in user\n    via:\n\n    ```\n    // GET /api/current_user\n    {\n      user: {\n        id: 1234,\n        username: 'admin'\n      }\n    }\n    ```\n\n    Since the specific `id` of the `user` is not known beforehand, we can use\n    `queryRecord` to get the user:\n\n    ```javascript\n    store.queryRecord('user', {}).then(function(user) {\n      let username = user.username;\n      // do thing\n    });\n    ```\n\n    The request is made through the adapters' `queryRecord`:\n\n    ```app/adapters/user.js\n    import Adapter from '@ember-data/adapter';\n    import $ from 'jquery';\n\n    export default class UserAdapter extends Adapter {\n      queryRecord(modelName, query) {\n        return $.getJSON('/api/current_user');\n      }\n    }\n    ```\n\n    Note: the primary use case for `store.queryRecord` is when a single record\n    is queried and the `id` is not known beforehand. In all other cases\n    `store.query` and using the first item of the array is likely the preferred\n    way:\n\n    ```\n    // GET /users?username=unique\n    {\n      data: [{\n        id: 1234,\n        type: 'user',\n        attributes: {\n          username: \"unique\"\n        }\n      }]\n    }\n    ```\n\n    ```javascript\n    store.query('user', { username: 'unique' }).then(function(users) {\n      return users.firstObject;\n    }).then(function(user) {\n      let id = user.id;\n    });\n    ```\n\n    This method returns a promise, which resolves with the found record.\n\n    If the adapter returns no data for the primary data of the payload, then\n    `queryRecord` resolves with `null`:\n\n    ```\n    // GET /users?username=unique\n    {\n      data: null\n    }\n    ```\n\n    ```javascript\n    store.queryRecord('user', { username: 'unique' }).then(function(user) {\n       // user is null\n    });\n    ```\n\n    @since 1.13.0\n    @method queryRecord\n    @public\n    @param {String} modelName\n    @param {any} query an opaque query to be used by the adapter\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter.queryRecord\n    @return {Promise} promise which resolves with the found record or `null`\n  */\n  queryRecord(\n    modelName: string,\n    query: Record<string, unknown>,\n    options?: QueryOptions\n  ): Promise<RecordInstance | null> {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'queryRecord');\n    }\n    assert(`You need to pass a model name to the store's queryRecord method`, modelName);\n    assert(`You need to pass a query hash to the store's queryRecord method`, query);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${modelName}`,\n      typeof modelName === 'string'\n    );\n\n    const promise = this.request<RecordInstance | null>({\n      op: 'queryRecord',\n      data: {\n        type: normalizeModelName(modelName),\n        query,\n        options: options || {},\n      },\n      cacheOptions: { [SkipCache as symbol]: true },\n    });\n\n    return promise.then((document) => document.content);\n  }\n\n  /**\n    `findAll` asks the adapter's `findAll` method to find the records for the\n    given type, and returns a promise which will resolve with all records of\n    this type present in the store, even if the adapter only returns a subset\n    of them.\n\n    ```app/routes/authors.js\n    import Route from '@ember/routing/route';\n\n    export default class AuthorsRoute extends Route {\n      model(params) {\n        return this.store.findAll('author');\n      }\n    }\n    ```\n\n    _When_ the returned promise resolves depends on the reload behavior,\n    configured via the passed `options` hash and the result of the adapter's\n    `shouldReloadAll` method.\n\n    ### Reloading\n\n    If `{ reload: true }` is passed or `adapter.shouldReloadAll` evaluates to\n    `true`, then the returned promise resolves once the adapter returns data,\n    regardless if there are already records in the store:\n\n    ```js\n    store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n\n    // adapter#findAll resolves with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n    store.findAll('author', { reload: true }).then(function(authors) {\n      authors.getEach('id'); // ['first', 'second']\n    });\n    ```\n\n    If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with all the records currently loaded in the store.\n\n    ### Background Reloading\n\n    Optionally, if `adapter.shouldBackgroundReloadAll` evaluates to `true`,\n    then a background reload is started. Once this resolves, the array with\n    which the promise resolves, is updated automatically so it contains all the\n    records in the store:\n\n    ```app/adapters/application.js\n    import Adapter from '@ember-data/adapter';\n\n    export default class ApplicationAdapter extends Adapter {\n      shouldReloadAll(store, snapshotsArray) {\n        return false;\n      },\n\n      shouldBackgroundReloadAll(store, snapshotsArray) {\n        return true;\n      }\n    });\n\n    // ...\n\n    store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n\n    let allAuthors;\n    store.findAll('author').then(function(authors) {\n      authors.getEach('id'); // ['first']\n\n      allAuthors = authors;\n    });\n\n    // later, once adapter#findAll resolved with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n\n    allAuthors.getEach('id'); // ['first', 'second']\n    ```\n\n    If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findAll`.\n\n    ```app/routes/post/edit.js\n    import Route from '@ember/routing/route';\n\n    export default class PostEditRoute extends Route {\n      model() {\n        return this.store.findAll('post', { backgroundReload: false });\n      }\n    }\n    ```\n\n    If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to you adapter via the `snapshotRecordArray`\n\n    ```app/routes/posts.js\n    import Route from '@ember/routing/route';\n\n    export default class PostsRoute extends Route {\n      model(params) {\n        return this.store.findAll('post', {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n\n    ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n\n    export default class UserAdapter extends MyCustomAdapter {\n      findAll(store, type, sinceToken, snapshotRecordArray) {\n        if (snapshotRecordArray.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n\n    See [peekAll](../methods/peekAll?anchor=peekAll) to get an array of current records in the\n    store, without waiting until a reload is finished.\n\n    ### Retrieving Related Model Records\n\n    If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findAll()` to automatically retrieve additional records related to\n    those requested by supplying an `include` parameter in the `options` object.\n\n    For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve all of the post records we can have the server also return\n    all of the posts' comments in the same request:\n\n    ```app/routes/posts.js\n    import Route from '@ember/routing/route';\n\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: 'comments' });\n      }\n    }\n    ```\n    Multiple relationships can be requested using an `include` parameter consisting of a\n    comma-separated list (without white-space) while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the posts'\n    comments and the authors of those comments the request would look like this:\n\n    ```app/routes/posts.js\n    import Route from '@ember/routing/route';\n\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: 'comments,comments.author' });\n      }\n    }\n    ```\n\n    See [query](../methods/query?anchor=query) to only get a subset of records from the server.\n\n    @since 1.13.0\n    @method findAll\n    @public\n    @param {String} modelName\n    @param {Object} options\n    @return {Promise} promise\n  */\n  findAll(modelName: string, options: { reload?: boolean; backgroundReload?: boolean } = {}): Promise<IdentifierArray> {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'findAll');\n    }\n    assert(`You need to pass a model name to the store's findAll method`, modelName);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${modelName}`,\n      typeof modelName === 'string'\n    );\n\n    const promise = this.request<IdentifierArray>({\n      op: 'findAll',\n      data: {\n        type: normalizeModelName(modelName),\n        options: options || {},\n      },\n      cacheOptions: { [SkipCache as symbol]: true },\n    });\n\n    return promise.then((document) => document.content);\n  }\n\n  /**\n    This method returns a filtered array that contains all of the\n    known records for a given type in the store.\n\n    Note that because it's just a filter, the result will contain any\n    locally created records of the type, however, it will not make a\n    request to the backend to retrieve additional records. If you\n    would like to request all the records from the backend please use\n    [store.findAll](../methods/findAll?anchor=findAll).\n\n    Also note that multiple calls to `peekAll` for a given type will always\n    return the same `RecordArray`.\n\n    Example\n\n    ```javascript\n    let localPosts = store.peekAll('post');\n    ```\n\n    @since 1.13.0\n    @method peekAll\n    @public\n    @param {String} modelName\n    @return {RecordArray}\n  */\n  peekAll(modelName: string): IdentifierArray {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'peekAll');\n    }\n    assert(`You need to pass a model name to the store's peekAll method`, modelName);\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${modelName}`,\n      typeof modelName === 'string'\n    );\n\n    const type = normalizeModelName(modelName);\n    return this.recordArrayManager.liveArrayFor(type);\n  }\n\n  /**\n    This method unloads all records in the store.\n    It schedules unloading to happen during the next run loop.\n\n    Optionally you can pass a type which unload all records for a given type.\n\n    ```javascript\n    store.unloadAll();\n    store.unloadAll('post');\n    ```\n\n    @method unloadAll\n    @public\n    @param {String} modelName\n  */\n  unloadAll(modelName?: string) {\n    if (DEBUG) {\n      assertDestroyedStoreOnly(this, 'unloadAll');\n    }\n    assert(\n      `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(\n        modelName\n      )}`,\n      !modelName || typeof modelName === 'string'\n    );\n\n    this._join(() => {\n      if (modelName === undefined) {\n        // destroy the graph before unloadAll\n        // since then we avoid churning relationships\n        // during unload\n        this._graph?.identifiers.clear();\n\n        this.recordArrayManager.clear();\n        this._instanceCache.clear();\n      } else {\n        const normalizedModelName = normalizeModelName(modelName);\n        this._instanceCache.clear(normalizedModelName);\n      }\n    });\n  }\n\n  /**\n    Push some data for a given type into the store.\n\n    This method expects normalized [JSON API](http://jsonapi.org/) document. This means you have to follow [JSON API specification](http://jsonapi.org/format/) with few minor adjustments:\n    - record's `type` should always be in singular, dasherized form\n    - members (properties) should be camelCased\n\n    [Your primary data should be wrapped inside `data` property](http://jsonapi.org/format/#document-top-level):\n\n    ```js\n    store.push({\n      data: {\n        // primary data for single record of type `Person`\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Daniel',\n          lastName: 'Kmak'\n        }\n      }\n    });\n    ```\n\n    [Demo.](http://ember-twiddle.com/fb99f18cd3b4d3e2a4c7)\n\n    `data` property can also hold an array (of records):\n\n    ```js\n    store.push({\n      data: [\n        // an array of records\n        {\n          id: '1',\n          type: 'person',\n          attributes: {\n            firstName: 'Daniel',\n            lastName: 'Kmak'\n          }\n        },\n        {\n          id: '2',\n          type: 'person',\n          attributes: {\n            firstName: 'Tom',\n            lastName: 'Dale'\n          }\n        }\n      ]\n    });\n    ```\n\n    [Demo.](http://ember-twiddle.com/69cdbeaa3702159dc355)\n\n    There are some typical properties for `JSONAPI` payload:\n    * `id` - mandatory, unique record's key\n    * `type` - mandatory string which matches `model`'s dasherized name in singular form\n    * `attributes` - object which holds data for record attributes - `attr`'s declared in model\n    * `relationships` - object which must contain any of the following properties under each relationships' respective key (example path is `relationships.achievements.data`):\n      - [`links`](http://jsonapi.org/format/#document-links)\n      - [`data`](http://jsonapi.org/format/#document-resource-object-linkage) - place for primary data\n      - [`meta`](http://jsonapi.org/format/#document-meta) - object which contains meta-information about relationship\n\n    For this model:\n\n    ```app/models/person.js\n    import Model, { attr, hasMany } from '@ember-data/model';\n\n    export default class PersonRoute extends Route {\n      @attr('string') firstName;\n      @attr('string') lastName;\n\n      @hasMany('person') children;\n    }\n    ```\n\n    To represent the children as IDs:\n\n    ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            data: [\n              {\n                id: '2',\n                type: 'person'\n              },\n              {\n                id: '3',\n                type: 'person'\n              },\n              {\n                id: '4',\n                type: 'person'\n              }\n            ]\n          }\n        }\n      }\n    }\n    ```\n\n    [Demo.](http://ember-twiddle.com/343e1735e034091f5bde)\n\n    To represent the children relationship as a URL:\n\n    ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            links: {\n              related: '/people/1/children'\n            }\n          }\n        }\n      }\n    }\n    ```\n\n    If you're streaming data or implementing an adapter, make sure\n    that you have converted the incoming data into this form. The\n    store's [normalize](../methods/normalize?anchor=normalize) method is a convenience\n    helper for converting a json payload into the form Ember Data\n    expects.\n\n    ```js\n    store.push(store.normalize('person', data));\n    ```\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    @method push\n    @public\n    @param {Object} data\n    @return the record(s) that was created or\n      updated.\n  */\n  push(data: EmptyResourceDocument): null;\n  push(data: SingleResourceDocument): RecordInstance;\n  push(data: CollectionResourceDocument): RecordInstance[];\n  push(data: JsonApiDocument): RecordInstance | RecordInstance[] | null {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'push');\n    }\n    const pushed = this._push(data, false);\n\n    if (Array.isArray(pushed)) {\n      return pushed.map((identifier) => this._instanceCache.getRecord(identifier));\n    }\n\n    if (pushed === null) {\n      return null;\n    }\n\n    return this._instanceCache.getRecord(pushed);\n  }\n\n  /**\n    Push some data in the form of a json-api document into the store,\n    without creating materialized records.\n\n    @method _push\n    @private\n    @param {Object} jsonApiDoc\n    @return {StableRecordIdentifier|Array<StableRecordIdentifier>|null} identifiers for the primary records that had data loaded\n  */\n  _push(\n    jsonApiDoc: JsonApiDocument,\n    asyncFlush?: boolean\n  ): StableExistingRecordIdentifier | StableExistingRecordIdentifier[] | null {\n    if (DEBUG) {\n      assertDestroyingStore(this, '_push');\n    }\n    if (LOG_PAYLOADS) {\n      try {\n        const data: unknown = JSON.parse(JSON.stringify(jsonApiDoc)) as unknown;\n        // eslint-disable-next-line no-console\n        console.log('EmberData | Payload - push', data);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log('EmberData | Payload - push', jsonApiDoc);\n      }\n    }\n    if (asyncFlush) {\n      this._enableAsyncFlush = true;\n    }\n\n    let ret!: ResourceDocument;\n    this._join(() => {\n      ret = this.cache.put({ content: jsonApiDoc });\n    });\n\n    this._enableAsyncFlush = null;\n\n    return 'data' in ret ? ret.data : null;\n  }\n\n  /**\n   * Trigger a save for a Record.\n   *\n   * @method saveRecord\n   * @public\n   * @param {RecordInstance} record\n   * @param options\n   * @return {Promise<RecordInstance>}\n   */\n  saveRecord(record: RecordInstance, options: Record<string, unknown> = {}): Promise<RecordInstance> {\n    if (DEBUG) {\n      assertDestroyingStore(this, 'saveRecord');\n    }\n    assert(`Unable to initate save for a record in a disconnected state`, storeFor(record));\n    const identifier = recordIdentifierFor(record);\n    const cache = this.cache;\n\n    if (!identifier) {\n      // this commonly means we're disconnected\n      // but just in case we reject here to prevent bad things.\n      return Promise.reject(new Error(`Record Is Disconnected`));\n    }\n    // TODO we used to check if the record was destroyed here\n    assert(\n      `Cannot initiate a save request for an unloaded record: ${identifier.lid}`,\n      this._instanceCache.recordIsLoaded(identifier)\n    );\n    if (resourceIsFullyDeleted(this._instanceCache, identifier)) {\n      return Promise.resolve(record);\n    }\n\n    if (!options) {\n      options = {};\n    }\n    let operation: 'createRecord' | 'deleteRecord' | 'updateRecord' = 'updateRecord';\n\n    if (cache.isNew(identifier)) {\n      operation = 'createRecord';\n    } else if (cache.isDeleted(identifier)) {\n      operation = 'deleteRecord';\n    }\n\n    const request = {\n      op: operation,\n      data: {\n        options,\n        record: identifier,\n      },\n      records: [identifier],\n      cacheOptions: { [SkipCache as symbol]: true },\n    };\n\n    // we lie here on the type because legacy doesn't have enough context\n    cache.willCommit(identifier, { request } as unknown as StoreRequestContext);\n\n    return this.request<RecordInstance>(request).then((document) => document.content);\n  }\n\n  /**\n   * Instantiation hook allowing applications or addons to configure the store\n   * to utilize a custom Cache implementation.\n   *\n   * This hook should not be called directly by consuming applications or libraries.\n   * Use `Store.cache` to access the Cache instance.\n   *\n   * @method createCache (hook)\n   * @public\n   * @param storeWrapper\n   * @return {Cache}\n   */\n\n  /**\n   * Returns the cache instance associated to this Store, instantiates the Cache\n   * if necessary via `Store.createCache`\n   *\n   * @property {Cache} cache\n   * @public\n   */\n  get cache(): Cache {\n    let { cache } = this._instanceCache;\n    if (!cache) {\n      cache = this._instanceCache.cache = this.createCache(this._instanceCache._storeWrapper);\n      if (DEBUG) {\n        cache = new CacheManager(cache);\n      }\n    }\n    return cache;\n  }\n\n  // @ts-expect-error\n  destroy(): void {\n    if (this.isDestroyed) {\n      // @ember/test-helpers will call destroy multiple times\n      return;\n    }\n    this.isDestroying = true;\n\n    this._graph?.destroy();\n    this._graph = undefined;\n\n    this.notifications.destroy();\n    this.recordArrayManager.destroy();\n    this.identifierCache.destroy();\n\n    this.unloadAll();\n    this.isDestroyed = true;\n  }\n\n  static create(args?: Record<string, unknown>) {\n    return new this(args);\n  }\n}\n\nexport default Store;\n\nlet assertDestroyingStore: (store: Store, method: string) => void;\nlet assertDestroyedStoreOnly: (store: Store, method: string) => void;\n\nif (DEBUG) {\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  assertDestroyingStore = function assertDestroyingStore(store: Store, method: string) {\n    assert(\n      `Attempted to call store.${method}(), but the store instance has already been destroyed.`,\n      !(store.isDestroying || store.isDestroyed)\n    );\n  };\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  assertDestroyedStoreOnly = function assertDestroyedStoreOnly(store: Store, method: string) {\n    assert(\n      `Attempted to call store.${method}(), but the store instance has already been destroyed.`,\n      !store.isDestroyed\n    );\n  };\n}\n\nfunction isMaybeIdentifier(\n  maybeIdentifier: string | ResourceIdentifierObject\n): maybeIdentifier is ResourceIdentifierObject {\n  return Boolean(\n    maybeIdentifier !== null &&\n      typeof maybeIdentifier === 'object' &&\n      (('id' in maybeIdentifier && 'type' in maybeIdentifier && maybeIdentifier.id && maybeIdentifier.type) ||\n        maybeIdentifier.lid)\n  );\n}\n\nfunction normalizeProperties(\n  store: Store,\n  identifier: StableRecordIdentifier,\n  properties?: { [key: string]: unknown }\n): { [key: string]: unknown } | undefined {\n  // assert here\n  if (properties !== undefined) {\n    if ('id' in properties) {\n      assert(`expected id to be a string or null`, properties.id !== undefined);\n    }\n    assert(\n      `You passed '${typeof properties}' as properties for record creation instead of an object.`,\n      typeof properties === 'object' && properties !== null\n    );\n\n    const { type } = identifier;\n\n    // convert relationship Records to RecordDatas before passing to RecordData\n    const defs = store.getSchemaDefinitionService().relationshipsDefinitionFor({ type });\n\n    if (defs !== null) {\n      const keys = Object.keys(properties);\n      let relationshipValue;\n\n      for (let i = 0; i < keys.length; i++) {\n        const prop = keys[i];\n        const def = defs[prop];\n\n        if (def !== undefined) {\n          if (def.kind === 'hasMany') {\n            if (DEBUG) {\n              assertRecordsPassedToHasMany(properties[prop] as RecordInstance[]);\n            }\n            relationshipValue = extractIdentifiersFromRecords(properties[prop] as RecordInstance[]);\n          } else {\n            relationshipValue = extractIdentifierFromRecord(properties[prop]);\n          }\n\n          properties[prop] = relationshipValue;\n        }\n      }\n    }\n  }\n  return properties;\n}\n\nfunction assertRecordsPassedToHasMany(records: RecordInstance[]) {\n  assert(`You must pass an array of records to set a hasMany relationship`, Array.isArray(records));\n  assert(\n    `All elements of a hasMany relationship must be instances of Model, you passed ${records\n      .map((r) => `${typeof r}`)\n      .join(', ')}`,\n    (function () {\n      return records.every((record) => {\n        try {\n          recordIdentifierFor(record);\n          return true;\n        } catch {\n          return false;\n        }\n      });\n    })()\n  );\n}\n\nfunction extractIdentifiersFromRecords(records: RecordInstance[]): StableRecordIdentifier[] {\n  return records.map((record) => extractIdentifierFromRecord(record)) as StableRecordIdentifier[];\n}\n\ntype PromiseProxyRecord = { then(): void; content: RecordInstance | null | undefined };\n\nfunction extractIdentifierFromRecord(recordOrPromiseRecord: PromiseProxyRecord | RecordInstance | null) {\n  if (!recordOrPromiseRecord) {\n    return null;\n  }\n  const extract = recordIdentifierFor;\n\n  return extract(recordOrPromiseRecord);\n}\n","/**\n * @module @ember-data/store\n */\nimport { assert } from '@ember/debug';\n\nimport { defineSignal } from '@ember-data/tracking/-private';\nimport type { StableDocumentIdentifier } from '@warp-drive/core-types/identifier';\nimport type { RequestInfo } from '@warp-drive/core-types/request';\nimport type { Link, Meta, PaginationLinks } from '@warp-drive/core-types/spec/raw';\n\nimport type Store from './store-service';\n\nfunction urlFromLink(link: Link): string {\n  if (typeof link === 'string') return link;\n  return link.href;\n}\n\n/**\n * A Document is a class that wraps the response content from a request to the API\n * returned by `Cache.put` or `Cache.peek`, converting resource-identifiers into\n * record instances.\n *\n * It is not directly instantiated by the user, and its properties should not\n * be directly modified. Whether individual properties are mutable or not is\n * determined by the record instance itself.\n *\n * @public\n * @class Document\n */\nexport class Document<T> {\n  /**\n   * The links object for this document, if any\n   *\n   * e.g.\n   *\n   * ```\n   * {\n   *   self: '/articles?page[number]=3',\n   * }\n   * ```\n   *\n   * @property links\n   * @type {object|undefined} - a links object\n   * @public\n   */\n  declare links?: PaginationLinks;\n  /**\n   * The primary data for this document, if any.\n   *\n   * If this document has no primary data (e.g. because it is an error document)\n   * this property will be `undefined`.\n   *\n   * For collections this will be an array of record instances,\n   * for single resource requests it will be a single record instance or null.\n   *\n   * @property data\n   * @public\n   * @type {object|Array<object>|null|undefined} - a data object\n   */\n  declare data?: T;\n\n  /**\n   * The errors returned by the API for this request, if any\n   *\n   * @property errors\n   * @public\n   * @type {object|undefined} - an errors object\n   */\n  declare errors?: object[];\n\n  /**\n   * The meta object for this document, if any\n   *\n   * @property meta\n   * @public\n   * @type {object|undefined} - a meta object\n   */\n  declare meta?: Meta;\n\n  /**\n   * The identifier associated with this document, if any\n   *\n   * @property identifier\n   * @public\n   * @type {StableDocumentIdentifier|null}\n   */\n  declare identifier: StableDocumentIdentifier | null;\n\n  #store: Store;\n  constructor(store: Store, identifier: StableDocumentIdentifier | null) {\n    this.#store = store;\n    this.identifier = identifier;\n  }\n\n  async #request(link: keyof PaginationLinks, options: Partial<RequestInfo>): Promise<Document<T> | null> {\n    const href = this.links?.[link];\n    if (!href) {\n      return null;\n    }\n\n    options.method = options.method || 'GET';\n    const response = await this.#store.request<Document<T>>(Object.assign(options, { url: urlFromLink(href) }));\n\n    return response.content;\n  }\n\n  /**\n   * Fetches the related link for this document, returning a promise that resolves\n   * with the document when the request completes. If no related link is present,\n   * will fallback to the self link if present\n   *\n   * @method fetch\n   * @public\n   * @param {object} options\n   * @return Promise<Document>\n   */\n  fetch(options: Partial<RequestInfo> = {}): Promise<Document<T>> {\n    assert(`No self or related link`, this.links?.related || this.links?.self);\n    options.cacheOptions = options.cacheOptions || {};\n    options.cacheOptions.key = this.identifier?.lid;\n    return this.#request(this.links.related ? 'related' : 'self', options) as Promise<Document<T>>;\n  }\n\n  /**\n   * Fetches the next link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null  if there is no\n   * next link.\n   *\n   * @method next\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */\n  next(options: Partial<RequestInfo> = {}): Promise<Document<T> | null> {\n    return this.#request('next', options);\n  }\n\n  /**\n   * Fetches the prev link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * prev link.\n   *\n   * @method prev\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */\n  prev(options: Partial<RequestInfo> = {}): Promise<Document<T> | null> {\n    return this.#request('prev', options);\n  }\n\n  /**\n   * Fetches the first link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * first link.\n   *\n   * @method first\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */\n  first(options: Partial<RequestInfo> = {}): Promise<Document<T> | null> {\n    return this.#request('first', options);\n  }\n\n  /**\n   * Fetches the last link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * last link.\n   *\n   * @method last\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */\n  last(options: Partial<RequestInfo> = {}): Promise<Document<T> | null> {\n    return this.#request('last', options);\n  }\n\n  /**\n   * Implemented for `JSON.stringify` support.\n   *\n   * Returns the JSON representation of the document wrapper.\n   *\n   * This is a shallow serialization, it does not deeply serialize\n   * the document's contents, leaving that to the individual record\n   * instances to determine how to do, if at all.\n   *\n   * @method toJSON\n   * @public\n   * @return\n   */\n  toJSON(): object {\n    const data: Partial<Document<T>> = {};\n    data.identifier = this.identifier;\n    if (this.data !== undefined) {\n      data.data = this.data;\n    }\n    if (this.links !== undefined) {\n      data.links = this.links;\n    }\n    if (this.errors !== undefined) {\n      data.errors = this.errors;\n    }\n    if (this.meta !== undefined) {\n      data.meta = this.meta;\n    }\n    return data;\n  }\n}\n\ndefineSignal(Document.prototype, 'data');\ndefineSignal(Document.prototype, 'links');\ndefineSignal(Document.prototype, 'errors');\ndefineSignal(Document.prototype, 'meta');\n","/**\n * @module @ember-data/store\n */\nimport { assert } from '@ember/debug';\n\nimport type { Future, Handler, NextFn } from '@ember-data/request/-private/types';\nimport type { StableDocumentIdentifier } from '@warp-drive/core-types/identifier';\nimport type {\n  ImmutableCreateRequestOptions,\n  ImmutableDeleteRequestOptions,\n  ImmutableRequestInfo,\n  ImmutableUpdateRequestOptions,\n  RequestContext,\n  ResponseInfo,\n  StructuredDataDocument,\n  StructuredErrorDocument,\n} from '@warp-drive/core-types/request';\nimport { EnableHydration, SkipCache } from '@warp-drive/core-types/request';\nimport type {\n  CollectionResourceDataDocument,\n  ResourceDataDocument,\n  ResourceErrorDocument,\n} from '@warp-drive/core-types/spec/document';\nimport type { ApiError } from '@warp-drive/core-types/spec/error';\nimport type { ResourceIdentifierObject } from '@warp-drive/core-types/spec/raw';\n\nimport type { RecordInstance } from '../-types/q/record-instance';\nimport { Document } from './document';\nimport type Store from './store-service';\n\n/**\n * A service which an application may provide to the store via\n * the store's `lifetimes` property to configure the behavior\n * of the CacheHandler.\n *\n * The default behavior for request lifetimes is to never expire\n * unless manually refreshed via `cacheOptions.reload` or `cacheOptions.backgroundReload`.\n *\n * Implementing this service allows you to programatically define\n * when a request should be considered expired.\n *\n * @class <Interface> LifetimesService\n * @public\n */\nexport interface LifetimesService {\n  /**\n   * Invoked to determine if the request may be fulfilled from cache\n   * if possible.\n   *\n   * Note, this is only invoked if the request has a cache-key.\n   *\n   * If no cache entry is found or the entry is hard expired,\n   * the request will be fulfilled from the configured request handlers\n   * and the cache will be updated before returning the response.\n   *\n   * @method isHardExpired\n   * @public\n   * @param {StableDocumentIdentifier} identifier\n   * @param {Store} store\n   * @return {boolean} true if the request is considered hard expired\n   */\n  isHardExpired(identifier: StableDocumentIdentifier, store: Store): boolean;\n  /**\n   * Invoked if `isHardExpired` is false to determine if the request\n   * should be update behind the scenes if cache data is already available.\n   *\n   * Note, this is only invoked if the request has a cache-key.\n   *\n   * If true, the request will be fulfilled from cache while a backgrounded\n   * request is made to update the cache via the configured request handlers.\n   *\n   * @method isSoftExpired\n   * @public\n   * @param {StableDocumentIdentifier} identifier\n   * @param {Store} store\n   * @return {boolean} true if the request is considered soft expired\n   */\n  isSoftExpired(identifier: StableDocumentIdentifier, store: Store): boolean;\n\n  /**\n   * Invoked when a request will be sent to the configured request handlers.\n   * This is invoked for both foreground and background requests.\n   *\n   * Note, this is invoked regardless of whether the request has a cache-key.\n   *\n   * @method willRequest [Optional]\n   * @public\n   * @param {ImmutableRequestInfo} request\n   * @param {StableDocumentIdentifier | null} identifier\n   * @param {Store} store\n   * @return {void}\n   */\n  willRequest?(request: ImmutableRequestInfo, identifier: StableDocumentIdentifier | null, store: Store): void;\n\n  /**\n   * Invoked when a request has been fulfilled from the configured request handlers.\n   * This is invoked for both foreground and background requests once the cache has\n   * been updated.\n   *\n   * Note, this is invoked regardless of whether the request has a cache-key.\n   *\n   * @method didRequest [Optional]\n   * @public\n   * @param {ImmutableRequestInfo} request\n   * @param {ImmutableResponse} response\n   * @param {StableDocumentIdentifier | null} identifier\n   * @param {Store} store\n   * @return {void}\n   */\n  didRequest?(\n    request: ImmutableRequestInfo,\n    response: Response | ResponseInfo | null,\n    identifier: StableDocumentIdentifier | null,\n    store: Store\n  ): void;\n}\n\nexport type StoreRequestInfo = ImmutableRequestInfo;\nexport type LooseStoreRequestInfo = Omit<StoreRequestInfo, 'records' | 'headers'> & {\n  records?: ResourceIdentifierObject[];\n  headers?: Headers;\n};\n\nexport type StoreRequestInput = StoreRequestInfo | LooseStoreRequestInfo;\n\nexport interface StoreRequestContext extends RequestContext {\n  request: StoreRequestInfo & { store: Store; [EnableHydration]?: boolean };\n}\n\nconst MUTATION_OPS = new Set(['createRecord', 'updateRecord', 'deleteRecord']);\n\nfunction isErrorDocument(document: ResourceDataDocument | ResourceErrorDocument): document is ResourceErrorDocument {\n  return 'errors' in document;\n}\n\nfunction maybeUpdateUiObjects<T>(\n  store: Store,\n  request: StoreRequestInfo,\n  options: {\n    shouldHydrate?: boolean;\n    shouldFetch?: boolean;\n    shouldBackgroundFetch?: boolean;\n    identifier: StableDocumentIdentifier | null;\n  },\n  document: ResourceDataDocument | ResourceErrorDocument,\n  isFromCache: boolean\n): T {\n  const { identifier } = options;\n\n  if (isErrorDocument(document)) {\n    if (!identifier && !options.shouldHydrate) {\n      return document as T;\n    }\n    let doc: Document<undefined> | undefined;\n    if (identifier) {\n      doc = store._documentCache.get(identifier) as Document<undefined> | undefined;\n    }\n\n    if (!doc) {\n      doc = new Document<undefined>(store, identifier);\n      copyDocumentProperties(doc, document);\n\n      if (identifier) {\n        store._documentCache.set(identifier, doc);\n      }\n    } else if (!isFromCache) {\n      doc.data = undefined;\n      copyDocumentProperties(doc, document);\n    }\n\n    return options.shouldHydrate ? (doc as T) : (document as T);\n  }\n\n  if (Array.isArray(document.data)) {\n    const { recordArrayManager } = store;\n    if (!identifier) {\n      if (!options.shouldHydrate) {\n        return document as T;\n      }\n      const data = recordArrayManager.createArray({\n        type: request.url,\n        identifiers: document.data,\n        doc: document as CollectionResourceDataDocument,\n        query: request,\n      }) as T;\n\n      const doc = new Document(store, null);\n      doc.data = data;\n      doc.meta = document.meta;\n      doc.links = document.links;\n\n      return doc as T;\n    }\n    let managed = recordArrayManager._keyedArrays.get(identifier.lid);\n\n    if (!managed) {\n      managed = recordArrayManager.createArray({\n        type: identifier.lid,\n        identifiers: document.data,\n        doc: document as CollectionResourceDataDocument,\n      });\n      recordArrayManager._keyedArrays.set(identifier.lid, managed);\n      const doc = new Document<RecordInstance[]>(store, identifier);\n      doc.data = managed;\n      doc.meta = document.meta;\n      doc.links = document.links;\n      store._documentCache.set(identifier, doc);\n\n      return options.shouldHydrate ? (doc as T) : (document as T);\n    } else {\n      const doc = store._documentCache.get(identifier)!;\n      if (!isFromCache) {\n        recordArrayManager.populateManagedArray(managed, document.data, document as CollectionResourceDataDocument);\n        doc.data = managed;\n        doc.meta = document.meta;\n        doc.links = document.links;\n      }\n\n      return options.shouldHydrate ? (doc as T) : (document as T);\n    }\n  } else {\n    if (!identifier && !options.shouldHydrate) {\n      return document as T;\n    }\n    const data = document.data ? store.peekRecord(document.data) : null;\n    let doc: Document<RecordInstance | null> | undefined;\n    if (identifier) {\n      doc = store._documentCache.get(identifier);\n    }\n\n    if (!doc) {\n      doc = new Document<RecordInstance | null>(store, identifier);\n      doc.data = data;\n      copyDocumentProperties(doc, document);\n\n      if (identifier) {\n        store._documentCache.set(identifier, doc);\n      }\n    } else if (!isFromCache) {\n      doc.data = data;\n      copyDocumentProperties(doc, document);\n    }\n\n    return options.shouldHydrate ? (doc as T) : (document as T);\n  }\n}\n\nfunction calcShouldFetch(\n  store: Store,\n  request: StoreRequestInfo,\n  hasCachedValue: boolean,\n  identifier: StableDocumentIdentifier | null\n): boolean {\n  const { cacheOptions } = request;\n  return (\n    (request.op && MUTATION_OPS.has(request.op)) ||\n    cacheOptions?.reload ||\n    !hasCachedValue ||\n    (store.lifetimes && identifier ? store.lifetimes.isHardExpired(identifier, store) : false)\n  );\n}\n\nfunction calcShouldBackgroundFetch(\n  store: Store,\n  request: StoreRequestInfo,\n  willFetch: boolean,\n  identifier: StableDocumentIdentifier | null\n): boolean {\n  const { cacheOptions } = request;\n  return (\n    !willFetch &&\n    (cacheOptions?.backgroundReload ||\n      (store.lifetimes && identifier ? store.lifetimes.isSoftExpired(identifier, store) : false))\n  );\n}\n\nfunction isMutation(\n  request: Partial<StoreRequestInfo>\n): request is ImmutableUpdateRequestOptions | ImmutableCreateRequestOptions | ImmutableDeleteRequestOptions {\n  return Boolean(request.op && MUTATION_OPS.has(request.op));\n}\n\nfunction fetchContentAndHydrate<T>(\n  next: NextFn<T>,\n  context: StoreRequestContext,\n  identifier: StableDocumentIdentifier | null,\n  shouldFetch: boolean,\n  shouldBackgroundFetch: boolean\n): Promise<T> {\n  const { store } = context.request;\n  const shouldHydrate: boolean = (context.request[EnableHydration] as boolean | undefined) || false;\n\n  let isMut = false;\n  if (isMutation(context.request)) {\n    isMut = true;\n    // TODO should we handle multiple records in request.records by iteratively calling willCommit for each\n    const record = context.request.data?.record || context.request.records?.[0];\n    assert(`Expected to receive a list of records included in the ${context.request.op} request`, record);\n    store.cache.willCommit(record, context);\n  }\n\n  if (store.lifetimes?.willRequest) {\n    store.lifetimes.willRequest(context.request, identifier, store);\n  }\n\n  const promise = next(context.request).then(\n    (document) => {\n      store.requestManager._pending.delete(context.id);\n      store._enableAsyncFlush = true;\n      let response: ResourceDataDocument;\n      store._join(() => {\n        if (isMutation(context.request)) {\n          const record = context.request.data?.record || context.request.records?.[0];\n          response = store.cache.didCommit(record, document) as ResourceDataDocument;\n        } else {\n          response = store.cache.put(document) as ResourceDataDocument;\n        }\n        response = maybeUpdateUiObjects(\n          store,\n          context.request,\n          { shouldHydrate, shouldFetch, shouldBackgroundFetch, identifier },\n          response,\n          false\n        );\n      });\n      store._enableAsyncFlush = null;\n\n      if (store.lifetimes?.didRequest) {\n        store.lifetimes.didRequest(context.request, document.response, identifier, store);\n      }\n\n      if (shouldFetch) {\n        return response!;\n      } else if (shouldBackgroundFetch) {\n        store.notifications._flush();\n      }\n    },\n    (error: StructuredErrorDocument) => {\n      store.requestManager._pending.delete(context.id);\n      if (context.request.signal?.aborted) {\n        throw error;\n      }\n      store.requestManager._pending.delete(context.id);\n      store._enableAsyncFlush = true;\n      let response: ResourceErrorDocument | undefined;\n      store._join(() => {\n        if (isMutation(context.request)) {\n          // TODO similar to didCommit we should spec this to be similar to cache.put for handling full response\n          // currently we let the response remain undefiend.\n          const errors =\n            error &&\n            error.content &&\n            typeof error.content === 'object' &&\n            'errors' in error.content &&\n            Array.isArray(error.content.errors)\n              ? (error.content.errors as ApiError[])\n              : undefined;\n\n          const record = context.request.data?.record || context.request.records?.[0];\n\n          store.cache.commitWasRejected(record, errors);\n          // re-throw the original error to preserve `errors` property.\n          throw error;\n        } else {\n          response = store.cache.put(error) as ResourceErrorDocument;\n          response = maybeUpdateUiObjects(\n            store,\n            context.request,\n            { shouldHydrate, shouldFetch, shouldBackgroundFetch, identifier },\n            response,\n            false\n          );\n        }\n      });\n      store._enableAsyncFlush = null;\n\n      if (identifier && store.lifetimes?.didRequest) {\n        store.lifetimes.didRequest(context.request, error.response, identifier, store);\n      }\n\n      if (!shouldBackgroundFetch) {\n        const newError = cloneError(error);\n        newError.content = response;\n        throw newError;\n      } else {\n        store.notifications._flush();\n      }\n    }\n  ) as Promise<T>;\n\n  if (!isMut) {\n    return promise;\n  }\n  assert(`Expected a mutation`, isMutation(context.request));\n\n  // for mutations we need to enqueue the promise with the requestStateService\n  // TODO should we enque a request per record in records?\n  const record = context.request.data?.record || context.request.records?.[0];\n\n  return store._requestCache._enqueue(promise, {\n    data: [{ op: 'saveRecord', recordIdentifier: record, options: undefined }],\n  });\n}\n\nfunction cloneError(error: Error & { error: string | object }) {\n  const cloned: Error & { error: string | object; content?: object } = new Error(error.message) as Error & {\n    error: string | object;\n    content?: object;\n  };\n  cloned.stack = error.stack;\n  cloned.error = error.error;\n  return cloned;\n}\n\nexport const CacheHandler: Handler = {\n  request<T>(context: StoreRequestContext, next: NextFn<T>): Promise<T | StructuredDataDocument<T>> | Future<T> {\n    // if we have no cache or no cache-key skip cache handling\n    if (!context.request.store || context.request.cacheOptions?.[SkipCache]) {\n      return next(context.request);\n    }\n\n    const { store } = context.request;\n    const identifier = store.identifierCache.getOrCreateDocumentIdentifier(context.request);\n\n    const peeked = identifier ? store.cache.peekRequest(identifier) : null;\n\n    // determine if we should skip cache\n    if (calcShouldFetch(store, context.request, !!peeked, identifier)) {\n      return fetchContentAndHydrate(next, context, identifier, true, false);\n    }\n\n    // if we have not skipped cache, determine if we should update behind the scenes\n    if (calcShouldBackgroundFetch(store, context.request, false, identifier)) {\n      const promise = fetchContentAndHydrate(next, context, identifier, false, true);\n      store.requestManager._pending.set(context.id, promise);\n    }\n\n    const shouldHydrate: boolean = (context.request[EnableHydration] as boolean | undefined) || false;\n\n    if ('error' in peeked!) {\n      const content = shouldHydrate\n        ? maybeUpdateUiObjects<T>(\n            store,\n            context.request,\n            { shouldHydrate, identifier },\n            peeked.content as ResourceErrorDocument,\n            true\n          )\n        : peeked.content;\n      const newError = cloneError(peeked);\n      newError.content = content as object;\n      throw newError;\n    }\n\n    return Promise.resolve(\n      shouldHydrate\n        ? maybeUpdateUiObjects<T>(\n            store,\n            context.request,\n            { shouldHydrate, identifier },\n            peeked!.content as ResourceDataDocument,\n            true\n          )\n        : (peeked!.content as T)\n    );\n  },\n};\n\nfunction copyDocumentProperties(target: { links?: unknown; meta?: unknown; errors?: unknown }, source: object) {\n  if ('links' in source) {\n    target.links = source.links;\n  }\n  if ('meta' in source) {\n    target.meta = source.meta;\n  }\n  if ('errors' in source) {\n    target.errors = source.errors;\n  }\n}\n"],"names":["coerceId","id","macroCondition","getOwnConfig","deprecations","DEPRECATE_NON_STRICT_ID","normalized","undefined","String","deprecate","JSON","stringify","until","for","since","available","enabled","assert","length","ensureStringId","isNaN","normalizeModelName","type","DEPRECATE_NON_STRICT_TYPES","result","dasherize","installPolyfill","isFastBoot","FastBoot","CRYPTO","require","window","crypto","randomUUID","rng","rnds8","Uint8Array","getRandomValues","Error","randomFillSync","byteToHex","i","toString","substr","bytesToUuid","buf","bth","join","uuidv4","rnds","isResource","resource","Boolean","hasProp","prop","hasLid","hasId","hasType","IDENTIFIERS","Set","DOCUMENTS","isStableIdentifier","identifier","CACHE_OWNER","has","isDocumentIdentifier","_crypto","polyfillUUID","freeze","obj","Object","configuredForgetMethod","configuredGenerationMethod","configuredResetMethod","configuredUpdateMethod","setIdentifierGenerationMethod","method","setIdentifierUpdateMethod","setIdentifierForgetMethod","setIdentifierResetMethod","NEW_IDENTIFIERS","Map","IDENTIFIER_CACHE_ID","updateTypeIdMapping","typeMap","idMap","get","set","lid","defaultUpdateMethod","data","bucket","defaultKeyInfoMethod","known","defaultGenerationMethod","url","toUpperCase","defaultEmptyCallback","args","defaultMergeMethod","a","_b","_c","DEBUG_MAP","env","DEBUG","WeakMap","IdentifierCache","constructor","_generate","_update","_forget","_reset","_merge","_keyInfoForResource","_isDefaultConfig","_id","_cache","resources","resourcesByType","create","documents","polymorphicLidBackMap","__configureMerge","upgradeIdentifier","_getRecordIdentifier","shouldGenerate","debug","LOG_IDENTIFIERS","console","groupCollapsed","log","groupEnd","getIdentifierFromLid","makeStableRecordIdentifier","keyInfo","addResourceToCache","peekRecordIdentifier","getOrCreateDocumentIdentifier","request","cacheKey","cacheOptions","key","add","getOrCreateRecordIdentifier","createIdentifierForNewRecord","newLid","updateRecordIdentifier","identifierObject","existingIdentifier","detectMerge","hadLid","generatedIdentifier","_mergeRecordIdentifiers","performRecordIdentifierUpdate","newId","typeSet","delete","kept","abandoned","abandonedBackReferences","forgetRecordIdentifier","keptBackReferences","push","forEach","backReferences","DEBUG_STALE_CACHE_OWNER","destroy","clear","recordIdentifier","clientOriginated","wrapper","value","defineProperty","enumerable","DEBUG_CLIENT_ORIGINATED","DEBUG_IDENTIFIER_BUCKET","updateFn","warn","cache","newType","newTypeSet","RecordReference","store","___token","___identifier","notifications","subscribe","_","notifiedKey","_ref","unsubscribe","remoteType","objectOrPromise","Promise","resolve","then","peekRecord","load","findRecord","reload","defineSignal","prototype","CacheCapabilitiesManager","_store","_willNotify","_pendingNotifies","identifierCache","_scheduleNotification","pending","_cbs","_schedule","_flushNotifications","notify","notifyChange","namespace","getSchemaDefinitionService","schema","setRecordId","_instanceCache","hasRecord","peek","disconnectRecord","disconnect","CacheForIdentifierCache","setCacheFor","removeRecordDataFor","peekCache","instance","isDestroyable","record","RecordCache","recordIdentifierFor","setRecordIdentifier","StoreMap","storeFor","InstanceCache","__instances","reference","_storeWrapper","matchedIdentifier","resourceData","keptIdentifier","staleIdentifier","keptHasRecord","staleHasRecord","patch","op","unloadRecord","getRecord","properties","isDestroying","isDestroyed","instantiateRecord","LOG_INSTANCE_CACHE","getReference","recordIsLoaded","filterDeleted","isNew","isEmpty","isDeleted","isDeletionCommitted","_graph","remove","_requestCache","_clearEntries","requests","getRequestStateService","getPendingRequestsForRecord","some","req","_join","teardownRecord","typeCache","identifiers","oldId","_resourceIsFullDeleted","resourceIsFullyDeleted","instanceCache","preloadData","preload","jsonPayload","schemas","relationships","relationshipsDefinitionFor","keys","preloadValue","relationshipMeta","preloadRelationship","attributes","upsert","relatedType","kind","Array","isArray","map","_convertPreloadRelationshipToJSON","_clearCaches","AvailableShims","getShimClass","modelName","shims","shim","ShimModelClass","mapFromHash","hash","hasOwnProperty","call","__store","fields","attrs","attributesDefinitionFor","relationshipsByName","eachAttribute","callback","binding","attrDefs","eachRelationship","relationshipDefs","eachTransformedAttribute","_classPrivateFieldBase","receiver","privateKey","TypeError","_classPrivateFieldKey","name","CacheManager","version","writable","_classPrivateFieldLooseBase","put","doc","mutate","mutation","peekRequest","fork","merge","diff","dump","hydrate","stream","clientDidCreate","options","willCommit","context","didCommit","commitWasRejected","errors","getAttr","propertyName","setAttr","changedAttrs","hasChangedAttrs","rollbackAttrs","changedRelationships","hasChangedRelationships","rollbackRelationships","getRelationship","setIsDeleted","getErrors","tokenId","CacheOperations","isCacheOperationValue","runLoopIsFlushing","_backburner","currentInstance","_autorun","_unsubscribe","tokens","token","LOG_NOTIFICATIONS","NotificationManager","_buffered","_hasFlush","_tokens","unsubToken","_tokenRef","hasSubscribers","size","buffer","_scheduleNotify","_onNextFlush","cb","_onFlushCB","asyncFlush","_enableAsyncFlush","_flush","states","_flushNotification","callbackMap","_applyDecoratedDescriptor","target","property","decorators","descriptor","desc","configurable","initializer","slice","reverse","reduce","decorator","ARRAY_GETTER_METHODS","Symbol","iterator","ARRAY_SETTER_METHODS","SYNC_PROPS","isArrayGetter","isArraySetter","isSelfProp","self","ARRAY_SIGNAL","SOURCE","MUTATE","NOTIFY","IS_COLLECTION","notifyArray","arr","addToTransaction","convertToInt","num","Number","safeForEach","index","IdentifierArray","_class","isLoaded","_updatingPromise","_manager","manager","createSignal","boundFns","_SIGNAL","PrivateState","links","meta","transaction","proxy","Proxy","shouldReset","_syncArray","t","fn","arguments","Reflect","apply","allowMutation","outcome","original","newIdentifier","extractIdentifierFromRecord","deleteProperty","getPrototypeOf","createArrayTags","bind","update","isUpdating","updatingPromise","finally","findAll","save","promise","all","saveRecord","compat","getOwnPropertyDescriptor","Collection","query","_recordArray","_managed","_pending","assertRecordPassedToHasMany","FAKE_ARR","SLICE_BATCH_SIZE","fastPush","source","startLength","newLength","RecordArrayManager","_live","_staged","_keyedArrays","_identifiers","_set","_visibilitySet","_subscription","identifierAdded","identifierRemoved","identifierChanged","array","sync","liveArrayFor","staged","createArray","config","associate","dirtyArray","delta","tag","addTransactionCB","_getPendingFor","includeManaged","isRemove","liveArray","allPending","managed","changes","pendingLive","populateManagedArray","payload","old","disassociate","changeSets","existing","newState","isClear","ArraysCache","disassociateIdentifier","arraySet","state","adds","removes","indexOf","splice","Touching","RequestPromise","EMPTY_ARR","hasRecordIdentifier","RequestStateService","_done","_subscriptions","_toFlush","_enqueue","queryRequest","_triggerSubscriptions","_dequeue","finalizedRequest","response","_addDone","error","_flushRequest","subscriptions","filter","requestDataOp","subscribeForRecord","getLastRequestForRecord","isNonEmptyString","str","constructResource","trueId","Store","EmberObject","_isDestroying","_isDestroyed","createArgs","assign","recordArrayManager","_documentCache","_run","coalesce","_getAllPending","TESTING","v","requestManager","allSettled","requestConfig","opts","EnableHydration","records","r","DISABLE_WAITER","disableTestWaiter","LOG_REQUESTS","parse","future","onFinalize","_schema","registerSchemaDefinitionService","registerSchema","modelFor","assertDestroyedStoreOnly","doesTypeExist","createRecord","inputProperties","assertDestroyingStore","normalizedModelName","adapter","adapterFor","generateIdForRecord","createOptions","normalizeProperties","resultProps","deleteRecord","isMaybeIdentifier","normalizedId","SkipCache","document","content","resourceIdentifier","stableIdentifier","queryRecord","peekAll","unloadAll","pushed","_push","jsonApiDoc","LOG_PAYLOADS","e","ret","reject","operation","createCache","maybeIdentifier","defs","relationshipValue","def","assertRecordsPassedToHasMany","extractIdentifiersFromRecords","every","recordOrPromiseRecord","extract","urlFromLink","link","href","_classPrivateFieldLooseKey","_request","Document","_request2","fetch","related","next","prev","first","last","toJSON","MUTATION_OPS","isErrorDocument","maybeUpdateUiObjects","isFromCache","shouldHydrate","copyDocumentProperties","calcShouldFetch","hasCachedValue","lifetimes","isHardExpired","calcShouldBackgroundFetch","willFetch","backgroundReload","isSoftExpired","isMutation","fetchContentAndHydrate","shouldFetch","shouldBackgroundFetch","isMut","willRequest","didRequest","signal","aborted","newError","cloneError","cloned","message","stack","CacheHandler","peeked"],"mappings":"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,MAAM,CAACC,UAAU,CAAC,MAAM;AACtB,MAAA,IAAA7jB,cAAA,CAAAC,YAAA,GAAA4H,KAAA,CAAA6b,YAAA,CAAkB,EAAA;AAChB;AACA3b,QAAAA,OAAO,CAACE,GAAG,CACR,CAAA,sBAAA,EAAwBkb,aAAa,CAAC9T,EAAE,IAAI,CAAC8T,aAAa,CAACtd,GAAG,GAAG,WAAW,GAAG,EAAG,CAAA,EACjFsd,aAAa,CAAC9T,EAAE,IAAI,qBACrB,CAAG8T,CAAAA,EAAAA,aAAa,CAACtd,GAAG,IAAI,aAAc,CAAA,EAAA,EAAIsd,aAAa,CAACze,MAAM,IAAI,gBAAiB,EACtF,CAAC,CAAA;AACH,OAAA;AACA;MACA,IAAIye,aAAa,CAAC9T,EAAE,KAAK,eAAe,IAAI,CAAC8T,aAAa,CAACtd,GAAG,EAAE;AAC9D,QAAA,OAAA;AACF,OAAA;AACA,MAAA,IAAI,CAAC2F,aAAa,CAACwM,MAAM,EAAE,CAAA;AAC7B,KAAC,CAAC,CAAA;AAEF,IAAA,OAAO4L,MAAM,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEtW,EAAAA,0BAA0BA,GAAkB;AAC1CvM,IAAAA,MAAM,CAAE,CAAoF,mFAAA,CAAA,EAAE,IAAI,CAAC+iB,OAAO,CAAC,CAAA;IAC3G,OAAO,IAAI,CAACA,OAAO,CAAA;AACrB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,+BAA+BA,CAACxW,MAAqB,EAAE;IACrD,IAAI,CAACuW,OAAO,GAAGvW,MAAM,CAAA;AACvB,GAAA;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyW,cAAcA,CAACzW,MAAqB,EAAE;IACpC,IAAI,CAACuW,OAAO,GAAGvW,MAAM,CAAA;AACvB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;;EAEA0W,QAAQA,CAAC7iB,IAAY,EAAe;AAClC,IAAA,IAAApB,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT2d,MAAAA,wBAAwB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;AAC5C,KAAA;IACAnjB,MAAM,CAAE,CAAuD,sDAAA,CAAA,EAAE,OAAOK,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACJ,MAAM,CAAC,CAAA;AACzGD,IAAAA,MAAM,CACH,CAAA,wBAAA,EAA0BK,IAAK,CAAA,gCAAA,CAAiC,EACjE,IAAI,CAACkM,0BAA0B,EAAE,CAAC6W,aAAa,CAAC/iB,IAAI,CACtD,CAAC,CAAA;AAED,IAAA,OAAOqR,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC,CAAA;AACjC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMEgjB,EAAAA,YAAYA,CAAC1R,SAAiB,EAAE2R,eAAuC,EAAkB;AACvF,IAAA,IAAArkB,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,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IE0L,YAAYA,CAAClB,MAAsB,EAAQ;AACzC,IAAA,IAAApO,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAA;AAC7C,KAAA;AACA,IAAA,MAAM1gB,UAAU,GAAG2E,oBAAoB,CAAC6F,MAAM,CAAC,CAAA;AAC/C,IAAA,IAAIxK,UAAU,EAAE;AACd,MAAA,IAAI,CAAC6J,cAAc,CAAC6B,YAAY,CAAC1L,UAAU,CAAC,CAAA;AAC9C,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAuFEyI,EAAAA,UAAUA,CACRpJ,QAA2C,EAC3ClD,EAAkC,EAClCqV,OAAqB,EACI;AACzB,IAAA,IAAApV,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAA;AAC3C,KAAA;AAEAvjB,IAAAA,MAAM,CACH,CAAA,0GAAA,CAA2G,EAC5GkC,QACF,CAAC,CAAA;AACD,IAAA,IAAI8hB,iBAAiB,CAAC9hB,QAAQ,CAAC,EAAE;AAC/BmS,MAAAA,OAAO,GAAGrV,EAA6B,CAAA;AACzC,KAAC,MAAM;MACLgB,MAAM,CACH,iGAAgGkC,QAAS,CAAA,CAAC,EAC3G,OAAOA,QAAQ,KAAK,QACtB,CAAC,CAAA;AACD,MAAA,MAAM7B,IAAI,GAAGD,kBAAkB,CAAC8B,QAAQ,CAAC,CAAA;AACzC,MAAA,MAAM+hB,YAAY,GAAG/jB,cAAc,CAAClB,EAAqB,CAAC,CAAA;AAC1DkD,MAAAA,QAAQ,GAAGif,iBAAiB,CAAC9gB,IAAI,EAAE4jB,YAAY,CAAC,CAAA;AAClD,KAAA;IAEA,MAAMphB,UAAU,GAAG,IAAI,CAACiJ,eAAe,CAAC/D,2BAA2B,CAAC7F,QAAQ,CAAC,CAAA;AAC7EmS,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAAE,CAAA;IAEvB,IAAIA,OAAO,CAAC9D,OAAO,EAAE;AACnB;AACA;AACA;MACA,IAAI,CAAC,IAAI,CAAC7D,cAAc,CAACqC,cAAc,CAAClM,UAAU,CAAC,EAAE;QACnDwR,OAAO,CAAC9I,MAAM,GAAG,IAAI,CAAA;AACvB,OAAA;MACA,IAAI,CAACuE,KAAK,CAAC,MAAM;QACfQ,WAAW,CAAC,IAAI,EAAEzN,UAAU,EAAEwR,OAAO,CAAE9D,OAAQ,CAAC,CAAA;AAClD,OAAC,CAAC,CAAA;AACJ,KAAA;AAEA,IAAA,MAAMqL,OAAO,GAAG,IAAI,CAAClU,OAAO,CAAiB;AAC3C4G,MAAAA,EAAE,EAAE,YAAY;AAChB7J,MAAAA,IAAI,EAAE;AACJ4I,QAAAA,MAAM,EAAExK,UAAU;AAClBwR,QAAAA,OAAAA;OACD;AACDzM,MAAAA,YAAY,EAAE;AAAE,QAAA,CAACsc,SAAS,GAAa,IAAA;AAAK,OAAA;AAC9C,KAAC,CAAC,CAAA;AAEF,IAAA,OAAOtI,OAAO,CAACzQ,IAAI,CAAEgZ,QAAQ,IAAK;MAChC,OAAOA,QAAQ,CAACC,OAAO,CAAA;AACzB,KAAC,CAAC,CAAA;AACJ,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUE;AACAtV,EAAAA,YAAYA,CAAC5M,QAA2C,EAAElD,EAAmB,EAAmB;AAC9F,IAAA,IAAAC,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAA;AAC7C,KAAA;AAEA,IAAA,IAAIc,kBAA4C,CAAA;IAChD,IAAI3J,SAAS,CAACza,MAAM,KAAK,CAAC,IAAI+jB,iBAAiB,CAAC9hB,QAAQ,CAAC,EAAE;AACzDmiB,MAAAA,kBAAkB,GAAGniB,QAAQ,CAAA;AAC/B,KAAC,MAAM;AACL,MAAA,MAAM7B,IAAI,GAAGD,kBAAkB,CAAC8B,QAAkB,CAAC,CAAA;AACnD,MAAA,MAAM+hB,YAAY,GAAG/jB,cAAc,CAAClB,EAAE,CAAC,CAAA;AACvCqlB,MAAAA,kBAAkB,GAAGlD,iBAAiB,CAAC9gB,IAAI,EAAE4jB,YAAY,CAAC,CAAA;AAC5D,KAAA;AAEAjkB,IAAAA,MAAM,CACJ,2FAA2F,EAC3FgkB,iBAAiB,CAACK,kBAAkB,CACtC,CAAC,CAAA;IAED,MAAMxhB,UAAkC,GAAG,IAAI,CAACiJ,eAAe,CAAC/D,2BAA2B,CAACsc,kBAAkB,CAAC,CAAA;AAE/G,IAAA,OAAO,IAAI,CAAC3X,cAAc,CAACoC,YAAY,CAACjM,UAAU,CAAC,CAAA;AACrD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAiBEuI,EAAAA,UAAUA,CAAqBvI,UAA6C,EAAE7D,EAAoB,EAAY;IAC5G,IAAI0b,SAAS,CAACza,MAAM,KAAK,CAAC,IAAI+jB,iBAAiB,CAACnhB,UAAU,CAAC,EAAE;MAC3D,MAAMyhB,gBAAgB,GAAG,IAAI,CAACxY,eAAe,CAACtE,oBAAoB,CAAC3E,UAAU,CAAC,CAAA;MAC9E,MAAM4W,QAAQ,GAAG6K,gBAAgB,IAAI,IAAI,CAAC5X,cAAc,CAACqC,cAAc,CAACuV,gBAAgB,CAAC,CAAA;AACzF;AACA;MACA,OAAO7K,QAAQ,GAAI,IAAI,CAAC/M,cAAc,CAAC8B,SAAS,CAAC8V,gBAAgB,CAAC,GAAS,IAAI,CAAA;AACjF,KAAA;AAEA,IAAA,IAAArlB,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,YAAY,CAAC,CAAA;AAC3C,KAAA;AAEAvjB,IAAAA,MAAM,CAAE,CAAA,8DAAA,CAA+D,EAAE6C,UAAU,CAAC,CAAA;AACpF7C,IAAAA,MAAM,CACH,CAAA,8FAAA,EAAgGT,MAAM,CACrGsD,UACF,CAAE,CAAC,CAAA,EACH,OAAOA,UAAU,KAAK,QACxB,CAAC,CAAA;AAED,IAAA,MAAMxC,IAAI,GAAGD,kBAAkB,CAACyC,UAAU,CAAC,CAAA;AAC3C,IAAA,MAAMohB,YAAY,GAAG/jB,cAAc,CAAClB,EAAE,CAAC,CAAA;AACvC,IAAA,MAAMkD,QAAQ,GAAG;MAAE7B,IAAI;AAAErB,MAAAA,EAAE,EAAEilB,YAAAA;KAAc,CAAA;IAC3C,MAAMK,gBAAgB,GAAG,IAAI,CAACxY,eAAe,CAACtE,oBAAoB,CAACtF,QAAQ,CAAC,CAAA;IAC5E,MAAMuX,QAAQ,GAAG6K,gBAAgB,IAAI,IAAI,CAAC5X,cAAc,CAACqC,cAAc,CAACuV,gBAAgB,CAAC,CAAA;IAEzF,OAAO7K,QAAQ,GAAI,IAAI,CAAC/M,cAAc,CAAC8B,SAAS,CAAC8V,gBAAgB,CAAC,GAAS,IAAI,CAAA;AACjF,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeEpI,EAAAA,KAAKA,CACHvK,SAAiB,EACjBuK,KAA8B,EAC9B7H,OAA6E,EACxD;AACrB,IAAA,IAAApV,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;AACtC,KAAA;AACAvjB,IAAAA,MAAM,CAAE,CAAA,yDAAA,CAA0D,EAAE2R,SAAS,CAAC,CAAA;AAC9E3R,IAAAA,MAAM,CAAE,CAAA,yDAAA,CAA0D,EAAEkc,KAAK,CAAC,CAAA;IAC1Elc,MAAM,CACH,iGAAgG2R,SAAU,CAAA,CAAC,EAC5G,OAAOA,SAAS,KAAK,QACvB,CAAC,CAAA;AAED,IAAA,MAAMiK,OAAO,GAAG,IAAI,CAAClU,OAAO,CAAa;AACvC4G,MAAAA,EAAE,EAAE,OAAO;AACX7J,MAAAA,IAAI,EAAE;AACJpE,QAAAA,IAAI,EAAED,kBAAkB,CAACuR,SAAS,CAAC;QACnCuK,KAAK;QACL7H,OAAO,EAAEA,OAAO,IAAI,EAAC;OACtB;AACDzM,MAAAA,YAAY,EAAE;AAAE,QAAA,CAACsc,SAAS,GAAa,IAAA;AAAK,OAAA;AAC9C,KAAC,CAAC,CAAA;IAEF,OAAOtI,OAAO,CAACzQ,IAAI,CAAEgZ,QAAQ,IAAKA,QAAQ,CAACC,OAAO,CAAC,CAAA;AACrD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBEG,EAAAA,WAAWA,CACT5S,SAAiB,EACjBuK,KAA8B,EAC9B7H,OAAsB,EACU;AAChC,IAAA,IAAApV,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,aAAa,CAAC,CAAA;AAC5C,KAAA;AACAvjB,IAAAA,MAAM,CAAE,CAAA,+DAAA,CAAgE,EAAE2R,SAAS,CAAC,CAAA;AACpF3R,IAAAA,MAAM,CAAE,CAAA,+DAAA,CAAgE,EAAEkc,KAAK,CAAC,CAAA;IAChFlc,MAAM,CACH,iGAAgG2R,SAAU,CAAA,CAAC,EAC5G,OAAOA,SAAS,KAAK,QACvB,CAAC,CAAA;AAED,IAAA,MAAMiK,OAAO,GAAG,IAAI,CAAClU,OAAO,CAAwB;AAClD4G,MAAAA,EAAE,EAAE,aAAa;AACjB7J,MAAAA,IAAI,EAAE;AACJpE,QAAAA,IAAI,EAAED,kBAAkB,CAACuR,SAAS,CAAC;QACnCuK,KAAK;QACL7H,OAAO,EAAEA,OAAO,IAAI,EAAC;OACtB;AACDzM,MAAAA,YAAY,EAAE;AAAE,QAAA,CAACsc,SAAS,GAAa,IAAA;AAAK,OAAA;AAC9C,KAAC,CAAC,CAAA;IAEF,OAAOtI,OAAO,CAACzQ,IAAI,CAAEgZ,QAAQ,IAAKA,QAAQ,CAACC,OAAO,CAAC,CAAA;AACrD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsCE1I,EAAAA,OAAOA,CAAC/J,SAAiB,EAAE0C,OAAyD,GAAG,EAAE,EAA4B;AACnH,IAAA,IAAApV,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;AACxC,KAAA;AACAvjB,IAAAA,MAAM,CAAE,CAAA,2DAAA,CAA4D,EAAE2R,SAAS,CAAC,CAAA;IAChF3R,MAAM,CACH,iGAAgG2R,SAAU,CAAA,CAAC,EAC5G,OAAOA,SAAS,KAAK,QACvB,CAAC,CAAA;AAED,IAAA,MAAMiK,OAAO,GAAG,IAAI,CAAClU,OAAO,CAAkB;AAC5C4G,MAAAA,EAAE,EAAE,SAAS;AACb7J,MAAAA,IAAI,EAAE;AACJpE,QAAAA,IAAI,EAAED,kBAAkB,CAACuR,SAAS,CAAC;QACnC0C,OAAO,EAAEA,OAAO,IAAI,EAAC;OACtB;AACDzM,MAAAA,YAAY,EAAE;AAAE,QAAA,CAACsc,SAAS,GAAa,IAAA;AAAK,OAAA;AAC9C,KAAC,CAAC,CAAA;IAEF,OAAOtI,OAAO,CAACzQ,IAAI,CAAEgZ,QAAQ,IAAKA,QAAQ,CAACC,OAAO,CAAC,CAAA;AACrD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAMEI,OAAOA,CAAC7S,SAAiB,EAAmB;AAC1C,IAAA,IAAA1S,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT+d,MAAAA,qBAAqB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;AACxC,KAAA;AACAvjB,IAAAA,MAAM,CAAE,CAAA,2DAAA,CAA4D,EAAE2R,SAAS,CAAC,CAAA;IAChF3R,MAAM,CACH,iGAAgG2R,SAAU,CAAA,CAAC,EAC5G,OAAOA,SAAS,KAAK,QACvB,CAAC,CAAA;AAED,IAAA,MAAMtR,IAAI,GAAGD,kBAAkB,CAACuR,SAAS,CAAC,CAAA;AAC1C,IAAA,OAAO,IAAI,CAACgQ,kBAAkB,CAACjE,YAAY,CAACrd,IAAI,CAAC,CAAA;AACnD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAIEokB,SAASA,CAAC9S,SAAkB,EAAE;AAC5B,IAAA,IAAA1S,cAAA,CAAAC,YAAA,GAAAqG,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT2d,MAAAA,wBAAwB,CAAC,IAAI,EAAE,WAAW,CAAC,CAAA;AAC7C,KAAA;AACAnjB,IAAAA,MAAM,CACH,CAAA,8FAAA,EAAgGT,MAAM,CACrGoS,SACF,CAAE,CAAA,CAAC,EACH,CAACA,SAAS,IAAI,OAAOA,SAAS,KAAK,QACrC,CAAC,CAAA;IAED,IAAI,CAAC7B,KAAK,CAAC,MAAM;MACf,IAAI6B,SAAS,KAAKrS,SAAS,EAAE;AAC3B;AACA;AACA;AACA,QAAA,IAAI,CAAC+P,MAAM,EAAEY,WAAW,CAAC1G,KAAK,EAAE,CAAA;AAEhC,QAAA,IAAI,CAACoY,kBAAkB,CAACpY,KAAK,EAAE,CAAA;AAC/B,QAAA,IAAI,CAACmD,cAAc,CAACnD,KAAK,EAAE,CAAA;AAC7B,OAAC,MAAM;AACL,QAAA,MAAMia,mBAAmB,GAAGpjB,kBAAkB,CAACuR,SAAS,CAAC,CAAA;AACzD,QAAA,IAAI,CAACjF,cAAc,CAACnD,KAAK,CAACia,mBAAmB,CAAC,CAAA;AAChD,OAAA;AACF,KAAC,CAAC,CAAA;AACJ,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","x_google_ignoreList":[10,11,14]}