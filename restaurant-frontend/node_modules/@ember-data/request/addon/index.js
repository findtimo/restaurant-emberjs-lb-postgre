import { _ as _classPrivateFieldBase, a as assertValidRequest, e as executeNextHandler, u as upgradePromise, b as _classPrivateFieldKey } from "./context-g9X123os";
export { d as createDeferred } from "./context-g9X123os";
import { macroCondition, getOwnConfig, importSync } from '@embroider/macros';
let REQ_ID = 0;
/**
 * ```js
 * import RequestManager from '@ember-data/request';
 * ```
 *
 * A RequestManager provides a request/response flow in which configured
 * handlers are successively given the opportunity to handle, modify, or
 * pass-along a request.
 *
 * ```ts
 * interface RequestManager {
 *   request<T>(req: RequestInfo): Future<T>;
 * }
 * ```
 *
 * For example:
 *
 * ```ts
 * import RequestManager from '@ember-data/request';
 * import Fetch from '@ember-data/request/fetch';
 * import Auth from 'ember-simple-auth/ember-data-handler';
 * import Config from './config';
 *
 * const { apiUrl } = Config;
 *
 * // ... create manager
 * const manager = new RequestManager();
 * manager.use([Auth, Fetch]);
 *
 * // ... execute a request
 * const response = await manager.request({
 *   url: `${apiUrl}/users`
 * });
 * ```
 *
 * ### Futures
 *
 * The return value of `manager.request` is a `Future`, which allows
 * access to limited information about the request while it is still
 * pending and fulfills with the final state when the request completes.
 *
 * A `Future` is cancellable via `abort`.
 *
 * Handlers may optionally expose a `ReadableStream` to the `Future` for
 * streaming data; however, when doing so the future should not resolve
 * until the response stream is fully read.
 *
 * ```ts
 * interface Future<T> extends Promise<StructuredDocument<T>> {
 *   abort(): void;
 *
 *   async getStream(): ReadableStream | null;
 * }
 * ```
 *
 * ### StructuredDocuments
 *
 * A Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.
 *
 * ```ts
 * interface StructuredDataDocument<T> {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   content: T;
 * }
 * interface StructuredErrorDocument extends Error {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   error: string | object;
 * }
 * type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;
 * ```
 *
 * @class RequestManager
 * @public
 */
var _handlers = /*#__PURE__*/_classPrivateFieldKey("handlers");
class RequestManager {
  constructor(options) {
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: []
    });
    Object.assign(this, options);
    this._pending = new Map();
  }

  /**
   * Register a handler to use for primary cache intercept.
   *
   * Only one such handler may exist. If using the same
   * RequestManager as the Store instance the Store
   * registers itself as a Cache handler.
   *
   * @method useCache
   * @public
   * @param {Handler[]} cacheHandler
   * @return {void}
   */
  useCache(cacheHandler) {
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (this._hasCacheHandler) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked once.`);
      }
      if (Object.isFrozen(_classPrivateFieldBase(this, _handlers)[_handlers])) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked prior to any request having been made.`);
      }
      this._hasCacheHandler = true;
    }
    _classPrivateFieldBase(this, _handlers)[_handlers].unshift(cacheHandler);
  }

  /**
   * Register handler(s) to use when a request is issued.
   *
   * Handlers will be invoked in the order they are registered.
   * Each Handler is given the opportunity to handle the request,
   * curry the request, or pass along a modified request.
   *
   * @method use
   * @public
   * @param {Handler[]} newHandlers
   * @return {void}
   */
  use(newHandlers) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (Object.isFrozen(handlers)) {
        throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);
      }
      if (!Array.isArray(newHandlers)) {
        throw new Error(`\`RequestManager.use(<Handler[]>)\` expects an array of handlers, but was called with \`${typeof newHandlers}\``);
      }
      newHandlers.forEach((handler, index) => {
        if (!handler || typeof handler !== 'object' || typeof handler.request !== 'function') {
          throw new Error(`\`RequestManager.use(<Handler[]>)\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);
        }
      });
    }
    handlers.push(...newHandlers);
  }

  /**
   * Issue a Request.
   *
   * Returns a Future that fulfills with a StructuredDocument
   *
   * @method request
   * @public
   * @param {RequestInfo} request
   * @return {Future}
   */
  request(request) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (!Object.isFrozen(handlers)) {
        Object.freeze(handlers);
      }
      assertValidRequest(request, true);
    }
    const controller = request.controller || new AbortController();
    if (request.controller) {
      delete request.controller;
    }
    const promise = executeNextHandler(handlers, request, 0, {
      controller,
      response: null,
      stream: null,
      id: REQ_ID++
    });
    if (macroCondition(getOwnConfig().env.TESTING)) {
      if (!request.disableTestWaiter) {
        const {
          waitForPromise
        } = importSync('@ember/test-waiters');
        const newPromise = waitForPromise(promise);
        return upgradePromise(newPromise, promise);
      }
    }
    return promise;
  }
  static create(options) {
    return new this(options);
  }
}
export { RequestManager as default };