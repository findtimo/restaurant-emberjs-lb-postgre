{"version":3,"file":"-private-1aicprWG.js","sources":["../src/legacy-network-handler/snapshot-record-array.ts","../src/legacy-network-handler/identifier-has-id.ts","../src/legacy-network-handler/legacy-data-utils.ts","../src/legacy-network-handler/serializer-response.ts","../src/legacy-network-handler/snapshot.ts","../src/legacy-network-handler/fetch-manager.ts","../src/-private.ts"],"sourcesContent":["/**\n  @module @ember-data/legacy-compat\n*/\nimport type Store from '@ember-data/store';\nimport { SOURCE } from '@ember-data/store/-private';\nimport type IdentifierArray from '@ember-data/store/-private/record-arrays/identifier-array';\nimport type { ModelSchema } from '@ember-data/store/-types/q/ds-model';\nimport type { FindOptions } from '@ember-data/store/-types/q/store';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types';\n\nimport { upgradeStore } from '../-private';\nimport type Snapshot from './snapshot';\n/**\n  SnapshotRecordArray is not directly instantiable.\n  Instances are provided to consuming application's\n  adapters for certain requests.\n\n  @class SnapshotRecordArray\n  @public\n*/\nexport default class SnapshotRecordArray {\n  declare _snapshots: Snapshot[] | null;\n  declare _type: ModelSchema | null;\n  declare modelName: string;\n  declare __store: Store;\n\n  declare adapterOptions?: Record<string, unknown>;\n  declare include?: string;\n\n  /**\n    SnapshotRecordArray is not directly instantiable.\n    Instances are provided to consuming application's\n    adapters and serializers for certain requests.\n\n    @method constructor\n    @private\n    @constructor\n    @param {Store} store\n    @param {string} type\n    @param options\n   */\n  constructor(store: Store, type: string, options: FindOptions = {}) {\n    this.__store = store;\n    /**\n      An array of snapshots\n      @private\n      @property _snapshots\n      @type {Array}\n    */\n    this._snapshots = null;\n\n    /**\n    The modelName of the underlying records for the snapshots in the array, as a Model\n    @property modelName\n    @public\n    @type {Model}\n  */\n    this.modelName = type;\n\n    /**\n      A hash of adapter options passed into the store method for this request.\n\n      Example\n\n      ```app/adapters/post.js\n      import MyCustomAdapter from './custom-adapter';\n\n      export default class PostAdapter extends MyCustomAdapter {\n        findAll(store, type, sinceToken, snapshotRecordArray) {\n          if (snapshotRecordArray.adapterOptions.subscribe) {\n            // ...\n          }\n          // ...\n        }\n      }\n      ```\n\n      @property adapterOptions\n      @public\n      @type {Object}\n    */\n    this.adapterOptions = options.adapterOptions;\n\n    /**\n      The relationships to include for this request.\n\n      Example\n\n      ```app/adapters/application.js\n      import Adapter from '@ember-data/adapter';\n\n      export default class ApplicationAdapter extends Adapter {\n        findAll(store, type, snapshotRecordArray) {\n          let url = `/${type.modelName}?include=${encodeURIComponent(snapshotRecordArray.include)}`;\n\n          return fetch(url).then((response) => response.json())\n        }\n      }\n      ```\n\n      @property include\n      @public\n      @type {String|Array}\n    */\n    this.include = options.include;\n  }\n\n  /**\n    An array of records\n\n    @property _recordArray\n    @private\n    @type {Array}\n  */\n  get _recordArray(): IdentifierArray {\n    return this.__store.peekAll(this.modelName);\n  }\n\n  /**\n      Number of records in the array\n\n      Example\n\n      ```app/adapters/post.js\n      import JSONAPIAdapter from '@ember-data/adapter/json-api';\n\n      export default class PostAdapter extends JSONAPIAdapter {\n        shouldReloadAll(store, snapshotRecordArray) {\n          return !snapshotRecordArray.length;\n        }\n      });\n      ```\n\n      @property length\n      @public\n      @type {Number}\n    */\n  get length(): number {\n    return this._recordArray.length;\n  }\n\n  /**\n    Get snapshots of the underlying record array\n\n    Example\n\n    ```app/adapters/post.js\n    import JSONAPIAdapter from '@ember-data/adapter/json-api';\n\n    export default class PostAdapter extends JSONAPIAdapter {\n      shouldReloadAll(store, snapshotArray) {\n        let snapshots = snapshotArray.snapshots();\n\n        return snapshots.any(function(ticketSnapshot) {\n          let timeDiff = moment().diff(ticketSnapshot.attr('lastAccessedAt'), 'minutes');\n          if (timeDiff > 20) {\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    }\n    ```\n\n    @method snapshots\n    @public\n    @return {Array} Array of snapshots\n  */\n  snapshots() {\n    if (this._snapshots !== null) {\n      return this._snapshots;\n    }\n    upgradeStore(this.__store);\n\n    const { _fetchManager } = this.__store;\n    this._snapshots = this._recordArray[SOURCE].map((identifier: StableRecordIdentifier) =>\n      _fetchManager.createSnapshot(identifier)\n    );\n\n    return this._snapshots;\n  }\n}\n","import { assert } from '@ember/debug';\n\nimport type { StableExistingRecordIdentifier } from '@warp-drive/core-types/identifier';\n\nexport function assertIdentifierHasId(identifier: unknown): asserts identifier is StableExistingRecordIdentifier {\n  assert(\n    `Attempted to schedule a fetch for a record without an id.`,\n    identifier && (identifier as StableExistingRecordIdentifier).id !== null\n  );\n}\n","import type { AdapterPayload } from './minimum-adapter-interface';\n\nexport function iterateData<T>(data: T[] | T, fn: (o: T, index?: number) => T) {\n  if (Array.isArray(data)) {\n    return data.map(fn);\n  } else {\n    return fn(data);\n  }\n}\n\nexport function payloadIsNotBlank<T>(adapterPayload: T | AdapterPayload): adapterPayload is AdapterPayload {\n  if (Array.isArray(adapterPayload)) {\n    return true;\n  } else {\n    return Object.keys(adapterPayload || {}).length !== 0;\n  }\n}\n","import { assert } from '@ember/debug';\n\nimport { DEBUG } from '@ember-data/env';\nimport type Store from '@ember-data/store';\nimport type { ModelSchema } from '@ember-data/store/-types/q/ds-model';\nimport type { JsonApiDocument } from '@warp-drive/core-types/spec/raw';\n\nimport type { AdapterPayload } from './minimum-adapter-interface';\nimport type { MinimumSerializerInterface, RequestType } from './minimum-serializer-interface';\n\n/**\n  This is a helper method that validates a JSON API top-level document\n\n  The format of a document is described here:\n  http://jsonapi.org/format/#document-top-level\n\n  @internal\n*/\nfunction validateDocumentStructure(doc?: AdapterPayload | JsonApiDocument): asserts doc is JsonApiDocument {\n  if (DEBUG) {\n    const errors: string[] = [];\n    if (!doc || typeof doc !== 'object') {\n      errors.push('Top level of a JSON API document must be an object');\n    } else {\n      if (!('data' in doc) && !('errors' in doc) && !('meta' in doc)) {\n        errors.push('One or more of the following keys must be present: \"data\", \"errors\", \"meta\".');\n      } else {\n        if ('data' in doc && 'errors' in doc) {\n          errors.push('Top level keys \"errors\" and \"data\" cannot both be present in a JSON API document');\n        }\n      }\n      if ('data' in doc) {\n        if (!(doc.data === null || Array.isArray(doc.data) || typeof doc.data === 'object')) {\n          errors.push('data must be null, an object, or an array');\n        }\n      }\n      if ('meta' in doc) {\n        if (typeof doc.meta !== 'object') {\n          errors.push('meta must be an object');\n        }\n      }\n      if ('errors' in doc) {\n        if (!Array.isArray(doc.errors)) {\n          errors.push('errors must be an array');\n        }\n      }\n      if ('links' in doc) {\n        if (typeof doc.links !== 'object') {\n          errors.push('links must be an object');\n        }\n      }\n      if ('jsonapi' in doc) {\n        if (typeof doc.jsonapi !== 'object') {\n          errors.push('jsonapi must be an object');\n        }\n      }\n      if ('included' in doc) {\n        if (typeof doc.included !== 'object') {\n          errors.push('included must be an array');\n        }\n      }\n    }\n\n    assert(\n      `Response must be normalized to a valid JSON API document:\\n\\t* ${errors.join('\\n\\t* ')}`,\n      errors.length === 0\n    );\n  }\n}\n\nexport function normalizeResponseHelper(\n  serializer: MinimumSerializerInterface | null,\n  store: Store,\n  modelClass: ModelSchema,\n  payload: AdapterPayload,\n  id: string | null,\n  requestType: RequestType\n): JsonApiDocument {\n  const normalizedResponse = serializer\n    ? serializer.normalizeResponse(store, modelClass, payload, id, requestType)\n    : payload;\n\n  validateDocumentStructure(normalizedResponse);\n\n  return normalizedResponse;\n}\n","/**\n  @module @ember-data/store\n*/\nimport { assert } from '@ember/debug';\n\nimport { importSync } from '@embroider/macros';\n\nimport { DEBUG } from '@ember-data/env';\nimport type { CollectionEdge } from '@ember-data/graph/-private/edges/collection';\nimport type { ResourceEdge } from '@ember-data/graph/-private/edges/resource';\nimport { HAS_JSON_API_PACKAGE } from '@ember-data/packages';\nimport type Store from '@ember-data/store';\nimport type { RecordInstance } from '@ember-data/store/-types/q/record-instance';\nimport type { FindOptions } from '@ember-data/store/-types/q/store';\nimport type { StableRecordIdentifier } from '@warp-drive/core-types';\nimport type { ChangedAttributesHash } from '@warp-drive/core-types/cache';\nimport type { CollectionRelationship } from '@warp-drive/core-types/cache/relationship';\nimport type { Value } from '@warp-drive/core-types/json/raw';\nimport type { AttributeSchema, RelationshipSchema } from '@warp-drive/core-types/schema';\n\nimport { upgradeStore } from '../-private';\nimport type { SerializerOptions } from './minimum-serializer-interface';\n\ntype RecordId = string | null;\n\n/**\n  Snapshot is not directly instantiable.\n  Instances are provided to a consuming application's\n  adapters and serializers for certain requests.\n\n  Snapshots are only available when using `@ember-data/legacy-compat`\n  for legacy compatibility with adapters and serializers.\n\n  @class Snapshot\n  @public\n*/\nexport default class Snapshot implements Snapshot {\n  declare __attributes: Record<string, unknown> | null;\n  declare _belongsToRelationships: Record<string, Snapshot>;\n  declare _belongsToIds: Record<string, RecordId>;\n  declare _hasManyRelationships: Record<string, Snapshot[]>;\n  declare _hasManyIds: Record<string, RecordId[]>;\n  declare _changedAttributes: ChangedAttributesHash;\n\n  declare identifier: StableRecordIdentifier;\n  declare modelName: string;\n  declare id: string | null;\n  declare include?: unknown;\n  declare adapterOptions?: Record<string, unknown>;\n  declare _store: Store;\n\n  /**\n   * @method constructor\n   * @constructor\n   * @private\n   * @param options\n   * @param identifier\n   * @param _store\n   */\n  constructor(options: FindOptions, identifier: StableRecordIdentifier, store: Store) {\n    this._store = store;\n\n    this.__attributes = null;\n    this._belongsToRelationships = Object.create(null) as Record<string, Snapshot>;\n    this._belongsToIds = Object.create(null) as Record<string, RecordId>;\n    this._hasManyRelationships = Object.create(null) as Record<string, Snapshot[]>;\n    this._hasManyIds = Object.create(null) as Record<string, RecordId[]>;\n\n    const hasRecord = !!store._instanceCache.peek(identifier);\n    this.modelName = identifier.type;\n\n    /**\n      The unique RecordIdentifier associated with this Snapshot.\n\n      @property identifier\n      @public\n      @type {StableRecordIdentifier}\n    */\n    this.identifier = identifier;\n\n    /*\n      If the we do not yet have a record, then we are\n      likely a snapshot being provided to a find request, so we\n      populate __attributes lazily. Else, to preserve the \"moment\n      in time\" in which a snapshot is created, we greedily grab\n      the values.\n     */\n    if (hasRecord) {\n      this._attributes;\n    }\n\n    /**\n     The id of the snapshot's underlying record\n\n     Example\n\n     ```javascript\n     // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n     postSnapshot.id; // => '1'\n     ```\n\n     @property id\n     @type {String}\n     @public\n     */\n    this.id = identifier.id;\n\n    /**\n     A hash of adapter options\n     @property adapterOptions\n     @type {Object}\n     @public\n     */\n    this.adapterOptions = options.adapterOptions;\n\n    /**\n     If `include` was passed to the options hash for the request, the value\n     would be available here.\n\n     @property include\n     @type {String|Array}\n     @public\n     */\n    this.include = options.include;\n\n    /**\n     The name of the type of the underlying record for this snapshot, as a string.\n\n     @property modelName\n     @type {String}\n     @public\n     */\n    this.modelName = identifier.type;\n    if (hasRecord) {\n      const cache = this._store.cache;\n      this._changedAttributes = cache.changedAttrs(identifier);\n    }\n  }\n\n  /**\n   The underlying record for this snapshot. Can be used to access methods and\n   properties defined on the record.\n\n   Example\n\n   ```javascript\n   let json = snapshot.record.toJSON();\n   ```\n\n   @property record\n   @type {Model}\n   @public\n   */\n  get record(): RecordInstance | null {\n    const record = this._store.peekRecord(this.identifier);\n    assert(\n      `Record ${this.identifier.type} ${this.identifier.id} (${this.identifier.lid}) is not yet loaded and thus cannot be accessed from the Snapshot during serialization`,\n      record !== null\n    );\n    return record;\n  }\n\n  get _attributes(): Record<string, unknown> {\n    if (this.__attributes !== null) {\n      return this.__attributes;\n    }\n    const attributes = (this.__attributes = Object.create(null) as Record<string, unknown>);\n    const { identifier } = this;\n    const attrs = Object.keys(this._store.getSchemaDefinitionService().attributesDefinitionFor(identifier));\n    const cache = this._store.cache;\n\n    attrs.forEach((keyName) => {\n      attributes[keyName] = cache.getAttr(identifier, keyName);\n    });\n\n    return attributes;\n  }\n\n  get isNew(): boolean {\n    const cache = this._store.cache;\n    return cache?.isNew(this.identifier) || false;\n  }\n\n  /**\n   Returns the value of an attribute.\n\n   Example\n\n   ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attr('author'); // => 'Tomster'\n   postSnapshot.attr('title'); // => 'Ember.js rocks'\n   ```\n\n   Note: Values are loaded eagerly and cached when the snapshot is created.\n\n   @method attr\n   @param {String} keyName\n   @return {Object} The attribute value or undefined\n   @public\n   */\n  attr(keyName: string): unknown {\n    if (keyName in this._attributes) {\n      return this._attributes[keyName];\n    }\n    assert(`Model '${this.identifier.lid}' has no attribute named '${keyName}' defined.`, false);\n  }\n\n  /**\n   Returns all attributes and their corresponding values.\n\n   Example\n\n   ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attributes(); // => { author: 'Tomster', title: 'Ember.js rocks' }\n   ```\n\n   @method attributes\n   @return {Object} All attributes of the current snapshot\n   @public\n   */\n  attributes(): Record<string, unknown> {\n    return { ...this._attributes };\n  }\n\n  /**\n   Returns all changed attributes and their old and new values.\n\n   Example\n\n   ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postModel.set('title', 'Ember.js rocks!');\n   postSnapshot.changedAttributes(); // => { title: ['Ember.js rocks', 'Ember.js rocks!'] }\n   ```\n\n   @method changedAttributes\n   @return {Object} All changed attributes of the current snapshot\n   @public\n   */\n  changedAttributes(): ChangedAttributesHash {\n    const changedAttributes = Object.create(null) as ChangedAttributesHash;\n    if (!this._changedAttributes) {\n      return changedAttributes;\n    }\n\n    const changedAttributeKeys = Object.keys(this._changedAttributes);\n\n    for (let i = 0, length = changedAttributeKeys.length; i < length; i++) {\n      const key = changedAttributeKeys[i];\n      changedAttributes[key] = this._changedAttributes[key].slice() as [Value | undefined, Value];\n    }\n\n    return changedAttributes;\n  }\n\n  /**\n   Returns the current value of a belongsTo relationship.\n\n   `belongsTo` takes an optional hash of options as a second parameter,\n   currently supported options are:\n\n   - `id`: set to `true` if you only want the ID of the related record to be\n   returned.\n\n   Example\n\n   ```javascript\n   // store.push('post', { id: 1, title: 'Hello World' });\n   // store.createRecord('comment', { body: 'Lorem ipsum', post: post });\n   commentSnapshot.belongsTo('post'); // => Snapshot\n   commentSnapshot.belongsTo('post', { id: true }); // => '1'\n\n   // store.push('comment', { id: 1, body: 'Lorem ipsum' });\n   commentSnapshot.belongsTo('post'); // => undefined\n   ```\n\n   Calling `belongsTo` will return a new Snapshot as long as there's any known\n   data for the relationship available, such as an ID. If the relationship is\n   known but unset, `belongsTo` will return `null`. If the contents of the\n   relationship is unknown `belongsTo` will return `undefined`.\n\n   Note: Relationships are loaded lazily and cached upon first access.\n\n   @method belongsTo\n   @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Snapshot|String|null|undefined)} A snapshot or ID of a known\n   relationship or null if the relationship is known but unset. undefined\n   will be returned if the contents of the relationship is unknown.\n   */\n  belongsTo(keyName: string, options?: { id?: boolean }): Snapshot | RecordId | undefined {\n    const returnModeIsId = !!(options && options.id);\n    let result: Snapshot | RecordId | undefined;\n    const store = this._store;\n\n    if (returnModeIsId === true && keyName in this._belongsToIds) {\n      return this._belongsToIds[keyName];\n    }\n\n    if (returnModeIsId === false && keyName in this._belongsToRelationships) {\n      return this._belongsToRelationships[keyName];\n    }\n\n    const relationshipMeta = store.getSchemaDefinitionService().relationshipsDefinitionFor({ type: this.modelName })[\n      keyName\n    ];\n    assert(\n      `Model '${this.identifier.lid}' has no belongsTo relationship named '${keyName}' defined.`,\n      relationshipMeta && relationshipMeta.kind === 'belongsTo'\n    );\n\n    // TODO @runspired it seems this code branch would not work with CUSTOM_MODEL_CLASSes\n    // this check is not a regression in behavior because relationships don't currently\n    // function without access to intimate API contracts between RecordData and Model.\n    // This is a requirement we should fix as soon as the relationship layer does not require\n    // this intimate API usage.\n    if (!HAS_JSON_API_PACKAGE) {\n      assert(`snapshot.belongsTo only supported when using the package @ember-data/json-api`);\n    }\n\n    const graphFor = (importSync('@ember-data/graph/-private') as typeof import('@ember-data/graph/-private')).graphFor;\n    const { identifier } = this;\n\n    if (DEBUG) {\n      const relationship = graphFor(this._store).get(identifier, keyName) as ResourceEdge;\n      assert(\n        `You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${\n          identifier.id || ''\n        }, lid: ${identifier.lid} but no such relationship was found.`,\n        relationship\n      );\n      assert(\n        `You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${\n          identifier.id || ''\n        }, lid: ${identifier.lid} but that relationship is a hasMany.`,\n        relationship.definition.kind === 'belongsTo'\n      );\n    }\n\n    const value = graphFor(this._store).getData(identifier, keyName);\n    const data = value && value.data;\n    upgradeStore(store);\n\n    const inverseIdentifier = data ? store.identifierCache.getOrCreateRecordIdentifier(data) : null;\n\n    if (value && value.data !== undefined) {\n      const cache = store.cache;\n\n      if (inverseIdentifier && !cache.isDeleted(inverseIdentifier)) {\n        if (returnModeIsId) {\n          result = inverseIdentifier.id;\n        } else {\n          result = store._fetchManager.createSnapshot(inverseIdentifier);\n        }\n      } else {\n        result = null;\n      }\n    }\n\n    if (returnModeIsId) {\n      this._belongsToIds[keyName] = result as RecordId;\n    } else {\n      this._belongsToRelationships[keyName] = result as Snapshot;\n    }\n\n    return result;\n  }\n\n  /**\n   Returns the current value of a hasMany relationship.\n\n   `hasMany` takes an optional hash of options as a second parameter,\n   currently supported options are:\n\n   - `ids`: set to `true` if you only want the IDs of the related records to be\n   returned.\n\n   Example\n\n   ```javascript\n   // store.push('post', { id: 1, title: 'Hello World', comments: [2, 3] });\n   postSnapshot.hasMany('comments'); // => [Snapshot, Snapshot]\n   postSnapshot.hasMany('comments', { ids: true }); // => ['2', '3']\n\n   // store.push('post', { id: 1, title: 'Hello World' });\n   postSnapshot.hasMany('comments'); // => undefined\n   ```\n\n   Note: Relationships are loaded lazily and cached upon first access.\n\n   @method hasMany\n   @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Array|undefined)} An array of snapshots or IDs of a known\n   relationship or an empty array if the relationship is known but unset.\n   undefined will be returned if the contents of the relationship is unknown.\n   */\n  hasMany(keyName: string, options?: { ids?: boolean }): RecordId[] | Snapshot[] | undefined {\n    const returnModeIsIds = !!(options && options.ids);\n    let results: RecordId[] | Snapshot[] | undefined;\n    const cachedIds: RecordId[] | undefined = this._hasManyIds[keyName];\n    const cachedSnapshots: Snapshot[] | undefined = this._hasManyRelationships[keyName];\n\n    if (returnModeIsIds === true && keyName in this._hasManyIds) {\n      return cachedIds;\n    }\n\n    if (returnModeIsIds === false && keyName in this._hasManyRelationships) {\n      return cachedSnapshots;\n    }\n\n    const store = this._store;\n    upgradeStore(store);\n    const relationshipMeta = store.getSchemaDefinitionService().relationshipsDefinitionFor({ type: this.modelName })[\n      keyName\n    ];\n    assert(\n      `Model '${this.identifier.lid}' has no hasMany relationship named '${keyName}' defined.`,\n      relationshipMeta && relationshipMeta.kind === 'hasMany'\n    );\n\n    // TODO @runspired it seems this code branch would not work with CUSTOM_MODEL_CLASSes\n    // this check is not a regression in behavior because relationships don't currently\n    // function without access to intimate API contracts between RecordData and Model.\n    // This is a requirement we should fix as soon as the relationship layer does not require\n    // this intimate API usage.\n    if (!HAS_JSON_API_PACKAGE) {\n      assert(`snapshot.hasMany only supported when using the package @ember-data/json-api`);\n    }\n\n    const graphFor = (importSync('@ember-data/graph/-private') as typeof import('@ember-data/graph/-private')).graphFor;\n    const { identifier } = this;\n    if (DEBUG) {\n      const relationship = graphFor(this._store).get(identifier, keyName) as CollectionEdge;\n      assert(\n        `You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${\n          identifier.id || ''\n        }, lid: ${identifier.lid} but no such relationship was found.`,\n        relationship\n      );\n      assert(\n        `You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${\n          identifier.id || ''\n        }, lid: ${identifier.lid} but that relationship is a belongsTo.`,\n        relationship.definition.kind === 'hasMany'\n      );\n    }\n\n    const value = graphFor(this._store).getData(identifier, keyName) as CollectionRelationship;\n\n    if (value.data) {\n      results = [];\n      value.data.forEach((member) => {\n        const inverseIdentifier = store.identifierCache.getOrCreateRecordIdentifier(member);\n        const cache = store.cache;\n\n        if (!cache.isDeleted(inverseIdentifier)) {\n          if (returnModeIsIds) {\n            (results as RecordId[]).push(inverseIdentifier.id);\n          } else {\n            (results as Snapshot[]).push(store._fetchManager.createSnapshot(inverseIdentifier));\n          }\n        }\n      });\n    }\n\n    // we assign even if `undefined` so that we don't reprocess the relationship\n    // on next access. This works with the `keyName in` checks above.\n    if (returnModeIsIds) {\n      this._hasManyIds[keyName] = results as RecordId[];\n    } else {\n      this._hasManyRelationships[keyName] = results as Snapshot[];\n    }\n\n    return results;\n  }\n\n  /**\n    Iterates through all the attributes of the model, calling the passed\n    function on each attribute.\n\n    Example\n\n    ```javascript\n    snapshot.eachAttribute(function(name, meta) {\n      // ...\n    });\n    ```\n\n    @method eachAttribute\n    @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */\n  eachAttribute(callback: (key: string, meta: AttributeSchema) => void, binding?: unknown): void {\n    const attrDefs = this._store.getSchemaDefinitionService().attributesDefinitionFor(this.identifier);\n    Object.keys(attrDefs).forEach((key) => {\n      callback.call(binding, key, attrDefs[key]);\n    });\n  }\n\n  /**\n    Iterates through all the relationships of the model, calling the passed\n    function on each relationship.\n\n    Example\n\n    ```javascript\n    snapshot.eachRelationship(function(name, relationship) {\n      // ...\n    });\n    ```\n\n    @method eachRelationship\n    @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */\n  eachRelationship(callback: (key: string, meta: RelationshipSchema) => void, binding?: unknown): void {\n    const relationshipDefs = this._store.getSchemaDefinitionService().relationshipsDefinitionFor(this.identifier);\n    Object.keys(relationshipDefs).forEach((key) => {\n      callback.call(binding, key, relationshipDefs[key]);\n    });\n  }\n\n  /**\n    Serializes the snapshot using the serializer for the model.\n\n    Example\n\n    ```app/adapters/application.js\n    import Adapter from '@ember-data/adapter';\n\n    export default Adapter.extend({\n      createRecord(store, type, snapshot) {\n        let data = snapshot.serialize({ includeId: true });\n        let url = `/${type.modelName}`;\n\n        return fetch(url, {\n          method: 'POST',\n          body: data,\n        }).then((response) => response.json())\n      }\n    });\n    ```\n\n    @method serialize\n    @param {Object} options\n    @return {Object} an object whose values are primitive JSON values only\n    @public\n   */\n  serialize(options?: SerializerOptions): unknown {\n    upgradeStore(this._store);\n    const serializer = this._store.serializerFor(this.modelName);\n    assert(`Cannot serialize record, no serializer found`, serializer);\n    return serializer.serialize(this, options);\n  }\n}\n","import { assert, warn } from '@ember/debug';\n\nimport { importSync } from '@embroider/macros';\n\nimport { DEBUG, TESTING } from '@ember-data/env';\nimport { HAS_GRAPH_PACKAGE } from '@ember-data/packages';\nimport { createDeferred } from '@ember-data/request';\nimport type { Deferred } from '@ember-data/request/-private/types';\nimport type Store from '@ember-data/store';\nimport { coerceId } from '@ember-data/store/-private';\nimport type { StoreRequestInfo } from '@ember-data/store/-private/cache-handler';\nimport type { InstanceCache } from '@ember-data/store/-private/caches/instance-cache';\nimport type RequestStateService from '@ember-data/store/-private/network/request-cache';\nimport type { FindRecordQuery, Request, SaveRecordMutation } from '@ember-data/store/-private/network/request-cache';\nimport type { ModelSchema } from '@ember-data/store/-types/q/ds-model';\nimport type { FindOptions } from '@ember-data/store/-types/q/store';\nimport type { StableExistingRecordIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { CollectionResourceDocument, SingleResourceDocument } from '@warp-drive/core-types/spec/raw';\n\nimport { upgradeStore } from '../-private';\nimport { assertIdentifierHasId } from './identifier-has-id';\nimport { payloadIsNotBlank } from './legacy-data-utils';\nimport type { AdapterPayload, MinimumAdapterInterface } from './minimum-adapter-interface';\nimport type { MinimumSerializerInterface } from './minimum-serializer-interface';\nimport { normalizeResponseHelper } from './serializer-response';\nimport Snapshot from './snapshot';\n\ntype AdapterErrors = Error & { errors?: string[]; isAdapterError?: true };\ntype SerializerWithParseErrors = MinimumSerializerInterface & {\n  extractErrors?(store: Store, modelClass: ModelSchema, error: AdapterErrors, recordId: string | null): unknown;\n};\n\nexport const SaveOp: unique symbol = Symbol('SaveOp');\n\nexport type FetchMutationOptions = FindOptions & { [SaveOp]: 'createRecord' | 'deleteRecord' | 'updateRecord' };\n\ninterface PendingFetchItem {\n  identifier: StableExistingRecordIdentifier;\n  queryRequest: Request;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  resolver: Deferred<any>;\n  options: FindOptions;\n  trace?: unknown;\n  promise: Promise<StableExistingRecordIdentifier>;\n}\n\ninterface PendingSaveItem {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  resolver: Deferred<any>;\n  snapshot: Snapshot;\n  identifier: StableRecordIdentifier;\n  options: FetchMutationOptions;\n  queryRequest: Request;\n}\n\nexport default class FetchManager {\n  declare isDestroyed: boolean;\n  declare requestCache: RequestStateService;\n  // fetches pending in the runloop, waiting to be coalesced\n  declare _pendingFetch: Map<string, Map<StableExistingRecordIdentifier, PendingFetchItem[]>>;\n  declare _store: Store;\n\n  constructor(store: Store) {\n    this._store = store;\n    // used to keep track of all the find requests that need to be coalesced\n    this._pendingFetch = new Map();\n    this.requestCache = store.getRequestStateService();\n    this.isDestroyed = false;\n  }\n\n  createSnapshot(identifier: StableRecordIdentifier, options: FindOptions = {}): Snapshot {\n    return new Snapshot(options, identifier, this._store);\n  }\n\n  /**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n\n    It schedules saving to happen at the end of the run loop.\n\n    @internal\n  */\n  scheduleSave(\n    identifier: StableRecordIdentifier,\n    options: FetchMutationOptions\n  ): Promise<null | SingleResourceDocument> {\n    const resolver = createDeferred<SingleResourceDocument | null>();\n    const query: SaveRecordMutation = {\n      op: 'saveRecord',\n      recordIdentifier: identifier,\n      options,\n    };\n\n    const queryRequest: Request = {\n      data: [query],\n    };\n\n    const snapshot = this.createSnapshot(identifier, options);\n    const pendingSaveItem: PendingSaveItem = {\n      snapshot: snapshot,\n      resolver: resolver,\n      identifier,\n      options,\n      queryRequest,\n    };\n\n    const monitored = this.requestCache._enqueue(resolver.promise, pendingSaveItem.queryRequest);\n    _flushPendingSave(this._store, pendingSaveItem);\n\n    return monitored;\n  }\n\n  scheduleFetch(\n    identifier: StableExistingRecordIdentifier,\n    options: FindOptions,\n    request: StoreRequestInfo\n  ): Promise<StableExistingRecordIdentifier> {\n    const query: FindRecordQuery = {\n      op: 'findRecord',\n      recordIdentifier: identifier,\n      options,\n    };\n\n    const queryRequest: Request = {\n      data: [query],\n    };\n\n    const pendingFetch = this.getPendingFetch(identifier, options);\n    if (pendingFetch) {\n      return pendingFetch;\n    }\n\n    const modelName = identifier.type;\n\n    const resolver = createDeferred<SingleResourceDocument>();\n    const pendingFetchItem: PendingFetchItem = {\n      identifier,\n      resolver,\n      options,\n      queryRequest,\n    } as PendingFetchItem;\n\n    const resolverPromise = resolver.promise;\n    const store = this._store;\n    const isInitialLoad = !store._instanceCache.recordIsLoaded(identifier); // we don't use isLoading directly because we are the request\n\n    const monitored = this.requestCache._enqueue(resolverPromise, pendingFetchItem.queryRequest);\n    let promise = monitored.then(\n      (payload) => {\n        // ensure that regardless of id returned we assign to the correct record\n        if (payload.data && !Array.isArray(payload.data)) {\n          payload.data.lid = identifier.lid;\n        }\n\n        // additional data received in the payload\n        // may result in the merging of identifiers (and thus records)\n        const potentiallyNewIm = store._push(payload, options.reload);\n        if (potentiallyNewIm && !Array.isArray(potentiallyNewIm)) {\n          return potentiallyNewIm;\n        }\n\n        return identifier;\n      },\n      (error) => {\n        assert(`Async Leak Detected: Expected the store to not be destroyed`, !store.isDestroyed);\n        const cache = store.cache;\n        if (!cache || cache.isEmpty(identifier) || isInitialLoad) {\n          let isReleasable = true;\n          if (HAS_GRAPH_PACKAGE) {\n            if (!cache) {\n              const graphFor = (importSync('@ember-data/graph/-private') as typeof import('@ember-data/graph/-private'))\n                .graphFor;\n              const graph = graphFor(store);\n              isReleasable = graph.isReleasable(identifier);\n              if (!isReleasable) {\n                graph.unload(identifier, true);\n              }\n            }\n          }\n          if (cache || isReleasable) {\n            store._enableAsyncFlush = true;\n            store._instanceCache.unloadRecord(identifier);\n            store._enableAsyncFlush = null;\n          }\n        }\n        throw error;\n      }\n    );\n\n    if (this._pendingFetch.size === 0) {\n      void new Promise((resolve) => setTimeout(resolve, 0)).then(() => {\n        this.flushAllPendingFetches();\n      });\n    }\n\n    const fetchesByType = this._pendingFetch;\n    let fetchesById = fetchesByType.get(modelName);\n\n    if (!fetchesById) {\n      fetchesById = new Map();\n      fetchesByType.set(modelName, fetchesById);\n    }\n\n    let requestsForIdentifier = fetchesById.get(identifier);\n    if (!requestsForIdentifier) {\n      requestsForIdentifier = [];\n      fetchesById.set(identifier, requestsForIdentifier);\n    }\n\n    requestsForIdentifier.push(pendingFetchItem);\n\n    if (TESTING) {\n      if (!request.disableTestWaiter) {\n        const { waitForPromise } = importSync('@ember/test-waiters') as {\n          waitForPromise: <T>(promise: Promise<T>) => Promise<T>;\n        };\n        promise = waitForPromise(promise);\n      }\n    }\n\n    pendingFetchItem.promise = promise;\n    return promise;\n  }\n\n  getPendingFetch(identifier: StableExistingRecordIdentifier, options: FindOptions) {\n    const pendingFetches = this._pendingFetch.get(identifier.type)?.get(identifier);\n\n    // We already have a pending fetch for this\n    if (pendingFetches) {\n      const matchingPendingFetch = pendingFetches.find((fetch) => isSameRequest(options, fetch.options));\n      if (matchingPendingFetch) {\n        return matchingPendingFetch.promise;\n      }\n    }\n  }\n\n  flushAllPendingFetches() {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    const store = this._store;\n    this._pendingFetch.forEach((fetchItem, type) => _flushPendingFetchForType(store, fetchItem, type));\n    this._pendingFetch.clear();\n  }\n\n  fetchDataIfNeededForIdentifier(\n    identifier: StableExistingRecordIdentifier,\n    options: FindOptions = {},\n    request: StoreRequestInfo\n  ): Promise<StableExistingRecordIdentifier> {\n    // pre-loading will change the isEmpty value\n    const isEmpty = _isEmpty(this._store._instanceCache, identifier);\n    const isLoading = _isLoading(this._store._instanceCache, identifier);\n\n    let promise: Promise<StableExistingRecordIdentifier>;\n    if (isEmpty) {\n      assertIdentifierHasId(identifier);\n\n      if (DEBUG) {\n        promise = this.scheduleFetch(identifier, Object.assign({}, options, { reload: true }), request);\n      } else {\n        options.reload = true;\n        promise = this.scheduleFetch(identifier, options, request);\n      }\n    } else if (isLoading) {\n      promise = this.getPendingFetch(identifier, options)!;\n      assert(`Expected to find a pending request for a record in the loading state, but found none`, promise);\n    } else {\n      promise = Promise.resolve(identifier);\n    }\n\n    return promise;\n  }\n\n  destroy() {\n    this.isDestroyed = true;\n  }\n}\n\nfunction _isEmpty(instanceCache: InstanceCache, identifier: StableRecordIdentifier): boolean {\n  const cache = instanceCache.cache;\n  if (!cache) {\n    return true;\n  }\n  const isNew = cache.isNew(identifier);\n  const isDeleted = cache.isDeleted(identifier);\n  const isEmpty = cache.isEmpty(identifier);\n\n  return (!isNew || isDeleted) && isEmpty;\n}\n\nfunction _isLoading(cache: InstanceCache, identifier: StableRecordIdentifier): boolean {\n  const req = cache.store.getRequestStateService();\n  // const fulfilled = req.getLastRequestForRecord(identifier);\n  const isLoaded = cache.recordIsLoaded(identifier);\n\n  return (\n    !isLoaded &&\n    // fulfilled === null &&\n    req.getPendingRequestsForRecord(identifier).some((r) => r.type === 'query')\n  );\n}\n\nfunction includesSatisfies(current: undefined | string | string[], existing: undefined | string | string[]): boolean {\n  // if we have no includes we are good\n  if (!current?.length) {\n    return true;\n  }\n\n  // if we are here we have includes,\n  // and if existing has no includes then we will need a new request\n  if (!existing?.length) {\n    return false;\n  }\n\n  const arrCurrent = (Array.isArray(current) ? current : current.split(',')).sort();\n  const arrExisting = (Array.isArray(existing) ? existing : existing.split(',')).sort();\n\n  // includes are identical\n  if (arrCurrent.join(',') === arrExisting.join(',')) {\n    return true;\n  }\n\n  // if all of current includes are in existing includes then we are good\n  // so if we find one that is not in existing then we need a new request\n  for (let i = 0; i < arrCurrent.length; i++) {\n    if (!arrExisting.includes(arrCurrent[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction optionsSatisfies(current: object | undefined, existing: object | undefined): boolean {\n  return !current || current === existing || Object.keys(current).length === 0;\n}\n\n// this function helps resolve whether we have a pending request that we should use instead\nfunction isSameRequest(options: FindOptions = {}, existingOptions: FindOptions = {}) {\n  return (\n    optionsSatisfies(options.adapterOptions, existingOptions.adapterOptions) &&\n    includesSatisfies(options.include, existingOptions.include)\n  );\n}\n\nfunction _findMany(\n  store: Store,\n  adapter: MinimumAdapterInterface,\n  modelName: string,\n  snapshots: Snapshot[]\n): Promise<CollectionResourceDocument> {\n  const modelClass = store.modelFor(modelName); // `adapter.findMany` gets the modelClass still\n  const promise = Promise.resolve().then(() => {\n    const ids = snapshots.map((s) => s.id!);\n    assert(\n      `Cannot fetch a record without an id`,\n      ids.every((v) => v !== null)\n    );\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    assert(`Expected this adapter to implement findMany for coalescing`, adapter.findMany);\n    const ret = adapter.findMany(store, modelClass, ids, snapshots);\n    assert('adapter.findMany returned undefined, this was very likely a mistake', ret !== undefined);\n    return ret;\n  });\n  upgradeStore(store);\n\n  return promise.then((adapterPayload) => {\n    assert(\n      `You made a 'findMany' request for '${modelName}' records with ids '[${snapshots\n        .map((s) => s.id!)\n        .join(',')}]', but the adapter's response did not have any data`,\n      !!payloadIsNotBlank(adapterPayload)\n    );\n    const serializer = store.serializerFor(modelName);\n    const payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, 'findMany');\n    return payload as CollectionResourceDocument;\n  });\n}\n\nfunction rejectFetchedItems(fetchMap: Map<Snapshot, PendingFetchItem>, snapshots: Snapshot[], error?: Error) {\n  for (let i = 0, l = snapshots.length; i < l; i++) {\n    const snapshot = snapshots[i];\n    const pair = fetchMap.get(snapshot);\n\n    if (pair) {\n      pair.resolver.reject(\n        error ||\n          new Error(\n            `Expected: '<${\n              snapshot.modelName\n            }:${snapshot.id!}>' to be present in the adapter provided payload, but it was not found.`\n          )\n      );\n    }\n  }\n}\n\nfunction handleFoundRecords(\n  store: Store,\n  fetchMap: Map<Snapshot, PendingFetchItem>,\n  snapshots: Snapshot[],\n  coalescedPayload: CollectionResourceDocument\n) {\n  /*\n    It is possible that the same ID is included multiple times\n    via multiple snapshots. This happens when more than one\n    options hash was supplied, each of which must be uniquely\n    accounted for.\n\n    However, since we can't map from response to a specific\n    options object, we resolve all snapshots by id with\n    the first response we see.\n  */\n  const snapshotsById = new Map<string, Snapshot[]>();\n  for (let i = 0; i < snapshots.length; i++) {\n    const id = snapshots[i].id!;\n    let snapshotGroup = snapshotsById.get(id);\n    if (!snapshotGroup) {\n      snapshotGroup = [];\n      snapshotsById.set(id, snapshotGroup);\n    }\n    snapshotGroup.push(snapshots[i]);\n  }\n\n  const included = Array.isArray(coalescedPayload.included) ? coalescedPayload.included : [];\n\n  // resolve found records\n  const resources = coalescedPayload.data;\n  for (let i = 0, l = resources.length; i < l; i++) {\n    const resource = resources[i];\n    const snapshotGroup = snapshotsById.get(resource.id);\n    snapshotsById.delete(resource.id);\n\n    if (!snapshotGroup) {\n      // TODO consider whether this should be a deprecation/assertion\n      included.push(resource);\n    } else {\n      snapshotGroup.forEach((snapshot) => {\n        const pair = fetchMap.get(snapshot)!;\n        const resolver = pair.resolver;\n        resolver.resolve({ data: resource });\n      });\n    }\n  }\n\n  if (included.length > 0) {\n    store._push({ data: null, included }, true);\n  }\n\n  if (snapshotsById.size === 0) {\n    return;\n  }\n\n  // reject missing records\n  const rejected: Snapshot[] = [];\n  snapshotsById.forEach((snapshotArray) => {\n    rejected.push(...snapshotArray);\n  });\n  warn(\n    'Ember Data expected to find records with the following ids in the adapter response from findMany but they were missing: [ \"' +\n      [...snapshotsById.values()].map((r) => r[0].id).join('\", \"') +\n      '\" ]',\n    {\n      id: 'ds.store.missing-records-from-adapter',\n    }\n  );\n\n  rejectFetchedItems(fetchMap, rejected);\n}\n\nfunction _fetchRecord(store: Store, adapter: MinimumAdapterInterface, fetchItem: PendingFetchItem) {\n  upgradeStore(store);\n  const identifier = fetchItem.identifier;\n  const modelName = identifier.type;\n\n  assert(`You tried to find a record but you have no adapter (for ${modelName})`, adapter);\n  assert(\n    `You tried to find a record but your adapter (for ${modelName}) does not implement 'findRecord'`,\n    typeof adapter.findRecord === 'function'\n  );\n\n  const snapshot = store._fetchManager.createSnapshot(identifier, fetchItem.options);\n  const klass = store.modelFor(identifier.type);\n  const id = identifier.id;\n\n  let promise = Promise.resolve().then(() => {\n    return adapter.findRecord(store, klass, identifier.id, snapshot);\n  });\n\n  promise = promise.then((adapterPayload) => {\n    assert(`Async Leak Detected: Expected the store to not be destroyed`, !(store.isDestroyed || store.isDestroying));\n    assert(\n      `You made a 'findRecord' request for a '${modelName}' with id '${id}', but the adapter's response did not have any data`,\n      !!payloadIsNotBlank(adapterPayload)\n    );\n    const serializer = store.serializerFor(modelName);\n    const payload = normalizeResponseHelper(serializer, store, klass, adapterPayload, id, 'findRecord');\n    assert(\n      `Ember Data expected the primary data returned from a 'findRecord' response to be an object but instead it found an array.`,\n      !Array.isArray(payload.data)\n    );\n    assert(\n      `The 'findRecord' request for ${modelName}:${id} resolved indicating success but contained no primary data. To indicate a 404 not found you should either reject the promise returned by the adapter's findRecord method or throw a NotFoundError.`,\n      'data' in payload && payload.data !== null && typeof payload.data === 'object'\n    );\n\n    warn(\n      `You requested a record of type '${modelName}' with id '${id}' but the adapter returned a payload with primary data having an id of '${payload.data.id}'. Use 'store.findRecord()' when the requested id is the same as the one returned by the adapter. In other cases use 'store.queryRecord()' instead.`,\n      coerceId(payload.data.id) === coerceId(id),\n      {\n        id: 'ds.store.findRecord.id-mismatch',\n      }\n    );\n\n    return payload;\n  }) as Promise<AdapterPayload>;\n\n  fetchItem.resolver.resolve(promise);\n}\n\nfunction _processCoalescedGroup(\n  store: Store,\n  fetchMap: Map<Snapshot, PendingFetchItem>,\n  group: Snapshot[],\n  adapter: MinimumAdapterInterface,\n  modelName: string\n) {\n  if (group.length > 1) {\n    _findMany(store, adapter, modelName, group)\n      .then((payloads: CollectionResourceDocument) => {\n        handleFoundRecords(store, fetchMap, group, payloads);\n      })\n      .catch((error: Error) => {\n        rejectFetchedItems(fetchMap, group, error);\n      });\n  } else if (group.length === 1) {\n    _fetchRecord(store, adapter, fetchMap.get(group[0])!);\n  } else {\n    assert(\"You cannot return an empty array from adapter's method groupRecordsForFindMany\", false);\n  }\n}\n\nfunction _flushPendingFetchForType(\n  store: Store,\n  pendingFetchMap: Map<StableExistingRecordIdentifier, PendingFetchItem[]>,\n  modelName: string\n) {\n  upgradeStore(store);\n  const adapter = store.adapterFor(modelName);\n  const shouldCoalesce = !!adapter.findMany && adapter.coalesceFindRequests;\n\n  if (shouldCoalesce) {\n    const pendingFetchItems: PendingFetchItem[] = [];\n    pendingFetchMap.forEach((requestsForIdentifier, identifier) => {\n      if (requestsForIdentifier.length > 1) {\n        return;\n      }\n\n      // remove this entry from the map so it's not processed again\n      pendingFetchMap.delete(identifier);\n      pendingFetchItems.push(requestsForIdentifier[0]);\n    });\n\n    const totalItems = pendingFetchItems.length;\n\n    if (totalItems > 1) {\n      const snapshots = new Array<Snapshot>(totalItems);\n      const fetchMap = new Map<Snapshot, PendingFetchItem>();\n      for (let i = 0; i < totalItems; i++) {\n        const fetchItem = pendingFetchItems[i];\n        snapshots[i] = store._fetchManager.createSnapshot(fetchItem.identifier, fetchItem.options);\n        fetchMap.set(snapshots[i], fetchItem);\n      }\n\n      let groups: Snapshot[][];\n      if (adapter.groupRecordsForFindMany) {\n        groups = adapter.groupRecordsForFindMany(store, snapshots);\n      } else {\n        groups = [snapshots];\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        _processCoalescedGroup(store, fetchMap, groups[i], adapter, modelName);\n      }\n    } else if (totalItems === 1) {\n      _fetchRecord(store, adapter, pendingFetchItems[0]);\n    }\n  }\n\n  pendingFetchMap.forEach((pendingFetchItems) => {\n    pendingFetchItems.forEach((pendingFetchItem) => {\n      _fetchRecord(store, adapter, pendingFetchItem);\n    });\n  });\n}\n\nfunction _flushPendingSave(store: Store, pending: PendingSaveItem) {\n  const { snapshot, resolver, identifier, options } = pending;\n  upgradeStore(store);\n  const adapter = store.adapterFor(identifier.type);\n  const operation = options[SaveOp];\n\n  const modelName = snapshot.modelName;\n  const modelClass = store.modelFor(modelName);\n\n  assert(`You tried to update a record but you have no adapter (for ${modelName})`, adapter);\n  assert(\n    `You tried to update a record but your adapter (for ${modelName}) does not implement '${operation}'`,\n    typeof adapter[operation] === 'function'\n  );\n\n  let promise: Promise<AdapterPayload> = Promise.resolve().then(() => adapter[operation](store, modelClass, snapshot));\n  const serializer: SerializerWithParseErrors | null = store.serializerFor(modelName);\n\n  assert(\n    `Your adapter's '${operation}' method must return a value, but it returned 'undefined'`,\n    promise !== undefined\n  );\n\n  promise = promise.then((adapterPayload) => {\n    if (adapterPayload) {\n      return normalizeResponseHelper(serializer, store, modelClass, adapterPayload, snapshot.id, operation);\n    }\n  }) as Promise<AdapterPayload>;\n\n  resolver.resolve(promise);\n}\n","import type Store from '@ember-data/store';\n\nimport type { CompatStore } from '.';\n\n/**\n * Utilities - often temporary - for maintaining backwards compatibility with\n * older parts of EmberData.\n *\n  @module @ember-data/legacy-compat\n  @main @ember-data/legacy-compat\n*/\nexport { default as SnapshotRecordArray } from './legacy-network-handler/snapshot-record-array';\nexport { SaveOp } from './legacy-network-handler/fetch-manager';\nexport { default as FetchManager } from './legacy-network-handler/fetch-manager';\nexport { default as Snapshot } from './legacy-network-handler/snapshot';\n\nexport function upgradeStore(store: Store): asserts store is CompatStore {}\n"],"names":["SnapshotRecordArray","constructor","store","type","options","__store","_snapshots","modelName","adapterOptions","include","_recordArray","peekAll","length","snapshots","upgradeStore","_fetchManager","SOURCE","map","identifier","createSnapshot","assertIdentifierHasId","assert","id","iterateData","data","fn","Array","isArray","payloadIsNotBlank","adapterPayload","Object","keys","validateDocumentStructure","doc","macroCondition","getOwnConfig","env","DEBUG","errors","push","meta","links","jsonapi","included","join","normalizeResponseHelper","serializer","modelClass","payload","requestType","normalizedResponse","normalizeResponse","Snapshot","_store","__attributes","_belongsToRelationships","create","_belongsToIds","_hasManyRelationships","_hasManyIds","hasRecord","_instanceCache","peek","_attributes","cache","_changedAttributes","changedAttrs","record","peekRecord","lid","attributes","attrs","getSchemaDefinitionService","attributesDefinitionFor","forEach","keyName","getAttr","isNew","attr","changedAttributes","changedAttributeKeys","i","key","slice","belongsTo","returnModeIsId","result","relationshipMeta","relationshipsDefinitionFor","kind","packages","HAS_JSON_API_PACKAGE","graphFor","importSync","relationship","get","definition","value","getData","inverseIdentifier","identifierCache","getOrCreateRecordIdentifier","undefined","isDeleted","hasMany","returnModeIsIds","ids","results","cachedIds","cachedSnapshots","member","eachAttribute","callback","binding","attrDefs","call","eachRelationship","relationshipDefs","serialize","serializerFor","SaveOp","Symbol","FetchManager","_pendingFetch","Map","requestCache","getRequestStateService","isDestroyed","scheduleSave","resolver","createDeferred","query","op","recordIdentifier","queryRequest","snapshot","pendingSaveItem","monitored","_enqueue","promise","_flushPendingSave","scheduleFetch","request","pendingFetch","getPendingFetch","pendingFetchItem","resolverPromise","isInitialLoad","recordIsLoaded","then","potentiallyNewIm","_push","reload","error","isEmpty","isReleasable","HAS_GRAPH_PACKAGE","graph","unload","_enableAsyncFlush","unloadRecord","size","Promise","resolve","setTimeout","flushAllPendingFetches","fetchesByType","fetchesById","set","requestsForIdentifier","TESTING","disableTestWaiter","waitForPromise","pendingFetches","matchingPendingFetch","find","fetch","isSameRequest","fetchItem","_flushPendingFetchForType","clear","fetchDataIfNeededForIdentifier","_isEmpty","isLoading","_isLoading","assign","destroy","instanceCache","req","isLoaded","getPendingRequestsForRecord","some","r","includesSatisfies","current","existing","arrCurrent","split","sort","arrExisting","includes","optionsSatisfies","existingOptions","_findMany","adapter","modelFor","s","every","v","findMany","ret","rejectFetchedItems","fetchMap","l","pair","reject","Error","handleFoundRecords","coalescedPayload","snapshotsById","snapshotGroup","resources","resource","delete","rejected","snapshotArray","warn","values","_fetchRecord","findRecord","klass","isDestroying","coerceId","_processCoalescedGroup","group","payloads","catch","pendingFetchMap","adapterFor","shouldCoalesce","coalesceFindRequests","pendingFetchItems","totalItems","groups","groupRecordsForFindMany","pending","operation"],"mappings":";;;;;AAAA;AACA;AACA;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMA,mBAAmB,CAAC;AASvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEEC,WAAWA,CAACC,KAAY,EAAEC,IAAY,EAAEC,OAAoB,GAAG,EAAE,EAAE;IACjE,IAAI,CAACC,OAAO,GAAGH,KAAK,CAAA;AACpB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,UAAU,GAAG,IAAI,CAAA;;AAEtB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,SAAS,GAAGJ,IAAI,CAAA;;AAErB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKI,IAAA,IAAI,CAACK,cAAc,GAAGJ,OAAO,CAACI,cAAc,CAAA;;AAE5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMI,IAAA,IAAI,CAACC,OAAO,GAAGL,OAAO,CAACK,OAAO,CAAA;AAChC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;EAEE,IAAIC,YAAYA,GAAoB;IAClC,OAAO,IAAI,CAACL,OAAO,CAACM,OAAO,CAAC,IAAI,CAACJ,SAAS,CAAC,CAAA;AAC7C,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAKE,IAAIK,MAAMA,GAAW;AACnB,IAAA,OAAO,IAAI,CAACF,YAAY,CAACE,MAAM,CAAA;AACjC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMEC,EAAAA,SAASA,GAAG;AACV,IAAA,IAAI,IAAI,CAACP,UAAU,KAAK,IAAI,EAAE;MAC5B,OAAO,IAAI,CAACA,UAAU,CAAA;AACxB,KAAA;AACAQ,IAAAA,YAA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"}