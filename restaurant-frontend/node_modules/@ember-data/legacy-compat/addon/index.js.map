{"version":3,"file":"index.js","sources":["../src/legacy-network-handler/legacy-data-fetch.js","../src/legacy-network-handler/legacy-network-handler.ts","../src/index.ts"],"sourcesContent":["import { assert } from '@ember/debug';\n\nimport { DEBUG } from '@ember-data/env';\n\nimport { iterateData, payloadIsNotBlank } from './legacy-data-utils';\nimport { normalizeResponseHelper } from './serializer-response';\n\nexport function _findHasMany(adapter, store, identifier, link, relationship, options) {\n  let promise = Promise.resolve().then(() => {\n    const snapshot = store._fetchManager.createSnapshot(identifier, options);\n    const useLink = !link || typeof link === 'string';\n    const relatedLink = useLink ? link : link.href;\n    return adapter.findHasMany(store, snapshot, relatedLink, relationship);\n  });\n\n  promise = promise.then(\n    (adapterPayload) => {\n      assert(\n        `You made a 'findHasMany' request for a ${identifier.type}'s '${relationship.name}' relationship, using link '${link}' , but the adapter's response did not have any data`,\n        payloadIsNotBlank(adapterPayload)\n      );\n      const modelClass = store.modelFor(relationship.type);\n\n      const serializer = store.serializerFor(relationship.type);\n      let payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, 'findHasMany');\n\n      assert(\n        `fetched the hasMany relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${link}', but no data member is present in the response. If no data exists, the response should set { data: [] }`,\n        'data' in payload && Array.isArray(payload.data)\n      );\n\n      payload = syncRelationshipDataFromLink(store, payload, identifier, relationship);\n      return store._push(payload, true);\n    },\n    null,\n    `DS: Extract payload of '${identifier.type}' : hasMany '${relationship.type}'`\n  );\n\n  return promise;\n}\n\nexport function _findBelongsTo(store, identifier, link, relationship, options) {\n  let promise = Promise.resolve().then(() => {\n    const adapter = store.adapterFor(identifier.type);\n    assert(`You tried to load a belongsTo relationship but you have no adapter (for ${identifier.type})`, adapter);\n    assert(\n      `You tried to load a belongsTo relationship from a specified 'link' in the original payload but your adapter does not implement 'findBelongsTo'`,\n      typeof adapter.findBelongsTo === 'function'\n    );\n    const snapshot = store._fetchManager.createSnapshot(identifier, options);\n    const useLink = !link || typeof link === 'string';\n    const relatedLink = useLink ? link : link.href;\n    return adapter.findBelongsTo(store, snapshot, relatedLink, relationship);\n  });\n\n  promise = promise.then(\n    (adapterPayload) => {\n      const modelClass = store.modelFor(relationship.type);\n      const serializer = store.serializerFor(relationship.type);\n      let payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, 'findBelongsTo');\n\n      assert(\n        `fetched the belongsTo relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${link}', but no data member is present in the response. If no data exists, the response should set { data: null }`,\n        'data' in payload &&\n          (payload.data === null || (typeof payload.data === 'object' && !Array.isArray(payload.data)))\n      );\n\n      if (!payload.data && !payload.links && !payload.meta) {\n        return null;\n      }\n\n      payload = syncRelationshipDataFromLink(store, payload, identifier, relationship);\n\n      return store._push(payload, true);\n    },\n    null,\n    `DS: Extract payload of ${identifier.type} : ${relationship.type}`\n  );\n\n  return promise;\n}\n\n// sync\n// iterate over records in payload.data\n// for each record\n//   assert that record.relationships[inverse] is either undefined (so we can fix it)\n//     or provide a data: {id, type} that matches the record that requested it\n//   return the relationship data for the parent\nfunction syncRelationshipDataFromLink(store, payload, parentIdentifier, relationship) {\n  // ensure the right hand side (incoming payload) points to the parent record that\n  // requested this relationship\n  const relationshipData = payload.data\n    ? iterateData(payload.data, (data, index) => {\n        const { id, type } = data;\n        ensureRelationshipIsSetToParent(data, parentIdentifier, store, relationship, index);\n        return { id, type };\n      })\n    : null;\n\n  const relatedDataHash = {};\n\n  if ('meta' in payload) {\n    relatedDataHash.meta = payload.meta;\n  }\n  if ('links' in payload) {\n    relatedDataHash.links = payload.links;\n  }\n  if ('data' in payload) {\n    relatedDataHash.data = relationshipData;\n  }\n\n  // now, push the left hand side (the parent record) to ensure things are in sync, since\n  // the payload will be pushed with store._push\n  const parentPayload = {\n    id: parentIdentifier.id,\n    type: parentIdentifier.type,\n    relationships: {\n      [relationship.name]: relatedDataHash,\n    },\n  };\n\n  if (!Array.isArray(payload.included)) {\n    payload.included = [];\n  }\n  payload.included.push(parentPayload);\n\n  return payload;\n}\n\nfunction ensureRelationshipIsSetToParent(payload, parentIdentifier, store, parentRelationship, index) {\n  const { id, type } = payload;\n\n  if (!payload.relationships) {\n    payload.relationships = {};\n  }\n  const { relationships } = payload;\n\n  const inverse = getInverse(store, parentIdentifier, parentRelationship, type);\n  if (inverse) {\n    const { inverseKey, kind } = inverse;\n\n    const relationshipData = relationships[inverseKey] && relationships[inverseKey].data;\n\n    if (DEBUG) {\n      if (\n        typeof relationshipData !== 'undefined' &&\n        !relationshipDataPointsToParent(relationshipData, parentIdentifier)\n      ) {\n        const inspect = function inspect(thing) {\n          return `'${JSON.stringify(thing)}'`;\n        };\n        const quotedType = inspect(type);\n        const quotedInverse = inspect(inverseKey);\n        const expected = inspect({\n          id: parentIdentifier.id,\n          type: parentIdentifier.type,\n        });\n        const expectedModel = `${parentIdentifier.type}:${parentIdentifier.id}`;\n        const got = inspect(relationshipData);\n        const prefix = typeof index === 'number' ? `data[${index}]` : `data`;\n        const path = `${prefix}.relationships.${inverseKey}.data`;\n        const other = relationshipData ? `<${relationshipData.type}:${relationshipData.id}>` : null;\n        const relationshipFetched = `${expectedModel}.${parentRelationship.kind}(\"${parentRelationship.name}\")`;\n        const includedRecord = `<${type}:${id}>`;\n        const message = [\n          `Encountered mismatched relationship: Ember Data expected ${path} in the payload from ${relationshipFetched} to include ${expected} but got ${got} instead.\\n`,\n          `The ${includedRecord} record loaded at ${prefix} in the payload specified ${other} as its ${quotedInverse}, but should have specified ${expectedModel} (the record the relationship is being loaded from) as its ${quotedInverse} instead.`,\n          `This could mean that the response for ${relationshipFetched} may have accidentally returned ${quotedType} records that aren't related to ${expectedModel} and could be related to a different ${parentIdentifier.type} record instead.`,\n          `Ember Data has corrected the ${includedRecord} record's ${quotedInverse} relationship to ${expectedModel} so that ${relationshipFetched} will include ${includedRecord}.`,\n          `Please update the response from the server or change your serializer to either ensure that the response for only includes ${quotedType} records that specify ${expectedModel} as their ${quotedInverse}, or omit the ${quotedInverse} relationship from the response.`,\n        ].join('\\n');\n\n        assert(message);\n      }\n    }\n\n    if (kind !== 'hasMany' || typeof relationshipData !== 'undefined') {\n      relationships[inverseKey] = relationships[inverseKey] || {};\n      relationships[inverseKey].data = fixRelationshipData(relationshipData, kind, parentIdentifier);\n    }\n  }\n}\n\nfunction inverseForRelationship(store, identifier, key) {\n  const definition = store.getSchemaDefinitionService().relationshipsDefinitionFor(identifier)[key];\n  if (!definition) {\n    return null;\n  }\n\n  assert(\n    `Expected the relationship defintion to specify the inverse type or null.`,\n    definition.options?.inverse === null ||\n      (typeof definition.options?.inverse === 'string' && definition.options.inverse.length > 0)\n  );\n  return definition.options.inverse;\n}\n\nfunction getInverse(store, parentIdentifier, parentRelationship, type) {\n  const { name: lhs_relationshipName } = parentRelationship;\n  const { type: parentType } = parentIdentifier;\n  const inverseKey = inverseForRelationship(store, { type: parentType }, lhs_relationshipName);\n\n  if (inverseKey) {\n    const definition = store.getSchemaDefinitionService().relationshipsDefinitionFor({ type });\n    const { kind } = definition[inverseKey];\n    return {\n      inverseKey,\n      kind,\n    };\n  }\n}\n\nfunction relationshipDataPointsToParent(relationshipData, identifier) {\n  if (relationshipData === null) {\n    return false;\n  }\n\n  if (Array.isArray(relationshipData)) {\n    if (relationshipData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < relationshipData.length; i++) {\n      const entry = relationshipData[i];\n      if (validateRelationshipEntry(entry, identifier)) {\n        return true;\n      }\n    }\n  } else {\n    return validateRelationshipEntry(relationshipData, identifier);\n  }\n\n  return false;\n}\n\nfunction fixRelationshipData(relationshipData, relationshipKind, { id, type }) {\n  const parentRelationshipData = {\n    id,\n    type,\n  };\n\n  let payload;\n\n  if (relationshipKind === 'hasMany') {\n    payload = relationshipData || [];\n    if (relationshipData) {\n      // these arrays could be massive so this is better than filter\n      // Note: this is potentially problematic if type/id are not in the\n      // same state of normalization.\n      const found = relationshipData.find((v) => {\n        return v.type === parentRelationshipData.type && v.id === parentRelationshipData.id;\n      });\n      if (!found) {\n        payload.push(parentRelationshipData);\n      }\n    } else {\n      payload.push(parentRelationshipData);\n    }\n  } else {\n    payload = relationshipData || {};\n    Object.assign(payload, parentRelationshipData);\n  }\n\n  return payload;\n}\n\nfunction validateRelationshipEntry({ id }, { id: parentModelID }) {\n  return id && id.toString() === parentModelID;\n}\n","import { assert } from '@ember/debug';\n\nimport { importSync } from '@embroider/macros';\n\nimport { LOG_PAYLOADS } from '@ember-data/debugging';\nimport { DEBUG, TESTING } from '@ember-data/env';\nimport type { Future, Handler, NextFn, StructuredDataDocument } from '@ember-data/request';\nimport type Store from '@ember-data/store';\nimport type { StoreRequestContext, StoreRequestInfo } from '@ember-data/store/-private/cache-handler';\nimport type { Collection } from '@ember-data/store/-private/record-arrays/identifier-array';\nimport type { ModelSchema } from '@ember-data/store/-types/q/ds-model';\nimport type { JsonApiError } from '@ember-data/store/-types/q/record-data-json-api';\nimport type { StableExistingRecordIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';\nimport type { RelationshipSchema } from '@warp-drive/core-types/schema';\nimport type { SingleResourceDataDocument } from '@warp-drive/core-types/spec/document';\nimport type {\n  CollectionResourceDocument,\n  JsonApiDocument,\n  Links,\n  PaginationLinks,\n  SingleResourceDocument,\n} from '@warp-drive/core-types/spec/raw';\n\nimport { upgradeStore } from '../-private';\nimport FetchManager, { SaveOp } from './fetch-manager';\nimport { assertIdentifierHasId } from './identifier-has-id';\nimport { _findBelongsTo, _findHasMany } from './legacy-data-fetch';\nimport { payloadIsNotBlank } from './legacy-data-utils';\nimport type { MinimumAdapterInterface } from './minimum-adapter-interface';\nimport type { MinimumSerializerInterface } from './minimum-serializer-interface';\nimport { normalizeResponseHelper } from './serializer-response';\nimport type Snapshot from './snapshot';\nimport SnapshotRecordArray from './snapshot-record-array';\n\ntype AdapterErrors = Error & { errors?: unknown[]; isAdapterError?: true; code?: string };\ntype SerializerWithParseErrors = MinimumSerializerInterface & {\n  extractErrors?(store: Store, modelClass: ModelSchema, error: AdapterErrors, recordId: string | null): unknown;\n};\n\nconst PotentialLegacyOperations = new Set([\n  'findRecord',\n  'findAll',\n  'query',\n  'queryRecord',\n  'findBelongsTo',\n  'findHasMany',\n  'updateRecord',\n  'createRecord',\n  'deleteRecord',\n]);\n\nexport const LegacyNetworkHandler: Handler = {\n  request<T>(context: StoreRequestContext, next: NextFn<T>): Future<T> | Promise<StructuredDataDocument<T>> {\n    // if we are not a legacy request, move on\n    if (context.request.url || !context.request.op || !PotentialLegacyOperations.has(context.request.op)) {\n      return next(context.request);\n    }\n\n    const { store } = context.request;\n    upgradeStore(store);\n    if (!store._fetchManager) {\n      store._fetchManager = new FetchManager(store);\n    }\n\n    switch (context.request.op) {\n      case 'findRecord':\n        return findRecord(context);\n      case 'findAll':\n        return findAll(context);\n      case 'query':\n        return query(context);\n      case 'queryRecord':\n        return queryRecord(context);\n      case 'findBelongsTo':\n        return findBelongsTo(context);\n      case 'findHasMany':\n        return findHasMany(context);\n      case 'updateRecord':\n        return saveRecord(context);\n      case 'createRecord':\n        return saveRecord(context);\n      case 'deleteRecord':\n        return saveRecord(context);\n      default:\n        return next(context.request);\n    }\n  },\n};\n\nfunction findBelongsTo<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, records: identifiers } = context.request;\n  const { options, record, links, useLink, field } = data as {\n    record: StableRecordIdentifier;\n    options: Record<string, unknown>;\n    links?: Links;\n    useLink: boolean;\n    field: RelationshipSchema;\n  };\n  const identifier = identifiers?.[0];\n  upgradeStore(store);\n\n  // short circuit if we are already loading\n  const pendingRequest =\n    identifier && store._fetchManager.getPendingFetch(identifier as StableExistingRecordIdentifier, options);\n  if (pendingRequest) {\n    return pendingRequest as Promise<T>;\n  }\n\n  if (useLink) {\n    assert(`Expected a related link when calling store.findBelongsTo, found ${String(links)}`, links && links.related);\n    return _findBelongsTo(store, record, links.related, field, options) as Promise<T>;\n  }\n\n  assert(`Expected an identifier`, Array.isArray(identifiers) && identifiers.length === 1);\n\n  const manager = store._fetchManager;\n  assertIdentifierHasId(identifier);\n\n  return options.reload\n    ? (manager.scheduleFetch(identifier, options, context.request) as Promise<T>)\n    : (manager.fetchDataIfNeededForIdentifier(identifier, options, context.request) as Promise<T>);\n}\n\nfunction findHasMany<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, records: identifiers } = context.request;\n  const { options, record, links, useLink, field } = data as {\n    record: StableRecordIdentifier;\n    options: Record<string, unknown>;\n    links?: PaginationLinks | Links;\n    useLink: boolean;\n    field: RelationshipSchema;\n  };\n  upgradeStore(store);\n\n  // link case\n  if (useLink) {\n    const adapter = store.adapterFor(record.type);\n    /*\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n\n    The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n\n    The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n  */\n    assert(`You tried to load a hasMany relationship but you have no adapter (for ${record.type})`, adapter);\n    assert(\n      `You tried to load a hasMany relationship from a specified 'link' in the original payload but your adapter does not implement 'findHasMany'`,\n      typeof adapter.findHasMany === 'function'\n    );\n    assert(`Expected a related link when calling store.findhasMany, found ${String(links)}`, links && links.related);\n\n    return _findHasMany(adapter, store, record, links.related, field, options) as Promise<T>;\n  }\n\n  // identifiers case\n  assert(`Expected an array of identifiers to fetch`, Array.isArray(identifiers));\n  const fetches = new Array<globalThis.Promise<StableRecordIdentifier>>(identifiers.length);\n  const manager = store._fetchManager;\n\n  for (let i = 0; i < identifiers.length; i++) {\n    const identifier = identifiers[i];\n    // TODO we probably can be lenient here and return from cache for the isNew case\n    assertIdentifierHasId(identifier);\n    fetches[i] = options.reload\n      ? manager.scheduleFetch(identifier, options, context.request)\n      : manager.fetchDataIfNeededForIdentifier(identifier, options, context.request);\n  }\n\n  return Promise.all(fetches) as Promise<T>;\n}\n\nfunction saveRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, op: operation } = context.request;\n  const { options, record: identifier } = data as { record: StableRecordIdentifier; options: Record<string, unknown> };\n\n  upgradeStore(store);\n\n  const saveOptions = Object.assign(\n    { [SaveOp]: operation as 'updateRecord' | 'deleteRecord' | 'createRecord' },\n    options\n  );\n  const fetchManagerPromise = store._fetchManager.scheduleSave(identifier, saveOptions);\n\n  return fetchManagerPromise\n    .then((payload) => {\n      if (LOG_PAYLOADS) {\n        try {\n          const payloadCopy: unknown = payload ? JSON.parse(JSON.stringify(payload)) : payload;\n          // eslint-disable-next-line no-console\n          console.log(`EmberData | Payload - ${operation}`, payloadCopy);\n        } catch (e) {\n          // eslint-disable-next-line no-console\n          console.log(`EmberData | Payload - ${operation}`, payload);\n        }\n      }\n      let result: SingleResourceDataDocument;\n      store._join(() => {\n        // @ts-expect-error we don't have access to a response in legacy\n        result = store.cache.didCommit(identifier, { request: context.request, content: payload });\n      });\n\n      // blatantly lie if we were a createRecord request\n      // to give some semblance of cache-control to the\n      // lifetimes service while legacy is still around\n      if (store.lifetimes?.didRequest && operation === 'createRecord') {\n        store.lifetimes.didRequest(context.request, { status: 201 } as Response, null, store);\n      }\n      return store.peekRecord(result!.data!);\n    })\n    .catch((e: unknown) => {\n      let err = e;\n      if (!e) {\n        err = new Error(`Unknown Error Occurred During Request`);\n      } else if (typeof e === 'string') {\n        err = new Error(e);\n      }\n      adapterDidInvalidate(store, identifier, err as Error);\n      throw err;\n    }) as Promise<T>;\n}\n\nfunction adapterDidInvalidate(\n  store: Store,\n  identifier: StableRecordIdentifier,\n  error: Error & { errors?: JsonApiError[]; isAdapterError?: true; code?: string }\n) {\n  upgradeStore(store);\n  if (error && error.isAdapterError === true && error.code === 'InvalidError') {\n    const serializer = store.serializerFor(identifier.type) as SerializerWithParseErrors;\n\n    // TODO @deprecate extractErrors being called\n    // TODO remove extractErrors from the default serializers.\n    if (serializer && typeof serializer.extractErrors === 'function') {\n      const errorsHash = serializer.extractErrors(\n        store,\n        store.modelFor(identifier.type),\n        error,\n        identifier.id\n      ) as Record<string, string | string[]>;\n      error.errors = errorsHashToArray(errorsHash);\n    }\n  }\n  const cache = store.cache;\n\n  if (error.errors) {\n    assert(\n      `Expected the cache in use by resource ${String(\n        identifier\n      )} to have a getErrors(identifier) method for retreiving errors.`,\n      typeof cache.getErrors === 'function'\n    );\n\n    let jsonApiErrors: JsonApiError[] = error.errors;\n    if (jsonApiErrors.length === 0) {\n      jsonApiErrors = [{ title: 'Invalid Error', detail: '', source: { pointer: '/data' } }];\n    }\n    cache.commitWasRejected(identifier, jsonApiErrors);\n  } else {\n    cache.commitWasRejected(identifier);\n  }\n}\n\nfunction makeArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst PRIMARY_ATTRIBUTE_KEY = 'base';\nfunction errorsHashToArray(errors: Record<string, string | string[]>): JsonApiError[] {\n  const out: JsonApiError[] = [];\n\n  if (errors) {\n    Object.keys(errors).forEach((key) => {\n      const messages = makeArray(errors[key]);\n      for (let i = 0; i < messages.length; i++) {\n        let title = 'Invalid Attribute';\n        let pointer = `/data/attributes/${key}`;\n        if (key === PRIMARY_ATTRIBUTE_KEY) {\n          title = 'Invalid Document';\n          pointer = `/data`;\n        }\n        out.push({\n          title: title,\n          detail: messages[i],\n          source: {\n            pointer: pointer,\n          },\n        });\n      }\n    });\n  }\n\n  return out;\n}\n\nfunction findRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  const { record: identifier, options } = data as {\n    record: StableExistingRecordIdentifier;\n    options: { reload?: boolean; backgroundReload?: boolean };\n  };\n  upgradeStore(store);\n  let promise: Promise<StableRecordIdentifier>;\n\n  // if not loaded start loading\n  if (!store._instanceCache.recordIsLoaded(identifier)) {\n    promise = store._fetchManager.fetchDataIfNeededForIdentifier(identifier, options, context.request);\n\n    // Refetch if the reload option is passed\n  } else if (options.reload) {\n    assertIdentifierHasId(identifier);\n\n    promise = store._fetchManager.scheduleFetch(identifier, options, context.request);\n  } else {\n    let snapshot: Snapshot | null = null;\n    const adapter = store.adapterFor(identifier.type);\n\n    // Refetch the record if the adapter thinks the record is stale\n    if (\n      typeof options.reload === 'undefined' &&\n      adapter.shouldReloadRecord &&\n      adapter.shouldReloadRecord(store, (snapshot = store._fetchManager.createSnapshot(identifier, options)))\n    ) {\n      assertIdentifierHasId(identifier);\n      if (DEBUG) {\n        promise = store._fetchManager.scheduleFetch(\n          identifier,\n          Object.assign({}, options, { reload: true }),\n          context.request\n        );\n      } else {\n        options.reload = true;\n        promise = store._fetchManager.scheduleFetch(identifier, options, context.request);\n      }\n    } else {\n      // Trigger the background refetch if backgroundReload option is passed\n      if (\n        options.backgroundReload !== false &&\n        (options.backgroundReload ||\n          !adapter.shouldBackgroundReloadRecord ||\n          adapter.shouldBackgroundReloadRecord(\n            store,\n            (snapshot = snapshot || store._fetchManager.createSnapshot(identifier, options))\n          ))\n      ) {\n        assertIdentifierHasId(identifier);\n\n        if (DEBUG) {\n          void store._fetchManager.scheduleFetch(\n            identifier,\n            Object.assign({}, options, { backgroundReload: true }),\n            context.request\n          );\n        } else {\n          options.backgroundReload = true;\n          void store._fetchManager.scheduleFetch(identifier, options, context.request);\n        }\n      }\n\n      // Return the cached record\n      promise = Promise.resolve(identifier) as Promise<StableRecordIdentifier>;\n    }\n  }\n\n  return promise.then((i: StableRecordIdentifier) => store.peekRecord(i)) as Promise<T>;\n}\n\nfunction findAll<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  const { type, options } = data as {\n    type: string;\n    options: { reload?: boolean; backgroundReload?: boolean };\n  };\n  upgradeStore(store);\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to load all records but you have no adapter (for ${type})`, adapter);\n  assert(\n    `You tried to load all records but your adapter does not implement 'findAll'`,\n    typeof adapter.findAll === 'function'\n  );\n\n  // avoid initializing the liveArray just to set `isUpdating`\n  const maybeRecordArray = store.recordArrayManager._live.get(type);\n  const snapshotArray = new SnapshotRecordArray(store, type, options);\n\n  const shouldReload =\n    options.reload ||\n    (options.reload !== false &&\n      ((adapter.shouldReloadAll && adapter.shouldReloadAll(store, snapshotArray)) ||\n        (!adapter.shouldReloadAll && snapshotArray.length === 0)));\n\n  let fetch: Promise<T> | undefined;\n  if (shouldReload) {\n    maybeRecordArray && (maybeRecordArray.isUpdating = true);\n    fetch = _findAll(adapter, store, type, snapshotArray, context.request, true);\n  } else {\n    fetch = Promise.resolve(store.peekAll(type)) as Promise<T>;\n\n    if (\n      options.backgroundReload ||\n      (options.backgroundReload !== false &&\n        (!adapter.shouldBackgroundReloadAll || adapter.shouldBackgroundReloadAll(store, snapshotArray)))\n    ) {\n      maybeRecordArray && (maybeRecordArray.isUpdating = true);\n      void _findAll(adapter, store, type, snapshotArray, context.request, false);\n    }\n  }\n\n  return fetch;\n}\n\nfunction _findAll<T>(\n  adapter: MinimumAdapterInterface,\n  store: Store,\n  type: string,\n  snapshotArray: SnapshotRecordArray,\n  request: StoreRequestInfo,\n  isAsyncFlush: boolean\n): Promise<T> {\n  const schema = store.modelFor(type);\n  let promise: Promise<T> = Promise.resolve().then(() =>\n    adapter.findAll(store, schema, null, snapshotArray)\n  ) as Promise<T>;\n\n  promise = promise.then((adapterPayload: T) => {\n    assert(\n      `You made a 'findAll' request for '${type}' records, but the adapter's response did not have any data`,\n      payloadIsNotBlank(adapterPayload)\n    );\n    upgradeStore(store);\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(serializer, store, schema, adapterPayload, null, 'findAll');\n\n    store._push(payload, isAsyncFlush);\n    snapshotArray._recordArray.isUpdating = false;\n\n    if (LOG_PAYLOADS) {\n      // eslint-disable-next-line no-console\n      console.log(`request: findAll<${type}> background reload complete`);\n    }\n    return snapshotArray._recordArray;\n  }) as Promise<T>;\n\n  if (TESTING) {\n    if (!request.disableTestWaiter) {\n      const { waitForPromise } = importSync('@ember/test-waiters') as {\n        waitForPromise: <PT>(promise: Promise<PT>) => Promise<PT>;\n      };\n      promise = waitForPromise(promise);\n    }\n  }\n\n  return promise;\n}\n\nfunction query<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  upgradeStore(store);\n  let { options } = data as {\n    options: { _recordArray?: Collection; adapterOptions?: Record<string, unknown> };\n  };\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const { type, query } = data as {\n    type: string;\n    query: Record<string, unknown>;\n    options: { _recordArray?: Collection; adapterOptions?: Record<string, unknown> };\n  };\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to make a query but you have no adapter (for ${type})`, adapter);\n  assert(`You tried to make a query but your adapter does not implement 'query'`, typeof adapter.query === 'function');\n\n  const recordArray =\n    options._recordArray ||\n    store.recordArrayManager.createArray({\n      type,\n      query,\n    });\n\n  if (DEBUG) {\n    options = Object.assign({}, options);\n    delete options._recordArray;\n  } else {\n    delete options._recordArray;\n  }\n  const schema = store.modelFor(type);\n  const promise = Promise.resolve().then(() => adapter.query(store, schema, query, recordArray, options));\n\n  return promise.then((adapterPayload) => {\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(\n      serializer,\n      store,\n      schema,\n      adapterPayload as Record<string, unknown>,\n      null,\n      'query'\n    );\n    const identifiers = store._push(payload, true);\n\n    assert(\n      'The response to store.query is expected to be an array but it was a single record. Please wrap your response in an array or use `store.queryRecord` to query for a single record.',\n      Array.isArray(identifiers)\n    );\n\n    store.recordArrayManager.populateManagedArray(recordArray, identifiers, payload as CollectionResourceDocument);\n\n    return recordArray;\n  }) as Promise<T>;\n}\n\nfunction assertSingleResourceDocument(payload: JsonApiDocument): asserts payload is SingleResourceDocument {\n  assert(\n    `Expected the primary data returned by the serializer for a 'queryRecord' response to be a single object or null but instead it was an array.`,\n    !Array.isArray(payload.data)\n  );\n}\n\nfunction queryRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const { type, query, options } = data as { type: string; query: Record<string, unknown>; options: object };\n  upgradeStore(store);\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to make a query but you have no adapter (for ${type})`, adapter);\n  assert(\n    `You tried to make a query but your adapter does not implement 'queryRecord'`,\n    typeof adapter.queryRecord === 'function'\n  );\n\n  const schema = store.modelFor(type);\n  const promise = Promise.resolve().then(() => adapter.queryRecord(store, schema, query, options)) as Promise<T>;\n\n  return promise.then((adapterPayload: T) => {\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(\n      serializer,\n      store,\n      schema,\n      adapterPayload as Record<string, unknown>,\n      null,\n      'queryRecord'\n    );\n\n    assertSingleResourceDocument(payload);\n\n    const identifier = store._push(payload, true) as StableRecordIdentifier;\n    return identifier ? store.peekRecord(identifier) : null;\n  }) as Promise<T>;\n}\n","import { getOwner } from '@ember/application';\nimport { assert } from '@ember/debug';\n\nimport type Store from '@ember-data/store';\nimport { recordIdentifierFor } from '@ember-data/store';\nimport { _deprecatingNormalize } from '@ember-data/store/-private';\nimport type { ObjectValue } from '@warp-drive/core-types/json/raw';\n\nimport { FetchManager, upgradeStore } from './-private';\nimport type { MinimumAdapterInterface } from './legacy-network-handler/minimum-adapter-interface';\nimport type {\n  MinimumSerializerInterface,\n  SerializerOptions,\n} from './legacy-network-handler/minimum-serializer-interface';\n\nexport { LegacyNetworkHandler } from './legacy-network-handler/legacy-network-handler';\n\n/**\n * @module @ember-data/store\n * @class Store\n */\nexport type LegacyStoreCompat = {\n  _fetchManager: FetchManager;\n  adapterFor(this: Store, modelName: string): MinimumAdapterInterface;\n  adapterFor(this: Store, modelName: string, _allowMissing: true): MinimumAdapterInterface | undefined;\n\n  serializerFor<K extends string>(modelName: K, _allowMissing?: boolean): MinimumSerializerInterface | null;\n\n  normalize(modelName: string, payload: ObjectValue): ObjectValue;\n  pushPayload(modelName: string, payload: ObjectValue): void;\n  serializeRecord(record: unknown, options?: SerializerOptions): unknown;\n\n  _adapterCache: Record<string, MinimumAdapterInterface & { store: Store }>;\n  _serializerCache: Record<string, MinimumSerializerInterface & { store: Store }>;\n};\n\nexport type CompatStore = Store & LegacyStoreCompat;\n\n/**\n    Returns an instance of the adapter for a given type. For\n    example, `adapterFor('person')` will return an instance of\n    the adapter located at `app/adapters/person.js`\n\n    If no `person` adapter is found, this method will look\n    for an `application` adapter (the default adapter for\n    your entire application).\n\n    @method adapterFor\n    @public\n    @param {String} modelName\n    @return Adapter\n  */\nexport function adapterFor(this: Store, modelName: string): MinimumAdapterInterface;\nexport function adapterFor(this: Store, modelName: string, _allowMissing: true): MinimumAdapterInterface | undefined;\nexport function adapterFor(this: Store, modelName: string, _allowMissing?: true): MinimumAdapterInterface | undefined {\n  assert(\n    `Attempted to call store.adapterFor(), but the store instance has already been destroyed.`,\n    !(this.isDestroying || this.isDestroyed)\n  );\n  assert(`You need to pass a model name to the store's adapterFor method`, modelName);\n  assert(\n    `Passing classes to store.adapterFor has been removed. Please pass a dasherized string instead of ${modelName}`,\n    typeof modelName === 'string'\n  );\n  upgradeStore(this);\n  this._adapterCache =\n    this._adapterCache || (Object.create(null) as Record<string, MinimumAdapterInterface & { store: Store }>);\n\n  const normalizedModelName = _deprecatingNormalize(modelName);\n\n  const { _adapterCache } = this;\n  let adapter: (MinimumAdapterInterface & { store: Store }) | undefined = _adapterCache[normalizedModelName];\n  if (adapter) {\n    return adapter;\n  }\n\n  const owner = getOwner(this)!;\n\n  // name specific adapter\n  adapter = owner.lookup(`adapter:${normalizedModelName}`) as (MinimumAdapterInterface & { store: Store }) | undefined;\n  if (adapter !== undefined) {\n    _adapterCache[normalizedModelName] = adapter;\n    return adapter;\n  }\n\n  // no adapter found for the specific name, fallback and check for application adapter\n  adapter = _adapterCache.application || owner.lookup('adapter:application');\n  if (adapter !== undefined) {\n    _adapterCache[normalizedModelName] = adapter;\n    _adapterCache.application = adapter;\n    return adapter;\n  }\n\n  assert(\n    `No adapter was found for '${modelName}' and no 'application' adapter was found as a fallback.`,\n    _allowMissing\n  );\n}\n\n/**\n    Returns an instance of the serializer for a given type. For\n    example, `serializerFor('person')` will return an instance of\n    `App.PersonSerializer`.\n\n    If no `App.PersonSerializer` is found, this method will look\n    for an `App.ApplicationSerializer` (the default serializer for\n    your entire application).\n\n    If a serializer cannot be found on the adapter, it will fall back\n    to an instance of `JSONSerializer`.\n\n    @method serializerFor\n    @public\n    @param {String} modelName the record to serialize\n    @return {Serializer}\n  */\nexport function serializerFor(this: Store, modelName: string): MinimumSerializerInterface | null {\n  assert(\n    `Attempted to call store.serializerFor(), but the store instance has already been destroyed.`,\n    !(this.isDestroying || this.isDestroyed)\n  );\n  assert(`You need to pass a model name to the store's serializerFor method`, modelName);\n  assert(\n    `Passing classes to store.serializerFor has been removed. Please pass a dasherized string instead of ${modelName}`,\n    typeof modelName === 'string'\n  );\n  upgradeStore(this);\n  this._serializerCache =\n    this._serializerCache || (Object.create(null) as Record<string, MinimumSerializerInterface & { store: Store }>);\n  const normalizedModelName = _deprecatingNormalize(modelName);\n\n  const { _serializerCache } = this;\n  let serializer: (MinimumSerializerInterface & { store: Store }) | undefined = _serializerCache[normalizedModelName];\n  if (serializer) {\n    return serializer;\n  }\n\n  // by name\n  const owner = getOwner(this)!;\n  serializer = owner.lookup(`serializer:${normalizedModelName}`) as\n    | (MinimumSerializerInterface & { store: Store })\n    | undefined;\n  if (serializer !== undefined) {\n    _serializerCache[normalizedModelName] = serializer;\n    return serializer;\n  }\n\n  // no serializer found for the specific model, fallback and check for application serializer\n  serializer = _serializerCache.application || owner.lookup('serializer:application');\n  if (serializer !== undefined) {\n    _serializerCache[normalizedModelName] = serializer;\n    _serializerCache.application = serializer;\n    return serializer;\n  }\n\n  return null;\n}\n\n/**\n    `normalize` converts a json payload into the normalized form that\n    [push](../methods/push?anchor=push) expects.\n\n    Example\n\n    ```js\n    socket.on('message', function(message) {\n      let modelName = message.model;\n      let data = message.data;\n      store.push(store.normalize(modelName, data));\n    });\n    ```\n\n    @method normalize\n    @public\n    @param {String} modelName The name of the model type for this payload\n    @param {Object} payload\n    @return {Object} The normalized payload\n  */\n// TODO @runspired @deprecate users should call normalize on the associated serializer directly\nexport function normalize(this: Store, modelName: string, payload: ObjectValue) {\n  upgradeStore(this);\n  assert(\n    `Attempted to call store.normalize(), but the store instance has already been destroyed.`,\n    !(this.isDestroying || this.isDestroyed)\n  );\n  assert(`You need to pass a model name to the store's normalize method`, modelName);\n  assert(\n    `Passing classes to store methods has been removed. Please pass a dasherized string instead of ${typeof modelName}`,\n    typeof modelName === 'string'\n  );\n  const normalizedModelName = _deprecatingNormalize(modelName);\n  const serializer = this.serializerFor(normalizedModelName);\n  const schema = this.modelFor(normalizedModelName);\n  assert(\n    `You must define a normalize method in your serializer in order to call store.normalize`,\n    typeof serializer?.normalize === 'function'\n  );\n  return serializer.normalize(schema, payload);\n}\n\n/**\n    Push some raw data into the store.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records. You\n    can push in more than one type of object at once.\n    All objects should be in the format expected by the\n    serializer.\n\n    ```app/serializers/application.js\n    import RESTSerializer from '@ember-data/serializer/rest';\n\n    export default class ApplicationSerializer extends RESTSerializer;\n    ```\n\n    ```js\n    let pushData = {\n      posts: [\n        { id: 1, postTitle: \"Great post\", commentIds: [2] }\n      ],\n      comments: [\n        { id: 2, commentBody: \"Insightful comment\" }\n      ]\n    }\n\n    store.pushPayload(pushData);\n    ```\n\n    By default, the data will be deserialized using a default\n    serializer (the application serializer if it exists).\n\n    Alternatively, `pushPayload` will accept a model type which\n    will determine which serializer will process the payload.\n\n    ```app/serializers/application.js\n    import RESTSerializer from '@ember-data/serializer/rest';\n\n     export default class ApplicationSerializer extends RESTSerializer;\n    ```\n\n    ```app/serializers/post.js\n    import JSONSerializer from '@ember-data/serializer/json';\n\n    export default JSONSerializer;\n    ```\n\n    ```js\n    store.pushPayload(pushData); // Will use the application serializer\n    store.pushPayload('post', pushData); // Will use the post serializer\n    ```\n\n    @method pushPayload\n    @public\n    @param {String} modelName Optionally, a model type used to determine which serializer will be used\n    @param {Object} inputPayload\n  */\n// TODO @runspired @deprecate pushPayload in favor of looking up the serializer\nexport function pushPayload(this: Store, modelName: string, inputPayload: ObjectValue): void {\n  upgradeStore(this);\n  assert(\n    `Attempted to call store.pushPayload(), but the store instance has already been destroyed.`,\n    !(this.isDestroying || this.isDestroyed)\n  );\n\n  const payload: ObjectValue = inputPayload || (modelName as unknown as ObjectValue);\n  const normalizedModelName = inputPayload ? _deprecatingNormalize(modelName) : 'application';\n  const serializer = this.serializerFor(normalizedModelName);\n\n  assert(\n    `You cannot use 'store.pushPayload(<type>, <payload>)' unless the serializer for '${normalizedModelName}' defines 'pushPayload'`,\n    serializer && typeof serializer.pushPayload === 'function'\n  );\n  serializer.pushPayload(this, payload);\n}\n\n// TODO @runspired @deprecate records should implement their own serialization if desired\nexport function serializeRecord(this: Store, record: unknown, options?: SerializerOptions): unknown {\n  upgradeStore(this);\n  // TODO we used to check if the record was destroyed here\n  if (!this._fetchManager) {\n    this._fetchManager = new FetchManager(this);\n  }\n\n  return this._fetchManager.createSnapshot(recordIdentifierFor(record)).serialize(options);\n}\n\nexport function cleanup(this: Store) {\n  upgradeStore(this);\n  // enqueue destruction of any adapters/serializers we have created\n  for (const adapterName in this._adapterCache) {\n    const adapter = this._adapterCache[adapterName]!;\n    if (typeof adapter.destroy === 'function') {\n      adapter.destroy();\n    }\n  }\n\n  for (const serializerName in this._serializerCache) {\n    const serializer = this._serializerCache[serializerName]!;\n    if (typeof serializer.destroy === 'function') {\n      serializer.destroy();\n    }\n  }\n}\n"],"names":["_findHasMany","adapter","store","identifier","link","relationship","options","promise","Promise","resolve","then","snapshot","_fetchManager","createSnapshot","useLink","relatedLink","href","findHasMany","adapterPayload","assert","type","name","payloadIsNotBlank","modelClass","modelFor","serializer","serializerFor","payload","normalizeResponseHelper","id","Array","isArray","data","syncRelationshipDataFromLink","_push","_findBelongsTo","adapterFor","findBelongsTo","links","meta","parentIdentifier","relationshipData","iterateData","index","ensureRelationshipIsSetToParent","relatedDataHash","parentPayload","relationships","included","push","parentRelationship","inverse","getInverse","inverseKey","kind","macroCondition","getOwnConfig","env","DEBUG","relationshipDataPointsToParent","inspect","thing","JSON","stringify","quotedType","quotedInverse","expected","expectedModel","got","prefix","path","other","relationshipFetched","includedRecord","message","join","fixRelationshipData","inverseForRelationship","key","definition","getSchemaDefinitionService","relationshipsDefinitionFor","length","lhs_relationshipName","parentType","i","entry","validateRelationshipEntry","relationshipKind","parentRelationshipData","found","find","v","Object","assign","parentModelID","toString","PotentialLegacyOperations","Set","LegacyNetworkHandler","request","context","next","url","op","has","FetchManager","findRecord","findAll","query","queryRecord","saveRecord","records","identifiers","record","field","pendingRequest","getPendingFetch","String","related","manager","assertIdentifierHasId","reload","scheduleFetch","fetchDataIfNeededForIdentifier","fetches","all","operation","saveOptions","SaveOp","fetchManagerPromise","scheduleSave","debug","LOG_PAYLOADS","payloadCopy","parse","console","log","e","result","_join","cache","didCommit","content","lifetimes","didRequest","status","peekRecord","catch","err","Error","adapterDidInvalidate","error","isAdapterError","code","extractErrors","errorsHash","errors","errorsHashToArray","getErrors","jsonApiErrors","title","detail","source","pointer","commitWasRejected","makeArray","value","PRIMARY_ATTRIBUTE_KEY","out","keys","forEach","messages","_instanceCache","recordIsLoaded","shouldReloadRecord","backgroundReload","shouldBackgroundReloadRecord","maybeRecordArray","recordArrayManager","_live","get","snapshotArray","SnapshotRecordArray","shouldReload","shouldReloadAll","fetch","isUpdating","_findAll","peekAll","shouldBackgroundReloadAll","isAsyncFlush","schema","_recordArray","TESTING","disableTestWaiter","waitForPromise","importSync","recordArray","createArray","populateManagedArray","assertSingleResourceDocument","modelName","_allowMissing","isDestroying","isDestroyed","_adapterCache","create","normalizedModelName","_deprecatingNormalize","owner","getOwner","lookup","undefined","application","_serializerCache","normalize","pushPayload","inputPayload","serializeRecord","recordIdentifierFor","serialize","cleanup","adapterName","destroy","serializerName"],"mappings":"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"}