import { assert } from '@ember/debug';
import { recordIdentifierFor } from '@ember-data/store';
import { u as unloadRecord, s as serialize, b as save, r as rollbackAttributes, c as reload, h as hasMany, E as Errors, d as destroyRecord, e as deleteRecord, f as RecordState, g as changedAttributes, i as belongsTo, j as createSnapshot } from "./model-YsOraZ6y";
// 'isDestroying', 'isDestroyed'
const LegacyFields = ['_createSnapshot', 'adapterError', 'belongsTo', 'changedAttributes', 'constructor', 'currentState', 'deleteRecord', 'destroyRecord', 'dirtyType', 'errors', 'hasDirtyAttributes', 'hasMany', 'isDeleted', 'isEmpty', 'isError', 'isLoaded', 'isLoading', 'isNew', 'isSaving', 'isValid', 'reload', 'rollbackAttributes', 'save', 'serialize', 'unloadRecord'];
const LegacySupport = new WeakMap();
function legacySupport(record, options, prop) {
  let state = LegacySupport.get(record);
  if (!state) {
    state = {};
    LegacySupport.set(record, state);
  }
  switch (prop) {
    case '_createSnapshot':
      return createSnapshot;
    case 'adapterError':
      return record.currentState.adapterError;
    case 'belongsTo':
      return belongsTo;
    case 'changedAttributes':
      return changedAttributes;
    case 'constructor':
      return state._constructor = state._constructor || {
        isModel: true,
        name: `Record<${recordIdentifierFor(record).type}>`,
        modelName: recordIdentifierFor(record).type
      };
    case 'currentState':
      return state.recordState = state.recordState || new RecordState(record);
    case 'deleteRecord':
      return deleteRecord;
    case 'destroyRecord':
      return destroyRecord;
    case 'dirtyType':
      return record.currentState.dirtyType;
    case 'errors':
      // @ts-expect-error
      // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      return state.errors = state.errors || Errors.create({
        __record: record
      });
    case 'hasDirtyAttributes':
      return record.currentState.isDirty;
    case 'hasMany':
      return hasMany;
    case 'isDeleted':
      return record.currentState.isDeleted;
    case 'isEmpty':
      return record.currentState.isEmpty;
    case 'isError':
      return record.currentState.isError;
    case 'isLoaded':
      return record.currentState.isLoaded;
    case 'isLoading':
      return record.currentState.isLoading;
    case 'isNew':
      return record.currentState.isNew;
    case 'isSaving':
      return record.currentState.isSaving;
    case 'isValid':
      return record.currentState.isValid;
    case 'reload':
      return reload;
    case 'rollbackAttributes':
      return rollbackAttributes;
    case 'save':
      return save;
    case 'serialize':
      return serialize;
    case 'unloadRecord':
      return unloadRecord;
    default:
      assert(`${prop} is not a supported legacy field`, false);
  }
}
function withFields(fields) {
  LegacyFields.forEach(field => {
    fields.push({
      type: '@legacy',
      name: field,
      kind: 'derived'
    });
  });
  fields.push({
    name: 'id',
    kind: '@id',
    type: null
  });
  fields.push({
    name: 'isReloading',
    kind: '@local',
    type: 'boolean',
    options: {
      defaultValue: false
    }
  });
  fields.push({
    name: 'isDestroying',
    kind: '@local',
    type: 'boolean',
    options: {
      defaultValue: false
    }
  });
  fields.push({
    name: 'isDestroyed',
    kind: '@local',
    type: 'boolean',
    options: {
      defaultValue: false
    }
  });
  return fields;
}
function registerDerivations(schema) {
  schema.registerDerivation('@legacy', legacySupport);
}
export { registerDerivations, withFields };