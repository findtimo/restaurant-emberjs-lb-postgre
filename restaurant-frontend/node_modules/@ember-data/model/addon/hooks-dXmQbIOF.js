import { getOwner, setOwner } from '@ember/application';
import { assert } from '@ember/debug';
import { setRecordIdentifier, StoreMap, setCacheFor } from '@ember-data/store/-private';
import { M as Model } from "./model-YsOraZ6y";
import { n as normalizeModelName } from "./util-3DHZJC9h";

/*
    In case someone defined a relationship to a mixin, for example:
    ```ts
      class CommentModel extends Model {
        @belongsTo('commentable', { polymorphic: true }) owner;
      }

      let Commentable = Mixin.create({
        @hasMany('comment') comments;
      });
    ```
    we want to look up a Commentable class which has all the necessary
    relationship meta data. Thus, we look up the mixin and create a mock
    Model, so we can access the relationship CPs of the mixin (`comments`)
    in this case
  */
function modelForMixin(store, normalizedModelName) {
  const owner = getOwner(store);
  const MaybeMixin = owner.factoryFor(`mixin:${normalizedModelName}`);
  const mixin = MaybeMixin && MaybeMixin.class;
  if (mixin) {
    const ModelForMixin = Model.extend(mixin);
    ModelForMixin.__isMixin = true;
    ModelForMixin.__mixin = mixin;
    //Cache the class as a model
    owner.register(`model:${normalizedModelName}`, ModelForMixin);
  }
  return owner.factoryFor(`model:${normalizedModelName}`);
}
class ModelSchemaProvider {
  constructor(store) {
    this.store = store;
    this._relationshipsDefCache = Object.create(null);
    this._attributesDefCache = Object.create(null);
    this._fieldsDefCache = Object.create(null);
  }
  fields(identifier) {
    const {
      type
    } = identifier;
    let fieldDefs = this._fieldsDefCache[type];
    if (fieldDefs === undefined) {
      fieldDefs = new Map();
      this._fieldsDefCache[type] = fieldDefs;
      const attributes = this.attributesDefinitionFor(identifier);
      const relationships = this.relationshipsDefinitionFor(identifier);
      for (const attr of Object.values(attributes)) {
        fieldDefs.set(attr.name, attr);
      }
      for (const rel of Object.values(relationships)) {
        fieldDefs.set(rel.name, rel);
      }
    }
    return fieldDefs;
  }

  // Following the existing RD implementation
  attributesDefinitionFor(identifier) {
    const {
      type
    } = identifier;
    let attributes;
    attributes = this._attributesDefCache[type];
    if (attributes === undefined) {
      const modelClass = this.store.modelFor(type);
      const attributeMap = modelClass.attributes;
      attributes = Object.create(null);
      attributeMap.forEach((meta, name) => attributes[name] = meta);
      this._attributesDefCache[type] = attributes;
    }
    return attributes;
  }

  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier) {
    const {
      type
    } = identifier;
    let relationships;
    relationships = this._relationshipsDefCache[type];
    if (relationships === undefined) {
      const modelClass = this.store.modelFor(type);
      relationships = modelClass.relationshipsObject || null;
      this._relationshipsDefCache[type] = relationships;
    }
    return relationships;
  }
  doesTypeExist(modelName) {
    const type = normalizeModelName(modelName);
    const factory = getModelFactory(this.store, type);
    return factory !== null;
  }
}
function buildSchema(store) {
  return new ModelSchemaProvider(store);
}
function getModelFactory(store, type) {
  if (!store._modelFactoryCache) {
    store._modelFactoryCache = Object.create(null);
  }
  const cache = store._modelFactoryCache;
  let factory = cache[type];
  if (!factory) {
    const owner = getOwner(store);
    factory = owner.factoryFor(`model:${type}`);
    if (!factory) {
      //Support looking up mixins as base types for polymorphic relationships
      factory = modelForMixin(store, type);
    }
    if (!factory) {
      // we don't cache misses in case someone wants to register a missing model
      return null;
    }
    const klass = factory.class;
    if (klass.isModel) {
      const hasOwnModelNameSet = klass.modelName && Object.prototype.hasOwnProperty.call(klass, 'modelName');
      if (!hasOwnModelNameSet) {
        Object.defineProperty(klass, 'modelName', {
          value: type
        });
      }
    }
    cache[type] = factory;
  }
  return factory;
}
function instantiateRecord(identifier, createRecordArgs) {
  const type = identifier.type;
  const cache = this.cache;
  // TODO deprecate allowing unknown args setting
  const createOptions = {
    _createProps: createRecordArgs,
    // TODO @deprecate consider deprecating accessing record properties during init which the below is necessary for
    _secretInit: {
      identifier,
      cache,
      store: this,
      cb: secretInit
    }
  };

  // ensure that `getOwner(this)` works inside a model instance
  setOwner(createOptions, getOwner(this));
  const factory = getModelFactory(this, type);
  assert(`No model was found for '${type}'`, factory);
  return factory.class.create(createOptions);
}
function teardownRecord(record) {
  assert(`expected to receive an instance of Model from @ember-data/model. If using a custom model make sure you implement teardownRecord`, 'destroy' in record);
  record.destroy();
}
function modelFor(modelName) {
  assert(`Attempted to call store.modelFor(), but the store instance has already been destroyed.`, !this.isDestroyed && !this.isDestroying);
  assert(`You need to pass a model name to the store's modelFor method`, modelName);
  assert(`Please pass a proper model name to the store's modelFor method`, typeof modelName === 'string' && modelName.length);
  const type = normalizeModelName(modelName);
  const maybeFactory = getModelFactory(this, type);
  const klass = maybeFactory && maybeFactory.class ? maybeFactory.class : null;
  const ignoreType = !klass || !klass.isModel || this._forceShim;
  if (!ignoreType) {
    return klass;
  }
  assert(`No model was found for '${type}' and no schema handles the type`, this.getSchemaDefinitionService().doesTypeExist(type));
}
function secretInit(record, cache, identifier, store) {
  setRecordIdentifier(record, identifier);
  StoreMap.set(record, store);
  setCacheFor(record, cache);
}
export { ModelSchemaProvider as M, buildSchema as b, instantiateRecord as i, modelFor as m, teardownRecord as t };