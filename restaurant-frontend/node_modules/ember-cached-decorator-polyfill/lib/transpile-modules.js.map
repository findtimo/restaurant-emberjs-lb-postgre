{"version":3,"file":"transpile-modules.js","sourceRoot":"","sources":["transpile-modules.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport path from 'path';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport { ImportUtil } from 'babel-import-util';\n\ninterface State {\n  importer: ImportUtil;\n}\n\nexport default function (babel: typeof Babel) {\n  const t = babel.types;\n\n  const REAL_MODULE = '@glimmer/tracking';\n  const IMPORT = 'cached';\n  const POLYFILL_MODULE = 'ember-cached-decorator-polyfill';\n  const AVAILABE_AT = '>= 4.1.0-alpha.0';\n\n  // Notice that the only name we introduce into scope here is %%local%%, and we\n  // know that name is safe to use because it's the name the user was already\n  // using in the ImportSpecifier that we're replacing.\n  let loader = babel.template(`\n    let %%local%% = %%macroCondition%%(%%dependencySatisfies%%('ember-source', '${AVAILABE_AT}')) ? \n      %%importSync%%('${REAL_MODULE}').${IMPORT} : \n      %%importSync%%('${POLYFILL_MODULE}').${IMPORT};\n  `);\n\n  return {\n    name: 'ember-cache-decorator-polyfill',\n    visitor: {\n      Program(path: NodePath<t.Program>, state: State) {\n        state.importer = new ImportUtil(t, path);\n      },\n      ImportDeclaration(path: NodePath<t.ImportDeclaration>, state: State) {\n        if (path.node.source.value !== REAL_MODULE) {\n          return;\n        }\n\n        for (let specifierPath of path.get('specifiers')) {\n          let names = getNames(specifierPath);\n          if (names?.imported !== IMPORT) {\n            continue;\n          }\n\n          // using babel-import-util to gain access to these functions ensures\n          // that we will never smash any existing bindings (and we'll reuse\n          // existing imports for these if they exist)\n          let importSync = state.importer.import(\n            path,\n            '@embroider/macros',\n            'importSync'\n          );\n          let macroCondition = state.importer.import(\n            path,\n            '@embroider/macros',\n            'macroCondition'\n          );\n          let dependencySatisfies = state.importer.import(\n            path,\n            '@embroider/macros',\n            'dependencySatisfies'\n          );\n\n          specifierPath.remove();\n\n          path.insertAfter(\n            loader({\n              local: t.identifier(names.local),\n              macroCondition,\n              dependencySatisfies,\n              importSync,\n            })\n          );\n        }\n      },\n    },\n  };\n}\n\n// Provide the path to the package's base directory for caching with broccoli\n// Ref: https://github.com/babel/broccoli-babel-transpiler#caching\nmodule.exports.baseDir = () => path.resolve(__dirname, '..');\n\nfunction getNames(\n  specifierPath: NodePath<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >\n): { imported: string; local: string } | undefined {\n  if (specifierPath.isImportDefaultSpecifier()) {\n    return { imported: 'default', local: specifierPath.node.local.name };\n  } else if (specifierPath.isImportSpecifier()) {\n    let importedNode = specifierPath.node.imported;\n    if (importedNode.type === 'Identifier') {\n      return {\n        imported: importedNode.name,\n        local: specifierPath.node.local.name,\n      };\n    } else {\n      return {\n        imported: importedNode.value,\n        local: specifierPath.node.local.name,\n      };\n    }\n  }\n  return undefined;\n}\n"]}