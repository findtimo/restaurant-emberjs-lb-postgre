'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const babel_import_util_1 = require("babel-import-util");
function default_1(babel) {
    const t = babel.types;
    const REAL_MODULE = '@glimmer/tracking';
    const IMPORT = 'cached';
    const POLYFILL_MODULE = 'ember-cached-decorator-polyfill';
    const AVAILABE_AT = '>= 4.1.0-alpha.0';
    // Notice that the only name we introduce into scope here is %%local%%, and we
    // know that name is safe to use because it's the name the user was already
    // using in the ImportSpecifier that we're replacing.
    let loader = babel.template(`
    let %%local%% = %%macroCondition%%(%%dependencySatisfies%%('ember-source', '${AVAILABE_AT}')) ? 
      %%importSync%%('${REAL_MODULE}').${IMPORT} : 
      %%importSync%%('${POLYFILL_MODULE}').${IMPORT};
  `);
    return {
        name: 'ember-cache-decorator-polyfill',
        visitor: {
            Program(path, state) {
                state.importer = new babel_import_util_1.ImportUtil(t, path);
            },
            ImportDeclaration(path, state) {
                if (path.node.source.value !== REAL_MODULE) {
                    return;
                }
                for (let specifierPath of path.get('specifiers')) {
                    let names = getNames(specifierPath);
                    if ((names === null || names === void 0 ? void 0 : names.imported) !== IMPORT) {
                        continue;
                    }
                    // using babel-import-util to gain access to these functions ensures
                    // that we will never smash any existing bindings (and we'll reuse
                    // existing imports for these if they exist)
                    let importSync = state.importer.import(path, '@embroider/macros', 'importSync');
                    let macroCondition = state.importer.import(path, '@embroider/macros', 'macroCondition');
                    let dependencySatisfies = state.importer.import(path, '@embroider/macros', 'dependencySatisfies');
                    specifierPath.remove();
                    path.insertAfter(loader({
                        local: t.identifier(names.local),
                        macroCondition,
                        dependencySatisfies,
                        importSync,
                    }));
                }
            },
        },
    };
}
exports.default = default_1;
// Provide the path to the package's base directory for caching with broccoli
// Ref: https://github.com/babel/broccoli-babel-transpiler#caching
module.exports.baseDir = () => path_1.default.resolve(__dirname, '..');
function getNames(specifierPath) {
    if (specifierPath.isImportDefaultSpecifier()) {
        return { imported: 'default', local: specifierPath.node.local.name };
    }
    else if (specifierPath.isImportSpecifier()) {
        let importedNode = specifierPath.node.imported;
        if (importedNode.type === 'Identifier') {
            return {
                imported: importedNode.name,
                local: specifierPath.node.local.name,
            };
        }
        else {
            return {
                imported: importedNode.value,
                local: specifierPath.node.local.name,
            };
        }
    }
    return undefined;
}
//# sourceMappingURL=transpile-modules.js.map